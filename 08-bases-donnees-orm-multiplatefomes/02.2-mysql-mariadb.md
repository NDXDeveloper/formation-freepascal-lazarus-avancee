üîù Retour au [Sommaire](/SOMMAIRE.md)

# MySQL/MariaDB avec FreePascal/Lazarus - Guide Complet pour D√©butants

## Introduction √† MySQL et MariaDB

### Qu'est-ce que MySQL ?

MySQL est l'un des syst√®mes de gestion de base de donn√©es relationnelles (SGBDR) les plus populaires au monde. Cr√©√© en 1995, il est devenu le standard de facto pour les applications web, notamment gr√¢ce √† la stack LAMP (Linux, Apache, MySQL, PHP). MySQL est maintenant propri√©t√© d'Oracle Corporation.

### Qu'est-ce que MariaDB ?

MariaDB est un fork (une version d√©riv√©e) de MySQL, cr√©√© en 2009 par les d√©veloppeurs originaux de MySQL. Il reste 100% compatible avec MySQL tout en ajoutant des fonctionnalit√©s et optimisations suppl√©mentaires. MariaDB est enti√®rement open source et communautaire.

### MySQL vs MariaDB : Lequel choisir ?

| Aspect | MySQL | MariaDB |
|--------|-------|---------|
| **Licence** | Double : GPL et commerciale (Oracle) | GPL uniquement (vraiment libre) |
| **Compatibilit√©** | Original | 100% compatible avec MySQL |
| **Performance** | Excellente | Souvent l√©g√®rement sup√©rieure |
| **Fonctionnalit√©s** | √âvolution plus lente | Plus d'innovations et de moteurs de stockage |
| **Support** | Oracle (payant) | Communaut√© + support commercial optionnel |
| **Utilisation** | Entreprises li√©es √† Oracle | Distributions Linux (remplace MySQL) |

**En pratique** : Le code FreePascal/Lazarus fonctionne identiquement avec les deux. MariaDB est souvent pr√©f√©r√© pour les nouveaux projets open source.

### Cas d'usage typiques

- Sites web et applications web (WordPress, Drupal, Joomla)
- E-commerce (PrestaShop, Magento, WooCommerce)
- Applications mobiles n√©cessitant un backend
- Syst√®mes de gestion et ERP l√©gers
- Prototypes et d√©veloppements rapides
- Applications multi-utilisateurs en r√©seau

## Installation de MySQL/MariaDB

### Installation de MySQL sur Windows

#### M√©thode 1 : MySQL Installer

1. T√©l√©charger MySQL Installer depuis https://dev.mysql.com/downloads/installer/
2. Choisir "Custom" pour s√©lectionner les composants :
   - MySQL Server (obligatoire)
   - MySQL Workbench (interface graphique recommand√©e)
   - Connector/ODBC (optionnel)
   - MySQL Shell (ligne de commande avanc√©e)

3. Configuration durant l'installation :
   ```
   Type de configuration : Development Machine
   Port : 3306 (par d√©faut)
   Mot de passe root : [choisir un mot de passe fort]
   Cr√©er un utilisateur : recommand√© pour vos applications
   Service Windows : Oui (d√©marrage automatique)
   ```

#### M√©thode 2 : Via Chocolatey

```powershell
# MySQL
choco install mysql

# Ou MariaDB
choco install mariadb
```

### Installation de MariaDB sur Windows

1. T√©l√©charger depuis https://mariadb.org/download/
2. Lancer l'installateur MSI
3. Configuration :
   ```
   Mot de passe root : [d√©finir]
   Service : Installer comme service Windows
   Port : 3306
   Buffer pool size : Par d√©faut ou selon RAM disponible
   ```

### Installation sur Linux/Ubuntu

#### MySQL sur Ubuntu

```bash
# Mise √† jour des paquets
sudo apt update

# Installation du serveur MySQL
sudo apt install mysql-server

# Installation du client de d√©veloppement
sudo apt install libmysqlclient-dev

# S√©curisation de l'installation
sudo mysql_secure_installation

# V√©rification
sudo systemctl status mysql
```

#### MariaDB sur Ubuntu

```bash
# Installation du serveur MariaDB
sudo apt install mariadb-server

# Installation du client de d√©veloppement
sudo apt install libmariadb-dev

# S√©curisation
sudo mysql_secure_installation

# V√©rification
sudo systemctl status mariadb
```

### Configuration post-installation

#### Cr√©ation d'un utilisateur pour l'application

```sql
-- Se connecter en root
mysql -u root -p

-- Cr√©er un utilisateur (MySQL 8.0+)
CREATE USER 'monapp'@'localhost' IDENTIFIED BY 'motdepasse';  
CREATE USER 'monapp'@'%' IDENTIFIED BY 'motdepasse'; -- Pour acc√®s r√©seau

-- Cr√©er une base de donn√©es
CREATE DATABASE mabase CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- Donner les droits
GRANT ALL PRIVILEGES ON mabase.* TO 'monapp'@'localhost';  
GRANT ALL PRIVILEGES ON mabase.* TO 'monapp'@'%';

-- Appliquer les changements
FLUSH PRIVILEGES;

-- Quitter
EXIT;
```

## Configuration avec FreePascal/Lazarus

### Les composants MySQL dans Lazarus

FreePascal/Lazarus propose plusieurs composants selon la version de MySQL/MariaDB :

```pascal
// Composants disponibles
TMySQL40Connection  // MySQL 4.0 (ancien)  
TMySQL41Connection  // MySQL 4.1  
TMySQL50Connection  // MySQL 5.0  
TMySQL51Connection  // MySQL 5.1  
TMySQL55Connection  // MySQL 5.5  
TMySQL56Connection  // MySQL 5.6  
TMySQL57Connection  // MySQL 5.7 et MariaDB 10.x  
TMySQL80Connection  // MySQL 8.0+
```

### Choix du bon composant

```pascal
// Pour MySQL 5.7 ou MariaDB 10.x
uses
  mysql57conn;

var
  MySQLConnection: TMySQL57Connection;

// Pour MySQL 8.0+
uses
  mysql80conn;

var
  MySQLConnection: TMySQL80Connection;
```

### Configuration de base

```pascal
procedure ConnecterMySQL;  
var
  MySQLConnection: TMySQL57Connection;
  Transaction: TSQLTransaction;
begin
  MySQLConnection := TMySQL57Connection.Create(nil);
  Transaction := TSQLTransaction.Create(nil);
  try
    // Configuration de la connexion
    MySQLConnection.HostName := 'localhost';
    MySQLConnection.DatabaseName := 'mabase';
    MySQLConnection.UserName := 'monapp';
    MySQLConnection.Password := 'motdepasse';
    MySQLConnection.Port := 3306;
    MySQLConnection.CharSet := 'utf8mb4';  // Important pour l'Unicode complet

    // Lier la transaction
    MySQLConnection.Transaction := Transaction;
    Transaction.Database := MySQLConnection;

    // Connexion
    MySQLConnection.Open;
    ShowMessage('Connect√© √† MySQL/MariaDB !');
  finally
    MySQLConnection.Free;
    Transaction.Free;
  end;
end;
```

### Gestion des biblioth√®ques clientes

#### Windows

```pascal
procedure ConfigurerCheminDLL;  
begin
  {$IFDEF WINDOWS}
  // MySQL 5.7/MariaDB
  MySQL57Connection.LibraryLocation := ExtractFilePath(ParamStr(0)) + 'libmysql.dll';

  // MySQL 8.0
  MySQL80Connection.LibraryLocation := ExtractFilePath(ParamStr(0)) + 'libmysql.dll';
  {$ENDIF}
end;
```

Les DLL n√©cessaires :
- **libmysql.dll** pour MySQL
- **libmariadb.dll** pour MariaDB
- Placer dans le dossier de l'application ou le PATH syst√®me

#### Linux/Ubuntu

```bash
# V√©rifier les biblioth√®ques install√©es
ldconfig -p | grep mysql  
ldconfig -p | grep mariadb

# Cr√©er des liens symboliques si n√©cessaire
sudo ln -s /usr/lib/x86_64-linux-gnu/libmysqlclient.so.21 /usr/lib/x86_64-linux-gnu/libmysqlclient.so
```

## Types de donn√©es MySQL/MariaDB vs Pascal

### Correspondance des types

| MySQL/MariaDB | Pascal/Lazarus | Notes |
|---------------|---------------|--------|
| TINYINT | ShortInt (-128 √† 127) | Ou Byte (0 √† 255) si UNSIGNED |
| SMALLINT | SmallInt | 16 bits |
| MEDIUMINT | Integer | 24 bits dans MySQL |
| INT/INTEGER | Integer | 32 bits |
| BIGINT | Int64 | 64 bits |
| FLOAT | Single | Pr√©cision simple |
| DOUBLE | Double | Pr√©cision double |
| DECIMAL(p,s) | Currency ou BCD | Pr√©cision fixe pour l'argent |
| CHAR(n) | String[n] | Longueur fixe |
| VARCHAR(n) | String/AnsiString | Longueur variable |
| TEXT | String/Memo | Texte long |
| DATE | TDate | Date seulement |
| TIME | TTime | Heure seulement |
| DATETIME | TDateTime | Date et heure |
| TIMESTAMP | TDateTime | Avec fuseau horaire |
| YEAR | Word | Ann√©e sur 4 chiffres |
| BOOLEAN/BOOL | Boolean | TINYINT(1) en interne |
| BLOB | TBlobField/TBytes | Donn√©es binaires |
| JSON | String | Type natif depuis MySQL 5.7 |
| ENUM | String | Liste de valeurs |
| SET | String | Ensemble de valeurs |

### Gestion de l'Unicode et des caract√®res

```pascal
// Configuration pour support Unicode complet
procedure ConfigurerUnicode;  
begin
  // Utiliser utf8mb4 pour supporter tous les caract√®res Unicode (emojis inclus)
  MySQLConnection.CharSet := 'utf8mb4';

  // Ex√©cuter apr√®s connexion
  MySQLConnection.ExecuteDirect('SET NAMES utf8mb4');
  MySQLConnection.ExecuteDirect('SET CHARACTER SET utf8mb4');
  MySQLConnection.ExecuteDirect('SET character_set_connection=utf8mb4');

  // Pour les comparaisons insensibles √† la casse et accents
  MySQLConnection.ExecuteDirect('SET collation_connection=utf8mb4_unicode_ci');
end;
```

## Sp√©cificit√©s MySQL/MariaDB

### AUTO_INCREMENT

MySQL utilise AUTO_INCREMENT pour les cl√©s primaires automatiques :

```pascal
// Cr√©er une table avec AUTO_INCREMENT
procedure CreerTable;  
begin
  MySQLConnection.ExecuteDirect(
    'CREATE TABLE IF NOT EXISTS clients (' +
    '  id INT AUTO_INCREMENT PRIMARY KEY,' +
    '  nom VARCHAR(100) NOT NULL,' +
    '  email VARCHAR(255) UNIQUE,' +
    '  date_creation TIMESTAMP DEFAULT CURRENT_TIMESTAMP' +
    ') ENGINE=InnoDB DEFAULT CHARSET=utf8mb4'
  );
end;

// R√©cup√©rer le dernier ID ins√©r√©
function InsererEtRecupererID: Integer;  
begin
  SQLQuery.SQL.Text := 'INSERT INTO clients (nom, email) VALUES (:nom, :email)';
  SQLQuery.ParamByName('nom').AsString := 'Dupont';
  SQLQuery.ParamByName('email').AsString := 'dupont@email.com';
  SQLQuery.ExecSQL;

  // M√©thode 1 : LAST_INSERT_ID()
  SQLQuery.SQL.Text := 'SELECT LAST_INSERT_ID() as id';
  SQLQuery.Open;
  Result := SQLQuery.FieldByName('id').AsInteger;
  SQLQuery.Close;

  // M√©thode 2 : Via la connexion
  Result := MySQLConnection.GetInsertID;
end;
```

### Moteurs de stockage

MySQL/MariaDB offre plusieurs moteurs de stockage :

```pascal
// InnoDB (par d√©faut, recommand√©)
MySQLConnection.ExecuteDirect(
  'CREATE TABLE commandes (' +
  '  id INT PRIMARY KEY,' +
  '  client_id INT,' +
  '  FOREIGN KEY (client_id) REFERENCES clients(id)' +
  ') ENGINE=InnoDB'
);

// MyISAM (rapide en lecture, pas de transactions)
MySQLConnection.ExecuteDirect(
  'CREATE TABLE logs (' +
  '  id INT PRIMARY KEY,' +
  '  message TEXT' +
  ') ENGINE=MyISAM'
);

// Memory (en RAM, tr√®s rapide, donn√©es temporaires)
MySQLConnection.ExecuteDirect(
  'CREATE TABLE cache_session (' +
  '  session_id VARCHAR(40) PRIMARY KEY,' +
  '  data TEXT' +
  ') ENGINE=Memory'
);

// Archive (compression, logs)
MySQLConnection.ExecuteDirect(
  'CREATE TABLE archives (' +
  '  id INT,' +
  '  data TEXT' +
  ') ENGINE=Archive'
);
```

### ENUM et SET

Types sp√©cifiques √† MySQL pour limiter les valeurs :

```pascal
// Type ENUM (une seule valeur parmi la liste)
MySQLConnection.ExecuteDirect(
  'CREATE TABLE produits (' +
  '  id INT PRIMARY KEY,' +
  '  nom VARCHAR(100),' +
  '  statut ENUM(''actif'', ''inactif'', ''archive'') DEFAULT ''actif''' +
  ')'
);

// Type SET (plusieurs valeurs possibles)
MySQLConnection.ExecuteDirect(
  'CREATE TABLE utilisateurs (' +
  '  id INT PRIMARY KEY,' +
  '  nom VARCHAR(100),' +
  '  permissions SET(''lecture'', ''ecriture'', ''suppression'', ''admin'')' +
  ')'
);

// Utilisation
SQLQuery.SQL.Text := 'INSERT INTO utilisateurs (nom, permissions) ' +
                     'VALUES (:nom, :perms)';
SQLQuery.ParamByName('nom').AsString := 'Jean';  
SQLQuery.ParamByName('perms').AsString := 'lecture,ecriture';  
SQLQuery.ExecSQL;
```

### Support JSON (MySQL 5.7+, MariaDB 10.2+)

```pascal
// Cr√©er une table avec colonne JSON
MySQLConnection.ExecuteDirect(
  'CREATE TABLE configurations (' +
  '  id INT PRIMARY KEY AUTO_INCREMENT,' +
  '  nom VARCHAR(50),' +
  '  parametres JSON' +
  ')'
);

// Ins√©rer du JSON
SQLQuery.SQL.Text := 'INSERT INTO configurations (nom, parametres) VALUES (:nom, :json)';  
SQLQuery.ParamByName('nom').AsString := 'app_config';  
SQLQuery.ParamByName('json').AsString := '{"theme": "dark", "lang": "fr", "notifications": true}';  
SQLQuery.ExecSQL;

// Requ√™tes sur JSON
// Extraire une valeur
SQLQuery.SQL.Text := 'SELECT parametres->>''$.theme'' as theme FROM configurations';

// Filtrer par valeur JSON
SQLQuery.SQL.Text := 'SELECT * FROM configurations WHERE parametres->>''$.lang'' = ''fr''';

// Modifier une valeur JSON
SQLQuery.SQL.Text := 'UPDATE configurations SET parametres = JSON_SET(parametres, ''$.theme'', ''light'')';
```

## Fonctionnalit√©s avanc√©es

### Proc√©dures stock√©es

```pascal
// Cr√©er une proc√©dure stock√©e
procedure CreerProcedure;  
begin
  MySQLConnection.ExecuteDirect(
    'CREATE PROCEDURE IF NOT EXISTS calculer_stats(' +
    '  IN p_annee INT,' +
    '  OUT p_total DECIMAL(10,2),' +
    '  OUT p_count INT' +
    ') ' +
    'BEGIN ' +
    '  SELECT COUNT(*), SUM(montant) INTO p_count, p_total ' +
    '  FROM commandes ' +
    '  WHERE YEAR(date_commande) = p_annee; ' +
    'END'
  );
end;

// Appeler une proc√©dure stock√©e
procedure AppelerProcedure;  
var
  Total: Currency;
  Count: Integer;
begin
  SQLQuery.SQL.Text := 'CALL calculer_stats(:annee, @total, @count)';
  SQLQuery.ParamByName('annee').AsInteger := 2024;
  SQLQuery.ExecSQL;

  // R√©cup√©rer les param√®tres OUT
  SQLQuery.SQL.Text := 'SELECT @total as total, @count as count';
  SQLQuery.Open;
  Total := SQLQuery.FieldByName('total').AsCurrency;
  Count := SQLQuery.FieldByName('count').AsInteger;
  SQLQuery.Close;

  ShowMessage(Format('Total: %.2f‚Ç¨, Nombre: %d', [Total, Count]));
end;
```

### Fonctions stock√©es

```pascal
// Cr√©er une fonction
MySQLConnection.ExecuteDirect(
  'CREATE FUNCTION IF NOT EXISTS tva_comprise(montant_ht DECIMAL(10,2)) ' +
  'RETURNS DECIMAL(10,2) ' +
  'DETERMINISTIC ' +
  'BEGIN ' +
  '  RETURN montant_ht * 1.20; ' +
  'END'
);

// Utiliser la fonction
SQLQuery.SQL.Text := 'SELECT nom, prix_ht, tva_comprise(prix_ht) as prix_ttc FROM produits';  
SQLQuery.Open;
```

### Triggers

```pascal
// Cr√©er un trigger pour l'audit
procedure CreerTriggerAudit;  
begin
  // Table d'audit
  MySQLConnection.ExecuteDirect(
    'CREATE TABLE IF NOT EXISTS audit_clients (' +
    '  id INT AUTO_INCREMENT PRIMARY KEY,' +
    '  action VARCHAR(10),' +
    '  client_id INT,' +
    '  ancien_nom VARCHAR(100),' +
    '  nouveau_nom VARCHAR(100),' +
    '  utilisateur VARCHAR(50),' +
    '  date_action TIMESTAMP DEFAULT CURRENT_TIMESTAMP' +
    ')'
  );

  // Trigger sur UPDATE
  MySQLConnection.ExecuteDirect(
    'CREATE TRIGGER IF NOT EXISTS audit_update_client ' +
    'AFTER UPDATE ON clients ' +
    'FOR EACH ROW ' +
    'BEGIN ' +
    '  INSERT INTO audit_clients (action, client_id, ancien_nom, nouveau_nom, utilisateur) ' +
    '  VALUES (''UPDATE'', NEW.id, OLD.nom, NEW.nom, USER()); ' +
    'END'
  );
end;
```

### √âv√©nements (T√¢ches planifi√©es)

```pascal
// Activer l'event scheduler
MySQLConnection.ExecuteDirect('SET GLOBAL event_scheduler = ON');

// Cr√©er un √©v√©nement
MySQLConnection.ExecuteDirect(
  'CREATE EVENT IF NOT EXISTS nettoyer_logs ' +
  'ON SCHEDULE EVERY 1 DAY ' +
  'STARTS CURRENT_TIMESTAMP ' +
  'DO ' +
  'DELETE FROM logs WHERE date_creation < DATE_SUB(NOW(), INTERVAL 30 DAY)'
);
```

### Vues

```pascal
// Cr√©er une vue
MySQLConnection.ExecuteDirect(
  'CREATE OR REPLACE VIEW vue_clients_actifs AS ' +
  'SELECT c.*, COUNT(co.id) as nb_commandes ' +
  'FROM clients c ' +
  'LEFT JOIN commandes co ON c.id = co.client_id ' +
  'WHERE c.actif = 1 ' +
  'GROUP BY c.id'
);

// Utiliser comme une table
SQLQuery.SQL.Text := 'SELECT * FROM vue_clients_actifs WHERE nb_commandes > 5';  
SQLQuery.Open;
```

## Optimisation des performances

### Index et cl√©s

```pascal
// Cr√©er diff√©rents types d'index
procedure CreerIndex;  
begin
  // Index simple
  MySQLConnection.ExecuteDirect(
    'CREATE INDEX idx_clients_email ON clients(email)'
  );

  // Index unique
  MySQLConnection.ExecuteDirect(
    'CREATE UNIQUE INDEX idx_clients_code ON clients(code_client)'
  );

  // Index compos√©
  MySQLConnection.ExecuteDirect(
    'CREATE INDEX idx_commandes_date_client ON commandes(date_commande, client_id)'
  );

  // Index FULLTEXT pour recherche textuelle
  MySQLConnection.ExecuteDirect(
    'CREATE FULLTEXT INDEX idx_articles_recherche ON articles(titre, contenu)'
  );

  // Index sur pr√©fixe (pour VARCHAR longs)
  MySQLConnection.ExecuteDirect(
    'CREATE INDEX idx_url_prefix ON pages(url(100))'
  );
end;

// Utilisation du FULLTEXT
SQLQuery.SQL.Text :=
  'SELECT * FROM articles ' +
  'WHERE MATCH(titre, contenu) AGAINST(:recherche IN NATURAL LANGUAGE MODE)';
SQLQuery.ParamByName('recherche').AsString := 'lazarus pascal';  
SQLQuery.Open;
```

### Analyse des requ√™tes avec EXPLAIN

```pascal
procedure AnalyserRequete(const ASQL: string);  
var
  Analyse: TStringList;
begin
  Analyse := TStringList.Create;
  try
    SQLQuery.SQL.Text := 'EXPLAIN ' + ASQL;
    SQLQuery.Open;

    while not SQLQuery.EOF do
    begin
      Analyse.Add(Format('Table: %s, Type: %s, Keys: %s, Rows: %s',
        [SQLQuery.FieldByName('table').AsString,
         SQLQuery.FieldByName('type').AsString,
         SQLQuery.FieldByName('possible_keys').AsString,
         SQLQuery.FieldByName('rows').AsString]));

      // Alertes
      if SQLQuery.FieldByName('type').AsString = 'ALL' then
        ShowMessage('Attention: Full table scan sur ' +
                   SQLQuery.FieldByName('table').AsString);

      SQLQuery.Next;
    end;

    ShowMessage('Analyse:' + LineEnding + Analyse.Text);
  finally
    Analyse.Free;
    SQLQuery.Close;
  end;
end;
```

### Cache de requ√™tes MySQL

```pascal
// V√©rifier le statut du cache
procedure VerifierCache;  
begin
  SQLQuery.SQL.Text := 'SHOW VARIABLES LIKE ''query_cache%''';
  SQLQuery.Open;
  // Afficher les r√©sultats

  // Statistiques du cache
  SQLQuery.SQL.Text := 'SHOW STATUS LIKE ''Qcache%''';
  SQLQuery.Open;
end;

// Forcer l'utilisation ou non du cache
SQLQuery.SQL.Text := 'SELECT SQL_CACHE * FROM clients';  // Forcer le cache  
SQLQuery.SQL.Text := 'SELECT SQL_NO_CACHE * FROM clients'; // Ignorer le cache
```

## Gestion des transactions

### Transactions avec InnoDB

```pascal
procedure TransactionComplete;  
begin
  // D√©marrer la transaction
  SQLTransaction.StartTransaction;
  try
    // Niveau d'isolation
    MySQLConnection.ExecuteDirect('SET TRANSACTION ISOLATION LEVEL READ COMMITTED');

    // Premi√®re op√©ration
    SQLQuery.SQL.Text := 'UPDATE comptes SET solde = solde - :montant WHERE id = :id';
    SQLQuery.ParamByName('montant').AsCurrency := 100.00;
    SQLQuery.ParamByName('id').AsInteger := 1;
    SQLQuery.ExecSQL;

    // V√©rification
    SQLQuery.SQL.Text := 'SELECT solde FROM comptes WHERE id = :id';
    SQLQuery.ParamByName('id').AsInteger := 1;
    SQLQuery.Open;
    if SQLQuery.FieldByName('solde').AsCurrency < 0 then
      raise Exception.Create('Solde insuffisant');
    SQLQuery.Close;

    // Deuxi√®me op√©ration
    SQLQuery.SQL.Text := 'UPDATE comptes SET solde = solde + :montant WHERE id = :id';
    SQLQuery.ParamByName('montant').AsCurrency := 100.00;
    SQLQuery.ParamByName('id').AsInteger := 2;
    SQLQuery.ExecSQL;

    // Valider
    SQLTransaction.Commit;
    ShowMessage('Transaction r√©ussie');
  except
    on E: Exception do
    begin
      SQLTransaction.Rollback;
      ShowMessage('Transaction annul√©e: ' + E.Message);
    end;
  end;
end;
```

### Verrouillage des tables

```pascal
// Verrouillage pour op√©ration critique
procedure OperationAvecVerrou;  
begin
  try
    // Verrouiller les tables
    MySQLConnection.ExecuteDirect('LOCK TABLES clients WRITE, commandes WRITE');

    // Op√©rations exclusives
    MySQLConnection.ExecuteDirect('UPDATE clients SET credit = credit + 100');
    MySQLConnection.ExecuteDirect('INSERT INTO commandes ...');

  finally
    // Toujours lib√©rer les verrous
    MySQLConnection.ExecuteDirect('UNLOCK TABLES');
  end;
end;

// Verrouillage au niveau ligne avec SELECT ... FOR UPDATE
procedure VerrouillageLigne;  
begin
  SQLTransaction.StartTransaction;
  try
    // Verrouiller une ligne sp√©cifique
    SQLQuery.SQL.Text := 'SELECT * FROM comptes WHERE id = :id FOR UPDATE';
    SQLQuery.ParamByName('id').AsInteger := 1;
    SQLQuery.Open;

    // Modifications s√ªres
    SQLQuery.SQL.Text := 'UPDATE comptes SET solde = :solde WHERE id = :id';
    SQLQuery.ParamByName('solde').AsCurrency := 1000.00;
    SQLQuery.ParamByName('id').AsInteger := 1;
    SQLQuery.ExecSQL;

    SQLTransaction.Commit;
  except
    SQLTransaction.Rollback;
    raise;
  end;
end;
```

## S√©curit√©

### Pr√©vention des injections SQL

```pascal
// JAMAIS faire ceci (vuln√©rable)
procedure RequeteVulnerable(const Nom: string);  
begin
  SQLQuery.SQL.Text := 'SELECT * FROM clients WHERE nom = ''' + Nom + '''';
  // Danger : si Nom = "'; DROP TABLE clients; --"
end;

// TOUJOURS utiliser des param√®tres
procedure RequeteSecurisee(const Nom: string);  
begin
  SQLQuery.SQL.Text := 'SELECT * FROM clients WHERE nom = :nom';
  SQLQuery.ParamByName('nom').AsString := Nom;
  // S√ªr : les param√®tres sont automatiquement √©chapp√©s
end;

// Pour requ√™tes dynamiques, utiliser QuotedStr
procedure RequeteDynamiqueSecurisee(const TableName: string);  
var
  SafeTable: string;
begin
  // Valider le nom de table
  if not TableName.IsEmpty and
     (Pos(' ', TableName) = 0) and
     (Pos(';', TableName) = 0) then
  begin
    SafeTable := MySQLConnection.EscapeString(TableName);
    SQLQuery.SQL.Text := Format('SELECT * FROM `%s`', [SafeTable]);
  end;
end;
```

### Connexions SSL/TLS

```pascal
procedure ConnexionSecurisee;  
begin
  MySQLConnection := TMySQL57Connection.Create(nil);
  try
    MySQLConnection.HostName := 'serveur.exemple.com';
    MySQLConnection.DatabaseName := 'base_sensible';
    MySQLConnection.UserName := 'utilisateur';
    MySQLConnection.Password := 'motdepasse';

    // Configuration SSL
    MySQLConnection.Params.Add('ssl_mode=REQUIRED');

    {$IFDEF WINDOWS}
    MySQLConnection.Params.Add('ssl_ca=' + ExtractFilePath(ParamStr(0)) + 'certs\ca.pem');
    MySQLConnection.Params.Add('ssl_cert=' + ExtractFilePath(ParamStr(0)) + 'certs\client-cert.pem');
    MySQLConnection.Params.Add('ssl_key=' + ExtractFilePath(ParamStr(0)) + 'certs\client-key.pem');
    {$ENDIF}

    {$IFDEF UNIX}
    MySQLConnection.Params.Add('ssl_ca=/etc/mysql/certs/ca.pem');
    MySQLConnection.Params.Add('ssl_cert=/etc/mysql/certs/client-cert.pem');
    MySQLConnection.Params.Add('ssl_key=/etc/mysql/certs/client-key.pem');
    {$ENDIF}

    MySQLConnection.Open;

    // V√©rifier la connexion SSL
    SQLQuery.Database := MySQLConnection;
    SQLQuery.SQL.Text := 'SHOW STATUS LIKE ''Ssl_cipher''';
    SQLQuery.Open;
    ShowMessage('Chiffrement: ' + SQLQuery.Fields[1].AsString);
  finally
    MySQLConnection.Free;
  end;
end;
```

## R√©plication et haute disponibilit√©

### Configuration pour la r√©plication

```pascal
// Connexion au serveur ma√Ætre
procedure ConnexionMaitre;  
begin
  MySQLMaster.HostName := 'master.exemple.com';
  MySQLMaster.DatabaseName := 'mabase';
  // Pour les √©critures
end;

// Connexion aux serveurs esclaves
procedure ConnexionEsclave;  
begin
  // Load balancing entre plusieurs esclaves
  case Random(3) of
    0: MySQLSlave.HostName := 'slave1.exemple.com';
    1: MySQLSlave.HostName := 'slave2.exemple.com';
    2: MySQLSlave.HostName := 'slave3.exemple.com';
  end;
  MySQLSlave.DatabaseName := 'mabase';
  // Pour les lectures
end;

// Pattern Read/Write splitting
procedure ExecuterRequete(const ASQL: string; AIsWrite: Boolean);  
begin
  if AIsWrite then
  begin
    // INSERT, UPDATE, DELETE vont au ma√Ætre
    SQLQueryMaster.SQL.Text := ASQL;
    SQLQueryMaster.ExecSQL;
  end
  else
  begin
    // SELECT vont aux esclaves
    SQLQuerySlave.SQL.Text := ASQL;
    SQLQuerySlave.Open;
  end;
end;
```

## Sauvegarde et restauration

### Backup avec mysqldump

```pascal
procedure BackupDatabase(const AOutputFile: string);  
var
  Process: TProcess;
begin
  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqldump.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/mysqldump';
    {$ENDIF}

    // Param√®tres
    Process.Parameters.Add('--host=' + MySQLConnection.HostName);
    Process.Parameters.Add('--user=' + MySQLConnection.UserName);
    Process.Parameters.Add('--password=' + MySQLConnection.Password);
    Process.Parameters.Add('--databases');
    Process.Parameters.Add(MySQLConnection.DatabaseName);
    Process.Parameters.Add('--single-transaction'); // Pour InnoDB
    Process.Parameters.Add('--routines');           // Inclure proc√©dures/fonctions
    Process.Parameters.Add('--triggers');           // Inclure triggers
    Process.Parameters.Add('--events');             // Inclure √©v√©nements
    Process.Parameters.Add('--result-file=' + AOutputFile);

    Process.Options := Process.Options + [poWaitOnExit, poUsePipes];
    Process.Execute;

    if Process.ExitStatus = 0 then
      ShowMessage('Sauvegarde r√©ussie : ' + AOutputFile)
    else
      ShowMessage('Erreur lors de la sauvegarde');
  finally
    Process.Free;
  end;
end;

// Backup avec options avanc√©es
procedure BackupComplet(const AOutputFile: string; ACompresser: Boolean = True);  
var
  Process: TProcess;
  BackupFile: string;
begin
  BackupFile := AOutputFile;

  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqldump.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/mysqldump';
    {$ENDIF}

    // Param√®tres de base
    Process.Parameters.Add('--host=' + MySQLConnection.HostName);
    Process.Parameters.Add('--user=' + MySQLConnection.UserName);
    Process.Parameters.Add('--password=' + MySQLConnection.Password);

    // Options de sauvegarde compl√®te
    Process.Parameters.Add('--all-databases');      // Toutes les bases
    Process.Parameters.Add('--add-drop-database');  // Ajouter DROP DATABASE
    Process.Parameters.Add('--add-drop-table');     // Ajouter DROP TABLE
    Process.Parameters.Add('--complete-insert');    // INSERT complets
    Process.Parameters.Add('--extended-insert');    // INSERT multiples
    Process.Parameters.Add('--lock-all-tables');    // Verrouiller pour coh√©rence
    Process.Parameters.Add('--flush-logs');         // Rotation des logs
    Process.Parameters.Add('--master-data=2');      // Info r√©plication
    Process.Parameters.Add('--hex-blob');           // Donn√©es binaires en hexa

    if ACompresser then
    begin
      // Compression directe sous Linux
      {$IFDEF UNIX}
      BackupFile := BackupFile + '.gz';
      Process.Parameters.Add('|');
      Process.Parameters.Add('gzip');
      Process.Parameters.Add('>');
      Process.Parameters.Add(BackupFile);
      {$ELSE}
      Process.Parameters.Add('--result-file=' + BackupFile);
      {$ENDIF}
    end
    else
      Process.Parameters.Add('--result-file=' + BackupFile);

    Process.Options := Process.Options + [poWaitOnExit];
    Process.Execute;

    if Process.ExitStatus = 0 then
    begin
      ShowMessage('Sauvegarde compl√®te r√©ussie');

      // Compression sous Windows apr√®s coup
      {$IFDEF WINDOWS}
      if ACompresser then
        CompresserFichier(BackupFile);
      {$ENDIF}
    end;
  finally
    Process.Free;
  end;
end;
```

### Restauration depuis un backup

```pascal
procedure RestaurerDatabase(const ABackupFile: string);  
var
  Process: TProcess;
  Commands: TStringList;
begin
  // M√©thode 1 : Via mysql en ligne de commande
  Process := TProcess.Create(nil);
  try
    {$IFDEF WINDOWS}
    Process.Executable := 'C:\Program Files\MySQL\MySQL Server 8.0\bin\mysql.exe';
    {$ENDIF}
    {$IFDEF UNIX}
    Process.Executable := '/usr/bin/mysql';
    {$ENDIF}

    Process.Parameters.Add('--host=' + MySQLConnection.HostName);
    Process.Parameters.Add('--user=' + MySQLConnection.UserName);
    Process.Parameters.Add('--password=' + MySQLConnection.Password);
    Process.Parameters.Add('--database=' + MySQLConnection.DatabaseName);
    Process.Parameters.Add('--execute=source ' + ABackupFile);

    Process.Options := Process.Options + [poWaitOnExit];
    Process.Execute;

    if Process.ExitStatus = 0 then
      ShowMessage('Restauration r√©ussie')
    else
      ShowMessage('Erreur lors de la restauration');
  finally
    Process.Free;
  end;
end;

// M√©thode 2 : Via FreePascal directement
procedure RestaurerDepuisSQL(const ABackupFile: string);  
var
  Script: TStringList;
  Command: string;
  i: Integer;
begin
  Script := TStringList.Create;
  try
    Script.LoadFromFile(ABackupFile);

    // Parser et ex√©cuter les commandes SQL
    Command := '';
    for i := 0 to Script.Count - 1 do
    begin
      if Trim(Script[i]) = '' then
        Continue;

      Command := Command + Script[i] + ' ';

      // D√©tection de fin de commande
      if (Pos(';', Script[i]) > 0) and
         (Pos('DELIMITER', UpperCase(Script[i])) = 0) then
      begin
        try
          MySQLConnection.ExecuteDirect(Command);
        except
          on E: Exception do
            WriteLn('Erreur SQL: ' + E.Message);
        end;
        Command := '';
      end;
    end;

    ShowMessage('Restauration termin√©e');
  finally
    Script.Free;
  end;
end;
```

### Sauvegarde binaire (donn√©es uniquement)

```pascal
procedure BackupTable(const ATableName, AOutputFile: string);  
var
  MemStream: TMemoryStream;
  FileStream: TFileStream;
begin
  MemStream := TMemoryStream.Create;
  FileStream := TFileStream.Create(AOutputFile, fmCreate);
  try
    // Export en CSV
    SQLQuery.SQL.Text := 'SELECT * FROM ' + ATableName;
    SQLQuery.Open;

    // En-t√™te avec noms de colonnes
    WriteLn(FileStream, GetColumnHeaders(SQLQuery));

    // Donn√©es
    while not SQLQuery.EOF do
    begin
      WriteLn(FileStream, GetRowAsCSV(SQLQuery));
      SQLQuery.Next;
    end;

    ShowMessage('Table export√©e : ' + ATableName);
  finally
    MemStream.Free;
    FileStream.Free;
    SQLQuery.Close;
  end;
end;

function GetColumnHeaders(AQuery: TSQLQuery): string;  
var
  i: Integer;
begin
  Result := '';
  for i := 0 to AQuery.Fields.Count - 1 do
  begin
    if i > 0 then Result := Result + ',';
    Result := Result + '"' + AQuery.Fields[i].FieldName + '"';
  end;
end;

function GetRowAsCSV(AQuery: TSQLQuery): string;  
var
  i: Integer;
  Value: string;
begin
  Result := '';
  for i := 0 to AQuery.Fields.Count - 1 do
  begin
    if i > 0 then Result := Result + ',';

    if AQuery.Fields[i].IsNull then
      Value := 'NULL'
    else
    begin
      Value := AQuery.Fields[i].AsString;
      // √âchapper les guillemets
      Value := StringReplace(Value, '"', '""', [rfReplaceAll]);
      Value := '"' + Value + '"';
    end;

    Result := Result + Value;
  end;
end;
```

## Monitoring et diagnostics

### Surveillance des performances

```pascal
procedure AfficherStatistiques;  
begin
  // Variables de statut global
  SQLQuery.SQL.Text := 'SHOW GLOBAL STATUS';
  SQLQuery.Open;

  while not SQLQuery.EOF do
  begin
    if SQLQuery.FieldByName('Variable_name').AsString = 'Uptime' then
      ShowMessage('Uptime: ' +
        FormatDateTime('hh:nn:ss', SQLQuery.FieldByName('Value').AsInteger / 86400))
    else if SQLQuery.FieldByName('Variable_name').AsString = 'Threads_connected' then
      ShowMessage('Connexions actives: ' +
        SQLQuery.FieldByName('Value').AsString)
    else if SQLQuery.FieldByName('Variable_name').AsString = 'Questions' then
      ShowMessage('Requ√™tes totales: ' +
        SQLQuery.FieldByName('Value').AsString)
    else if SQLQuery.FieldByName('Variable_name').AsString = 'Slow_queries' then
      ShowMessage('Requ√™tes lentes: ' +
        SQLQuery.FieldByName('Value').AsString);
    SQLQuery.Next;
  end;
  SQLQuery.Close;
end;

// Processus actifs
procedure AfficherProcessList;  
var
  Grid: TStringGrid;
begin
  SQLQuery.SQL.Text := 'SHOW FULL PROCESSLIST';
  SQLQuery.Open;

  // Afficher dans une grille
  while not SQLQuery.EOF do
  begin
    WriteLn(Format('ID: %s, User: %s, Host: %s, DB: %s, Command: %s, Time: %s, State: %s',
      [SQLQuery.FieldByName('Id').AsString,
       SQLQuery.FieldByName('User').AsString,
       SQLQuery.FieldByName('Host').AsString,
       SQLQuery.FieldByName('db').AsString,
       SQLQuery.FieldByName('Command').AsString,
       SQLQuery.FieldByName('Time').AsString,
       SQLQuery.FieldByName('State').AsString]));

    // Tuer les requ√™tes trop longues si n√©cessaire
    if SQLQuery.FieldByName('Time').AsInteger > 300 then // 5 minutes
    begin
      MySQLConnection.ExecuteDirect('KILL ' + SQLQuery.FieldByName('Id').AsString);
    end;

    SQLQuery.Next;
  end;
  SQLQuery.Close;
end;
```

### Analyse des tables

```pascal
procedure AnalyserTables;  
var
  Tables: TStringList;
  i: Integer;
begin
  Tables := TStringList.Create;
  try
    // Obtenir la liste des tables
    MySQLConnection.GetTableNames(Tables);

    for i := 0 to Tables.Count - 1 do
    begin
      // Analyser chaque table
      MySQLConnection.ExecuteDirect('ANALYZE TABLE ' + Tables[i]);

      // V√©rifier l'int√©grit√©
      SQLQuery.SQL.Text := 'CHECK TABLE ' + Tables[i];
      SQLQuery.Open;
      ShowMessage(Format('Table %s : %s',
        [Tables[i], SQLQuery.FieldByName('Msg_text').AsString]));
      SQLQuery.Close;

      // Optimiser si n√©cessaire
      MySQLConnection.ExecuteDirect('OPTIMIZE TABLE ' + Tables[i]);
    end;
  finally
    Tables.Free;
  end;
end;

// Informations d√©taill√©es sur une table
procedure InfoTable(const ATableName: string);  
begin
  // Structure
  SQLQuery.SQL.Text := 'DESCRIBE ' + ATableName;
  SQLQuery.Open;
  // Afficher les colonnes...
  SQLQuery.Close;

  // Index
  SQLQuery.SQL.Text := 'SHOW INDEX FROM ' + ATableName;
  SQLQuery.Open;
  // Afficher les index...
  SQLQuery.Close;

  // Statistiques
  SQLQuery.SQL.Text :=
    'SELECT ' +
    '  TABLE_ROWS as lignes,' +
    '  DATA_LENGTH as taille_donnees,' +
    '  INDEX_LENGTH as taille_index,' +
    '  DATA_FREE as espace_libre ' +
    'FROM information_schema.TABLES ' +
    'WHERE TABLE_SCHEMA = :db AND TABLE_NAME = :table';
  SQLQuery.ParamByName('db').AsString := MySQLConnection.DatabaseName;
  SQLQuery.ParamByName('table').AsString := ATableName;
  SQLQuery.Open;

  ShowMessage(Format('Table %s : %s lignes, %.2f MB donn√©es, %.2f MB index',
    [ATableName,
     SQLQuery.FieldByName('lignes').AsString,
     SQLQuery.FieldByName('taille_donnees').AsFloat / 1048576,
     SQLQuery.FieldByName('taille_index').AsFloat / 1048576]));

  SQLQuery.Close;
end;
```

### Logs MySQL

```pascal
// Configuration des logs
procedure ConfigurerLogs;  
begin
  // Log des requ√™tes lentes
  MySQLConnection.ExecuteDirect('SET GLOBAL slow_query_log = ON');
  MySQLConnection.ExecuteDirect('SET GLOBAL long_query_time = 2'); // 2 secondes

  // Log g√©n√©ral (attention aux performances)
  MySQLConnection.ExecuteDirect('SET GLOBAL general_log = ON');
  MySQLConnection.ExecuteDirect('SET GLOBAL general_log_file = ''/var/log/mysql/general.log''');

  // Log des erreurs
  SQLQuery.SQL.Text := 'SHOW VARIABLES LIKE ''log_error''';
  SQLQuery.Open;
  ShowMessage('Fichier log erreurs : ' + SQLQuery.Fields[1].AsString);
  SQLQuery.Close;
end;

// Lecture des logs depuis l'application
procedure LireDernieresErreurs;  
var
  LogFile: TStringList;
  i: Integer;
begin
  LogFile := TStringList.Create;
  try
    {$IFDEF WINDOWS}
    LogFile.LoadFromFile('C:\ProgramData\MySQL\MySQL Server 8.0\Data\' +
                        ComputerName + '.err');
    {$ENDIF}
    {$IFDEF UNIX}
    LogFile.LoadFromFile('/var/log/mysql/error.log');
    {$ENDIF}

    // Afficher les 20 derni√®res lignes
    for i := Max(0, LogFile.Count - 20) to LogFile.Count - 1 do
      WriteLn(LogFile[i]);
  finally
    LogFile.Free;
  end;
end;
```

## Gestion des utilisateurs et privil√®ges

### Cr√©ation et gestion des utilisateurs

```pascal
procedure GererUtilisateurs;  
begin
  // Cr√©er un nouvel utilisateur
  MySQLConnection.ExecuteDirect(
    'CREATE USER ''app_reader''@''localhost'' IDENTIFIED BY ''password123'''
  );

  // Utilisateur avec acc√®s r√©seau limit√©
  MySQLConnection.ExecuteDirect(
    'CREATE USER ''app_writer''@''192.168.1.%'' IDENTIFIED BY ''password456'''
  );

  // Modifier le mot de passe
  MySQLConnection.ExecuteDirect(
    'ALTER USER ''app_reader''@''localhost'' IDENTIFIED BY ''nouveau_pass'''
  );

  // Supprimer un utilisateur
  MySQLConnection.ExecuteDirect(
    'DROP USER ''old_user''@''localhost'''
  );
end;

// Gestion des privil√®ges
procedure AttribuerPrivileges;  
begin
  // Lecture seule sur une base
  MySQLConnection.ExecuteDirect(
    'GRANT SELECT ON mabase.* TO ''app_reader''@''localhost'''
  );

  // Lecture/√©criture sur des tables sp√©cifiques
  MySQLConnection.ExecuteDirect(
    'GRANT SELECT, INSERT, UPDATE, DELETE ON mabase.clients TO ''app_writer''@''192.168.1.%'''
  );

  // Privil√®ges sur colonnes sp√©cifiques
  MySQLConnection.ExecuteDirect(
    'GRANT SELECT (nom, prenom), UPDATE (email) ON mabase.utilisateurs ' +
    'TO ''app_limited''@''localhost'''
  );

  // Ex√©cution de proc√©dures stock√©es
  MySQLConnection.ExecuteDirect(
    'GRANT EXECUTE ON PROCEDURE mabase.calculer_stats TO ''app_reader''@''localhost'''
  );

  // Appliquer les changements
  MySQLConnection.ExecuteDirect('FLUSH PRIVILEGES');
end;

// Audit des privil√®ges
procedure AuditerPrivileges;  
begin
  // Voir tous les utilisateurs
  SQLQuery.SQL.Text := 'SELECT User, Host FROM mysql.user';
  SQLQuery.Open;
  // Afficher la liste...
  SQLQuery.Close;

  // Privil√®ges d'un utilisateur sp√©cifique
  SQLQuery.SQL.Text := 'SHOW GRANTS FOR ''app_reader''@''localhost''';
  SQLQuery.Open;
  while not SQLQuery.EOF do
  begin
    WriteLn(SQLQuery.Fields[0].AsString);
    SQLQuery.Next;
  end;
  SQLQuery.Close;
end;
```

## Partitionnement des tables

### Cr√©ation de tables partitionn√©es

```pascal
// Partitionnement par plage de dates
procedure CreerTablePartitionnee;  
begin
  MySQLConnection.ExecuteDirect(
    'CREATE TABLE commandes_part (' +
    '  id INT AUTO_INCREMENT,' +
    '  date_commande DATE,' +
    '  client_id INT,' +
    '  montant DECIMAL(10,2),' +
    '  PRIMARY KEY (id, date_commande)' +
    ') PARTITION BY RANGE (YEAR(date_commande)) (' +
    '  PARTITION p2020 VALUES LESS THAN (2021),' +
    '  PARTITION p2021 VALUES LESS THAN (2022),' +
    '  PARTITION p2022 VALUES LESS THAN (2023),' +
    '  PARTITION p2023 VALUES LESS THAN (2024),' +
    '  PARTITION p2024 VALUES LESS THAN (2025),' +
    '  PARTITION p_future VALUES LESS THAN MAXVALUE' +
    ')'
  );
end;

// Partitionnement par hash
procedure PartitionnerParHash;  
begin
  MySQLConnection.ExecuteDirect(
    'CREATE TABLE clients_part (' +
    '  id INT PRIMARY KEY,' +
    '  nom VARCHAR(100),' +
    '  region VARCHAR(50)' +
    ') PARTITION BY HASH(id) PARTITIONS 10'
  );
end;

// Gestion des partitions
procedure GererPartitions;  
begin
  // Ajouter une partition
  MySQLConnection.ExecuteDirect(
    'ALTER TABLE commandes_part ADD PARTITION (' +
    '  PARTITION p2025 VALUES LESS THAN (2026)' +
    ')'
  );

  // Supprimer une partition (et ses donn√©es!)
  MySQLConnection.ExecuteDirect(
    'ALTER TABLE commandes_part DROP PARTITION p2020'
  );

  // R√©organiser une partition
  MySQLConnection.ExecuteDirect(
    'ALTER TABLE commandes_part REORGANIZE PARTITION p_future INTO (' +
    '  PARTITION p2025 VALUES LESS THAN (2026),' +
    '  PARTITION p_future VALUES LESS THAN MAXVALUE' +
    ')'
  );

  // Voir les partitions
  SQLQuery.SQL.Text :=
    'SELECT PARTITION_NAME, TABLE_ROWS ' +
    'FROM information_schema.PARTITIONS ' +
    'WHERE TABLE_NAME = ''commandes_part''';
  SQLQuery.Open;
end;
```

## Fonctionnalit√©s sp√©cifiques MariaDB

### Colonnes virtuelles (MariaDB 5.2+)

```pascal
// Colonnes calcul√©es automatiquement
procedure ColonnesVirtuelles;  
begin
  MySQLConnection.ExecuteDirect(
    'CREATE TABLE produits_v (' +
    '  id INT PRIMARY KEY,' +
    '  prix_ht DECIMAL(10,2),' +
    '  taux_tva DECIMAL(4,2) DEFAULT 20.0,' +
    '  prix_ttc DECIMAL(10,2) AS (prix_ht * (1 + taux_tva/100)) VIRTUAL,' +
    '  prix_ttc_stored DECIMAL(10,2) AS (prix_ht * (1 + taux_tva/100)) STORED' +
    ')'
  );

  // Utilisation normale
  SQLQuery.SQL.Text := 'INSERT INTO produits_v (id, prix_ht) VALUES (1, 100.00)';
  SQLQuery.ExecSQL;

  // La colonne virtuelle est calcul√©e automatiquement
  SQLQuery.SQL.Text := 'SELECT prix_ttc FROM produits_v WHERE id = 1';
  SQLQuery.Open;
  ShowMessage('Prix TTC : ' + SQLQuery.Fields[0].AsString); // Affiche 120.00
end;
```

### S√©quences (MariaDB 10.3+)

```pascal
// Alternative aux AUTO_INCREMENT
procedure UtiliserSequences;  
begin
  // Cr√©er une s√©quence
  MySQLConnection.ExecuteDirect(
    'CREATE SEQUENCE seq_facture START WITH 1000 INCREMENT BY 1'
  );

  // Utiliser la s√©quence
  SQLQuery.SQL.Text :=
    'INSERT INTO factures (numero, montant) ' +
    'VALUES (NEXT VALUE FOR seq_facture, :montant)';
  SQLQuery.ParamByName('montant').AsCurrency := 250.00;
  SQLQuery.ExecSQL;

  // Obtenir la valeur actuelle
  SQLQuery.SQL.Text := 'SELECT LASTVAL(seq_facture)';
  SQLQuery.Open;
  ShowMessage('Dernier num√©ro : ' + SQLQuery.Fields[0].AsString);
end;
```

### Tables syst√®me versionn√©es (MariaDB 10.3+)

```pascal
// Historique automatique des modifications
procedure TablesVersionnees;  
begin
  MySQLConnection.ExecuteDirect(
    'CREATE TABLE employes (' +
    '  id INT PRIMARY KEY,' +
    '  nom VARCHAR(100),' +
    '  salaire DECIMAL(10,2)' +
    ') WITH SYSTEM VERSIONING'
  );

  // Les modifications sont automatiquement historis√©es
  MySQLConnection.ExecuteDirect(
    'UPDATE employes SET salaire = 3000 WHERE id = 1'
  );

  // Voir l'historique
  SQLQuery.SQL.Text :=
    'SELECT * FROM employes ' +
    'FOR SYSTEM_TIME ALL WHERE id = 1';
  SQLQuery.Open;
  // Affiche toutes les versions de l'enregistrement

  // √âtat √† une date pr√©cise
  SQLQuery.SQL.Text :=
    'SELECT * FROM employes ' +
    'FOR SYSTEM_TIME AS OF TIMESTAMP ''2024-01-01 00:00:00''';
  SQLQuery.Open;
end;
```

## Gestion des erreurs sp√©cifiques MySQL/MariaDB

```pascal
procedure GererErreursMySQL(E: Exception);  
var
  ErrorCode: Integer;
  ErrorMsg: string;
begin
  if E is ESQLDatabaseError then
  begin
    ErrorMsg := E.Message;

    // Extraction du code d'erreur MySQL
    if Pos('Error Code: ', ErrorMsg) > 0 then
    begin
      ErrorCode := StrToIntDef(
        Copy(ErrorMsg, Pos('Error Code: ', ErrorMsg) + 12, 4), 0);

      case ErrorCode of
        1045: ShowMessage('Acc√®s refus√© : v√©rifiez utilisateur/mot de passe');
        1049: ShowMessage('Base de donn√©es inconnue');
        1054: ShowMessage('Colonne inconnue dans la requ√™te');
        1062: ShowMessage('Violation de contrainte unique (doublon)');
        1064: ShowMessage('Erreur de syntaxe SQL');
        1146: ShowMessage('Table inexistante');
        1213: ShowMessage('Deadlock d√©tect√©, r√©essayez la transaction');
        1216: ShowMessage('Violation de cl√© √©trang√®re');
        1217: ShowMessage('Enregistrement r√©f√©renc√©, suppression impossible');
        1364: ShowMessage('Champ obligatoire sans valeur par d√©faut');
        1406: ShowMessage('Donn√©es trop longues pour la colonne');
        1451: ShowMessage('Impossible de supprimer : contrainte de cl√© √©trang√®re');
        1452: ShowMessage('Impossible d''ajouter : cl√© √©trang√®re invalide');
        2002: ShowMessage('Impossible de se connecter au serveur MySQL');
        2003: ShowMessage('Connexion au serveur impossible (v√©rifiez host/port)');
        2006: ShowMessage('Le serveur MySQL est parti (connexion perdue)');
        2013: ShowMessage('Connexion perdue pendant la requ√™te');
      else
        ShowMessage(Format('Erreur MySQL %d : %s', [ErrorCode, ErrorMsg]));
      end;
    end
    else
      ShowMessage('Erreur base de donn√©es : ' + ErrorMsg);
  end
  else
    ShowMessage('Erreur : ' + E.Message);
end;

// Utilisation avec gestion d'erreurs
procedure ExecuterAvecGestionErreurs;  
begin
  try
    SQLQuery.SQL.Text := 'SELECT * FROM table_inexistante';
    SQLQuery.Open;
  except
    on E: Exception do
      GererErreursMySQL(E);
  end;
end;
```

## Pool de connexions optimis√©

```pascal
type
  TMySQLConnectionPool = class
  private
    FConnections: TThreadList;
    FMaxConnections: Integer;
    FConnectionString: TConnectionParams;
    FCriticalSection: TCriticalSection;
    FActiveCount: Integer;
    FWaitingCount: Integer;
  public
    constructor Create(AMaxConnections: Integer);
    destructor Destroy; override;
    function GetConnection: TMySQLConnection;
    procedure ReleaseConnection(AConnection: TMySQLConnection);
    procedure ValidateConnection(AConnection: TMySQLConnection);
    property ActiveConnections: Integer read FActiveCount;
    property WaitingRequests: Integer read FWaitingCount;
  end;

implementation

function TMySQLConnectionPool.GetConnection: TMySQLConnection;  
var
  List: TList;
  i: Integer;
begin
  Result := nil;
  FCriticalSection.Enter;
  try
    Inc(FWaitingCount);

    List := FConnections.LockList;
    try
      // Chercher une connexion libre
      for i := 0 to List.Count - 1 do
      begin
        Result := TMySQLConnection(List[i]);
        if not Result.InUse then
        begin
          // Valider que la connexion est toujours valide
          ValidateConnection(Result);
          Result.InUse := True;
          Inc(FActiveCount);
          Dec(FWaitingCount);
          Exit;
        end;
      end;

      // Cr√©er une nouvelle connexion si possible
      if List.Count < FMaxConnections then
      begin
        Result := TMySQLConnection.Create(nil);
        Result.HostName := FConnectionString.Host;
        Result.DatabaseName := FConnectionString.Database;
        Result.UserName := FConnectionString.Username;
        Result.Password := FConnectionString.Password;
        Result.CharSet := 'utf8mb4';

        // Options de performance
        Result.Params.Add('connect_timeout=5');
        Result.Params.Add('interactive_timeout=28800');
        Result.Params.Add('wait_timeout=28800');

        Result.Connected := True;
        Result.InUse := True;
        List.Add(Result);
        Inc(FActiveCount);
        Dec(FWaitingCount);
      end;
    finally
      FConnections.UnlockList;
    end;
  finally
    FCriticalSection.Leave;
  end;

  // Si aucune connexion disponible, attendre
  if Result = nil then
  begin
    Sleep(100);
    Result := GetConnection; // R√©cursif
  end;
end;

procedure TMySQLConnectionPool.ValidateConnection(AConnection: TMySQLConnection);  
begin
  try
    // Ping pour v√©rifier la connexion
    AConnection.ExecuteDirect('SELECT 1');
  except
    // Reconnecter si n√©cessaire
    AConnection.Connected := False;
    AConnection.Connected := True;
  end;
end;
```

## Conclusion et bonnes pratiques r√©capitulatives

### Points essentiels √† retenir

1. **Toujours utiliser utf8mb4** pour un support Unicode complet
2. **Pr√©f√©rer InnoDB** pour les transactions et l'int√©grit√© r√©f√©rentielle
3. **Utiliser des index appropri√©s** mais sans exc√®s
4. **Param√©trer les requ√™tes** pour √©viter les injections SQL
5. **G√©rer les connexions** avec un pool en multi-utilisateurs
6. **Sauvegarder r√©guli√®rement** avec mysqldump ou alternatives
7. **Monitorer les performances** avec EXPLAIN et les logs
8. **S√©curiser les connexions** avec SSL pour les donn√©es sensibles
9. **G√©rer les erreurs sp√©cifiquement** selon les codes MySQL
10. **Tester la compatibilit√©** entre MySQL et MariaDB selon les fonctionnalit√©s utilis√©es

### Ressources compl√©mentaires

- Documentation MySQL : https://dev.mysql.com/doc/
- Documentation MariaDB : https://mariadb.com/kb/
- MySQL Workbench pour l'administration graphique
- HeidiSQL : Alternative l√©g√®re multi-plateforme
- phpMyAdmin : Interface web d'administration

MySQL/MariaDB avec FreePascal/Lazarus offre une solution robuste et √©prouv√©e pour le d√©veloppement d'applications de toutes tailles, avec une excellente portabilit√© entre Windows et Linux.

‚è≠Ô∏è [SQLite (embarqu√©)](/08-bases-donnees-orm-multiplatefomes/02.3-sqlite-embarque.md)
