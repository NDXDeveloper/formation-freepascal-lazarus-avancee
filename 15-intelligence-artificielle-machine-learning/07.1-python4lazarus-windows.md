ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 15.7.1 Python4Lazarus sur Windows

## Introduction

Cette section vous guide pas Ã  pas dans l'installation et la configuration de Python4Lazarus sur Windows. Nous allons voir comment intÃ©grer l'interprÃ©teur Python directement dans vos applications Lazarus sous Windows, avec toutes les spÃ©cificitÃ©s et bonnes pratiques de cette plateforme.

## PrÃ©requis

Avant de commencer, assurez-vous d'avoir :

### 1. Lazarus et FreePascal installÃ©s

VÃ©rifiez votre installation :
- Ouvrez Lazarus
- Allez dans **Aide â†’ Ã€ propos de Lazarus**
- VÃ©rifiez que vous avez au minimum :
  - Lazarus 2.0 ou supÃ©rieur
  - FreePascal 3.2.0 ou supÃ©rieur

### 2. Python installÃ© sur Windows

**Option A : Installation depuis python.org (recommandÃ©e)**

1. TÃ©lÃ©chargez Python depuis [https://www.python.org/downloads/](https://www.python.org/downloads/)
2. Choisissez Python 3.9, 3.10 ou 3.11 (versions stables et bien supportÃ©es)
3. **IMPORTANT** : Lors de l'installation, cochez **"Add Python to PATH"**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Python 3.10.x Setup                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â˜‘ Install launcher for all users      â”‚
â”‚  â˜‘ Add Python 3.10 to PATH   â† CRUCIAL â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

4. Notez le chemin d'installation (gÃ©nÃ©ralement `C:\Python310` ou `C:\Users\VotreNom\AppData\Local\Programs\Python\Python310`)

**Option B : Via le Microsoft Store**

1. Ouvrez le Microsoft Store
2. Recherchez "Python 3.10"
3. Cliquez sur "Obtenir" puis "Installer"
4. Python sera installÃ© dans `C:\Users\VotreNom\AppData\Local\Microsoft\WindowsApps\`

**VÃ©rification de l'installation Python**

Ouvrez l'invite de commande (Win+R, tapez `cmd`) :

```cmd
python --version
```

Vous devriez voir :
```
Python 3.10.11
```

Si vous voyez un message d'erreur, Python n'est pas dans le PATH. Vous devrez ajouter le chemin manuellement.

### 3. ConnaÃ®tre les chemins Python importants

ExÃ©cutez dans l'invite de commande :

```cmd
python -c "import sys; print(sys.executable)"
```

Cela affiche le chemin de l'exÃ©cutable Python, par exemple :
```
C:\Python310\python.exe
```

Le dossier contenant `python310.dll` est gÃ©nÃ©ralement le mÃªme :
```
C:\Python310\python310.dll
```

**Notez ces chemins, vous en aurez besoin !**

## Installation de Python4Lazarus

### MÃ©thode 1 : Installation via OPM (Online Package Manager) - RecommandÃ©e

C'est la mÃ©thode la plus simple.

**Ã‰tape 1 : Ouvrir OPM**

1. Ouvrez Lazarus
2. Allez dans **Paquets â†’ Gestionnaire de paquets en ligne (OPM)**
3. Attendez que la liste des paquets se charge

**Ã‰tape 2 : Rechercher Python4Lazarus**

1. Dans la barre de recherche, tapez : `python`
2. Cherchez **"Python4Lazarus"** ou **"python4delphi"** dans la liste
3. SÃ©lectionnez le paquet

**Ã‰tape 3 : Installer**

1. Cliquez sur **"Installer"**
2. OPM tÃ©lÃ©charge et installe le paquet
3. Ã€ la fin, cliquez sur **"Recompiler l'IDE"**
4. Lazarus va redÃ©marrer

**Ã‰tape 4 : VÃ©rification**

AprÃ¨s le redÃ©marrage :
1. Allez dans l'onglet **Composants** de la palette
2. Vous devriez voir un nouvel onglet **"Python"** avec les composants :
   - `TPythonEngine`
   - `TPythonModule`
   - `TPythonInputOutput`
   - `TPythonGUIInputOutput`

### MÃ©thode 2 : Installation manuelle depuis GitHub

Si OPM ne fonctionne pas ou si vous voulez la derniÃ¨re version.

**Ã‰tape 1 : TÃ©lÃ©charger Python4Lazarus**

1. Allez sur [https://github.com/pyscripter/python4delphi](https://github.com/pyscripter/python4delphi)
2. Cliquez sur **Code â†’ Download ZIP**
3. Extrayez le ZIP dans un dossier, par exemple : `C:\Dev\Python4Delphi`

**Ã‰tape 2 : Ouvrir le paquet dans Lazarus**

1. Dans Lazarus, allez dans **Paquet â†’ Ouvrir un fichier paquet (.lpk)**
2. Naviguez vers le dossier extrait
3. Ouvrez le fichier : `Python4Delphi\Packages\Lazarus\python4lazarus_package.lpk`

**Ã‰tape 3 : Compiler et installer**

1. Dans la fenÃªtre du paquet, cliquez sur **"Compiler"**
2. Une fois compilÃ© avec succÃ¨s, cliquez sur **"Utiliser â†’ Installer"**
3. Lazarus demandera de recompiler l'IDE, acceptez
4. Lazarus redÃ©marre avec Python4Lazarus installÃ©

**Ã‰tape 4 : VÃ©rification**

VÃ©rifiez la prÃ©sence des composants Python dans la palette de composants.

## Configuration de base

### CrÃ©er un premier projet de test

**Ã‰tape 1 : Nouveau projet**

1. **Projet â†’ Nouveau projet**
2. Choisissez **Application**
3. Enregistrez le projet : `TestPython.lpi`

**Ã‰tape 2 : Ajouter un TPythonEngine**

1. Dans la palette de composants, onglet **Python**
2. Cliquez sur `TPythonEngine`
3. Cliquez sur le formulaire pour le placer (il sera invisible, c'est normal)
4. Le composant apparaÃ®t en bas du formulaire dans la zone des composants non-visuels

**Ã‰tape 3 : Configurer TPythonEngine**

SÃ©lectionnez `PythonEngine1` dans l'Object Inspector et configurez :

```
PropriÃ©tÃ© : DllPath  
Valeur   : C:\Python310
(Remplacez par votre chemin Python)

PropriÃ©tÃ© : DllName  
Valeur   : python310.dll
(Adaptez selon votre version : python39.dll, python311.dll, etc.)
```

**Alternatives pour trouver automatiquement Python** :

Vous pouvez laisser `DllPath` vide et Python4Lazarus cherchera Python dans le PATH Windows.

**Ã‰tape 4 : Ajouter un TPythonGUIInputOutput**

1. Cliquez sur `TPythonGUIInputOutput` dans la palette
2. Placez-le sur le formulaire
3. Dans l'Object Inspector, configurez :

```
PropriÃ©tÃ© : Engine  
Valeur   : PythonEngine1
```

Cela connecte l'objet InputOutput Ã  votre moteur Python.

**Ã‰tape 5 : Ajouter des composants visuels**

Ajoutez sur votre formulaire :
- 1 `TMemo` : nommez-le `MemoCode` (pour Ã©crire du code Python)
- 1 `TButton` : nommez-le `ButtonExecute`, Caption = "ExÃ©cuter"
- 1 `TMemo` : nommez-le `MemoOutput` (pour voir les rÃ©sultats)

**Disposition suggÃ©rÃ©e** :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MemoCode (Code Python)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ print("Hello from Python!")      â”‚  â”‚
â”‚  â”‚ x = 10 + 20                      â”‚  â”‚
â”‚  â”‚ print(f"RÃ©sultat : {x}")         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                        â”‚
â”‚  [ExÃ©cuter]  â† ButtonExecute           â”‚
â”‚                                        â”‚
â”‚  MemoOutput (RÃ©sultat)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Hello from Python!               â”‚  â”‚
â”‚  â”‚ RÃ©sultat : 30                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Ã‰crire le code Pascal

**Ã‰tape 1 : Initialisation de Python**

Double-cliquez sur le formulaire pour crÃ©er l'Ã©vÃ©nement `OnCreate` :

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
begin
  // Initialiser Python
  try
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      MemoOutput.Lines.Add('Python initialisÃ© avec succÃ¨s !');
      MemoOutput.Lines.Add('Version : ' + PythonEngine1.PyVersion);
    end
    else
      MemoOutput.Lines.Add('ERREUR : Python non initialisÃ©');

  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''initialisation :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;
```

**Ã‰tape 2 : Configurer la sortie Python**

Double-cliquez sur `PythonGUIInputOutput1` et crÃ©ez l'Ã©vÃ©nement `OnSendData` :

```pascal
procedure TForm1.PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);  
begin
  // Afficher les print() Python dans MemoOutput
  MemoOutput.Lines.Add(Data);
end;
```

**Ã‰tape 3 : ExÃ©cution du code Python**

Double-cliquez sur `ButtonExecute` et ajoutez :

```pascal
procedure TForm1.ButtonExecuteClick(Sender: TObject);  
var
  Code: string;
begin
  if not PythonEngine1.Initialized then
  begin
    ShowMessage('Python n''est pas initialisÃ© !');
    Exit;
  end;

  // Effacer l'ancien rÃ©sultat
  MemoOutput.Clear;

  // RÃ©cupÃ©rer le code Python
  Code := MemoCode.Text;

  try
    // ExÃ©cuter le code Python
    PythonEngine1.ExecStrings(MemoCode.Lines);
  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''exÃ©cution :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;
```

**Ã‰tape 4 : LibÃ©ration des ressources**

Double-cliquez sur le formulaire et crÃ©ez `OnDestroy` :

```pascal
procedure TForm1.FormDestroy(Sender: TObject);  
begin
  // LibÃ©rer Python proprement
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;
```

### Code complet du formulaire

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  PythonEngine, PythonGUIInputOutput;

type
  TForm1 = class(TForm)
    ButtonExecute: TButton;
    MemoCode: TMemo;
    MemoOutput: TMemo;
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonExecuteClick(Sender: TObject);
    procedure PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);
  private

  public

  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

procedure TForm1.FormCreate(Sender: TObject);  
begin
  try
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      MemoOutput.Lines.Add('Python initialisÃ© avec succÃ¨s !');
      MemoOutput.Lines.Add('Version : ' + PythonEngine1.PyVersion);
    end
    else
      MemoOutput.Lines.Add('ERREUR : Python non initialisÃ©');

  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''initialisation :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;

procedure TForm1.FormDestroy(Sender: TObject);  
begin
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TForm1.ButtonExecuteClick(Sender: TObject);  
begin
  if not PythonEngine1.Initialized then
  begin
    ShowMessage('Python n''est pas initialisÃ© !');
    Exit;
  end;

  MemoOutput.Clear;

  try
    PythonEngine1.ExecStrings(MemoCode.Lines);
  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('ERREUR lors de l''exÃ©cution :');
      MemoOutput.Lines.Add(E.Message);
    end;
  end;
end;

procedure TForm1.PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);  
begin
  MemoOutput.Lines.Add(Data);
end;

end.
```

### Tester l'application

**Test 1 : Hello World**

Dans `MemoCode`, Ã©crivez :
```python
print("Hello from Python!")  
print("Ceci fonctionne dans Lazarus !")
```

Cliquez sur **ExÃ©cuter**. Vous devriez voir dans `MemoOutput` :
```
Hello from Python!  
Ceci fonctionne dans Lazarus !
```

**Test 2 : Calculs**

```python
import math

x = 10  
y = 20  
print(f"Addition : {x} + {y} = {x + y}")  
print(f"Racine carrÃ©e de 16 : {math.sqrt(16)}")
```

**Test 3 : BibliothÃ¨ques externes**

```python
import sys  
print(f"Version Python : {sys.version}")  
print(f"Chemin d'exÃ©cution : {sys.executable}")
```

## Gestion des chemins Python sous Windows

### ProblÃ¨me courant : DLL introuvable

**Erreur typique :**
```
Could not load library python310.dll
```

**Solutions :**

**Solution 1 : SpÃ©cifier le chemin complet**

```pascal
PythonEngine1.DllPath := 'C:\Python310';  
PythonEngine1.DllName := 'python310.dll';
```

**Solution 2 : Utiliser UseLastKnownVersion**

```pascal
PythonEngine1.UseLastKnownVersion := True;  
PythonEngine1.LoadDll;
```

Cela recherche automatiquement la derniÃ¨re version de Python installÃ©e.

**Solution 3 : Ajouter au PATH systÃ¨me**

1. Ouvrez **Panneau de configuration â†’ SystÃ¨me â†’ ParamÃ¨tres systÃ¨me avancÃ©s**
2. Cliquez sur **Variables d'environnement**
3. Dans **Variables systÃ¨me**, sÃ©lectionnez **Path**, cliquez **Modifier**
4. Ajoutez : `C:\Python310` (votre chemin Python)
5. RedÃ©marrez Lazarus

**Solution 4 : DÃ©tection automatique par code**

```pascal
function FindPythonDLL: string;  
var
  PythonDir: string;
begin
  // Essayer diffÃ©rents emplacements
  if FileExists('C:\Python310\python310.dll') then
    Result := 'C:\Python310\python310.dll'
  else if FileExists('C:\Python39\python39.dll') then
    Result := 'C:\Python39\python39.dll'
  else if FileExists('C:\Python311\python311.dll') then
    Result := 'C:\Python311\python311.dll'
  else
    Result := ''; // Non trouvÃ©
end;

procedure TForm1.FormCreate(Sender: TObject);  
var
  PythonDLL: string;
begin
  PythonDLL := FindPythonDLL;

  if PythonDLL <> '' then
  begin
    PythonEngine1.DllPath := ExtractFilePath(PythonDLL);
    PythonEngine1.DllName := ExtractFileName(PythonDLL);
    PythonEngine1.LoadDll;
  end
  else
    ShowMessage('Python introuvable !');
end;
```

### DÃ©tection dynamique depuis le registre Windows

Python s'enregistre dans le registre. Vous pouvez le dÃ©tecter :

```pascal
uses
  Registry;

function GetPythonPathFromRegistry: string;  
var
  Reg: TRegistry;
begin
  Result := '';
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;

    // Python 3.10
    if Reg.OpenKeyReadOnly('SOFTWARE\Python\PythonCore\3.10\InstallPath') then
    begin
      Result := Reg.ReadString('');
      Reg.CloseKey;
    end;

    // Si 3.10 non trouvÃ©, essayer 3.9
    if (Result = '') and Reg.OpenKeyReadOnly('SOFTWARE\Python\PythonCore\3.9\InstallPath') then
    begin
      Result := Reg.ReadString('');
      Reg.CloseKey;
    end;

  finally
    Reg.Free;
  end;
end;

procedure TForm1.FormCreate(Sender: TObject);  
var
  PythonPath: string;
begin
  PythonPath := GetPythonPathFromRegistry;

  if PythonPath <> '' then
  begin
    PythonEngine1.DllPath := PythonPath;
    PythonEngine1.LoadDll;
  end;
end;
```

## Utilisation de bibliothÃ¨ques Python tierces

### Installer des bibliothÃ¨ques avec pip

Ouvrez l'invite de commande :

```cmd
pip install numpy  
pip install pandas  
pip install tensorflow  
pip install scikit-learn
```

### VÃ©rifier l'installation

```cmd
pip list
```

Vous verrez la liste des paquets installÃ©s.

### Utiliser les bibliothÃ¨ques dans votre application

```pascal
procedure TForm1.ButtonTestNumpyClick(Sender: TObject);  
begin
  try
    PythonEngine1.ExecString('import numpy as np');
    PythonEngine1.ExecString('arr = np.array([1, 2, 3, 4, 5])');
    PythonEngine1.ExecString('print(f"Tableau : {arr}")');
    PythonEngine1.ExecString('print(f"Moyenne : {np.mean(arr)}")');
  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

### ProblÃ¨me : ImportError avec des bibliothÃ¨ques

**Erreur :**
```
ImportError: DLL load failed: Le module spÃ©cifiÃ© est introuvable
```

**Cause :** BibliothÃ¨ques Python qui dÃ©pendent de DLL C/C++ externes (comme NumPy, TensorFlow).

**Solutions :**

1. **Installer Microsoft Visual C++ Redistributable**
   - TÃ©lÃ©chargez depuis [Microsoft](https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads)
   - Installez les versions x64 (2015-2022)

2. **VÃ©rifier l'architecture (32-bit vs 64-bit)**
   - Votre application Lazarus doit correspondre Ã  votre Python
   - Python 64-bit â†’ Application 64-bit
   - VÃ©rifiez avec : `python -c "import sys; print(sys.maxsize > 2**32)"`
   - True = 64-bit, False = 32-bit

3. **Utiliser une distribution Python avec tout inclus**
   - **Anaconda** : Contient NumPy, SciPy, etc. prÃ©-compilÃ©s
   - TÃ©lÃ©chargez depuis [anaconda.com](https://www.anaconda.com/products/distribution)

## Gestion des versions Python multiples

### Utiliser plusieurs versions de Python

Si vous avez Python 3.9, 3.10 et 3.11 installÃ©s :

```pascal
type
  TForm1 = class(TForm)
  private
    procedure LoadPythonVersion(Version: Integer);
  end;

procedure TForm1.LoadPythonVersion(Version: Integer);  
begin
  case Version of
    39:
    begin
      PythonEngine1.DllPath := 'C:\Python39';
      PythonEngine1.DllName := 'python39.dll';
    end;
    310:
    begin
      PythonEngine1.DllPath := 'C:\Python310';
      PythonEngine1.DllName := 'python310.dll';
    end;
    311:
    begin
      PythonEngine1.DllPath := 'C:\Python311';
      PythonEngine1.DllName := 'python311.dll';
    end;
  end;

  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
    ShowMessage('Python ' + PythonEngine1.PyVersion + ' chargÃ©')
  else
    ShowMessage('Ã‰chec du chargement');
end;
```

### Utiliser des environnements virtuels Python

**CrÃ©er un environnement virtuel :**

```cmd
cd C:\MonProjet  
python -m venv venv
```

**Activer l'environnement :**

```cmd
venv\Scripts\activate
```

**Installer des bibliothÃ¨ques dans cet environnement :**

```cmd
pip install tensorflow numpy
```

**Utiliser cet environnement dans Lazarus :**

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
begin
  // Pointer vers le Python de l'environnement virtuel
  PythonEngine1.DllPath := 'C:\MonProjet\venv\Scripts';
  PythonEngine1.DllName := 'python310.dll';
  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
  begin
    // Configurer le path Python pour trouver les modules du venv
    PythonEngine1.ExecString('import sys');
    PythonEngine1.ExecString('sys.path.insert(0, r"C:\MonProjet\venv\Lib\site-packages")');
  end;
end;
```

## Configuration avancÃ©e

### Passer des variables de Pascal Ã  Python

**MÃ©thode 1 : Injection directe dans le code**

```pascal
var
  UserName: string;
  Age: Integer;
begin
  UserName := 'Alice';
  Age := 25;

  PythonEngine1.ExecString(Format('name = "%s"', [UserName]));
  PythonEngine1.ExecString(Format('age = %d', [Age]));
  PythonEngine1.ExecString('print(f"Bonjour {name}, vous avez {age} ans")');
end;
```

**MÃ©thode 2 : Via SetVarFromVariant**

```pascal
procedure TForm1.ButtonPassDataClick(Sender: TObject);  
begin
  PythonEngine1.SetVar('pascal_text', VarPythonCreate('Texte depuis Pascal'));
  PythonEngine1.SetVar('pascal_number', VarPythonCreate(42));

  PythonEngine1.ExecString('print(f"Texte : {pascal_text}")');
  PythonEngine1.ExecString('print(f"Nombre : {pascal_number}")');
end;
```

### RÃ©cupÃ©rer des rÃ©sultats de Python

**MÃ©thode 1 : Via EvalString**

```pascal
var
  Result: string;
begin
  PythonEngine1.ExecString('result = 10 + 20');
  Result := PythonEngine1.EvalString('result');
  ShowMessage('RÃ©sultat : ' + Result); // "30"
end;
```

**MÃ©thode 2 : Via GetVarAsVariant**

```pascal
var
  PyResult: Variant;
  IntResult: Integer;
begin
  PythonEngine1.ExecString('my_value = 100');
  PyResult := PythonEngine1.GetVar('my_value');
  IntResult := PyResult;
  ShowMessage(IntToStr(IntResult)); // "100"
end;
```

### Appeler des fonctions Python dÃ©finies

```pascal
procedure TForm1.ButtonCallFunctionClick(Sender: TObject);  
var
  ResultStr: string;
begin
  // DÃ©finir une fonction Python
  PythonEngine1.ExecString(
    'def multiply(a, b):' + sLineBreak +
    '    return a * b'
  );

  // Appeler la fonction
  PythonEngine1.ExecString('result = multiply(7, 6)');
  ResultStr := PythonEngine1.EvalString('str(result)');

  ShowMessage('7 Ã— 6 = ' + ResultStr); // "42"
end;
```

### Charger et exÃ©cuter des scripts externes

**Script Python externe : `analysis.py`**

```python
def analyze_data(numbers):
    """Analyse une liste de nombres"""
    return {
        'sum': sum(numbers),
        'average': sum(numbers) / len(numbers),
        'max': max(numbers),
        'min': min(numbers)
    }

def main():
    data = [10, 20, 30, 40, 50]
    result = analyze_data(data)
    print(f"Somme : {result['sum']}")
    print(f"Moyenne : {result['average']}")
```

**Depuis Pascal :**

```pascal
procedure TForm1.ButtonLoadScriptClick(Sender: TObject);  
var
  ScriptPath: string;
begin
  ScriptPath := ExtractFilePath(Application.ExeName) + 'analysis.py';

  if FileExists(ScriptPath) then
  begin
    // ExÃ©cuter le script
    PythonEngine1.ExecFile(ScriptPath);

    // Appeler la fonction main du script
    PythonEngine1.ExecString('main()');
  end
  else
    ShowMessage('Script introuvable : ' + ScriptPath);
end;
```

## DÃ©bogage et rÃ©solution de problÃ¨mes

### Afficher les erreurs Python dÃ©taillÃ©es

```pascal
procedure TForm1.ExecutePythonWithDebug(const Code: string);  
begin
  try
    PythonEngine1.ExecString(Code);
  except
    on E: Exception do
    begin
      MemoOutput.Lines.Add('=== ERREUR PYTHON ===');
      MemoOutput.Lines.Add(E.Message);

      // Afficher le traceback Python complet
      if PythonEngine1.PyErr_Occurred <> nil then
      begin
        PythonEngine1.PyErr_Print;
        MemoOutput.Lines.Add('Voir la console pour le traceback complet');
      end;
    end;
  end;
end;
```

### Capturer stderr Python

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
begin
  PythonEngine1.LoadDll;

  // Rediriger stderr vers notre interface
  PythonEngine1.ExecString('import sys');
  PythonEngine1.ExecString('sys.stderr = sys.stdout');

  // Maintenant les erreurs apparaÃ®tront aussi dans PythonGUIInputOutput
end;
```

### VÃ©rifier si un module est disponible

```pascal
function TForm1.IsPythonModuleAvailable(const ModuleName: string): Boolean;  
begin
  Result := False;
  try
    PythonEngine1.ExecString('import ' + ModuleName);
    Result := True;
  except
    // Module non disponible
  end;
end;

// Utilisation
if IsPythonModuleAvailable('tensorflow') then
  ShowMessage('TensorFlow est disponible !')
else
  ShowMessage('TensorFlow n''est pas installÃ©');
```

### Logger toutes les opÃ©rations Python

```pascal
type
  TForm1 = class(TForm)
  private
    FLogFile: TextFile;
    procedure LogPythonCommand(const Command: string);
  end;

procedure TForm1.LogPythonCommand(const Command: string);  
begin
  WriteLn(FLogFile, FormatDateTime('hh:nn:ss', Now) + ' - ' + Command);
  Flush(FLogFile);
end;

procedure TForm1.FormCreate(Sender: TObject);  
begin
  AssignFile(FLogFile, 'python_log.txt');
  Rewrite(FLogFile);
end;

procedure TForm1.ExecuteAndLog(const Code: string);  
begin
  LogPythonCommand('EXEC: ' + Code);
  try
    PythonEngine1.ExecString(Code);
    LogPythonCommand('SUCCESS');
  except
    on E: Exception do
    begin
      LogPythonCommand('ERROR: ' + E.Message);
      raise;
    end;
  end;
end;
```

## Optimisation des performances

### Ã‰viter les ExecString rÃ©pÃ©tÃ©s

**âŒ Lent (multiples appels) :**

```pascal
PythonEngine1.ExecString('import numpy as np');  
PythonEngine1.ExecString('data = [1, 2, 3, 4, 5]');  
PythonEngine1.ExecString('result = np.mean(data)');  
PythonEngine1.ExecString('print(result)');
```

**âœ… Rapide (un seul appel) :**

```pascal
PythonEngine1.ExecString(
  'import numpy as np' + sLineBreak +
  'data = [1, 2, 3, 4, 5]' + sLineBreak +
  'result = np.mean(data)' + sLineBreak +
  'print(result)'
);
```

### RÃ©utiliser des objets Python

**âŒ Lent (rÃ©importer Ã  chaque fois) :**

```pascal
procedure TForm1.ProcessImage1Click(Sender: TObject);  
begin
  PythonEngine1.ExecString('import cv2');
  PythonEngine1.ExecString('img = cv2.imread("photo1.jpg")');
  // Traitement...
end;

procedure TForm1.ProcessImage2Click(Sender: TObject);  
begin
  PythonEngine1.ExecString('import cv2'); // RÃ©importation inutile
  PythonEngine1.ExecString('img = cv2.imread("photo2.jpg")');
  // Traitement...
end;
```

**âœ… Rapide (importer une seule fois) :**

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
begin
  PythonEngine1.LoadDll;

  // Importer les bibliothÃ¨ques une seule fois au dÃ©marrage
  PythonEngine1.ExecString('import cv2');
  PythonEngine1.ExecString('import numpy as np');
  PythonEngine1.ExecString('import tensorflow as tf');
end;

procedure TForm1.ProcessImage1Click(Sender: TObject);  
begin
  // Les modules sont dÃ©jÃ  chargÃ©s
  PythonEngine1.ExecString('img = cv2.imread("photo1.jpg")');
  // Traitement...
end;
```

### Charger les modÃ¨les ML une seule fois

```pascal
type
  TForm1 = class(TForm)
  private
    FModelLoaded: Boolean;
    procedure LoadMLModel;
  end;

procedure TForm1.LoadMLModel;  
begin
  if FModelLoaded then
    Exit; // DÃ©jÃ  chargÃ©

  MemoOutput.Lines.Add('Chargement du modÃ¨le...');

  PythonEngine1.ExecString('import tensorflow as tf');
  PythonEngine1.ExecString('model = tf.keras.models.load_model("my_model.h5")');

  FModelLoaded := True;
  MemoOutput.Lines.Add('ModÃ¨le chargÃ© !');
end;

procedure TForm1.ButtonPredictClick(Sender: TObject);  
begin
  LoadMLModel; // Ne charge que si nÃ©cessaire

  // Faire une prÃ©diction (rapide)
  PythonEngine1.ExecString('prediction = model.predict(data)');
end;
```

### Utiliser des threads pour les opÃ©rations longues

Pour Ã©viter de bloquer l'interface pendant un traitement Python long :

```pascal
uses
  Classes;

type
  TPythonThread = class(TThread)
  private
    FPythonCode: string;
    FOnComplete: TNotifyEvent;
  protected
    procedure Execute; override;
  public
    constructor Create(const PythonCode: string; OnComplete: TNotifyEvent);
  end;

constructor TPythonThread.Create(const PythonCode: string; OnComplete: TNotifyEvent);  
begin
  inherited Create(False);
  FreeOnTerminate := True;
  FPythonCode := PythonCode;
  FOnComplete := OnComplete;
end;

procedure TPythonThread.Execute;  
begin
  // IMPORTANT : AcquÃ©rir le GIL (Global Interpreter Lock) de Python
  with GetPythonEngine.PyLock do
  try
    GetPythonEngine.ExecString(FPythonCode);
  finally
    // Le GIL est libÃ©rÃ© automatiquement
  end;

  if Assigned(FOnComplete) then
    Synchronize(procedure
    begin
      FOnComplete(Self);
    end);
end;

// Utilisation
procedure TForm1.ButtonLongProcessClick(Sender: TObject);  
begin
  TPythonThread.Create(
    'import time' + sLineBreak +
    'for i in range(10):' + sLineBreak +
    '    print(f"Ã‰tape {i}")' + sLineBreak +
    '    time.sleep(1)',
    @OnPythonProcessComplete
  );

  ShowMessage('Traitement lancÃ© en arriÃ¨re-plan !');
end;

procedure TForm1.OnPythonProcessComplete(Sender: TObject);  
begin
  ShowMessage('Traitement Python terminÃ© !');
end;
```

## CrÃ©ation d'interfaces complexes

### Exemple : Application de classification d'images

CrÃ©ons une application complÃ¨te qui utilise un modÃ¨le TensorFlow pour classifier des images.

**Interface visuelle :**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Classification d'images - TensorFlow              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚  [Charger modÃ¨le]  Status: âšª Non chargÃ©           â”‚
â”‚                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚  â”‚                  â”‚  [SÃ©lectionner image]        â”‚
â”‚  â”‚                  â”‚                              â”‚
â”‚  â”‚   Image ici      â”‚  [Classifier]                â”‚
â”‚  â”‚                  â”‚                              â”‚
â”‚  â”‚                  â”‚  RÃ©sultat:                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  ğŸ± Chat (95.3%)             â”‚
â”‚                                                    â”‚
â”‚  Historique:                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ photo1.jpg - Chien (87.2%)                   â”‚  â”‚
â”‚  â”‚ photo2.jpg - Chat (95.3%)                    â”‚  â”‚
â”‚  â”‚ photo3.jpg - Oiseau (76.1%)                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Code Pascal complet :**

```pascal
unit MainForm;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  ExtDlgs, PythonEngine, PythonGUIInputOutput;

type
  TFormMain = class(TForm)
    ButtonLoadModel: TButton;
    ButtonSelectImage: TButton;
    ButtonClassify: TButton;
    ImagePreview: TImage;
    LabelStatus: TLabel;
    LabelResult: TLabel;
    MemoHistory: TMemo;
    OpenPictureDialog: TOpenPictureDialog;
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonLoadModelClick(Sender: TObject);
    procedure ButtonSelectImageClick(Sender: TObject);
    procedure ButtonClassifyClick(Sender: TObject);
    procedure PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);

  private
    FModelLoaded: Boolean;
    FCurrentImagePath: string;
    procedure InitializePython;
    procedure LoadTensorFlowModel;
    procedure ClassifyImage(const ImagePath: string);
    procedure UpdateStatus(const Status: string; IsReady: Boolean);
  end;

var
  FormMain: TFormMain;

implementation

{$R *.lfm}

procedure TFormMain.FormCreate(Sender: TObject);  
begin
  FModelLoaded := False;
  FCurrentImagePath := '';
  InitializePython;
end;

procedure TFormMain.FormDestroy(Sender: TObject);  
begin
  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TFormMain.InitializePython;  
begin
  try
    // Configurer le chemin Python (adapter selon votre installation)
    PythonEngine1.DllPath := 'C:\Python310';
    PythonEngine1.DllName := 'python310.dll';

    // Charger Python
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      UpdateStatus('Python ' + PythonEngine1.PyVersion + ' initialisÃ©', False);
      ButtonLoadModel.Enabled := True;
    end
    else
    begin
      UpdateStatus('Erreur : Python non initialisÃ©', False);
      ShowMessage('Impossible d''initialiser Python. VÃ©rifiez le chemin DLL.');
    end;

  except
    on E: Exception do
    begin
      UpdateStatus('Erreur : ' + E.Message, False);
      ShowMessage('Erreur lors de l''initialisation de Python : ' + E.Message);
    end;
  end;
end;

procedure TFormMain.ButtonLoadModelClick(Sender: TObject);  
begin
  ButtonLoadModel.Enabled := False;
  UpdateStatus('Chargement du modÃ¨le...', False);
  Application.ProcessMessages;

  try
    LoadTensorFlowModel;
  finally
    ButtonLoadModel.Enabled := not FModelLoaded;
  end;
end;

procedure TFormMain.LoadTensorFlowModel;  
begin
  try
    // Importer TensorFlow et autres bibliothÃ¨ques
    PythonEngine1.ExecString('import tensorflow as tf');
    PythonEngine1.ExecString('import numpy as np');
    PythonEngine1.ExecString('from PIL import Image');

    // Charger un modÃ¨le prÃ©-entraÃ®nÃ© (exemple : MobileNetV2)
    PythonEngine1.ExecString(
      'model = tf.keras.applications.MobileNetV2(' +
      'weights="imagenet", ' +
      'include_top=True)'
    );

    // Charger les labels ImageNet
    PythonEngine1.ExecString(
      'decode_predictions = tf.keras.applications.mobilenet_v2.decode_predictions'
    );
    PythonEngine1.ExecString(
      'preprocess_input = tf.keras.applications.mobilenet_v2.preprocess_input'
    );

    FModelLoaded := True;
    UpdateStatus('ModÃ¨le chargÃ© et prÃªt', True);
    ButtonSelectImage.Enabled := True;

    MemoHistory.Lines.Add('=== ModÃ¨le TensorFlow chargÃ© ===');
    MemoHistory.Lines.Add('Type : MobileNetV2');
    MemoHistory.Lines.Add('Dataset : ImageNet (1000 classes)');
    MemoHistory.Lines.Add('');

  except
    on E: Exception do
    begin
      FModelLoaded := False;
      UpdateStatus('Erreur de chargement', False);
      ShowMessage('Erreur lors du chargement du modÃ¨le : ' + E.Message +
                  sLineBreak + sLineBreak +
                  'Assurez-vous que TensorFlow est installÃ© :' + sLineBreak +
                  'pip install tensorflow pillow');
      ButtonLoadModel.Enabled := True;
    end;
  end;
end;

procedure TFormMain.ButtonSelectImageClick(Sender: TObject);  
begin
  if OpenPictureDialog.Execute then
  begin
    FCurrentImagePath := OpenPictureDialog.FileName;

    // Afficher l'image
    try
      ImagePreview.Picture.LoadFromFile(FCurrentImagePath);
      ButtonClassify.Enabled := True;
      LabelResult.Caption := 'RÃ©sultat : (en attente)';
    except
      on E: Exception do
        ShowMessage('Erreur lors du chargement de l''image : ' + E.Message);
    end;
  end;
end;

procedure TFormMain.ButtonClassifyClick(Sender: TObject);  
begin
  if not FModelLoaded then
  begin
    ShowMessage('Veuillez d''abord charger le modÃ¨le !');
    Exit;
  end;

  if FCurrentImagePath = '' then
  begin
    ShowMessage('Veuillez d''abord sÃ©lectionner une image !');
    Exit;
  end;

  ButtonClassify.Enabled := False;
  UpdateStatus('Classification en cours...', True);
  Application.ProcessMessages;

  try
    ClassifyImage(FCurrentImagePath);
  finally
    ButtonClassify.Enabled := True;
    UpdateStatus('ModÃ¨le prÃªt', True);
  end;
end;

procedure TFormMain.ClassifyImage(const ImagePath: string);  
var
  PredictionScript: string;
  ResultJSON: string;
  ClassName: string;
  Confidence: string;
begin
  try
    // PrÃ©parer le script Python de classification
    PredictionScript :=
      'img = Image.open(r"' + ImagePath + '")' + sLineBreak +
      'img = img.resize((224, 224))' + sLineBreak +
      'img_array = np.array(img)' + sLineBreak +
      'img_array = np.expand_dims(img_array, axis=0)' + sLineBreak +
      'img_array = preprocess_input(img_array)' + sLineBreak +
      'predictions = model.predict(img_array, verbose=0)' + sLineBreak +
      'decoded = decode_predictions(predictions, top=3)[0]' + sLineBreak +
      'result_class = decoded[0][1]' + sLineBreak +
      'result_confidence = float(decoded[0][2])';

    // ExÃ©cuter la classification
    PythonEngine1.ExecString(PredictionScript);

    // RÃ©cupÃ©rer les rÃ©sultats
    ClassName := PythonEngine1.EvalString('result_class');
    Confidence := PythonEngine1.EvalString('str(round(result_confidence * 100, 1))');

    // Afficher le rÃ©sultat
    LabelResult.Caption := Format('RÃ©sultat : %s (%s%%)', [ClassName, Confidence]);
    LabelResult.Font.Color := clGreen;
    LabelResult.Font.Style := [fsBold];

    // Ajouter Ã  l'historique
    MemoHistory.Lines.Add(
      Format('%s - %s (%s%%)',
      [ExtractFileName(ImagePath), ClassName, Confidence])
    );

    // Obtenir le top 3 des prÃ©dictions
    PythonEngine1.ExecString(
      'top3 = "\n".join([f"{i+1}. {pred[1]} ({pred[2]*100:.1f}%)" for i, pred in enumerate(decoded)])'
    );

    ShowMessage('Top 3 prÃ©dictions :' + sLineBreak + sLineBreak +
                PythonEngine1.EvalString('top3'));

  except
    on E: Exception do
    begin
      LabelResult.Caption := 'RÃ©sultat : Erreur';
      LabelResult.Font.Color := clRed;
      ShowMessage('Erreur lors de la classification : ' + E.Message);
    end;
  end;
end;

procedure TFormMain.UpdateStatus(const Status: string; IsReady: Boolean);  
begin
  LabelStatus.Caption := 'Status : ' + Status;

  if IsReady then
  begin
    LabelStatus.Font.Color := clGreen;
    LabelStatus.Caption := LabelStatus.Caption + ' ğŸŸ¢';
  end
  else
  begin
    LabelStatus.Font.Color := clMaroon;
    LabelStatus.Caption := LabelStatus.Caption + ' ğŸ”´';
  end;
end;

procedure TFormMain.PythonGUIInputOutput1SendData(Sender: TObject; const Data: string);  
begin
  // Afficher les messages Python dans l'historique
  if Trim(Data) <> '' then
    MemoHistory.Lines.Add('[Python] ' + Data);
end;

end.
```

### Exemple : Analyseur de sentiment de texte

Application qui analyse le sentiment (positif/nÃ©gatif) d'un texte.

```pascal
unit SentimentAnalyzer;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  PythonEngine, PythonGUIInputOutput;

type
  TFormSentiment = class(TForm)
    ButtonAnalyze: TButton;
    MemoInput: TMemo;
    MemoResult: TMemo;
    LabelScore: TLabel;
    ProgressBar1: TProgressBar;
    PythonEngine1: TPythonEngine;

    procedure FormCreate(Sender: TObject);
    procedure ButtonAnalyzeClick(Sender: TObject);

  private
    FModelReady: Boolean;
    procedure InitializeModel;
    function AnalyzeSentiment(const Text: string): Double;
  end;

implementation

{$R *.lfm}

procedure TFormSentiment.FormCreate(Sender: TObject);  
begin
  FModelReady := False;

  // Initialiser Python
  PythonEngine1.DllPath := 'C:\Python310';
  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
    InitializeModel;
end;

procedure TFormSentiment.InitializeModel;  
begin
  try
    // Utiliser TextBlob pour l'analyse de sentiment
    PythonEngine1.ExecString('from textblob import TextBlob');

    FModelReady := True;
    ButtonAnalyze.Enabled := True;

  except
    on E: Exception do
    begin
      ShowMessage('Erreur : ' + E.Message + sLineBreak + sLineBreak +
                  'Installez TextBlob avec : pip install textblob');
      ButtonAnalyze.Enabled := False;
    end;
  end;
end;

procedure TFormSentiment.ButtonAnalyzeClick(Sender: TObject);  
var
  InputText: string;
  Score: Double;
  ScorePercent: Integer;
  Sentiment: string;
begin
  InputText := MemoInput.Text;

  if Trim(InputText) = '' then
  begin
    ShowMessage('Veuillez entrer du texte Ã  analyser');
    Exit;
  end;

  try
    Score := AnalyzeSentiment(InputText);

    // Convertir le score (-1 Ã  1) en pourcentage (0 Ã  100)
    ScorePercent := Round((Score + 1) * 50);
    ProgressBar1.Position := ScorePercent;

    // DÃ©terminer le sentiment
    if Score > 0.3 then
      Sentiment := 'TrÃ¨s positif ğŸ˜Š'
    else if Score > 0.1 then
      Sentiment := 'Positif ğŸ™‚'
    else if Score > -0.1 then
      Sentiment := 'Neutre ğŸ˜'
    else if Score > -0.3 then
      Sentiment := 'NÃ©gatif ğŸ˜'
    else
      Sentiment := 'TrÃ¨s nÃ©gatif ğŸ˜¢';

    LabelScore.Caption := Format('Sentiment : %s (Score : %.2f)', [Sentiment, Score]);

    // DÃ©tails de l'analyse
    MemoResult.Clear;
    MemoResult.Lines.Add('=== RÃ©sultats de l''analyse ===');
    MemoResult.Lines.Add('');
    MemoResult.Lines.Add('Score brut : ' + FloatToStr(Score));
    MemoResult.Lines.Add('Score normalisÃ© : ' + IntToStr(ScorePercent) + '%');
    MemoResult.Lines.Add('InterprÃ©tation : ' + Sentiment);
    MemoResult.Lines.Add('');
    MemoResult.Lines.Add('Ã‰chelle :');
    MemoResult.Lines.Add('  -1.0 = TrÃ¨s nÃ©gatif');
    MemoResult.Lines.Add('   0.0 = Neutre');
    MemoResult.Lines.Add('  +1.0 = TrÃ¨s positif');

  except
    on E: Exception do
      ShowMessage('Erreur lors de l''analyse : ' + E.Message);
  end;
end;

function TFormSentiment.AnalyzeSentiment(const Text: string): Double;  
var
  EscapedText: string;
  ScoreStr: string;
begin
  // Ã‰chapper les guillemets dans le texte
  EscapedText := StringReplace(Text, '"', '\"', [rfReplaceAll]);
  EscapedText := StringReplace(EscapedText, sLineBreak, ' ', [rfReplaceAll]);

  // Analyser le sentiment
  PythonEngine1.ExecString(Format('blob = TextBlob("%s")', [EscapedText]));
  PythonEngine1.ExecString('polarity = blob.sentiment.polarity');

  ScoreStr := PythonEngine1.EvalString('str(polarity)');
  Result := StrToFloat(ScoreStr);
end;

end.
```

## DÃ©ploiement de l'application

### Option 1 : DÃ©ploiement avec Python portable

**CrÃ©er un package complet avec Python embarquÃ© :**

1. **TÃ©lÃ©charger Python Embedded**
   - Allez sur [python.org/downloads/windows](https://www.python.org/downloads/windows/)
   - TÃ©lÃ©chargez "Windows embeddable package (64-bit)"
   - Exemple : `python-3.10.11-embed-amd64.zip`

2. **Structure du dÃ©ploiement**

```
MonApplication\
â”œâ”€â”€ MonApp.exe                    â† Votre application
â”œâ”€â”€ python310.dll                 â† DLL Python
â”œâ”€â”€ python\                       â† Python embarquÃ©
â”‚   â”œâ”€â”€ python.exe
â”‚   â”œâ”€â”€ python310.zip
â”‚   â””â”€â”€ ...
â”œâ”€â”€ Lib\                          â† BibliothÃ¨ques Python
â”‚   â””â”€â”€ site-packages\
â”‚       â”œâ”€â”€ numpy\
â”‚       â”œâ”€â”€ tensorflow\
â”‚       â””â”€â”€ ...
â””â”€â”€ models\                       â† Vos modÃ¨les ML
    â””â”€â”€ my_model.h5
```

3. **Configurer le chemin dans votre application**

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
var
  AppPath: string;
begin
  AppPath := ExtractFilePath(Application.ExeName);

  // Utiliser le Python embarquÃ©
  PythonEngine1.DllPath := AppPath + 'python';
  PythonEngine1.DllName := 'python310.dll';

  PythonEngine1.LoadDll;

  if PythonEngine1.Initialized then
  begin
    // Configurer le sys.path pour trouver les modules
    PythonEngine1.ExecString('import sys');
    PythonEngine1.ExecString(
      Format('sys.path.insert(0, r"%sLib\site-packages")', [AppPath])
    );
  end;
end;
```

4. **Copier les bibliothÃ¨ques Python nÃ©cessaires**

```cmd
REM Installer les bibliothÃ¨ques dans le Python embarquÃ©  
cd MonApplication\python  
python.exe -m pip install --target=..\Lib\site-packages numpy tensorflow
```

### Option 2 : Installeur avec dÃ©tection de Python

CrÃ©er un installeur (Inno Setup par exemple) qui :

1. DÃ©tecte si Python est installÃ©
2. Si non, propose de l'installer
3. Installe les dÃ©pendances Python nÃ©cessaires

**Script Inno Setup basique :**

```inno
[Setup]
AppName=Mon Application IA  
AppVersion=1.0  
DefaultDirName={pf}\MonApplicationIA

[Files]
Source: "MonApp.exe"; DestDir: "{app}"  
Source: "requirements.txt"; DestDir: "{app}"

[Run]
; VÃ©rifier et installer Python si nÃ©cessaire
Filename: "python"; Parameters: "--version"; StatusMsg: "VÃ©rification de Python..."; Flags: runhidden  
Filename: "python"; Parameters: "-m pip install -r ""{app}\requirements.txt"""; StatusMsg: "Installation des dÃ©pendances Python..."; Flags: runhidden
```

**Fichier requirements.txt :**

```
tensorflow==2.13.0  
numpy==1.24.3  
pillow==10.0.0
```

### Option 3 : Application autonome avec PyInstaller

Vous pouvez mÃªme compiler vos scripts Python en exÃ©cutables :

```pascal
procedure TForm1.UseCompiledPythonScript;  
var
  Process: TProcess;
begin
  // Appeler un exÃ©cutable Python compilÃ©
  Process := TProcess.Create(nil);
  try
    Process.Executable := 'my_python_script.exe';
    Process.Parameters.Add('--input');
    Process.Parameters.Add('data.csv');
    Process.Options := [poWaitOnExit, poUsePipes];
    Process.Execute;

    // Lire la sortie
    MemoOutput.Lines.LoadFromStream(Process.Output);
  finally
    Process.Free;
  end;
end;
```

## Cas d'usage avancÃ©s

### Traitement d'images par lot

```pascal
procedure TForm1.BatchProcessImages;  
var
  ImageFiles: TStringList;
  i: Integer;
  ImagePath, Result: string;
begin
  ImageFiles := TStringList.Create;
  try
    // Obtenir tous les fichiers JPG d'un dossier
    FindAllFiles(ImageFiles, 'C:\Photos', '*.jpg', False);

    ProgressBar.Max := ImageFiles.Count;
    ProgressBar.Position := 0;

    // Charger le modÃ¨le une fois
    PythonEngine1.ExecString('import tensorflow as tf');
    PythonEngine1.ExecString('model = tf.keras.models.load_model("classifier.h5")');

    // Traiter chaque image
    for i := 0 to ImageFiles.Count - 1 do
    begin
      ImagePath := ImageFiles[i];

      // PrÃ©parer et classifier
      PythonEngine1.ExecString(
        Format('img = load_and_preprocess("%s")', [ImagePath])
      );
      PythonEngine1.ExecString('prediction = model.predict(img)');
      PythonEngine1.ExecString('class_name = get_class_name(prediction)');

      Result := PythonEngine1.EvalString('class_name');

      // Sauvegarder le rÃ©sultat
      MemoResults.Lines.Add(Format('%s: %s', [ExtractFileName(ImagePath), Result]));

      // Mise Ã  jour de la barre de progression
      ProgressBar.Position := i + 1;
      LabelStatus.Caption := Format('Traitement %d/%d', [i + 1, ImageFiles.Count]);
      Application.ProcessMessages;
    end;

    ShowMessage('Traitement terminÃ© !');

  finally
    ImageFiles.Free;
  end;
end;
```

### Serveur web Python depuis Lazarus

```pascal
unit WebServer;

interface

uses
  Classes, SysUtils, Forms, PythonEngine, Process;

type
  TPythonWebServer = class
  private
    FPythonEngine: TPythonEngine;
    FServerRunning: Boolean;
    FPort: Integer;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure Start(Port: Integer);
    procedure Stop;
    property IsRunning: Boolean read FServerRunning;
  end;

implementation

constructor TPythonWebServer.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;
  FServerRunning := False;
end;

procedure TPythonWebServer.Start(Port: Integer);  
var
  ServerCode: string;
begin
  FPort := Port;

  ServerCode :=
    'from flask import Flask, request, jsonify' + sLineBreak +
    'import threading' + sLineBreak +
    sLineBreak +
    'app = Flask(__name__)' + sLineBreak +
    sLineBreak +
    '@app.route("/predict", methods=["POST"])' + sLineBreak +
    'def predict():' + sLineBreak +
    '    data = request.json' + sLineBreak +
    '    # Faire la prÃ©diction' + sLineBreak +
    '    result = {"prediction": "example"}' + sLineBreak +
    '    return jsonify(result)' + sLineBreak +
    sLineBreak +
    'def run_server():' + sLineBreak +
    Format('    app.run(port=%d, debug=False)', [FPort]) + sLineBreak +
    sLineBreak +
    'server_thread = threading.Thread(target=run_server)' + sLineBreak +
    'server_thread.daemon = True' + sLineBreak +
    'server_thread.start()';

  FPythonEngine.ExecString(ServerCode);
  FServerRunning := True;
end;

procedure TPythonWebServer.Stop;  
begin
  // ArrÃªter le serveur (plus complexe, nÃ©cessite d'autres mÃ©canismes)
  FServerRunning := False;
end;

end.
```

## Ressources et documentation

### Documentation officielle

- **Python4Delphi GitHub** : [github.com/pyscripter/python4delphi](https://github.com/pyscripter/python4delphi)
- **Wiki Python4Delphi** : Exemples et tutoriels
- **Forum Lazarus** : Section Python Integration

### BibliothÃ¨ques Python utiles pour l'IA

**Vision par ordinateur :**
```cmd
pip install opencv-python  
pip install pillow  
pip install scikit-image
```

**Machine Learning :**
```cmd
pip install tensorflow  
pip install torch torchvision  
pip install scikit-learn  
pip install xgboost
```

**NLP (Traitement du langage) :**
```cmd
pip install transformers  
pip install spacy  
pip install nltk  
pip install textblob
```

**Data Science :**
```cmd
pip install numpy  
pip install pandas  
pip install matplotlib  
pip install seaborn
```

### Exemples de projets

**1. DÃ©tecteur de fraude**
```pascal
// Application qui analyse des transactions
procedure AnalyzeTransaction(Amount: Double; Location: string);  
begin
  PythonEngine.ExecString(
    Format('is_fraud = fraud_model.predict([[%.2f, "%s"]])[0]',
    [Amount, Location])
  );

  if PythonEngine.EvalString('str(is_fraud)') = 'True' then
    ShowMessage('Transaction suspecte dÃ©tectÃ©e !');
end;
```

**2. Recommandation de produits**
```pascal
// SystÃ¨me de recommandation e-commerce
function GetRecommendations(UserID: Integer): TStringList;  
var
  RecommendationsJSON: string;
  JSONData: TJSONData;
  JSONArray: TJSONArray;
  i: Integer;
begin
  Result := TStringList.Create;

  try
    // Obtenir les recommandations depuis le modÃ¨le Python
    PythonEngine.ExecString(
      Format('recommendations = recommender_model.recommend(user_id=%d, n_items=5)',
      [UserID])
    );
    PythonEngine.ExecString('import json');
    PythonEngine.ExecString('recommendations_json = json.dumps(recommendations)');

    RecommendationsJSON := PythonEngine.EvalString('recommendations_json');

    // Parser le JSON en Pascal
    JSONData := GetJSON(RecommendationsJSON);
    try
      if JSONData is TJSONArray then
      begin
        JSONArray := TJSONArray(JSONData);
        for i := 0 to JSONArray.Count - 1 do
          Result.Add(JSONArray.Items[i].AsString);
      end;
    finally
      JSONData.Free;
    end;

  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors de la recommandation : ' + E.Message);
      Result.Clear;
    end;
  end;
end;

// Utilisation dans l'interface
procedure TForm1.ButtonGetRecommendationsClick(Sender: TObject);  
var
  Recommendations: TStringList;
  i: Integer;
begin
  Recommendations := GetRecommendations(StrToInt(EditUserID.Text));
  try
    ListBoxRecommendations.Clear;
    for i := 0 to Recommendations.Count - 1 do
      ListBoxRecommendations.Items.Add(Recommendations[i]);

    LabelInfo.Caption := Format('%d recommandations trouvÃ©es', [Recommendations.Count]);
  finally
    Recommendations.Free;
  end;
end;
```

### 3. Transcription audio avec Whisper

Application de reconnaissance vocale utilisant OpenAI Whisper :

```pascal
unit AudioTranscription;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  ExtCtrls, PythonEngine, PythonGUIInputOutput;

type
  TFormTranscription = class(TForm)
    ButtonLoadModel: TButton;
    ButtonSelectAudio: TButton;
    ButtonTranscribe: TButton;
    MemoTranscription: TMemo;
    ProgressBar1: TProgressBar;
    LabelStatus: TLabel;
    OpenDialog1: TOpenDialog;
    PythonEngine1: TPythonEngine;

    procedure FormCreate(Sender: TObject);
    procedure ButtonLoadModelClick(Sender: TObject);
    procedure ButtonSelectAudioClick(Sender: TObject);
    procedure ButtonTranscribeClick(Sender: TObject);

  private
    FModelLoaded: Boolean;
    FAudioFilePath: string;
    procedure LoadWhisperModel;
    procedure TranscribeAudio(const FilePath: string);
  end;

var
  FormTranscription: TFormTranscription;

implementation

{$R *.lfm}

procedure TFormTranscription.FormCreate(Sender: TObject);  
begin
  FModelLoaded := False;
  FAudioFilePath := '';

  // Initialiser Python
  PythonEngine1.DllPath := 'C:\Python310';
  PythonEngine1.LoadDll;

  if not PythonEngine1.Initialized then
    ShowMessage('Erreur d''initialisation Python');
end;

procedure TFormTranscription.ButtonLoadModelClick(Sender: TObject);  
begin
  ButtonLoadModel.Enabled := False;
  LabelStatus.Caption := 'Chargement du modÃ¨le Whisper...';
  Application.ProcessMessages;

  LoadWhisperModel;
end;

procedure TFormTranscription.LoadWhisperModel;  
begin
  try
    LabelStatus.Caption := 'Installation/Import de Whisper...';
    Application.ProcessMessages;

    // Importer Whisper (peut prendre du temps la premiÃ¨re fois)
    PythonEngine1.ExecString('import whisper');

    LabelStatus.Caption := 'Chargement du modÃ¨le (cela peut prendre plusieurs minutes)...';
    Application.ProcessMessages;

    // Charger le modÃ¨le (base, small, medium, large)
    PythonEngine1.ExecString('model = whisper.load_model("base")');

    FModelLoaded := True;
    ButtonSelectAudio.Enabled := True;
    LabelStatus.Caption := 'ModÃ¨le Whisper chargÃ© et prÃªt !';

    MemoTranscription.Lines.Add('=== ModÃ¨le Whisper chargÃ© ===');
    MemoTranscription.Lines.Add('Taille : Base');
    MemoTranscription.Lines.Add('Langues supportÃ©es : 99');
    MemoTranscription.Lines.Add('');

  except
    on E: Exception do
    begin
      LabelStatus.Caption := 'Erreur de chargement';
      ShowMessage('Erreur : ' + E.Message + sLineBreak + sLineBreak +
                  'Installez Whisper avec : pip install openai-whisper');
      ButtonLoadModel.Enabled := True;
    end;
  end;
end;

procedure TFormTranscription.ButtonSelectAudioClick(Sender: TObject);  
begin
  OpenDialog1.Filter := 'Fichiers audio|*.mp3;*.wav;*.m4a;*.flac|Tous les fichiers|*.*';

  if OpenDialog1.Execute then
  begin
    FAudioFilePath := OpenDialog1.FileName;
    ButtonTranscribe.Enabled := True;
    LabelStatus.Caption := 'Fichier sÃ©lectionnÃ© : ' + ExtractFileName(FAudioFilePath);
  end;
end;

procedure TFormTranscription.ButtonTranscribeClick(Sender: TObject);  
begin
  if not FModelLoaded then
  begin
    ShowMessage('Veuillez d''abord charger le modÃ¨le !');
    Exit;
  end;

  if FAudioFilePath = '' then
  begin
    ShowMessage('Veuillez sÃ©lectionner un fichier audio !');
    Exit;
  end;

  ButtonTranscribe.Enabled := False;
  ProgressBar1.Style := pbstMarquee;
  LabelStatus.Caption := 'Transcription en cours...';
  Application.ProcessMessages;

  try
    TranscribeAudio(FAudioFilePath);
  finally
    ButtonTranscribe.Enabled := True;
    ProgressBar1.Style := pbstNormal;
  end;
end;

procedure TFormTranscription.TranscribeAudio(const FilePath: string);  
var
  TranscriptionText: string;
  Language: string;
begin
  try
    // Transcrire l'audio
    PythonEngine1.ExecString(
      Format('result = model.transcribe(r"%s")', [FilePath])
    );

    // RÃ©cupÃ©rer le texte transcrit
    PythonEngine1.ExecString('transcription_text = result["text"]');
    TranscriptionText := PythonEngine1.EvalString('transcription_text');

    // RÃ©cupÃ©rer la langue dÃ©tectÃ©e
    PythonEngine1.ExecString('detected_language = result["language"]');
    Language := PythonEngine1.EvalString('detected_language');

    // Afficher les rÃ©sultats
    MemoTranscription.Clear;
    MemoTranscription.Lines.Add('=== Transcription ===');
    MemoTranscription.Lines.Add('Fichier : ' + ExtractFileName(FilePath));
    MemoTranscription.Lines.Add('Langue dÃ©tectÃ©e : ' + Language);
    MemoTranscription.Lines.Add('');
    MemoTranscription.Lines.Add(TranscriptionText);

    LabelStatus.Caption := 'Transcription terminÃ©e !';

  except
    on E: Exception do
    begin
      LabelStatus.Caption := 'Erreur lors de la transcription';
      ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;

end.
```

### 4. GÃ©nÃ©rateur de texte avec GPT

Interface pour gÃ©nÃ©rer du texte avec des modÃ¨les de langage :

```pascal
procedure TFormTextGenerator.GenerateText;  
var
  Prompt: string;
  GeneratedText: string;
  MaxTokens: Integer;
begin
  Prompt := MemoPrompt.Text;
  MaxTokens := SpinEditMaxTokens.Value;

  if Trim(Prompt) = '' then
  begin
    ShowMessage('Entrez un prompt !');
    Exit;
  end;

  ButtonGenerate.Enabled := False;
  LabelStatus.Caption := 'GÃ©nÃ©ration en cours...';
  Application.ProcessMessages;

  try
    // Utiliser la bibliothÃ¨que transformers de HuggingFace
    PythonEngine1.ExecString(
      Format('prompt = """%s"""', [Prompt])
    );
    PythonEngine1.ExecString(
      Format('max_tokens = %d', [MaxTokens])
    );

    PythonEngine1.ExecString('inputs = tokenizer(prompt, return_tensors="pt")');
    PythonEngine1.ExecString(
      'outputs = model.generate(**inputs, max_length=max_tokens, ' +
      'num_return_sequences=1, temperature=0.7)'
    );
    PythonEngine1.ExecString(
      'generated_text = tokenizer.decode(outputs[0], skip_special_tokens=True)'
    );

    GeneratedText := PythonEngine1.EvalString('generated_text');

    MemoOutput.Text := GeneratedText;
    LabelStatus.Caption := 'GÃ©nÃ©ration terminÃ©e !';

  except
    on E: Exception do
    begin
      ShowMessage('Erreur : ' + E.Message);
      LabelStatus.Caption := 'Erreur';
    end;
  end;

  ButtonGenerate.Enabled := True;
end;
```

## Techniques avancÃ©es

### Callback Pascal depuis Python

Permettre Ã  Python d'appeler des fonctions Pascal :

```pascal
unit PythonCallbacks;

interface

uses
  PythonEngine;

// Fonction Pascal qui sera appelable depuis Python
function PascalCallback(Self, Args: PPyObject): PPyObject; cdecl;

procedure RegisterCallbacks(PythonModule: TPythonModule);

implementation

function PascalCallback(Self, Args: PPyObject): PPyObject; cdecl;  
var
  Message: PAnsiChar;
begin
  // RÃ©cupÃ©rer l'argument passÃ© par Python
  with GetPythonEngine do
  begin
    if PyArg_ParseTuple(Args, 's:pascal_callback', @Message) <> 0 then
    begin
      // Faire quelque chose avec le message
      ShowMessage('AppelÃ© depuis Python : ' + string(Message));

      // Retourner une valeur Ã  Python
      Result := PyString_FromString('RÃ©ponse depuis Pascal');
    end
    else
      Result := nil;
  end;
end;

procedure RegisterCallbacks(PythonModule: TPythonModule);  
begin
  with PythonModule do
  begin
    // Enregistrer la fonction Pascal pour qu'elle soit appelable depuis Python
    AddMethod('pascal_callback', @PascalCallback,
              'pascal_callback(message) -> str');
  end;
end;

end.

// Utilisation dans le formulaire principal
procedure TForm1.FormCreate(Sender: TObject);  
begin
  PythonEngine1.LoadDll;

  // CrÃ©er un module Python contenant nos fonctions Pascal
  PythonModule1 := TPythonModule.Create(Self);
  PythonModule1.Engine := PythonEngine1;
  PythonModule1.ModuleName := 'pascal_functions';
  PythonModule1.OnInitialization := @RegisterCallbacks;

  // Maintenant Python peut faire :
  // import pascal_functions
  // response = pascal_functions.pascal_callback("Hello from Python")
end;
```

### Passage de donnÃ©es complexes (DataFrames Pandas)

Ã‰changer des tableaux de donnÃ©es entre Pascal et Python :

```pascal
uses
  fpjson, jsonparser;

procedure TForm1.SendDataFrameToPython;  
var
  JSONData: TJSONObject;
  JSONArray: TJSONArray;
  JSONRow: TJSONObject;
  i: Integer;
begin
  // CrÃ©er des donnÃ©es en JSON
  JSONArray := TJSONArray.Create;
  try
    for i := 1 to 10 do
    begin
      JSONRow := TJSONObject.Create;
      JSONRow.Add('id', i);
      JSONRow.Add('name', 'User ' + IntToStr(i));
      JSONRow.Add('score', Random(100));
      JSONArray.Add(JSONRow);
    end;

    // Envoyer Ã  Python et crÃ©er un DataFrame
    PythonEngine1.ExecString('import pandas as pd');
    PythonEngine1.ExecString('import json');
    PythonEngine1.ExecString(
      Format('data = json.loads(''%s'')', [JSONArray.AsJSON])
    );
    PythonEngine1.ExecString('df = pd.DataFrame(data)');
    PythonEngine1.ExecString('print(df.head())');

    // Faire des opÃ©rations sur le DataFrame
    PythonEngine1.ExecString('average_score = df["score"].mean()');

    ShowMessage('Score moyen : ' + PythonEngine1.EvalString('str(average_score)'));

  finally
    JSONArray.Free;
  end;
end;

procedure TForm1.GetDataFrameFromPython;  
var
  JSONStr: string;
  JSONData: TJSONData;
  JSONArray: TJSONArray;
  i: Integer;
begin
  // Obtenir un DataFrame depuis Python au format JSON
  PythonEngine1.ExecString('result_json = df.to_json(orient="records")');
  JSONStr := PythonEngine1.EvalString('result_json');

  // Parser en Pascal
  JSONData := GetJSON(JSONStr);
  try
    if JSONData is TJSONArray then
    begin
      JSONArray := TJSONArray(JSONData);

      StringGrid1.RowCount := JSONArray.Count + 1;

      for i := 0 to JSONArray.Count - 1 do
      begin
        StringGrid1.Cells[0, i + 1] := JSONArray.Items[i].FindPath('id').AsString;
        StringGrid1.Cells[1, i + 1] := JSONArray.Items[i].FindPath('name').AsString;
        StringGrid1.Cells[2, i + 1] := JSONArray.Items[i].FindPath('score').AsString;
      end;
    end;
  finally
    JSONData.Free;
  end;
end;
```

### Streaming de donnÃ©es en temps rÃ©el

Pour traiter des flux de donnÃ©es continus :

```pascal
type
  TDataStreamProcessor = class
  private
    FPythonEngine: TPythonEngine;
    FProcessing: Boolean;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure StartProcessing;
    procedure StopProcessing;
    procedure ProcessDataPoint(const Value: Double);
  end;

constructor TDataStreamProcessor.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;
  FProcessing := False;

  // Initialiser le modÃ¨le de prÃ©diction en streaming
  FPythonEngine.ExecString('import numpy as np');
  FPythonEngine.ExecString('from collections import deque');
  FPythonEngine.ExecString('data_buffer = deque(maxlen=100)');
end;

procedure TDataStreamProcessor.StartProcessing;  
begin
  FProcessing := True;
  FPythonEngine.ExecString('data_buffer.clear()');
end;

procedure TDataStreamProcessor.StopProcessing;  
begin
  FProcessing := False;
end;

procedure TDataStreamProcessor.ProcessDataPoint(const Value: Double);  
var
  Prediction: string;
begin
  if not FProcessing then
    Exit;

  // Ajouter la valeur au buffer Python
  FPythonEngine.ExecString(Format('data_buffer.append(%.4f)', [Value]));

  // Si on a assez de donnÃ©es, faire une prÃ©diction
  FPythonEngine.ExecString(
    'if len(data_buffer) >= 10:' + sLineBreak +
    '    recent_data = list(data_buffer)[-10:]' + sLineBreak +
    '    prediction = predict_next_value(recent_data)' + sLineBreak +
    'else:' + sLineBreak +
    '    prediction = None'
  );

  Prediction := FPythonEngine.EvalString('str(prediction)');

  if Prediction <> 'None' then
    Form1.LabelPrediction.Caption := 'PrÃ©diction : ' + Prediction;
end;

// Utilisation avec un timer
procedure TForm1.Timer1Timer(Sender: TObject);  
var
  SensorValue: Double;
begin
  // Lire une valeur de capteur (exemple)
  SensorValue := ReadSensorData();

  // Traiter en temps rÃ©el
  DataStreamProcessor.ProcessDataPoint(SensorValue);
end;
```

### Visualisations matplotlib intÃ©grÃ©es

Afficher des graphiques matplotlib dans votre application :

```pascal
procedure TForm1.GeneratePlotClick(Sender: TObject);  
var
  PlotPath: string;
begin
  PlotPath := GetTempDir + 'plot.png';

  try
    // CrÃ©er un graphique avec matplotlib
    PythonEngine1.ExecString('import matplotlib.pyplot as plt');
    PythonEngine1.ExecString('import numpy as np');

    PythonEngine1.ExecString('x = np.linspace(0, 10, 100)');
    PythonEngine1.ExecString('y = np.sin(x)');

    PythonEngine1.ExecString('plt.figure(figsize=(10, 6))');
    PythonEngine1.ExecString('plt.plot(x, y, linewidth=2)');
    PythonEngine1.ExecString('plt.title("Fonction sinus")');
    PythonEngine1.ExecString('plt.xlabel("x")');
    PythonEngine1.ExecString('plt.ylabel("sin(x)")');
    PythonEngine1.ExecString('plt.grid(True)');

    // Sauvegarder dans un fichier temporaire
    PythonEngine1.ExecString(
      Format('plt.savefig(r"%s", dpi=150, bbox_inches="tight")', [PlotPath])
    );
    PythonEngine1.ExecString('plt.close()');

    // Afficher dans un TImage
    if FileExists(PlotPath) then
    begin
      ImagePlot.Picture.LoadFromFile(PlotPath);
      DeleteFile(PlotPath);
    end;

  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;

// Version avec graphiques interactifs multiples
procedure TForm1.GenerateMultiplePlots;  
var
  PlotTypes: array[0..2] of string = ('line', 'scatter', 'bar');
  i: Integer;
  PlotPath: string;
begin
  for i := 0 to High(PlotTypes) do
  begin
    PlotPath := GetTempDir + 'plot_' + PlotTypes[i] + '.png';

    PythonEngine1.ExecString('plt.figure()');

    case PlotTypes[i] of
      'line':
      begin
        PythonEngine1.ExecString('plt.plot([1,2,3,4], [1,4,2,3])');
        PythonEngine1.ExecString('plt.title("Line Plot")');
      end;
      'scatter':
      begin
        PythonEngine1.ExecString('plt.scatter([1,2,3,4], [1,4,2,3])');
        PythonEngine1.ExecString('plt.title("Scatter Plot")');
      end;
      'bar':
      begin
        PythonEngine1.ExecString('plt.bar([1,2,3,4], [1,4,2,3])');
        PythonEngine1.ExecString('plt.title("Bar Chart")');
      end;
    end;

    PythonEngine1.ExecString(Format('plt.savefig(r"%s")', [PlotPath]));
    PythonEngine1.ExecString('plt.close()');

    // Charger dans diffÃ©rents TImage selon le type
    case i of
      0: ImageLine.Picture.LoadFromFile(PlotPath);
      1: ImageScatter.Picture.LoadFromFile(PlotPath);
      2: ImageBar.Picture.LoadFromFile(PlotPath);
    end;

    DeleteFile(PlotPath);
  end;
end;
```

## Bonnes pratiques et astuces

### 1. Gestion de la mÃ©moire

```pascal
// âŒ Mauvais : Charger un gros modÃ¨le Ã  chaque utilisation
procedure ProcessData;  
begin
  PythonEngine.ExecString('model = load_huge_model()'); // Lent !
  PythonEngine.ExecString('result = model.predict(data)');
end;

// âœ… Bon : Charger une fois au dÃ©marrage
procedure TForm1.FormCreate(Sender: TObject);  
begin
  PythonEngine.LoadDll;
  PythonEngine.ExecString('model = load_huge_model()'); // Une seule fois
end;

procedure ProcessData;  
begin
  PythonEngine.ExecString('result = model.predict(data)'); // Rapide
end;
```

### 2. Gestion des chemins Windows

```pascal
// Toujours utiliser des chemins raw strings ou Ã©chapper les backslashes
procedure LoadFile(const FilePath: string);  
var
  SafePath: string;
begin
  // Option 1 : Remplacer \ par /
  SafePath := StringReplace(FilePath, '\', '/', [rfReplaceAll]);
  PythonEngine.ExecString(Format('data = load_file("%s")', [SafePath]));

  // Option 2 : Utiliser raw string (r"...")
  PythonEngine.ExecString(Format('data = load_file(r"%s")', [FilePath]));

  // Option 3 : Doubler les backslashes
  SafePath := StringReplace(FilePath, '\', '\\', [rfReplaceAll]);
  PythonEngine.ExecString(Format('data = load_file("%s")', [SafePath]));
end;
```

### 3. Logging et debugging

```pascal
procedure TForm1.EnablePythonLogging;  
begin
  // Configurer le logging Python
  PythonEngine1.ExecString('import logging');
  PythonEngine1.ExecString('logging.basicConfig(level=logging.DEBUG)');
  PythonEngine1.ExecString(
    'logging.basicConfig(' +
    '    filename="python_debug.log", ' +
    '    level=logging.DEBUG, ' +
    '    format="%(asctime)s - %(levelname)s - %(message)s")'
  );

  // Utiliser dans votre code Python
  PythonEngine1.ExecString('logging.info("Application dÃ©marrÃ©e")');
  PythonEngine1.ExecString('logging.debug("Valeur de x: " + str(x))');
end;
```

### 4. Timeout pour opÃ©rations longues

```pascal
uses
  DateUtils;

function ExecutePythonWithTimeout(const Code: string; TimeoutSeconds: Integer): Boolean;  
var
  StartTime: TDateTime;
  ThreadFinished: Boolean;
begin
  Result := False;
  ThreadFinished := False;
  StartTime := Now;

  // Lancer dans un thread
  TThread.CreateAnonymousThread(
    procedure
    begin
      try
        PythonEngine.ExecString(Code);
        ThreadFinished := True;
      except
        ThreadFinished := True;
      end;
    end
  ).Start;

  // Attendre avec timeout
  while not ThreadFinished do
  begin
    Application.ProcessMessages;
    Sleep(100);

    if SecondsBetween(Now, StartTime) > TimeoutSeconds then
    begin
      ShowMessage('Timeout : opÃ©ration trop longue');
      Exit(False);
    end;
  end;

  Result := ThreadFinished;
end;
```

### 5. VÃ©rification de disponibilitÃ© des modules

```pascal
procedure TForm1.CheckRequiredModules;  
var
  RequiredModules: array of string;
  i: Integer;
  ModuleOK: Boolean;
  MissingModules: TStringList;
begin
  RequiredModules := ['numpy', 'pandas', 'tensorflow', 'opencv'];
  MissingModules := TStringList.Create;
  try
    for i := 0 to High(RequiredModules) do
    begin
      try
        PythonEngine1.ExecString('import ' + RequiredModules[i]);
        ModuleOK := True;
      except
        ModuleOK := False;
      end;

      if not ModuleOK then
        MissingModules.Add(RequiredModules[i]);
    end;

    if MissingModules.Count > 0 then
    begin
      ShowMessage(
        'Modules Python manquants :' + sLineBreak +
        MissingModules.Text + sLineBreak +
        'Installez-les avec :' + sLineBreak +
        'pip install ' + StringReplace(MissingModules.Text, sLineBreak, ' ', [rfReplaceAll])
      );
    end
    else
      ShowMessage('Tous les modules requis sont installÃ©s !');

  finally
    MissingModules.Free;
  end;
end;
```

## RÃ©solution de problÃ¨mes courants

### ProblÃ¨me 1 : "ImportError: DLL load failed"

**SymptÃ´me :** Python s'initialise mais l'import de bibliothÃ¨ques Ã©choue.

**Solutions :**

```pascal
// 1. VÃ©rifier l'architecture (32/64 bits)
procedure CheckArchitecture;  
var
  Is64Bit: Boolean;
begin
  PythonEngine.ExecString('import sys');
  Is64Bit := PythonEngine.EvalString('sys.maxsize > 2**32') = 'True';

  ShowMessage(Format('Python est %d-bit', [IfThen(Is64Bit, 64, 32)]));
  ShowMessage(Format('Application est %d-bit', [IfThen(SizeOf(Pointer) = 8, 64, 32)]));

  if Is64Bit <> (SizeOf(Pointer) = 8) then
    ShowMessage('INCOMPATIBILITÃ‰ : Python et application doivent Ãªtre de mÃªme architecture !');
end;

// 2. Ajouter le PATH des DLL
procedure AddDLLPath;  
begin
  PythonEngine.ExecString('import os');
  PythonEngine.ExecString('import sys');

  // Ajouter le chemin des DLL NumPy par exemple
  PythonEngine.ExecString(
    'dll_path = r"C:\Python310\Lib\site-packages\numpy\.libs"'
  );
  PythonEngine.ExecString('os.add_dll_directory(dll_path)');
end;
```

### ProblÃ¨me 2 : Performance lente

**Optimisations :**

```pascal
// Ã‰viter les conversions rÃ©pÃ©tÃ©es
// âŒ Lent
for i := 1 to 1000 do  
begin
  PythonEngine.ExecString(Format('process_value(%d)', [i]));
end;

// âœ… Rapide : Construire une liste et traiter en une fois
var
  ValuesList: string;
  i: Integer;
begin
  ValuesList := '[';
  for i := 1 to 1000 do
  begin
    ValuesList := ValuesList + IntToStr(i);
    if i < 1000 then
      ValuesList := ValuesList + ',';
  end;
  ValuesList := ValuesList + ']';

  PythonEngine.ExecString(Format('process_values(%s)', [ValuesList]));
end;
```

### ProblÃ¨me 3 : Fuite mÃ©moire

```pascal
// âŒ Fuite mÃ©moire : CrÃ©er des objets Python sans les libÃ©rer
procedure LeakMemory;  
begin
  PythonEngine.ExecString('big_array = [0] * 10000000');
  // big_array reste en mÃ©moire !
end;

// âœ… LibÃ©rer explicitement
procedure NoLeak;  
begin
  PythonEngine.ExecString('big_array = [0] * 10000000');
  // Utiliser...
  PythonEngine.ExecString('del big_array'); // LibÃ©rer
  PythonEngine.ExecString('import gc; gc.collect()'); // Garbage collection
end;
```

## Conclusion

Python4Lazarus sur Windows offre une intÃ©gration puissante et flexible pour dÃ©velopper des applications d'Intelligence Artificielle avec FreePascal. Les points clÃ©s Ã  retenir :

### âœ… Avantages
- AccÃ¨s Ã  tout l'Ã©cosystÃ¨me IA Python
- Interface native Windows avec Lazarus
- Performance du code Pascal pour la logique mÃ©tier
- DÃ©ploiement flexible (avec ou sans Python embarquÃ©)

### âš ï¸ Points d'attention
- Configuration initiale demande de l'attention (chemins, DLL)
- Gestion de l'architecture 32/64 bits
- Performance de l'interopÃ©rabilitÃ© Ã  considÃ©rer
- Tester le dÃ©ploiement sur machine cible

### ğŸ¯ Cas d'usage idÃ©aux
- Applications desktop avec ML/IA
- Outils d'analyse de donnÃ©es avec interface riche
- Prototypes rapides combinant Python et Pascal
- Migration progressive d'applications existantes

### ğŸ“š Ressources essentielles
- Documentation Python4Delphi GitHub
- Forums Lazarus (section Python)
- Documentation Python officielle

## Projets complets

### Projet 1 : Dashboard d'analyse de donnÃ©es en temps rÃ©el

Une application complÃ¨te qui combine visualisation de donnÃ©es, analyse statistique et prÃ©dictions ML.

**Architecture du projet :**

```
DataDashboard\
â”œâ”€â”€ main.pas                    # Formulaire principal
â”œâ”€â”€ data_processor.pas          # Traitement des donnÃ©es
â”œâ”€â”€ ml_predictor.pas           # ModÃ¨les ML
â”œâ”€â”€ chart_generator.pas        # GÃ©nÃ©ration de graphiques
â”œâ”€â”€ python_scripts\            # Scripts Python rÃ©utilisables
â”‚   â”œâ”€â”€ analyze.py
â”‚   â”œâ”€â”€ predict.py
â”‚   â””â”€â”€ visualize.py
â””â”€â”€ models\                    # ModÃ¨les prÃ©-entraÃ®nÃ©s
    â””â”€â”€ predictor.pkl
```

**Code principal - main.pas :**

```pascal
unit Main;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls,
  ComCtrls, Grids, PythonEngine, PythonGUIInputOutput,
  DataProcessor, MLPredictor, ChartGenerator;

type
  TMainForm = class(TForm)
    // Composants visuels
    PageControl1: TPageControl;
    TabSheetData: TTabSheet;
    TabSheetAnalysis: TTabSheet;
    TabSheetPrediction: TTabSheet;

    // Onglet DonnÃ©es
    ButtonLoadCSV: TButton;
    StringGridData: TStringGrid;
    LabelRowCount: TLabel;

    // Onglet Analyse
    ImageHistogram: TImage;
    ImageScatter: TImage;
    MemoStats: TMemo;
    ButtonAnalyze: TButton;

    // Onglet PrÃ©diction
    ComboBoxModel: TComboBox;
    ButtonTrain: TButton;
    ButtonPredict: TButton;
    EditInput: TEdit;
    LabelPrediction: TLabel;
    ProgressBarTraining: TProgressBar;

    // Python
    PythonEngine1: TPythonEngine;
    PythonGUIInputOutput1: TPythonGUIInputOutput;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonLoadCSVClick(Sender: TObject);
    procedure ButtonAnalyzeClick(Sender: TObject);
    procedure ButtonTrainClick(Sender: TObject);
    procedure ButtonPredictClick(Sender: TObject);

  private
    FDataProcessor: TDataProcessor;
    FMLPredictor: TMLPredictor;
    FChartGenerator: TChartGenerator;
    FDataLoaded: Boolean;

    procedure InitializePython;
    procedure LoadDataToGrid(const CSVPath: string);
  end;

var
  MainForm: TMainForm;

implementation

{$R *.lfm}

procedure TMainForm.FormCreate(Sender: TObject);  
begin
  FDataLoaded := False;

  InitializePython;

  // CrÃ©er les objets de traitement
  FDataProcessor := TDataProcessor.Create(PythonEngine1);
  FMLPredictor := TMLPredictor.Create(PythonEngine1);
  FChartGenerator := TChartGenerator.Create(PythonEngine1);

  // Configurer la grille
  StringGridData.ColCount := 5;
  StringGridData.RowCount := 1;
  StringGridData.Cells[0, 0] := 'ID';
  StringGridData.Cells[1, 0] := 'Date';
  StringGridData.Cells[2, 0] := 'Valeur';
  StringGridData.Cells[3, 0] := 'CatÃ©gorie';
  StringGridData.Cells[4, 0] := 'Score';

  // Remplir la liste des modÃ¨les
  ComboBoxModel.Items.Add('RÃ©gression LinÃ©aire');
  ComboBoxModel.Items.Add('Random Forest');
  ComboBoxModel.Items.Add('RÃ©seau de Neurones');
  ComboBoxModel.ItemIndex := 0;
end;

procedure TMainForm.FormDestroy(Sender: TObject);  
begin
  FDataProcessor.Free;
  FMLPredictor.Free;
  FChartGenerator.Free;

  if PythonEngine1.Initialized then
    PythonEngine1.Finalize;
end;

procedure TMainForm.InitializePython;  
begin
  try
    PythonEngine1.DllPath := 'C:\Python310';
    PythonEngine1.DllName := 'python310.dll';
    PythonEngine1.LoadDll;

    if PythonEngine1.Initialized then
    begin
      // Charger les bibliothÃ¨ques communes
      PythonEngine1.ExecString('import pandas as pd');
      PythonEngine1.ExecString('import numpy as np');
      PythonEngine1.ExecString('import matplotlib.pyplot as plt');
      PythonEngine1.ExecString('from sklearn.model_selection import train_test_split');
      PythonEngine1.ExecString('from sklearn.preprocessing import StandardScaler');

      Caption := 'Data Dashboard - Python ' + PythonEngine1.PyVersion;
    end
    else
      ShowMessage('Erreur : Impossible d''initialiser Python');

  except
    on E: Exception do
      ShowMessage('Erreur Python : ' + E.Message);
  end;
end;

procedure TMainForm.ButtonLoadCSVClick(Sender: TObject);  
var
  OpenDialog: TOpenDialog;
begin
  OpenDialog := TOpenDialog.Create(nil);
  try
    OpenDialog.Filter := 'Fichiers CSV|*.csv|Tous les fichiers|*.*';

    if OpenDialog.Execute then
    begin
      LoadDataToGrid(OpenDialog.FileName);
      FDataLoaded := True;
      ButtonAnalyze.Enabled := True;
      ButtonTrain.Enabled := True;
    end;
  finally
    OpenDialog.Free;
  end;
end;

procedure TMainForm.LoadDataToGrid(const CSVPath: string);  
var
  RowCount, ColCount, MaxRows: Integer;
  i, row, col: Integer;
  RowCountStr, ColCountStr: string;
  Headers, RowData: string;
  HeaderList, CellList: TStringList;
begin
  try
    // Charger le CSV avec Pandas
    PythonEngine1.ExecString(
      Format('df = pd.read_csv(r"%s")', [CSVPath])
    );

    // Obtenir les dimensions
    RowCountStr := PythonEngine1.EvalString('str(len(df))');
    ColCountStr := PythonEngine1.EvalString('str(len(df.columns))');

    RowCount := StrToInt(RowCountStr);
    ColCount := StrToInt(ColCountStr);

    // Redimensionner la grille
    StringGridData.RowCount := RowCount + 1;
    StringGridData.ColCount := ColCount;

    // Charger les en-tÃªtes
    PythonEngine1.ExecString('headers = df.columns.tolist()');
    PythonEngine1.ExecString('headers_str = "|".join(headers)');

    Headers := PythonEngine1.EvalString('headers_str');
    HeaderList := TStringList.Create;
    try
      HeaderList.Delimiter := '|';
      HeaderList.StrictDelimiter := True;
      HeaderList.DelimitedText := Headers;

      for i := 0 to HeaderList.Count - 1 do
        StringGridData.Cells[i, 0] := HeaderList[i];
    finally
      HeaderList.Free;
    end;

    // Charger les donnÃ©es (limiter Ã  100 premiÃ¨res lignes pour la performance)
    MaxRows := Min(RowCount, 100);

    for row := 0 to MaxRows - 1 do
    begin
      PythonEngine1.ExecString(
        Format('row_data = df.iloc[%d].tolist()', [row])
      );
      PythonEngine1.ExecString('row_str = "|".join(map(str, row_data))');

      RowData := PythonEngine1.EvalString('row_str');
      CellList := TStringList.Create;
      try
        CellList.Delimiter := '|';
        CellList.StrictDelimiter := True;
        CellList.DelimitedText := RowData;

        for col := 0 to CellList.Count - 1 do
          StringGridData.Cells[col, row + 1] := CellList[col];
      finally
        CellList.Free;
      end;
    end;

    LabelRowCount.Caption := Format('%d lignes Ã— %d colonnes', [RowCount, ColCount]);

    if RowCount > 100 then
      LabelRowCount.Caption := LabelRowCount.Caption + ' (100 premiÃ¨res affichÃ©es)';

  except
    on E: Exception do
      ShowMessage('Erreur lors du chargement : ' + E.Message);
  end;
end;

procedure TMainForm.ButtonAnalyzeClick(Sender: TObject);  
begin
  if not FDataLoaded then
  begin
    ShowMessage('Veuillez d''abord charger des donnÃ©es !');
    Exit;
  end;

  ButtonAnalyze.Enabled := False;
  try
    // GÃ©nÃ©rer les statistiques
    MemoStats.Clear;
    MemoStats.Lines.Add('=== ANALYSE STATISTIQUE ===');
    MemoStats.Lines.Add('');

    PythonEngine1.ExecString('stats = df.describe().to_string()');
    MemoStats.Lines.Add(PythonEngine1.EvalString('stats'));

    // GÃ©nÃ©rer l'histogramme
    FChartGenerator.GenerateHistogram(ImageHistogram, 'df');

    // GÃ©nÃ©rer le scatter plot
    FChartGenerator.GenerateScatterPlot(ImageScatter, 'df');

    PageControl1.ActivePage := TabSheetAnalysis;

  finally
    ButtonAnalyze.Enabled := True;
  end;
end;

procedure TMainForm.ButtonTrainClick(Sender: TObject);  
var
  ModelType: string;
begin
  if not FDataLoaded then
  begin
    ShowMessage('Veuillez d''abord charger des donnÃ©es !');
    Exit;
  end;

  ModelType := ComboBoxModel.Text;

  ButtonTrain.Enabled := False;
  ProgressBarTraining.Position := 0;
  ProgressBarTraining.Style := pbstMarquee;

  try
    FMLPredictor.TrainModel(ModelType);

    ProgressBarTraining.Style := pbstNormal;
    ProgressBarTraining.Position := 100;

    ShowMessage('ModÃ¨le entraÃ®nÃ© avec succÃ¨s !');
    ButtonPredict.Enabled := True;

  except
    on E: Exception do
    begin
      ShowMessage('Erreur lors de l''entraÃ®nement : ' + E.Message);
      ProgressBarTraining.Style := pbstNormal;
      ProgressBarTraining.Position := 0;
    end;
  end;

  ButtonTrain.Enabled := True;
end;

procedure TMainForm.ButtonPredictClick(Sender: TObject);  
var
  InputValue: Double;
  Prediction: Double;
begin
  try
    InputValue := StrToFloat(EditInput.Text);
    Prediction := FMLPredictor.Predict(InputValue);

    LabelPrediction.Caption := Format('PrÃ©diction : %.2f', [Prediction]);
    LabelPrediction.Font.Color := clGreen;

  except
    on E: Exception do
    begin
      LabelPrediction.Caption := 'Erreur de prÃ©diction';
      LabelPrediction.Font.Color := clRed;
      ShowMessage('Erreur : ' + E.Message);
    end;
  end;
end;

end.
```

**Module de traitement - data_processor.pas :**

```pascal
unit DataProcessor;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, PythonEngine;

type
  TDataProcessor = class
  private
    FPythonEngine: TPythonEngine;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure CleanData;
    procedure NormalizeData;
    procedure HandleMissingValues(const Strategy: string);
    function GetColumnStats(const ColumnName: string): string;
    function FilterData(const Condition: string): Integer;
  end;

implementation

constructor TDataProcessor.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;
end;

procedure TDataProcessor.CleanData;  
begin
  // Supprimer les doublons
  FPythonEngine.ExecString('df = df.drop_duplicates()');

  // Supprimer les lignes avec trop de valeurs manquantes
  FPythonEngine.ExecString('df = df.dropna(thresh=len(df.columns) * 0.7)');
end;

procedure TDataProcessor.NormalizeData;  
begin
  FPythonEngine.ExecString('from sklearn.preprocessing import StandardScaler');
  FPythonEngine.ExecString('numeric_cols = df.select_dtypes(include=[np.number]).columns');
  FPythonEngine.ExecString('scaler = StandardScaler()');
  FPythonEngine.ExecString('df[numeric_cols] = scaler.fit_transform(df[numeric_cols])');
end;

procedure TDataProcessor.HandleMissingValues(const Strategy: string);  
begin
  if Strategy = 'mean' then
    FPythonEngine.ExecString('df = df.fillna(df.mean())')
  else if Strategy = 'median' then
    FPythonEngine.ExecString('df = df.fillna(df.median())')
  else if Strategy = 'mode' then
    FPythonEngine.ExecString('df = df.fillna(df.mode().iloc[0])')
  else if Strategy = 'drop' then
    FPythonEngine.ExecString('df = df.dropna()');
end;

function TDataProcessor.GetColumnStats(const ColumnName: string): string;  
begin
  FPythonEngine.ExecString(
    Format('stats = df["%s"].describe().to_string()', [ColumnName])
  );
  Result := FPythonEngine.EvalString('stats');
end;

function TDataProcessor.FilterData(const Condition: string): Integer;  
var
  CountStr: string;
begin
  FPythonEngine.ExecString(
    Format('filtered_df = df[%s]', [Condition])
  );
  CountStr := FPythonEngine.EvalString('str(len(filtered_df))');
  Result := StrToInt(CountStr);
end;

end.
```

**Module ML - ml_predictor.pas :**

```pascal
unit MLPredictor;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, PythonEngine;

type
  TDoubleArray = array of Double;

  TMLPredictor = class
  private
    FPythonEngine: TPythonEngine;
    FModelTrained: Boolean;
    FCurrentModel: string;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure TrainModel(const ModelType: string);
    function Predict(const InputValue: Double): Double;
    function PredictBatch(const InputValues: array of Double): TDoubleArray;
    function GetModelAccuracy: Double;
    procedure SaveModel(const FilePath: string);
    procedure LoadModel(const FilePath: string);
  end;

implementation

constructor TMLPredictor.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;
  FModelTrained := False;
  FCurrentModel := '';
end;

procedure TMLPredictor.TrainModel(const ModelType: string);  
begin
  FCurrentModel := ModelType;

  // PrÃ©parer les donnÃ©es
  FPythonEngine.ExecString('X = df.iloc[:, :-1].values');
  FPythonEngine.ExecString('y = df.iloc[:, -1].values');
  FPythonEngine.ExecString(
    'X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)'
  );

  // SÃ©lectionner et entraÃ®ner le modÃ¨le
  if ModelType = 'RÃ©gression LinÃ©aire' then
  begin
    FPythonEngine.ExecString('from sklearn.linear_model import LinearRegression');
    FPythonEngine.ExecString('model = LinearRegression()');
  end
  else if ModelType = 'Random Forest' then
  begin
    FPythonEngine.ExecString('from sklearn.ensemble import RandomForestRegressor');
    FPythonEngine.ExecString('model = RandomForestRegressor(n_estimators=100, random_state=42)');
  end
  else if ModelType = 'RÃ©seau de Neurones' then
  begin
    FPythonEngine.ExecString('from sklearn.neural_network import MLPRegressor');
    FPythonEngine.ExecString(
      'model = MLPRegressor(hidden_layer_sizes=(100, 50), max_iter=500, random_state=42)'
    );
  end;

  // EntraÃ®ner
  FPythonEngine.ExecString('model.fit(X_train, y_train)');

  // Ã‰valuer
  FPythonEngine.ExecString('score = model.score(X_test, y_test)');

  FModelTrained := True;
end;

function TMLPredictor.Predict(const InputValue: Double): Double;  
var
  PredictionStr: string;
begin
  if not FModelTrained then
    raise Exception.Create('ModÃ¨le non entraÃ®nÃ© !');

  FPythonEngine.ExecString(
    Format('prediction = model.predict([[%.4f]])[0]', [InputValue])
  );

  PredictionStr := FPythonEngine.EvalString('str(prediction)');
  Result := StrToFloat(PredictionStr);
end;

function TMLPredictor.PredictBatch(const InputValues: array of Double): TDoubleArray;  
var
  i: Integer;
  InputList: string;
  PredictionsStr: string;
  Predictions: TStringList;
begin
  if not FModelTrained then
    raise Exception.Create('ModÃ¨le non entraÃ®nÃ© !');

  // Construire la liste Python
  InputList := '[';
  for i := 0 to High(InputValues) do
  begin
    InputList := InputList + Format('[%.4f]', [InputValues[i]]);
    if i < High(InputValues) then
      InputList := InputList + ',';
  end;
  InputList := InputList + ']';

  FPythonEngine.ExecString(
    Format('predictions = model.predict(%s)', [InputList])
  );
  FPythonEngine.ExecString('predictions_str = "|".join(map(str, predictions))');

  PredictionsStr := FPythonEngine.EvalString('predictions_str');
  Predictions := TStringList.Create;
  try
    Predictions.Delimiter := '|';
    Predictions.StrictDelimiter := True;
    Predictions.DelimitedText := PredictionsStr;

    SetLength(Result, Predictions.Count);
    for i := 0 to Predictions.Count - 1 do
      Result[i] := StrToFloat(Predictions[i]);
  finally
    Predictions.Free;
  end;
end;

function TMLPredictor.GetModelAccuracy: Double;  
var
  ScoreStr: string;
begin
  if not FModelTrained then
    raise Exception.Create('ModÃ¨le non entraÃ®nÃ© !');

  ScoreStr := FPythonEngine.EvalString('str(score)');
  Result := StrToFloat(ScoreStr);
end;

procedure TMLPredictor.SaveModel(const FilePath: string);  
begin
  if not FModelTrained then
    raise Exception.Create('ModÃ¨le non entraÃ®nÃ© !');

  FPythonEngine.ExecString('import pickle');
  FPythonEngine.ExecString(
    Format('with open(r"%s", "wb") as f: pickle.dump(model, f)', [FilePath])
  );
end;

procedure TMLPredictor.LoadModel(const FilePath: string);  
begin
  FPythonEngine.ExecString('import pickle');
  FPythonEngine.ExecString(
    Format('with open(r"%s", "rb") as f: model = pickle.load(f)', [FilePath])
  );
  FModelTrained := True;
end;

end.
```

**Module graphiques - chart_generator.pas :**

```pascal
unit ChartGenerator;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Graphics, ExtCtrls, PythonEngine;

type
  TChartGenerator = class
  private
    FPythonEngine: TPythonEngine;
    function GetTempImagePath: string;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure GenerateHistogram(TargetImage: TImage; const DataFrameName: string);
    procedure GenerateScatterPlot(TargetImage: TImage; const DataFrameName: string);
    procedure GenerateLinePlot(TargetImage: TImage; const XColumn, YColumn: string);
    procedure GenerateBoxPlot(TargetImage: TImage; const ColumnName: string);
    procedure GenerateHeatmap(TargetImage: TImage; const DataFrameName: string);
  end;

implementation

constructor TChartGenerator.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;

  // Configurer matplotlib
  FPythonEngine.ExecString('import matplotlib');
  FPythonEngine.ExecString('matplotlib.use("Agg")'); // Backend sans GUI
  FPythonEngine.ExecString('import matplotlib.pyplot as plt');
  FPythonEngine.ExecString('import seaborn as sns');
  FPythonEngine.ExecString('sns.set_style("whitegrid")');
end;

function TChartGenerator.GetTempImagePath: string;  
begin
  Result := GetTempDir + 'chart_' + FormatDateTime('yyyymmddhhnnsszzz', Now) + '.png';
end;

procedure TChartGenerator.GenerateHistogram(TargetImage: TImage; const DataFrameName: string);  
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(10, 6))');
    FPythonEngine.ExecString(
      Format('%s.hist(bins=30, edgecolor="black")', [DataFrameName])
    );
    FPythonEngine.ExecString('plt.title("Distribution des donnÃ©es")');
    FPythonEngine.ExecString('plt.xlabel("Valeur")');
    FPythonEngine.ExecString('plt.ylabel("FrÃ©quence")');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur gÃ©nÃ©ration histogramme : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateScatterPlot(TargetImage: TImage; const DataFrameName: string);  
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(10, 6))');
    FPythonEngine.ExecString(
      Format('numeric_cols = %s.select_dtypes(include=[np.number]).columns', [DataFrameName])
    );
    FPythonEngine.ExecString(
      Format('if len(numeric_cols) >= 2: plt.scatter(%s[numeric_cols[0]], %s[numeric_cols[1]])',
      [DataFrameName, DataFrameName])
    );
    FPythonEngine.ExecString('plt.title("Scatter Plot")');
    FPythonEngine.ExecString('plt.xlabel("Variable 1")');
    FPythonEngine.ExecString('plt.ylabel("Variable 2")');
    FPythonEngine.ExecString('plt.grid(True, alpha=0.3)');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur gÃ©nÃ©ration scatter plot : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateLinePlot(TargetImage: TImage; const XColumn, YColumn: string);  
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(12, 6))');
    FPythonEngine.ExecString(
      Format('plt.plot(df["%s"], df["%s"], linewidth=2, marker="o")', [XColumn, YColumn])
    );
    FPythonEngine.ExecString(Format('plt.title("%s vs %s")', [YColumn, XColumn]));
    FPythonEngine.ExecString(Format('plt.xlabel("%s")', [XColumn]));
    FPythonEngine.ExecString(Format('plt.ylabel("%s")', [YColumn]));
    FPythonEngine.ExecString('plt.grid(True, alpha=0.3)');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur gÃ©nÃ©ration line plot : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateBoxPlot(TargetImage: TImage; const ColumnName: string);  
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(8, 6))');
    FPythonEngine.ExecString(
      Format('df[["%s"]].boxplot()', [ColumnName])
    );
    FPythonEngine.ExecString(Format('plt.title("Box Plot - %s")', [ColumnName]));
    FPythonEngine.ExecString('plt.ylabel("Valeur")');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur gÃ©nÃ©ration box plot : ' + E.Message);
  end;
end;

procedure TChartGenerator.GenerateHeatmap(TargetImage: TImage; const DataFrameName: string);  
var
  ImagePath: string;
begin
  ImagePath := GetTempImagePath;

  try
    FPythonEngine.ExecString('plt.figure(figsize=(10, 8))');
    FPythonEngine.ExecString(
      Format('correlation = %s.corr()', [DataFrameName])
    );
    FPythonEngine.ExecString(
      'sns.heatmap(correlation, annot=True, cmap="coolwarm", center=0)'
    );
    FPythonEngine.ExecString('plt.title("Matrice de corrÃ©lation")');
    FPythonEngine.ExecString('plt.tight_layout()');
    FPythonEngine.ExecString(
      Format('plt.savefig(r"%s", dpi=100)', [ImagePath])
    );
    FPythonEngine.ExecString('plt.close()');

    if FileExists(ImagePath) then
    begin
      TargetImage.Picture.LoadFromFile(ImagePath);
      DeleteFile(ImagePath);
    end;

  except
    on E: Exception do
      raise Exception.Create('Erreur gÃ©nÃ©ration heatmap : ' + E.Message);
  end;
end;

end.
```

## Conclusion et synthÃ¨se

### Ce que vous avez appris

Dans cette section complÃ¨te sur Python4Lazarus pour Windows, vous avez dÃ©couvert :

âœ… **Installation et configuration** complÃ¨te de Python et Python4Lazarus  
âœ… **IntÃ©gration basique** : exÃ©cution de code Python depuis Pascal  
âœ… **Ã‰change de donnÃ©es** : passage de variables entre les deux langages  
âœ… **Projets avancÃ©s** : applications ML complÃ¨tes avec interface graphique  
âœ… **Optimisations** : meilleures pratiques pour la performance  
âœ… **DÃ©ploiement** : stratÃ©gies pour distribuer vos applications  
âœ… **RÃ©solution de problÃ¨mes** : solutions aux erreurs courantes

### CompÃ©tences acquises

Vous Ãªtes maintenant capable de :

- CrÃ©er des applications Windows avec interface Lazarus et moteur IA Python
- IntÃ©grer TensorFlow, scikit-learn et autres bibliothÃ¨ques ML
- Construire des dashboards d'analyse de donnÃ©es
- GÃ©nÃ©rer des visualisations matplotlib dans vos applications
- DÃ©ployer des applications hybrides Pascal/Python
- Optimiser les performances de l'interopÃ©rabilitÃ©
- DÃ©boguer efficacement les erreurs d'intÃ©gration

### Prochaines Ã©tapes

**Section suivante : 15.7.2 Python4Lazarus sur Ubuntu**

La prochaine section couvrira les spÃ©cificitÃ©s de l'intÃ©gration Python sous Linux/Ubuntu, notamment :

- Installation via apt et pip
- Configuration des chemins Unix
- Gestion des bibliothÃ¨ques partagÃ©es .so
- DiffÃ©rences avec Windows
- Scripts de dÃ©ploiement Linux

### Ressources complÃ©mentaires

**Documentation officielle :**
- Python4Delphi : [github.com/pyscripter/python4delphi](https://github.com/pyscripter/python4delphi)
- Wiki Python4Delphi : Exemples et FAQ
- Python Documentation : [docs.python.org](https://docs.python.org)
- Lazarus Forums : Section "Third Party" pour Python

**BibliothÃ¨ques Python essentielles :**

```cmd
# Data Science
pip install numpy pandas matplotlib seaborn scipy

# Machine Learning
pip install scikit-learn tensorflow torch xgboost

# Computer Vision
pip install opencv-python pillow scikit-image

# NLP
pip install transformers spacy nltk textblob

# Autres utilitaires
pip install requests beautifulsoup4 sqlalchemy
```

**Tutoriels vidÃ©o et articles :**
- YouTube : "Python4Delphi tutorials"
- Medium : Articles sur l'intÃ©gration Python/Pascal
- Stack Overflow : Tag "python4delphi"

## Checklist de dÃ©ploiement

Avant de dÃ©ployer votre application sur Windows, vÃ©rifiez :

### âœ… Configuration Python

- [ ] Python installÃ© dans un emplacement cohÃ©rent
- [ ] Version Python testÃ©e (3.9, 3.10 ou 3.11)
- [ ] Architecture cohÃ©rente (32-bit ou 64-bit)
- [ ] BibliothÃ¨ques Python installÃ©es via requirements.txt
- [ ] Chemins Python configurables (fichier de configuration)

### âœ… Application Lazarus

- [ ] Gestion d'erreur robuste pour l'initialisation Python
- [ ] Chemins relatifs ou configurables pour les scripts
- [ ] LibÃ©ration correcte des ressources Python
- [ ] Tests sur machine propre (sans environnement de dÃ©veloppement)
- [ ] Documentation utilisateur pour l'installation Python

### âœ… Fichiers de dÃ©ploiement

```
MonApplication\
â”œâ”€â”€ MonApp.exe
â”œâ”€â”€ config.ini                    # Configuration Python
â”œâ”€â”€ readme.txt                    # Instructions installation
â”œâ”€â”€ requirements.txt              # DÃ©pendances Python
â”œâ”€â”€ scripts\                      # Scripts Python
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ preprocessing.py
â”‚   â””â”€â”€ models.py
â”œâ”€â”€ models\                       # ModÃ¨les ML
â”‚   â””â”€â”€ trained_model.pkl
â””â”€â”€ python_embedded\              # (Optionnel) Python portable
    â”œâ”€â”€ python.exe
    â””â”€â”€ ...
```

**Exemple config.ini :**

```ini
[Python]
DllPath=C:\Python310  
DllName=python310.dll  
UseSystemPython=1

[Paths]
ScriptsFolder=.\scripts  
ModelsFolder=.\models  
TempFolder=%TEMP%\MonApp

[Models]
DefaultModel=.\models\trained_model.pkl  
AutoLoadModel=1
```

**Code pour lire la configuration :**

```pascal
uses
  IniFiles;

procedure TForm1.LoadPythonConfig;  
var
  Config: TIniFile;
  DllPath, DllName: string;
  UseSystemPython: Boolean;
begin
  Config := TIniFile.Create(ExtractFilePath(Application.ExeName) + 'config.ini');
  try
    DllPath := Config.ReadString('Python', 'DllPath', 'C:\Python310');
    DllName := Config.ReadString('Python', 'DllName', 'python310.dll');
    UseSystemPython := Config.ReadBool('Python', 'UseSystemPython', True);

    if UseSystemPython then
    begin
      // Laisser Python4Lazarus trouver Python dans le PATH
      PythonEngine1.UseLastKnownVersion := True;
    end
    else
    begin
      // Utiliser le chemin spÃ©cifiÃ©
      PythonEngine1.DllPath := DllPath;
      PythonEngine1.DllName := DllName;
    end;

    PythonEngine1.LoadDll;

  finally
    Config.Free;
  end;
end;
```

### âœ… Tests de dÃ©ploiement

- [ ] Test sur Windows 10 propre
- [ ] Test sur Windows 11
- [ ] Test avec et sans Python prÃ©-installÃ©
- [ ] Test avec diffÃ©rentes versions Python
- [ ] Test de la gestion des erreurs (Python manquant, bibliothÃ¨ques manquantes)
- [ ] Test de performance avec donnÃ©es rÃ©elles
- [ ] Test de la consommation mÃ©moire

## Patterns de conception recommandÃ©s

### Pattern Singleton pour PythonEngine

Ã‰viter de crÃ©er plusieurs instances de PythonEngine :

```pascal
unit PythonManager;

{$mode objfpc}{$H+}

interface

uses
  PythonEngine;

type
  TPythonManager = class
  private
    class var FInstance: TPythonManager;
    FEngine: TPythonEngine;
    constructor Create;
  public
    destructor Destroy; override;
    class function Instance: TPythonManager;
    property Engine: TPythonEngine read FEngine;
  end;

implementation

var
  _Instance: TPythonManager = nil;

constructor TPythonManager.Create;  
begin
  inherited Create;
  FEngine := TPythonEngine.Create(nil);
  FEngine.DllPath := 'C:\Python310';
  FEngine.LoadDll;
end;

destructor TPythonManager.Destroy;  
begin
  if FEngine.Initialized then
    FEngine.Finalize;
  FEngine.Free;
  inherited Destroy;
end;

class function TPythonManager.Instance: TPythonManager;  
begin
  if _Instance = nil then
    _Instance := TPythonManager.Create;
  Result := _Instance;
end;

initialization

finalization
  if _Instance <> nil then
    _Instance.Free;

end.

// Utilisation partout dans l'application
var
  Python: TPythonEngine;
begin
  Python := TPythonManager.Instance.Engine;
  Python.ExecString('print("Hello!")');
end;
```

### Pattern Factory pour les modÃ¨les ML

```pascal
unit MLModelFactory;

interface

uses
  PythonEngine;

type
  IMLModel = interface
    ['{12345678-1234-1234-1234-123456789012}']
    procedure Train(const Data: string);
    function Predict(const Input: string): string;
    function GetAccuracy: Double;
  end;

  TLinearRegressionModel = class(TInterfacedObject, IMLModel)
  private
    FPythonEngine: TPythonEngine;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure Train(const Data: string);
    function Predict(const Input: string): string;
    function GetAccuracy: Double;
  end;

  TRandomForestModel = class(TInterfacedObject, IMLModel)
  private
    FPythonEngine: TPythonEngine;
  public
    constructor Create(APythonEngine: TPythonEngine);
    procedure Train(const Data: string);
    function Predict(const Input: string): string;
    function GetAccuracy: Double;
  end;

  TMLModelFactory = class
  public
    class function CreateModel(const ModelType: string;
                               APythonEngine: TPythonEngine): IMLModel;
  end;

implementation

{ TLinearRegressionModel }

constructor TLinearRegressionModel.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;
  FPythonEngine.ExecString('from sklearn.linear_model import LinearRegression');
  FPythonEngine.ExecString('model = LinearRegression()');
end;

procedure TLinearRegressionModel.Train(const Data: string);  
begin
  FPythonEngine.ExecString(Format('model.fit(%s)', [Data]));
end;

function TLinearRegressionModel.Predict(const Input: string): string;  
begin
  FPythonEngine.ExecString(Format('prediction = model.predict(%s)', [Input]));
  Result := FPythonEngine.EvalString('str(prediction)');
end;

function TLinearRegressionModel.GetAccuracy: Double;  
begin
  Result := StrToFloat(FPythonEngine.EvalString('str(model.score(X_test, y_test))'));
end;

{ TRandomForestModel }

constructor TRandomForestModel.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;
  FPythonEngine.ExecString('from sklearn.ensemble import RandomForestRegressor');
  FPythonEngine.ExecString('model = RandomForestRegressor()');
end;

procedure TRandomForestModel.Train(const Data: string);  
begin
  FPythonEngine.ExecString(Format('model.fit(%s)', [Data]));
end;

function TRandomForestModel.Predict(const Input: string): string;  
begin
  FPythonEngine.ExecString(Format('prediction = model.predict(%s)', [Input]));
  Result := FPythonEngine.EvalString('str(prediction)');
end;

function TRandomForestModel.GetAccuracy: Double;  
begin
  Result := StrToFloat(FPythonEngine.EvalString('str(model.score(X_test, y_test))'));
end;

{ TMLModelFactory }

class function TMLModelFactory.CreateModel(const ModelType: string;
                                          APythonEngine: TPythonEngine): IMLModel;
begin
  if ModelType = 'LinearRegression' then
    Result := TLinearRegressionModel.Create(APythonEngine)
  else if ModelType = 'RandomForest' then
    Result := TRandomForestModel.Create(APythonEngine)
  else
    raise Exception.Create('Type de modÃ¨le inconnu : ' + ModelType);
end;

end.

// Utilisation
var
  Model: IMLModel;
begin
  Model := TMLModelFactory.CreateModel('RandomForest', PythonEngine);
  Model.Train('X_train, y_train');
  ShowMessage('PrÃ©diction : ' + Model.Predict('[1.5, 2.3, 4.1]'));
end;
```

### Pattern Observer pour les notifications Python

```pascal
unit PythonObserver;

interface

uses
  Classes, SysUtils;

type
  IPythonObserver = interface
    ['{87654321-4321-4321-4321-210987654321}']
    procedure OnPythonOutput(const Output: string);
    procedure OnPythonError(const Error: string);
    procedure OnPythonProgress(const Progress: Integer);
  end;

  TPythonSubject = class
  private
    FObservers: TInterfaceList;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Attach(Observer: IPythonObserver);
    procedure Detach(Observer: IPythonObserver);
    procedure NotifyOutput(const Output: string);
    procedure NotifyError(const Error: string);
    procedure NotifyProgress(const Progress: Integer);
  end;

implementation

constructor TPythonSubject.Create;  
begin
  inherited Create;
  FObservers := TInterfaceList.Create;
end;

destructor TPythonSubject.Destroy;  
begin
  FObservers.Free;
  inherited Destroy;
end;

procedure TPythonSubject.Attach(Observer: IPythonObserver);  
begin
  FObservers.Add(Observer);
end;

procedure TPythonSubject.Detach(Observer: IPythonObserver);  
begin
  FObservers.Remove(Observer);
end;

procedure TPythonSubject.NotifyOutput(const Output: string);  
var
  i: Integer;
  Observer: IPythonObserver;
begin
  for i := 0 to FObservers.Count - 1 do
  begin
    Observer := FObservers[i] as IPythonObserver;
    Observer.OnPythonOutput(Output);
  end;
end;

procedure TPythonSubject.NotifyError(const Error: string);  
var
  i: Integer;
  Observer: IPythonObserver;
begin
  for i := 0 to FObservers.Count - 1 do
  begin
    Observer := FObservers[i] as IPythonObserver;
    Observer.OnPythonError(Error);
  end;
end;

procedure TPythonSubject.NotifyProgress(const Progress: Integer);  
var
  i: Integer;
  Observer: IPythonObserver;
begin
  for i := 0 to FObservers.Count - 1 do
  begin
    Observer := FObservers[i] as IPythonObserver;
    Observer.OnPythonProgress(Progress);
  end;
end;

end.
```

## Exemples d'utilisation professionnelle

### Cas d'usage 1 : Application mÃ©dicale d'analyse d'images

```pascal
// Analyse d'images mÃ©dicales avec dÃ©tection de pathologies
procedure TFormMedical.AnalyzeMedicalImage(const ImagePath: string);  
begin
  try
    // Charger le modÃ¨le de dÃ©tection (une seule fois au dÃ©marrage)
    if not FModelLoaded then
    begin
      PythonEngine.ExecString('import tensorflow as tf');
      PythonEngine.ExecString('model = tf.keras.models.load_model("medical_detector.h5")');
      FModelLoaded := True;
    end;

    // PrÃ©traiter l'image
    PythonEngine.ExecString(Format('img = preprocess_medical_image(r"%s")', [ImagePath]));

    // Faire la prÃ©diction
    PythonEngine.ExecString('prediction = model.predict(img)');
    PythonEngine.ExecString('pathology_detected = prediction[0][0] > 0.7');
    PythonEngine.ExecString('confidence = float(prediction[0][0])');

    // RÃ©cupÃ©rer les rÃ©sultats
    var Detected := PythonEngine.EvalString('str(pathology_detected)') = 'True';
    var Confidence := StrToFloat(PythonEngine.EvalString('str(confidence)'));

    // Afficher dans l'interface
    if Detected then
    begin
      LabelResult.Caption := Format('âš ï¸ Pathologie dÃ©tectÃ©e (confiance: %.1f%%)',
                                    [Confidence * 100]);
      LabelResult.Font.Color := clRed;

      // GÃ©nÃ©rer un rapport
      GenerateMedicalReport(ImagePath, Confidence);
    end
    else
    begin
      LabelResult.Caption := 'Aucune pathologie dÃ©tectÃ©e';
      LabelResult.Font.Color := clGreen;
    end;

  except
    on E: Exception do
      ShowMessage('Erreur analyse : ' + E.Message);
  end;
end;
```

### Cas d'usage 2 : SystÃ¨me de trading algorithmique

```pascal
unit TradingBot;

interface

uses
  Classes, SysUtils, PythonEngine;

type
  TTradingBot = class
  private
    FPythonEngine: TPythonEngine;
    FStrategy: string;
  public
    constructor Create(APythonEngine: TPythonEngine);

    procedure LoadStrategy(const StrategyName: string);
    function AnalyzeMarket(const Symbol: string): string;
    function ShouldBuy(const Symbol: string; const Price: Double): Boolean;
    function ShouldSell(const Symbol: string; const Price: Double): Boolean;
    function CalculatePosition(const Capital: Double): Double;
  end;

implementation

constructor TTradingBot.Create(APythonEngine: TPythonEngine);  
begin
  FPythonEngine := APythonEngine;

  // Initialiser les bibliothÃ¨ques de trading
  FPythonEngine.ExecString('import pandas as pd');
  FPythonEngine.ExecString('import numpy as np');
  FPythonEngine.ExecString('import ta'); // Technical Analysis library
end;

procedure TTradingBot.LoadStrategy(const StrategyName: string);  
begin
  FStrategy := StrategyName;

  if StrategyName = 'MA_Crossover' then
  begin
    FPythonEngine.ExecString(
      'def strategy(data):' + sLineBreak +
      '    data["MA20"] = data["Close"].rolling(20).mean()' + sLineBreak +
      '    data["MA50"] = data["Close"].rolling(50).mean()' + sLineBreak +
      '    signal = "BUY" if data["MA20"].iloc[-1] > data["MA50"].iloc[-1] else "SELL"' + sLineBreak +
      '    return signal'
    );
  end
  else if StrategyName = 'RSI' then
  begin
    FPythonEngine.ExecString(
      'def strategy(data):' + sLineBreak +
      '    rsi = ta.momentum.RSIIndicator(data["Close"]).rsi()' + sLineBreak +
      '    if rsi.iloc[-1] < 30:' + sLineBreak +
      '        return "BUY"' + sLineBreak +
      '    elif rsi.iloc[-1] > 70:' + sLineBreak +
      '        return "SELL"' + sLineBreak +
      '    else:' + sLineBreak +
      '        return "HOLD"'
    );
  end;
end;

function TTradingBot.AnalyzeMarket(const Symbol: string): string;  
begin
  FPythonEngine.ExecString(Format('data = get_market_data("%s")', [Symbol]));
  FPythonEngine.ExecString('signal = strategy(data)');
  Result := FPythonEngine.EvalString('signal');
end;

function TTradingBot.ShouldBuy(const Symbol: string; const Price: Double): Boolean;  
begin
  Result := AnalyzeMarket(Symbol) = 'BUY';
end;

function TTradingBot.ShouldSell(const Symbol: string; const Price: Double): Boolean;  
begin
  Result := AnalyzeMarket(Symbol) = 'SELL';
end;

function TTradingBot.CalculatePosition(const Capital: Double): Double;  
var
  RiskPercent: Double;
begin
  RiskPercent := 0.02; // 2% du capital
  Result := Capital * RiskPercent;
end;

end.
```

### Cas d'usage 3 : Analyse de sentiment sur rÃ©seaux sociaux

```pascal
procedure TFormSocialMedia.AnalyzeSocialSentiment(const Topic: string);  
var
  TweetCount: Integer;
  PositivePercent: Double;
  NegativePercent: Double;
  NeutralPercent: Double;
begin
  try
    // Collecter les tweets (simulation, en rÃ©alitÃ© utiliser l'API Twitter)
    PythonEngine.ExecString(
      Format('tweets = collect_tweets("%s", count=100)', [Topic])
    );

    // Analyser le sentiment avec un modÃ¨le prÃ©-entraÃ®nÃ©
    PythonEngine.ExecString('from transformers import pipeline');
    PythonEngine.ExecString('sentiment_analyzer = pipeline("sentiment-analysis")');

    PythonEngine.ExecString(
      'sentiments = [sentiment_analyzer(tweet)[0] for tweet in tweets]'
    );

    // Calculer les statistiques
    PythonEngine.ExecString(
      'positive = sum(1 for s in sentiments if s["label"] == "POSITIVE")' + sLineBreak +
      'negative = sum(1 for s in sentiments if s["label"] == "NEGATIVE")' + sLineBreak +
      'neutral = len(sentiments) - positive - negative' + sLineBreak +
      'total = len(sentiments)'
    );

    TweetCount := StrToInt(PythonEngine.EvalString('str(total)'));
    PositivePercent := StrToFloat(PythonEngine.EvalString('str(positive/total*100)'));
    NegativePercent := StrToFloat(PythonEngine.EvalString('str(negative/total*100)'));
    NeutralPercent := StrToFloat(PythonEngine.EvalString('str(neutral/total*100)'));

    // Afficher les rÃ©sultats
    MemoResults.Lines.Clear;
    MemoResults.Lines.Add(Format('=== Analyse de sentiment : %s ===', [Topic]));
    MemoResults.Lines.Add(Format('Tweets analysÃ©s : %d', [TweetCount]));
    MemoResults.Lines.Add('');
    MemoResults.Lines.Add(Format('ğŸ˜Š Positif : %.1f%%', [PositivePercent]));
    MemoResults.Lines.Add(Format('ğŸ˜ NÃ©gatif : %.1f%%', [NegativePercent]));
    MemoResults.Lines.Add(Format('ğŸ˜ Neutre : %.1f%%', [NeutralPercent]));

    // GÃ©nÃ©rer un graphique
    GenerateSentimentChart(PositivePercent, NegativePercent, NeutralPercent);

  except
    on E: Exception do
      ShowMessage('Erreur : ' + E.Message);
  end;
end;
```

## RÃ©capitulatif final

### Points clÃ©s Ã  retenir

1. **Installation** : Python 3.9-3.11, architecture cohÃ©rente, PATH configurÃ©
2. **Configuration** : DllPath, DllName, UseLastKnownVersion
3. **Initialisation** : LoadDll en FormCreate, gestion d'erreurs robuste
4. **Ã‰change de donnÃ©es** : ExecString, EvalString, JSON pour structures complexes
5. **Performance** : Charger modÃ¨les une fois, minimiser les appels, threading
6. **DÃ©ploiement** : Python embarquÃ© ou requirements.txt, configuration flexible
7. **Debugging** : Logging Python, capture stderr, gestion d'exceptions

### Erreurs Ã  Ã©viter

âŒ Ne pas gÃ©rer les erreurs d'initialisation Python  
âŒ RÃ©importer des bibliothÃ¨ques Ã  chaque utilisation  
âŒ Oublier de libÃ©rer les ressources (Finalize)  
âŒ MÃ©langer architectures 32/64 bits  
âŒ Chemins Windows avec backslashes non Ã©chappÃ©s  
âŒ Tester uniquement sur machine de dÃ©veloppement  
âŒ Ne pas vÃ©rifier la disponibilitÃ© des modules Python

### Avantages de cette approche

âœ… Interface native Windows rapide et professionnelle  
âœ… AccÃ¨s complet Ã  l'Ã©cosystÃ¨me Python pour l'IA  
âœ… Performance optimale pour la logique mÃ©tier  
âœ… DÃ©ploiement flexible selon les besoins  
âœ… Maintenance facilitÃ©e (Python pour IA, Pascal pour UI)  
âœ… Ã‰volutivitÃ© progressive (prototypage â†’ production)

## Pour aller plus loin

### Prochaine section

**15.7.2 Python4Lazarus sur Ubuntu** couvrira :
- Installation via apt-get et pip
- Gestion des bibliothÃ¨ques partagÃ©es (.so)
- Chemins Unix et permissions
- DiffÃ©rences avec Windows
- Scripts de dÃ©ploiement Linux
- Empaquetage .deb et AppImage

### Sujets avancÃ©s Ã  explorer

- **Async/Await** : IntÃ©gration asyncio Python avec threading Pascal
- **Microservices** : Application Pascal + API Python sÃ©parÃ©es
- **GPU Computing** : CUDA/OpenCL via Python depuis Pascal
- **Real-time** : Streaming de donnÃ©es avec ZeroMQ
- **Edge AI** : DÃ©ploiement sur Raspberry Pi

### CommunautÃ© et support

- **Forum Lazarus** : [forum.lazarus.freepascal.org](https://forum.lazarus.freepascal.org)
- **Python4Delphi GitHub** : Issues et discussions
- **Discord FreePascal** : Canal #python-integration
- **Stack Overflow** : Tags "freepascal" + "python"

---

**FÃ©licitations !** Vous maÃ®trisez maintenant l'intÃ©gration Python/FreePascal sur Windows. Vous Ãªtes prÃªt Ã  crÃ©er des applications professionnelles combinant la puissance de l'IA Python avec la performance et l'ergonomie de Lazarus.

**Prochaine Ã©tape** : Section 15.7.2 pour dÃ©couvrir les spÃ©cificitÃ©s Ubuntu/Linux ! ğŸ§ğŸ

â­ï¸ [Python4Lazarus sur Ubuntu](/15-intelligence-artificielle-machine-learning/07.2-python4lazarus-ubuntu.md)
