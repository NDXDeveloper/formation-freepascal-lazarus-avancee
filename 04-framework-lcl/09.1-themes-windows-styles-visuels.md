üîù Retour au [Sommaire](/SOMMAIRE.md)

# 4.9.1 Th√®mes Windows (styles visuels)

## Introduction aux styles visuels Windows

Depuis Windows XP, Microsoft a introduit le concept de "styles visuels" (Visual Styles) qui permet aux applications de s'int√©grer harmonieusement avec le th√®me du syst√®me. Que vous utilisiez Windows 7 avec Aero, Windows 10 avec son design moderne, ou Windows 11 avec ses coins arrondis, votre application Lazarus peut automatiquement adopter l'apparence native du syst√®me.

Les styles visuels Windows ne sont pas simplement des couleurs diff√©rentes : ils incluent des effets de transparence, des animations, des ombres, et m√™me des formes de boutons diff√©rentes selon la version de Windows. C'est ce qui fait qu'une application moderne sur Windows 11 a l'air... moderne !

## Activer les styles visuels dans votre application

### La m√©thode simple : Le manifeste d'application

Pour que votre application Lazarus utilise les styles visuels Windows, vous devez inclure un manifeste. C'est un fichier XML qui indique √† Windows comment traiter votre application.

#### M√©thode 1 : Via les options du projet

1. Ouvrez les options du projet : **Projet ‚Üí Options du projet**
2. Allez dans **Options Windows**
3. Cochez **Utiliser le manifeste pour activer les th√®mes**

Lazarus g√©n√®re automatiquement le manifeste appropri√© !

#### M√©thode 2 : Manifeste personnalis√©

Cr√©ez un fichier `MonApplication.exe.manifest` :

```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity
    version="1.0.0.0"
    processorArchitecture="*"
    name="CompanyName.ProductName.Application"
    type="win32"
  />
  <description>Mon Application Lazarus</description>

  <!-- D√©pendance pour les contr√¥les communs Windows -->
  <dependency>
    <dependentAssembly>
      <assemblyIdentity
        type="win32"
        name="Microsoft.Windows.Common-Controls"
        version="6.0.0.0"
        processorArchitecture="*"
        publicKeyToken="6595b64144ccf1df"
        language="*"
      />
    </dependentAssembly>
  </dependency>

  <!-- Support du DPI awareness (Windows 8.1+) -->
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
        true/PM
      </dpiAware>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">
        PerMonitorV2
      </dpiAwareness>
    </windowsSettings>
  </application>

  <!-- Compatibilit√© avec les versions de Windows -->
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 et 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
    </application>
  </compatibility>
</assembly>
```

#### M√©thode 3 : Int√©grer le manifeste dans les ressources

```pascal
{$R MonManifest.res}
```

O√π `MonManifest.res` contient votre manifeste compil√©.

### V√©rifier l'activation des th√®mes

```pascal
uses
  Windows, UxTheme, Themes;

procedure TForm1.FormCreate(Sender: TObject);
begin
  if ThemeServices.ThemesEnabled then
    ShowMessage('Les th√®mes Windows sont actifs !')
  else
    ShowMessage('Les th√®mes Windows ne sont pas disponibles');

  // Afficher des informations sur le th√®me actuel
  Caption := Format('Th√®me actif - DPI : %d', [Screen.PixelsPerInch]);
end;
```

## Utilisation de l'API UxTheme

### Les bases de UxTheme

Windows fournit l'API UxTheme pour dessiner des √©l√©ments avec le style visuel actuel. Lazarus encapsule cette API dans `ThemeServices`.

```pascal
uses
  Windows, UxTheme, Themes, Graphics;

procedure DrawThemedButton(Canvas: TCanvas; Rect: TRect; State: Integer);
var
  Details: TThemedElementDetails;
begin
  case State of
    1: Details := ThemeServices.GetElementDetails(tbPushButtonHot);
    2: Details := ThemeServices.GetElementDetails(tbPushButtonPressed);
    3: Details := ThemeServices.GetElementDetails(tbPushButtonDisabled);
  else
    Details := ThemeServices.GetElementDetails(tbPushButtonNormal);
  end;

  ThemeServices.DrawElement(Canvas.Handle, Details, Rect);
  ThemeServices.DrawText(Canvas.Handle, Details, 'Bouton', Rect,
                         DT_CENTER or DT_VCENTER or DT_SINGLELINE, 0);
end;
```

### Les √©l√©ments th√©matiques disponibles

Windows d√©finit de nombreux √©l√©ments que vous pouvez dessiner :

```pascal
type
  // Quelques exemples d'√©l√©ments th√©matiques
  TThemedButton = (
    tbButtonDontCare,
    tbButtonRoot,
    tbPushButtonNormal, tbPushButtonHot, tbPushButtonPressed,
    tbPushButtonDisabled, tbPushButtonDefaulted,
    tbRadioButtonUncheckedNormal, tbRadioButtonUncheckedHot,
    tbRadioButtonCheckedNormal, tbRadioButtonCheckedHot,
    tbCheckBoxUncheckedNormal, tbCheckBoxUncheckedHot,
    tbCheckBoxCheckedNormal, tbCheckBoxCheckedHot,
    tbCheckBoxMixedNormal, tbCheckBoxMixedHot
  );

  TThemedWindow = (
    twWindowDontCare,
    twWindowRoot,
    twCaptionActive, twCaptionInactive,
    twMinButtonNormal, twMinButtonHot, twMinButtonPushed,
    twMaxButtonNormal, twMaxButtonHot, twMaxButtonPushed,
    twCloseButtonNormal, twCloseButtonHot, twCloseButtonPushed
  );
```

### Dessiner des contr√¥les personnalis√©s avec le th√®me

```pascal
type
  TThemedPanel = class(TCustomPanel)
  protected
    procedure Paint; override;
  end;

procedure TThemedPanel.Paint;
var
  Details: TThemedElementDetails;
  R: TRect;
begin
  if ThemeServices.ThemesEnabled then
  begin
    R := ClientRect;

    // Dessiner le fond avec le style de panneau Windows
    Details := ThemeServices.GetElementDetails(teEditTextNormal);
    ThemeServices.DrawElement(Canvas.Handle, Details, R);

    // Dessiner une bordure th√©matique
    Details := ThemeServices.GetElementDetails(teEditBorderNoScrollNormal);
    ThemeServices.DrawEdge(Canvas.Handle, Details, R, EDGE_ETCHED, BF_RECT);
  end
  else
    inherited Paint; // Fallback si pas de th√®mes
end;
```

## Gestion des couleurs syst√®me Windows

### Les couleurs syst√®me standard

Windows d√©finit des couleurs syst√®me qui changent avec le th√®me :

```pascal
procedure ShowSystemColors;
begin
  WriteLn('Fen√™tre active : ', ColorToString(GetSysColor(COLOR_ACTIVECAPTION)));
  WriteLn('Fond de fen√™tre : ', ColorToString(GetSysColor(COLOR_WINDOW)));
  WriteLn('Texte de fen√™tre : ', ColorToString(GetSysColor(COLOR_WINDOWTEXT)));
  WriteLn('Fond de bouton : ', ColorToString(GetSysColor(COLOR_BTNFACE)));
  WriteLn('Surbrillance : ', ColorToString(GetSysColor(COLOR_HIGHLIGHT)));
  WriteLn('Texte surlign√© : ', ColorToString(GetSysColor(COLOR_HIGHLIGHTTEXT)));
  WriteLn('Info-bulle : ', ColorToString(GetSysColor(COLOR_INFOBK)));
end;
```

### R√©agir aux changements de th√®me

Windows envoie des messages quand le th√®me change :

```pascal
type
  TThemeAwareForm = class(TForm)
  private
    procedure WMThemeChanged(var Message: TMessage); message WM_THEMECHANGED;
    procedure WMSysColorChange(var Message: TMessage); message WM_SYSCOLORCHANGE;
  end;

procedure TThemeAwareForm.WMThemeChanged(var Message: TMessage);
begin
  // Le th√®me Windows a chang√©
  ShowMessage('Le th√®me Windows a chang√© !');

  // Mettre √† jour les couleurs
  Color := clBtnFace;
  Font.Color := clWindowText;

  // Rafra√Æchir l'affichage
  Invalidate;

  // Propager aux contr√¥les enfants
  inherited;
end;

procedure TThemeAwareForm.WMSysColorChange(var Message: TMessage);
begin
  // Les couleurs syst√®me ont chang√©
  UpdateSystemColors;
  inherited;
end;
```

## Support du Dark Mode Windows 10/11

### D√©tecter le Dark Mode

```pascal
uses
  Windows, Registry;

function IsDarkModeEnabled: Boolean;
var
  Reg: TRegistry;
begin
  Result := False;
  Reg := TRegistry.Create(KEY_READ);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion\Themes\Personalize', False) then
    begin
      if Reg.ValueExists('AppsUseLightTheme') then
        Result := Reg.ReadInteger('AppsUseLightTheme') = 0;
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

function GetSystemTheme: string;
begin
  if IsDarkModeEnabled then
    Result := 'Dark'
  else
    Result := 'Light';
end;
```

### Appliquer le Dark Mode

```pascal
type
  TDarkModeSupport = class
  private
    class procedure ApplyDarkColors(Control: TControl);
    class procedure ApplyLightColors(Control: TControl);
  public
    class procedure ApplyTheme(Form: TForm; DarkMode: Boolean);
  end;

class procedure TDarkModeSupport.ApplyTheme(Form: TForm; DarkMode: Boolean);
var
  i: Integer;
begin
  if DarkMode then
  begin
    Form.Color := $202020;  // Gris tr√®s fonc√©
    Form.Font.Color := $F0F0F0;  // Blanc cass√©

    for i := 0 to Form.ComponentCount - 1 do
      if Form.Components[i] is TControl then
        ApplyDarkColors(TControl(Form.Components[i]));
  end
  else
  begin
    Form.Color := clBtnFace;
    Form.Font.Color := clWindowText;

    for i := 0 to Form.ComponentCount - 1 do
      if Form.Components[i] is TControl then
        ApplyLightColors(TControl(Form.Components[i]));
  end;
end;

class procedure TDarkModeSupport.ApplyDarkColors(Control: TControl);
begin
  if Control is TEdit then
  begin
    TEdit(Control).Color := $303030;
    TEdit(Control).Font.Color := $F0F0F0;
  end
  else if Control is TPanel then
  begin
    TPanel(Control).Color := $252525;
    TPanel(Control).Font.Color := $F0F0F0;
  end
  else if Control is TLabel then
  begin
    TLabel(Control).Font.Color := $F0F0F0;
  end
  else if Control is TMemo then
  begin
    TMemo(Control).Color := $303030;
    TMemo(Control).Font.Color := $F0F0F0;
  end;
  // Ajouter d'autres types de contr√¥les...
end;
```

### Activer le Dark Mode pour la barre de titre (Windows 10 1809+)

```pascal
uses
  Windows;

const
  DWMWA_USE_IMMERSIVE_DARK_MODE = 20;

function AllowDarkModeForWindow(Handle: HWND; Allow: Boolean): Boolean;
var
  DarkMode: BOOL;
begin
  DarkMode := Allow;
  Result := DwmSetWindowAttribute(Handle, DWMWA_USE_IMMERSIVE_DARK_MODE,
                                  @DarkMode, SizeOf(DarkMode)) = S_OK;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  if IsDarkModeEnabled then
    AllowDarkModeForWindow(Handle, True);
end;
```

## Styles visuels personnalis√©s

### Cr√©er un style visuel personnalis√©

Vous pouvez cr√©er vos propres rendus tout en respectant le syst√®me de th√®mes :

```pascal
type
  TCustomThemedButton = class(TCustomControl)
  private
    FMouseOver: Boolean;
    FPressed: Boolean;
  protected
    procedure Paint; override;
    procedure MouseEnter; override;
    procedure MouseLeave; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
                       X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
                     X, Y: Integer); override;
  public
    constructor Create(AOwner: TComponent); override;
  end;

procedure TCustomThemedButton.Paint;
var
  Details: TThemedElementDetails;
  TextRect: TRect;
  Flags: Cardinal;
begin
  if ThemeServices.ThemesEnabled then
  begin
    // D√©terminer l'√©tat du bouton
    if not Enabled then
      Details := ThemeServices.GetElementDetails(tbPushButtonDisabled)
    else if FPressed then
      Details := ThemeServices.GetElementDetails(tbPushButtonPressed)
    else if FMouseOver then
      Details := ThemeServices.GetElementDetails(tbPushButtonHot)
    else
      Details := ThemeServices.GetElementDetails(tbPushButtonNormal);

    // Dessiner le bouton
    ThemeServices.DrawElement(Canvas.Handle, Details, ClientRect);

    // Dessiner le texte
    TextRect := ClientRect;
    Flags := DT_CENTER or DT_VCENTER or DT_SINGLELINE;

    // Utiliser DrawText th√©matique pour respecter les couleurs du th√®me
    ThemeServices.DrawText(Canvas.Handle, Details, Caption, TextRect, Flags, 0);
  end
  else
  begin
    // Fallback sans th√®mes
    Canvas.Brush.Color := clBtnFace;
    Canvas.FillRect(ClientRect);
    Canvas.TextOut((Width - Canvas.TextWidth(Caption)) div 2,
                   (Height - Canvas.TextHeight(Caption)) div 2,
                   Caption);
  end;
end;
```

### Effets visuels avanc√©s avec Windows

```pascal
uses
  DwmApi;  // Pour les effets Aero/Glass

procedure EnableBlurBehind(Form: TForm);
var
  BlurBehind: DWM_BLURBEHIND;
  Margins: MARGINS;
begin
  // V√©rifier si DWM est disponible (Vista+)
  if DwmCompositionEnabled then
  begin
    // Activer la transparence
    BlurBehind.dwFlags := DWM_BB_ENABLE or DWM_BB_BLURREGION;
    BlurBehind.fEnable := True;
    BlurBehind.hRgnBlur := CreateRectRgn(0, 0, Form.Width, 100); // Zone de blur

    DwmEnableBlurBehindWindow(Form.Handle, BlurBehind);

    // √âtendre le frame dans la zone cliente (pour l'effet glass)
    Margins.cxLeftWidth := 0;
    Margins.cxRightWidth := 0;
    Margins.cyTopHeight := 100;  // 100 pixels de glass en haut
    Margins.cyBottomHeight := 0;

    DwmExtendFrameIntoClientArea(Form.Handle, Margins);
  end;
end;
```

## Gestion des DPI et mise √† l'√©chelle

### Support du High DPI avec les th√®mes

```pascal
type
  TDPIAwareForm = class(TForm)
  private
    FCurrentDPI: Integer;
    procedure ScaleForDPI(NewDPI: Integer);
  protected
    procedure WMDPIChanged(var Message: TMessage); message WM_DPICHANGED;
  public
    constructor Create(AOwner: TComponent); override;
  end;

constructor TDPIAwareForm.Create(AOwner: TComponent);
begin
  inherited;
  FCurrentDPI := Screen.PixelsPerInch;
end;

procedure TDPIAwareForm.WMDPIChanged(var Message: TMessage);
var
  NewDPI: Integer;
  SuggestedRect: PRect;
begin
  NewDPI := LOWORD(Message.WParam);
  SuggestedRect := PRect(Message.LParam);

  // Adapter l'√©chelle
  ScaleForDPI(NewDPI);

  // Utiliser le rectangle sugg√©r√© par Windows
  SetBounds(SuggestedRect^.Left, SuggestedRect^.Top,
            SuggestedRect^.Right - SuggestedRect^.Left,
            SuggestedRect^.Bottom - SuggestedRect^.Top);

  FCurrentDPI := NewDPI;
end;

procedure TDPIAwareForm.ScaleForDPI(NewDPI: Integer);
var
  ScaleFactor: Double;
begin
  if FCurrentDPI = NewDPI then Exit;

  ScaleFactor := NewDPI / FCurrentDPI;

  // Adapter les polices
  Font.Size := Round(Font.Size * ScaleFactor);

  // Adapter les dimensions
  ScaleBy(Round(100 * ScaleFactor), 100);
end;
```

## Int√©gration avec les fonctionnalit√©s Windows modernes

### Support de la Taskbar Windows 7+

```pascal
uses
  ComObj, ShlObj;

type
  ITaskbarList3 = interface(ITaskbarList2)
    ['{EA1AFB91-9E28-4B86-90E9-9E9F8A5EEFAF}']
    function SetProgressValue(hwnd: HWND; ullCompleted: ULONGLONG;
                            ullTotal: ULONGLONG): HRESULT; stdcall;
    function SetProgressState(hwnd: HWND;
                            tbpFlags: Integer): HRESULT; stdcall;
  end;

const
  TBPF_NOPROGRESS = 0;
  TBPF_INDETERMINATE = 1;
  TBPF_NORMAL = 2;
  TBPF_ERROR = 4;
  TBPF_PAUSED = 8;

procedure SetTaskbarProgress(Handle: HWND; Progress: Integer);
var
  TaskbarList: ITaskbarList3;
begin
  TaskbarList := CreateComObject(CLSID_TaskbarList) as ITaskbarList3;
  TaskbarList.HrInit;

  if Progress < 0 then
    TaskbarList.SetProgressState(Handle, TBPF_INDETERMINATE)
  else if Progress = 0 then
    TaskbarList.SetProgressState(Handle, TBPF_NOPROGRESS)
  else
  begin
    TaskbarList.SetProgressState(Handle, TBPF_NORMAL);
    TaskbarList.SetProgressValue(Handle, Progress, 100);
  end;
end;
```

### Jump Lists Windows 7+

```pascal
procedure AddJumpListTasks;
var
  JumpList: ICustomDestinationList;
  Tasks: IObjectCollection;
  Link: IShellLink;
  PropertyStore: IPropertyStore;
begin
  JumpList := CreateComObject(CLSID_DestinationList) as ICustomDestinationList;
  Tasks := CreateComObject(CLSID_EnumerableObjectCollection) as IObjectCollection;

  // Cr√©er une t√¢che
  Link := CreateComObject(CLSID_ShellLink) as IShellLink;
  Link.SetPath(PChar(Application.ExeName));
  Link.SetArguments('/newtask');
  Link.SetDescription('Nouvelle t√¢che');

  // Ajouter √† la collection
  Tasks.AddObject(Link);

  // Appliquer √† la Jump List
  JumpList.AddUserTasks(Tasks);
  JumpList.CommitList;
end;
```

## Bonnes pratiques pour les th√®mes Windows

### 1. Toujours tester sans th√®mes

```pascal
procedure TestWithoutThemes;
begin
  // Dans Lazarus, les styles visuels sont contr√¥l√©s par le manifeste
  // √† la compilation (pas de propri√©t√© UseVisualStyles comme en Delphi).
  // Pour tester sans th√®mes, v√©rifier ThemesEnabled au runtime :
  if ThemeServices.ThemesEnabled then
    WriteLn('Th√®mes actifs : tester le rendu th√©matique')
  else
    WriteLn('Th√®mes inactifs : tester le rendu classique');
end;
```

### 2. Respecter les pr√©f√©rences utilisateur

```pascal
function ShouldUseSystemColors: Boolean;
var
  Reg: TRegistry;
begin
  Result := True;  // Par d√©faut

  Reg := TRegistry.Create(KEY_READ);
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    if Reg.OpenKey('Control Panel\Accessibility', False) then
    begin
      if Reg.ValueExists('HighContrast') then
        Result := Reg.ReadInteger('HighContrast') <> 0;
    end;
  finally
    Reg.Free;
  end;
end;
```

### 3. G√©rer les versions de Windows

```pascal
function GetWindowsVersion: string;
var
  VersionInfo: TOSVersionInfo;
begin
  VersionInfo.dwOSVersionInfoSize := SizeOf(VersionInfo);
  GetVersionEx(VersionInfo);

  case VersionInfo.dwMajorVersion of
    10: if VersionInfo.dwBuildNumber >= 22000 then
          Result := 'Windows 11'
        else
          Result := 'Windows 10';
    6: case VersionInfo.dwMinorVersion of
         3: Result := 'Windows 8.1';
         2: Result := 'Windows 8';
         1: Result := 'Windows 7';
         0: Result := 'Windows Vista';
       end;
  else
    Result := 'Windows ancien';
  end;
end;

procedure AdaptToWindowsVersion;
var
  Ver: string;
begin
  // Note : case...of ne supporte que les types ordinaux en FPC
  Ver := GetWindowsVersion;
  if Ver = 'Windows 11' then
  begin
    // Coins arrondis, nouveaux effets
  end
  else if Ver = 'Windows 10' then
  begin
    // Design moderne, Dark mode
  end
  else if Ver = 'Windows 7' then
  begin
    // Aero Glass
  end;
end;
```

## Points cl√©s √† retenir

1. **Le manifeste est essentiel** : Sans lui, pas de th√®mes visuels modernes
2. **ThemeServices est votre ami** : Utilisez-le pour dessiner des √©l√©ments natifs
3. **Respectez le Dark Mode** : De plus en plus d'utilisateurs l'utilisent
4. **G√©rez les DPI** : Les √©crans haute r√©solution sont la norme
5. **Testez sur diff√©rentes versions** : Windows 7 √† 11 ont des diff√©rences significatives
6. **Fallback gracieux** : Pr√©voyez toujours le cas o√π les th√®mes ne sont pas disponibles
7. **Performance** : Le dessin th√©matique peut √™tre plus lent, optimisez si n√©cessaire

Les th√®mes Windows permettent √† votre application Lazarus de s'int√©grer parfaitement dans l'environnement Windows moderne tout en conservant sa portabilit√©. En ma√Ætrisant ces techniques, vous cr√©erez des applications qui ont l'air natives et professionnelles sur toutes les versions de Windows !

‚è≠Ô∏è [Th√®mes GTK/Qt sur Ubuntu](/04-framework-lcl/09.2-themes-gtk-qt-ubuntu.md)
