üîù Retour au [Sommaire](/SOMMAIRE.md)

# 7.2.2 Journalctl et logging

## Introduction : Les logs, vos yeux dans le syst√®me

Quand votre application FreePascal tourne comme un service systemd, elle devient invisible - pas de console, pas de fen√™tre. Comment savoir ce qui se passe ? Comment d√©boguer les probl√®mes ? La r√©ponse : **journald** et son outil **journalctl**. C'est le syst√®me de logging centralis√© de systemd, et il va devenir votre meilleur ami pour comprendre et maintenir vos services.

## Comprendre journald

### Qu'est-ce que journald ?

**journald** est le d√©mon de journalisation de systemd. Il collecte et stocke les logs de :
- Tous les services systemd
- Le noyau Linux
- Les applications qui √©crivent vers syslog
- Les messages de d√©marrage du syst√®me
- Stdout/stderr des services

### Avantages par rapport aux logs traditionnels

| Logs traditionnels | journald |
|-------------------|----------|
| Fichiers texte √©parpill√©s (`/var/log/*.log`) | Base de donn√©es centralis√©e |
| Format variable selon l'application | Format structur√© uniforme |
| Rotation manuelle n√©cessaire | Rotation automatique |
| Recherche avec grep | Requ√™tes puissantes avec filtres |
| Pas de m√©tadonn√©es | M√©tadonn√©es riches (PID, UID, etc.) |
| Peuvent √™tre perdus si disque plein | Gestion intelligente de l'espace |

### Architecture du syst√®me de logs

```
Votre Application FreePascal
         ‚Üì
    WriteLn() / Syslog
         ‚Üì
    systemd-journald
         ‚Üì
    Journal (binaire)
         ‚Üì
    journalctl (lecture)
```

## Comment vos applications FreePascal envoient des logs

### M√©thode 1 : Simple WriteLn (stdout/stderr)

La m√©thode la plus simple - tout ce que vous √©crivez sur stdout/stderr est captur√© :

```pascal
program MonService;

uses
  SysUtils;

procedure LogInfo(const Message: string);  
begin
  WriteLn('[INFO] ', FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', Message);
end;

procedure LogError(const Message: string);  
begin
  // stderr pour les erreurs
  WriteLn(ErrOutput, '[ERROR] ', FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', Message);
end;

procedure LogDebug(const Message: string);  
begin
  {$IFDEF DEBUG}
  WriteLn('[DEBUG] ', FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', Message);
  {$ENDIF}
end;

begin
  LogInfo('Service d√©marr√©');
  LogDebug('Initialisation de la configuration');

  try
    // Votre code
    LogInfo('Traitement en cours...');
  except
    on E: Exception do
      LogError('Exception: ' + E.Message);
  end;

  LogInfo('Service arr√™t√©');
end.
```

### M√©thode 2 : Utilisation de syslog

Pour des logs plus structur√©s avec niveaux de priorit√© :

```pascal
program ServiceAvecSyslog;

uses
  SysUtils, BaseUnix, Sockets;

const
  // Facilit√©s syslog
  LOG_KERN     = 0 shl 3;
  LOG_USER     = 1 shl 3;
  LOG_MAIL     = 2 shl 3;
  LOG_DAEMON   = 3 shl 3;
  LOG_AUTH     = 4 shl 3;
  LOG_SYSLOG   = 5 shl 3;
  LOG_LOCAL0   = 16 shl 3;

  // Priorit√©s syslog
  LOG_EMERG    = 0;  // Syst√®me inutilisable
  LOG_ALERT    = 1;  // Action imm√©diate requise
  LOG_CRIT     = 2;  // Conditions critiques
  LOG_ERR      = 3;  // Erreurs
  LOG_WARNING  = 4;  // Avertissements
  LOG_NOTICE   = 5;  // Normal mais significatif
  LOG_INFO     = 6;  // Informatif
  LOG_DEBUG    = 7;  // Debug

// Bindings syslog
procedure openlog(ident: PChar; option: Integer; facility: Integer); cdecl; external 'c';  
procedure syslog(priority: Integer; format: PChar; args: array of const); cdecl; external 'c';  
procedure closelog; cdecl; external 'c';

procedure InitLogging;  
begin
  // Ouvrir la connexion syslog
  openlog('monservice', 0, LOG_DAEMON);
end;

procedure LogMessage(Priority: Integer; const Message: string);  
begin
  syslog(Priority, '%s', [PChar(Message)]);
end;

procedure CloseLogging;  
begin
  closelog;
end;

begin
  InitLogging;

  LogMessage(LOG_INFO, 'Service d√©marr√©');
  LogMessage(LOG_DEBUG, 'Configuration charg√©e');

  try
    // Traitement
    LogMessage(LOG_INFO, 'Traitement des donn√©es');
  except
    on E: Exception do
      LogMessage(LOG_ERR, 'Erreur: ' + E.Message);
  end;

  LogMessage(LOG_INFO, 'Service arr√™t√©');
  CloseLogging;
end.
```

### M√©thode 3 : Journald natif via SD-JOURNAL

Pour une int√©gration maximale avec systemd :

```pascal
program ServiceJournaldNatif;

uses
  SysUtils, DynLibs;

type
  // Types pour les fonctions systemd
  TSDJournalPrint = function(priority: Integer; format: PChar): Integer; cdecl; varargs;
  TSDJournalSend = function(format: PChar): Integer; cdecl; varargs;

var
  LibSystemd: TLibHandle;
  sd_journal_print: TSDJournalPrint;
  sd_journal_send: TSDJournalSend;

procedure InitSystemdLogging;  
begin
  LibSystemd := LoadLibrary('libsystemd.so.0');
  if LibSystemd <> NilHandle then
  begin
    sd_journal_print := TSDJournalPrint(GetProcAddress(LibSystemd, 'sd_journal_print'));
    sd_journal_send := TSDJournalSend(GetProcAddress(LibSystemd, 'sd_journal_send'));
  end;
end;

procedure LogToJournal(Priority: Integer; const Message: string);  
begin
  if Assigned(sd_journal_print) then
    sd_journal_print(Priority, PChar(Message));
end;

procedure LogStructured(const Message: string; const Fields: array of string);  
var
  i: Integer;
  Args: string;
begin
  if not Assigned(sd_journal_send) then
    Exit;

  Args := 'MESSAGE=' + Message + #0;
  for i := 0 to High(Fields) do
    Args := Args + Fields[i] + #0;
  Args := Args + #0;

  sd_journal_send(PChar(Args));
end;

begin
  InitSystemdLogging;

  // Log simple avec priorit√©
  LogToJournal(6, 'Service d√©marr√©'); // LOG_INFO = 6

  // Log structur√© avec m√©tadonn√©es
  LogStructured('Connexion utilisateur', [
    'EVENT=user_login',
    'USER_ID=42',
    'USER_NAME=jean',
    'IP_ADDRESS=192.168.1.100',
    'SUCCESS=true'
  ]);

  if LibSystemd <> NilHandle then
    FreeLibrary(LibSystemd);
end.
```

### M√©thode 4 : Classe de logging compl√®te

Voici une classe r√©utilisable pour vos projets :

```pascal
unit ServiceLogger;

interface

uses
  SysUtils, Classes, SyncObjs;

type
  TLogLevel = (llDebug, llInfo, llWarning, llError, llCritical);

  TServiceLogger = class
  private
    FAppName: string;
    FLogLevel: TLogLevel;
    FLock: TCriticalSection;
    FIncludeTimestamp: Boolean;
    FUseColors: Boolean;

    function LevelToString(Level: TLogLevel): string;
    function LevelToColor(Level: TLogLevel): string;
    procedure WriteLog(Level: TLogLevel; const Message: string);
  public
    constructor Create(const AppName: string);
    destructor Destroy; override;

    procedure Debug(const Message: string);
    procedure Info(const Message: string);
    procedure Warning(const Message: string);
    procedure Error(const Message: string);
    procedure Critical(const Message: string);

    procedure LogException(E: Exception; const Context: string = '');
    procedure LogMetric(const Name: string; Value: Double);

    property LogLevel: TLogLevel read FLogLevel write FLogLevel;
    property IncludeTimestamp: Boolean read FIncludeTimestamp write FIncludeTimestamp;
  end;

var
  Logger: TServiceLogger;

implementation

constructor TServiceLogger.Create(const AppName: string);  
begin
  inherited Create;
  FAppName := AppName;
  FLogLevel := llInfo;
  FLock := TCriticalSection.Create;
  FIncludeTimestamp := True;
  FUseColors := False; // Pas de couleurs pour journald
end;

destructor TServiceLogger.Destroy;  
begin
  FLock.Free;
  inherited;
end;

function TServiceLogger.LevelToString(Level: TLogLevel): string;  
begin
  case Level of
    llDebug:    Result := 'DEBUG';
    llInfo:     Result := 'INFO';
    llWarning:  Result := 'WARN';
    llError:    Result := 'ERROR';
    llCritical: Result := 'CRIT';
  end;
end;

function TServiceLogger.LevelToColor(Level: TLogLevel): string;  
begin
  if not FUseColors then
  begin
    Result := '';
    Exit;
  end;

  case Level of
    llDebug:    Result := #27'[36m';  // Cyan
    llInfo:     Result := #27'[32m';  // Vert
    llWarning:  Result := #27'[33m';  // Jaune
    llError:    Result := #27'[31m';  // Rouge
    llCritical: Result := #27'[35m';  // Magenta
  end;
end;

procedure TServiceLogger.WriteLog(Level: TLogLevel; const Message: string);  
var
  LogLine: string;
  Timestamp: string;
begin
  if Level < FLogLevel then
    Exit;

  FLock.Enter;
  try
    LogLine := Format('[%s]', [LevelToString(Level)]);

    if FIncludeTimestamp then
    begin
      Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now);
      LogLine := LogLine + ' ' + Timestamp;
    end;

    LogLine := LogLine + ' - ' + Message;

    // Utiliser stderr pour les erreurs
    if Level >= llError then
    begin
      WriteLn(ErrOutput, LogLine);
      Flush(ErrOutput);
    end
    else
    begin
      WriteLn(LogLine);
      Flush(System.Output);
    end;
  finally
    FLock.Leave;
  end;
end;

procedure TServiceLogger.Debug(const Message: string);  
begin
  WriteLog(llDebug, Message);
end;

procedure TServiceLogger.Info(const Message: string);  
begin
  WriteLog(llInfo, Message);
end;

procedure TServiceLogger.Warning(const Message: string);  
begin
  WriteLog(llWarning, Message);
end;

procedure TServiceLogger.Error(const Message: string);  
begin
  WriteLog(llError, Message);
end;

procedure TServiceLogger.Critical(const Message: string);  
begin
  WriteLog(llCritical, Message);
end;

procedure TServiceLogger.LogException(E: Exception; const Context: string);  
var
  Msg: string;
begin
  Msg := Format('Exception %s: %s', [E.ClassName, E.Message]);
  if Context <> '' then
    Msg := Format('%s (Context: %s)', [Msg, Context]);
  Error(Msg);
end;

procedure TServiceLogger.LogMetric(const Name: string; Value: Double);  
begin
  Info(Format('METRIC: %s=%.2f', [Name, Value]));
end;

initialization
  Logger := TServiceLogger.Create('MonService');

finalization
  Logger.Free;

end.
```

## Utilisation de journalctl

### Commandes de base

```bash
# Voir tous les logs
journalctl

# Voir les logs d'un service sp√©cifique
journalctl -u monservice

# Suivre les logs en temps r√©el (comme tail -f)
journalctl -u monservice -f

# Voir les derni√®res N lignes
journalctl -u monservice -n 50

# Voir depuis le dernier boot
journalctl -u monservice -b

# Voir le boot pr√©c√©dent
journalctl -u monservice -b -1
```

### Filtrage par temps

```bash
# Depuis une date/heure sp√©cifique
journalctl -u monservice --since "2024-01-15 10:00:00"

# Jusqu'√† une date/heure
journalctl -u monservice --until "2024-01-15 18:00:00"

# P√©riode sp√©cifique
journalctl -u monservice --since "2024-01-15" --until "2024-01-16"

# Temps relatifs
journalctl -u monservice --since "1 hour ago"  
journalctl -u monservice --since "yesterday"  
journalctl -u monservice --since "2 days ago" --until "1 day ago"

# Les 10 derni√®res minutes
journalctl -u monservice --since "10 minutes ago"
```

### Filtrage par priorit√©

```bash
# Seulement les erreurs et plus grave
journalctl -u monservice -p err

# Niveaux de priorit√© disponibles :
# 0: emerg    - Syst√®me inutilisable
# 1: alert    - Action imm√©diate requise
# 2: crit     - Conditions critiques
# 3: err      - Erreurs
# 4: warning  - Avertissements
# 5: notice   - Normal mais significatif
# 6: info     - Informatif
# 7: debug    - Debug

# Plage de priorit√©s
journalctl -u monservice -p warning..err

# Tout sauf debug
journalctl -u monservice -p info
```

### Formats de sortie

```bash
# Format court (une ligne par entr√©e)
journalctl -u monservice -o short

# Format d√©taill√© avec toutes les m√©tadonn√©es
journalctl -u monservice -o verbose

# Format JSON (pour scripts)
journalctl -u monservice -o json

# Format JSON pretty-printed
journalctl -u monservice -o json-pretty

# Seulement les messages (sans m√©tadonn√©es)
journalctl -u monservice -o cat

# Avec explication des champs
journalctl -u monservice -o export
```

### Filtres avanc√©s

```bash
# Par PID
journalctl _PID=1234

# Par utilisateur
journalctl _UID=1000

# Par ex√©cutable
journalctl _EXE=/usr/local/bin/monservice

# Par identifiant syslog
journalctl -t monservice

# Combinaison de filtres
journalctl -u monservice _PID=1234 -p err

# Recherche de texte
journalctl -u monservice --grep="ERROR"  
journalctl -u monservice --grep="user.*login"

# Inverser la recherche
journalctl -u monservice --grep="ERROR" --invert-match
```

## Analyse et monitoring des logs

### Statistiques et m√©triques

```bash
# Espace utilis√© par les logs
journalctl --disk-usage

# V√©rifier l'int√©grit√© des logs
journalctl --verify

# Liste des boots enregistr√©s
journalctl --list-boots

# Statistiques par unit√©
systemctl status monservice

# Voir les champs disponibles
journalctl -u monservice -o verbose -n 1
```

### Surveillance en temps r√©el

```bash
# Suivre plusieurs services
journalctl -u monservice -u postgresql -f

# Suivre avec mise en √©vidence
journalctl -u monservice -f | grep --color=always ERROR

# Suivre avec notification
journalctl -u monservice -f | while read line; do
  if [[ $line == *"ERROR"* ]]; then
    notify-send "Erreur dans monservice" "$line"
  fi
done
```

### Export et archivage

```bash
# Exporter en texte
journalctl -u monservice > monservice.log

# Exporter en JSON pour analyse
journalctl -u monservice -o json > monservice.json

# Exporter une p√©riode
journalctl -u monservice --since "2024-01-01" --until "2024-01-31" > janvier.log

# Rotation manuelle
journalctl --vacuum-time=7d  # Garder 7 jours  
journalctl --vacuum-size=1G   # Limiter √† 1GB  
journalctl --vacuum-files=10  # Garder 10 fichiers
```

## Patterns de logging pour vos services

### Pattern 1 : Logs structur√©s avec contexte

```pascal
type
  TLogContext = class
  private
    FFields: TStringList;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Add(const Key, Value: string);
    procedure Clear;
    function ToString: string;
  end;

implementation

constructor TLogContext.Create;  
begin
  FFields := TStringList.Create;
  FFields.Delimiter := ' ';
end;

destructor TLogContext.Destroy;  
begin
  FFields.Free;
  inherited;
end;

procedure TLogContext.Add(const Key, Value: string);  
begin
  FFields.Add(Format('%s=%s', [Key, Value]));
end;

function TLogContext.ToString: string;  
begin
  Result := FFields.DelimitedText;
end;

// Utilisation
procedure ProcessRequest(RequestID: Integer);  
var
  Context: TLogContext;
begin
  Context := TLogContext.Create;
  try
    Context.Add('request_id', IntToStr(RequestID));
    Context.Add('timestamp', IntToStr(DateTimeToUnix(Now)));

    WriteLn(Format('[INFO] Processing request %s', [Context.ToString]));

    // Traitement...

    Context.Add('duration_ms', '150');
    Context.Add('status', 'success');
    WriteLn(Format('[INFO] Request completed %s', [Context.ToString]));
  finally
    Context.Free;
  end;
end;
```

### Pattern 2 : Logs de performance

```pascal
type
  TPerformanceLogger = class
  private
    FStartTime: TDateTime;
    FOperationName: string;
  public
    constructor Create(const OperationName: string);
    destructor Destroy; override;
    procedure LogCheckpoint(const Name: string);
    procedure LogMetric(const Name: string; Value: Double);
  end;

implementation

constructor TPerformanceLogger.Create(const OperationName: string);  
begin
  FOperationName := OperationName;
  FStartTime := Now;
  WriteLn(Format('[PERF] START operation=%s', [FOperationName]));
end;

destructor TPerformanceLogger.Destroy;  
var
  Duration: Integer;
begin
  Duration := MilliSecondsBetween(Now, FStartTime);
  WriteLn(Format('[PERF] END operation=%s duration_ms=%d',
    [FOperationName, Duration]));
  inherited;
end;

procedure TPerformanceLogger.LogCheckpoint(const Name: string);  
var
  Elapsed: Integer;
begin
  Elapsed := MilliSecondsBetween(Now, FStartTime);
  WriteLn(Format('[PERF] CHECKPOINT operation=%s checkpoint=%s elapsed_ms=%d',
    [FOperationName, Name, Elapsed]));
end;

procedure TPerformanceLogger.LogMetric(const Name: string; Value: Double);  
begin
  WriteLn(Format('[PERF] METRIC operation=%s %s=%.2f',
    [FOperationName, Name, Value]));
end;

// Utilisation
procedure ComplexOperation;  
var
  PerfLog: TPerformanceLogger;
begin
  PerfLog := TPerformanceLogger.Create('data_processing');
  try
    PerfLog.LogCheckpoint('load_data');
    // Charger les donn√©es...

    PerfLog.LogCheckpoint('validate');
    // Valider...

    PerfLog.LogMetric('records_processed', 1000);
    PerfLog.LogCheckpoint('save_results');
    // Sauvegarder...
  finally
    PerfLog.Free;
  end;
end;
```

### Pattern 3 : Logs d'audit

```pascal
type
  TAuditLogger = class
  private
    procedure LogAudit(const Action, Entity, User: string; Success: Boolean);
  public
    procedure LogLogin(const User, IPAddress: string; Success: Boolean);
    procedure LogDataAccess(const User, Resource: string; Allowed: Boolean);
    procedure LogDataModification(const User, Entity, OldValue, NewValue: string);
    procedure LogSystemChange(const User, Setting, Value: string);
  end;

implementation

procedure TAuditLogger.LogAudit(const Action, Entity, User: string; Success: Boolean);  
var
  Status: string;
begin
  if Success then
    Status := 'SUCCESS'
  else
    Status := 'FAILURE';

  WriteLn(Format('[AUDIT] action=%s entity=%s user=%s status=%s timestamp=%s',
    [Action, Entity, User, Status, FormatDateTime('yyyy-mm-dd"T"hh:nn:ss', Now)]));
end;

procedure TAuditLogger.LogLogin(const User, IPAddress: string; Success: Boolean);  
begin
  LogAudit('LOGIN', Format('ip=%s', [IPAddress]), User, Success);
end;

procedure TAuditLogger.LogDataAccess(const User, Resource: string; Allowed: Boolean);  
begin
  LogAudit('ACCESS', Resource, User, Allowed);
end;

procedure TAuditLogger.LogDataModification(const User, Entity, OldValue, NewValue: string);  
begin
  WriteLn(Format('[AUDIT] action=MODIFY entity=%s user=%s old_value=%s new_value=%s timestamp=%s',
    [Entity, User, OldValue, NewValue, FormatDateTime('yyyy-mm-dd"T"hh:nn:ss', Now)]));
end;
```

## Configuration de journald

### Fichier de configuration

√âditez `/etc/systemd/journald.conf` :

```ini
[Journal]
# Stockage
Storage=persistent          # auto, volatile, persistent, none  
Compress=yes               # Compression des logs  
Seal=yes                   # Scellement cryptographique

# Limites de taille
SystemMaxUse=1G            # Espace max pour les logs syst√®me  
SystemKeepFree=100M        # Espace libre minimum  
SystemMaxFileSize=100M     # Taille max d'un fichier  
RuntimeMaxUse=100M         # Espace max en m√©moire

# Rotation
MaxFileSec=1month          # Rotation mensuelle  
MaxRetentionSec=3month     # Conservation 3 mois

# Forwarding
ForwardToSyslog=no         # Transf√©rer vers syslog  
ForwardToKMsg=no           # Transf√©rer vers console kernel  
ForwardToConsole=no        # Transf√©rer vers console  
ForwardToWall=yes          # Messages critiques vers tous

# Limitation de d√©bit
RateLimitIntervalSec=30s  
RateLimitBurst=10000

# Niveau de log
MaxLevelStore=debug        # Niveau max stock√©  
MaxLevelSyslog=debug       # Niveau max vers syslog  
MaxLevelKMsg=notice        # Niveau max vers kernel  
MaxLevelConsole=info       # Niveau max vers console
```

Apr√®s modification :
```bash
sudo systemctl restart systemd-journald
```

### Configuration par service

Dans votre fichier `.service` :

```ini
[Service]
# Identifiant dans les logs
SyslogIdentifier=monservice

# Niveau de log maximum
LogLevelMax=info

# Limitation du d√©bit de logs
LogRateLimitIntervalSec=1s  
LogRateLimitBurst=100

# Pr√©fixe pour les logs
SyslogPrefix=MONAPP

# Facility syslog
SyslogFacility=daemon
```

## Int√©gration avec des outils externes

### Envoi vers un serveur syslog distant

```ini
# /etc/systemd/journald.conf
[Journal]
ForwardToSyslog=yes

# /etc/rsyslog.conf
*.* @@serveur-log.exemple.com:514  # TCP
*.* @serveur-log.exemple.com:514   # UDP
```

### Export vers Elasticsearch (ELK Stack)

Script d'export :
```bash
#!/bin/bash
# export-to-elastic.sh

journalctl -u monservice -o json --since "5 minutes ago" | \  
while read line; do
  curl -X POST "http://elasticsearch:9200/logs/_doc" \
    -H "Content-Type: application/json" \
    -d "$line"
done
```

### Int√©gration avec Prometheus

Exposer des m√©triques depuis les logs :

```pascal
procedure ExposeMetrics;  
var
  Output: TStringList;
  MetricsFile: TextFile;
begin
  Output := TStringList.Create;
  try
    // Format Prometheus
    Output.Add('# HELP app_requests_total Total requests');
    Output.Add('# TYPE app_requests_total counter');
    Output.Add(Format('app_requests_total %d', [TotalRequests]));

    Output.Add('# HELP app_errors_total Total errors');
    Output.Add('# TYPE app_errors_total counter');
    Output.Add(Format('app_errors_total %d', [TotalErrors]));

    // √âcrire dans un fichier pour node_exporter
    AssignFile(MetricsFile, '/var/lib/node_exporter/monservice.prom');
    Rewrite(MetricsFile);
    Write(MetricsFile, Output.Text);
    CloseFile(MetricsFile);

    // Log aussi pour journald
    WriteLn('[METRICS] requests_total=', TotalRequests, ' errors_total=', TotalErrors);
  finally
    Output.Free;
  end;
end;
```

## Bonnes pratiques de logging

### 1. Niveaux de log appropri√©s

```pascal
procedure ExempleNiveauxLogs;  
begin
  // DEBUG : Informations de d√©bogage d√©taill√©es
  WriteLn('[DEBUG] Entering function ProcessData with param=42');

  // INFO : √âv√©nements normaux importants
  WriteLn('[INFO] Service started successfully');

  // WARNING : Situations inhabituelles mais g√©r√©es
  WriteLn('[WARNING] Configuration file not found, using defaults');

  // ERROR : Erreurs qui n'emp√™chent pas le fonctionnement
  WriteLn(ErrOutput, '[ERROR] Failed to connect to cache server, using database directly');

  // CRITICAL : Erreurs qui compromettent le service
  WriteLn(ErrOutput, '[CRITICAL] Database connection lost, service cannot continue');
end;
```

### 2. Messages de log informatifs

```pascal
// MAUVAIS
WriteLn('Error');  
WriteLn('Failed');  
WriteLn('Problem with data');

// BON
WriteLn('[ERROR] Database connection failed: Connection timeout after 30s to host=db.example.com port=5432');  
WriteLn('[ERROR] Failed to process order #12345: Invalid credit card number');  
WriteLn('[ERROR] Data validation failed for user_id=42: email field is empty');
```

### 3. Logs structur√©s pour parsing

```pascal
procedure LogStructured;  
begin
  // Format cl√©=valeur pour parsing facile
  WriteLn(Format('[INFO] event=user_login user_id=%d username=%s ip=%s success=%s',
    [UserID, Username, IPAddress, BoolToStr(Success, True)]));

  // Format JSON pour outils modernes
  WriteLn(Format('{"level":"info","event":"user_login","user_id":%d,"username":"%s","ip":"%s","success":%s}',
    [UserID, Username, IPAddress, BoolToStr(Success, 'true', 'false')]));
end;
```

### 4. Rotation et maintenance

```bash
# Script de maintenance des logs
#!/bin/bash

# Nettoyer les vieux logs
journalctl --vacuum-time=30d

# Archiver les logs importants
journalctl -u monservice --since "30 days ago" --until "yesterday" | \
  gzip > /backup/logs/monservice-$(date +%Y%m).log.gz

# Alerter si trop de logs d'erreur
ERROR_COUNT=$(journalctl -u monservice -p err --since "1 hour ago" | wc -l)  
if [ $ERROR_COUNT -gt 100 ]; then
  echo "Alert: $ERROR_COUNT errors in last hour" | mail -s "Log Alert" admin@example.com
fi
```

### 5. S√©curit√© des logs

```pascal
procedure LogSecure(const Message: string);  
var
  SanitizedMsg: string;
  RegEx: TRegExpr;
begin
  // Nettoyer les donn√©es sensibles
  SanitizedMsg := Message;

  // Masquer les mots de passe
  SanitizedMsg := StringReplace(SanitizedMsg, Password, '***', [rfReplaceAll]);

  // Masquer les num√©ros de carte et emails avec TRegExpr (unit√© RegExpr)
  RegEx := TRegExpr.Create;
  try
    RegEx.Expression := '\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}';
    SanitizedMsg := RegEx.Replace(SanitizedMsg, 'XXXX-XXXX-XXXX-XXXX', True);

    RegEx.Expression := '([^@]{2})[^@]*@';
    SanitizedMsg := RegEx.Replace(SanitizedMsg, '$1***@', True);
  finally
    RegEx.Free;
  end;

  WriteLn(SanitizedMsg);
end;
```

### Classe compl√®te de sanitisation des logs

```pascal
unit SecureLogger;

interface

uses
  SysUtils, Classes, RegExpr;

type
  TSensitiveDataType = (sdtPassword, sdtCreditCard, sdtEmail, sdtPhone,
                        sdtSSN, sdtAPIKey, sdtIPAddress);
  TSensitiveDataTypes = set of TSensitiveDataType;

  TSecureLogger = class
  private
    FSensitivePatterns: TStringList;
    FMaskingEnabled: Boolean;

    function MaskCreditCard(const Text: string): string;
    function MaskEmail(const Text: string): string;
    function MaskPhone(const Text: string): string;
    function MaskSSN(const Text: string): string;
    function MaskAPIKey(const Text: string): string;
    function MaskIPAddress(const Text: string; PartialMask: Boolean = True): string;
    function MaskCustomPatterns(const Text: string): string;
  public
    constructor Create;
    destructor Destroy; override;

    procedure AddSensitivePattern(const Pattern, Replacement: string);
    function Sanitize(const Message: string; DataTypes: TSensitiveDataTypes = []): string;
    procedure LogSecure(const Level, Message: string);

    property MaskingEnabled: Boolean read FMaskingEnabled write FMaskingEnabled;
  end;

implementation

constructor TSecureLogger.Create;  
begin
  inherited;
  FSensitivePatterns := TStringList.Create;
  FMaskingEnabled := True;

  // Patterns par d√©faut pour donn√©es sensibles communes
  AddSensitivePattern('password\s*=\s*[''"]?[^''"}\s]+', 'password=***');
  AddSensitivePattern('api[_-]?key\s*=\s*[''"]?[^''"}\s]+', 'api_key=***');
  AddSensitivePattern('token\s*=\s*[''"]?[^''"}\s]+', 'token=***');
  AddSensitivePattern('secret\s*=\s*[''"]?[^''"}\s]+', 'secret=***');
end;

destructor TSecureLogger.Destroy;  
begin
  FSensitivePatterns.Free;
  inherited;
end;

procedure TSecureLogger.AddSensitivePattern(const Pattern, Replacement: string);  
begin
  FSensitivePatterns.Values[Pattern] := Replacement;
end;

function TSecureLogger.MaskCreditCard(const Text: string): string;  
var
  RegEx: TRegExpr;
begin
  Result := Text;
  RegEx := TRegExpr.Create;
  try
    // Visa, MasterCard, Amex, etc.
    RegEx.Expression := '\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{3,4}\b';
    Result := RegEx.Replace(Result, 'XXXX-XXXX-XXXX-XXXX', True);
  finally
    RegEx.Free;
  end;
end;

function TSecureLogger.MaskEmail(const Text: string): string;  
var
  RegEx: TRegExpr;
begin
  Result := Text;
  RegEx := TRegExpr.Create;
  try
    // Garder 2 premiers caract√®res et domaine
    RegEx.Expression := '\b([a-zA-Z0-9]{1,2})[a-zA-Z0-9._%+-]*@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\b';
    Result := RegEx.Replace(Result, '$1***@$2', True);
  finally
    RegEx.Free;
  end;
end;

function TSecureLogger.MaskPhone(const Text: string): string;  
var
  RegEx: TRegExpr;
begin
  Result := Text;
  RegEx := TRegExpr.Create;
  try
    // Formats internationaux
    RegEx.Expression := '\b\+?\d{1,3}[\s-]?\(?\d{1,4}\)?[\s-]?\d{1,4}[\s-]?\d{1,4}\b';
    Result := RegEx.Replace(Result, 'XXX-XXX-XXXX', True);
  finally
    RegEx.Free;
  end;
end;

function TSecureLogger.MaskSSN(const Text: string): string;  
var
  RegEx: TRegExpr;
begin
  Result := Text;
  RegEx := TRegExpr.Create;
  try
    // Format US SSN
    RegEx.Expression := '\b\d{3}-\d{2}-\d{4}\b';
    Result := RegEx.Replace(Result, 'XXX-XX-XXXX', True);
  finally
    RegEx.Free;
  end;
end;

function TSecureLogger.MaskAPIKey(const Text: string): string;  
var
  RegEx: TRegExpr;
begin
  Result := Text;
  RegEx := TRegExpr.Create;
  try
    // Cl√©s API typiques (hexad√©cimal, base64, UUID)
    RegEx.Expression := '\b[A-Fa-f0-9]{32,}\b|\b[A-Za-z0-9+/]{20,}={0,2}\b';
    Result := RegEx.Replace(Result, '[API_KEY_MASKED]', True);
  finally
    RegEx.Free;
  end;
end;

function TSecureLogger.MaskIPAddress(const Text: string; PartialMask: Boolean): string;  
var
  RegEx: TRegExpr;
begin
  Result := Text;
  RegEx := TRegExpr.Create;
  try
    if PartialMask then
    begin
      // Masquer derniers octets
      RegEx.Expression := '\b(\d{1,3}\.\d{1,3}\.)\d{1,3}\.\d{1,3}\b';
      Result := RegEx.Replace(Result, '$1XXX.XXX', True);
    end
    else
    begin
      // Masquer compl√®tement
      RegEx.Expression := '\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b';
      Result := RegEx.Replace(Result, 'XXX.XXX.XXX.XXX', True);
    end;
  finally
    RegEx.Free;
  end;
end;

function TSecureLogger.MaskCustomPatterns(const Text: string): string;  
var
  i: Integer;
  Pattern, Replacement: string;
  RegEx: TRegExpr;
begin
  Result := Text;
  RegEx := TRegExpr.Create;
  try
    for i := 0 to FSensitivePatterns.Count - 1 do
    begin
      Pattern := FSensitivePatterns.Names[i];
      Replacement := FSensitivePatterns.ValueFromIndex[i];

      RegEx.Expression := Pattern;
      Result := RegEx.Replace(Result, Replacement, True);
    end;
  finally
    RegEx.Free;
  end;
end;

function TSecureLogger.Sanitize(const Message: string;
  DataTypes: TSensitiveDataTypes): string;
begin
  if not FMaskingEnabled then
  begin
    Result := Message;
    Exit;
  end;

  Result := Message;

  // Si aucun type sp√©cifi√©, appliquer tous
  if DataTypes = [] then
    DataTypes := [sdtPassword, sdtCreditCard, sdtEmail, sdtPhone,
                  sdtSSN, sdtAPIKey, sdtIPAddress];

  // Appliquer les masques selon les types
  if sdtCreditCard in DataTypes then
    Result := MaskCreditCard(Result);
  if sdtEmail in DataTypes then
    Result := MaskEmail(Result);
  if sdtPhone in DataTypes then
    Result := MaskPhone(Result);
  if sdtSSN in DataTypes then
    Result := MaskSSN(Result);
  if sdtAPIKey in DataTypes then
    Result := MaskAPIKey(Result);
  if sdtIPAddress in DataTypes then
    Result := MaskIPAddress(Result);

  // Appliquer les patterns personnalis√©s
  Result := MaskCustomPatterns(Result);
end;

procedure TSecureLogger.LogSecure(const Level, Message: string);  
var
  SanitizedMsg: string;
begin
  SanitizedMsg := Sanitize(Message);
  WriteLn(Format('[%s] %s', [Level, SanitizedMsg]));
end;

end.
```

## D√©bogage avanc√© avec journalctl

### Analyse des crashes et core dumps

```bash
# Voir les crashes syst√®me
journalctl -p err -b

# Analyser un crash sp√©cifique
coredumpctl list  
coredumpctl info [PID]  
coredumpctl gdb [PID]

# Logs autour d'un crash
journalctl -u monservice --since "2024-01-15 14:00" --until "2024-01-15 14:10"
```

### Tracer les probl√®mes de d√©marrage

```bash
# Analyser le temps de d√©marrage
systemd-analyze  
systemd-analyze blame  
systemd-analyze critical-chain monservice

# Voir les messages de d√©marrage d√©taill√©s
journalctl -b -u monservice -o verbose

# Mode debug pour un service
systemctl edit monservice
# Ajouter dans [Service]:
# Environment="DEBUG=1"
# StandardOutput=journal+console
```

### Corr√©lation d'√©v√©nements

```pascal
type
  TCorrelationLogger = class
  private
    FCorrelationID: string;
    FSessionID: string;
    FRequestID: string;

    function GenerateID: string;
  public
    constructor Create;

    procedure StartRequest;
    procedure LogWithContext(const Level, Message: string);
    procedure EndRequest;

    property CorrelationID: string read FCorrelationID;
    property SessionID: string read FSessionID write FSessionID;
  end;

implementation

constructor TCorrelationLogger.Create;  
begin
  FSessionID := GenerateID;
  FCorrelationID := GenerateID;
end;

function TCorrelationLogger.GenerateID: string;  
var
  GUID: TGUID;
begin
  CreateGUID(GUID);
  Result := GUIDToString(GUID);
end;

procedure TCorrelationLogger.StartRequest;  
begin
  FRequestID := GenerateID;
  LogWithContext('INFO', 'Request started');
end;

procedure TCorrelationLogger.LogWithContext(const Level, Message: string);  
begin
  WriteLn(Format('[%s] %s correlation_id=%s session_id=%s request_id=%s',
    [Level, Message, FCorrelationID, FSessionID, FRequestID]));
end;

procedure TCorrelationLogger.EndRequest;  
begin
  LogWithContext('INFO', 'Request completed');
  FRequestID := '';
end;

// Recherche dans journalctl
// journalctl -u monservice --grep="correlation_id=12345"
```

## Monitoring et alertes bas√©s sur les logs

### Script de monitoring simple

```bash
#!/bin/bash
# monitor-logs.sh

SERVICE="monservice"  
ERROR_THRESHOLD=10  
WARNING_THRESHOLD=5  
CHECK_INTERVAL=300  # 5 minutes

while true; do
  # Compter les erreurs des 5 derni√®res minutes
  ERROR_COUNT=$(journalctl -u $SERVICE --since "5 minutes ago" -p err --no-pager | wc -l)
  WARNING_COUNT=$(journalctl -u $SERVICE --since "5 minutes ago" -p warning --no-pager | wc -l)

  if [ $ERROR_COUNT -gt $ERROR_THRESHOLD ]; then
    echo "ALERT: $ERROR_COUNT errors in last 5 minutes for $SERVICE" | \
      mail -s "[$HOSTNAME] Critical: $SERVICE errors" admin@example.com

    # Log les d√©tails
    journalctl -u $SERVICE --since "5 minutes ago" -p err | \
      mail -s "[$HOSTNAME] Error details for $SERVICE" admin@example.com
  elif [ $WARNING_COUNT -gt $WARNING_THRESHOLD ]; then
    echo "WARNING: $WARNING_COUNT warnings in last 5 minutes for $SERVICE" | \
      mail -s "[$HOSTNAME] Warning: $SERVICE issues" admin@example.com
  fi

  sleep $CHECK_INTERVAL
done
```

### Int√©gration avec Zabbix

```pascal
unit ZabbixLogger;

interface

uses
  SysUtils, Classes, Variants, fphttpclient, ssockets, fpjson, jsonparser;

type
  TZabbixLogger = class
  private
    FZabbixServer: string;
    FHostname: string;
    FHTTPClient: TFPHTTPClient;

    procedure SendMetric(const Key: string; Value: Variant);
  public
    constructor Create(const Server, Hostname: string);
    destructor Destroy; override;

    procedure LogMetric(const Key: string; Value: Integer); overload;
    procedure LogMetric(const Key: string; Value: Double); overload;
    procedure LogMetric(const Key: string; Value: string); overload;
    procedure LogError(const Message: string);
  end;

implementation

constructor TZabbixLogger.Create(const Server, Hostname: string);  
begin
  FZabbixServer := Server;
  FHostname := Hostname;
  FHTTPClient := TFPHTTPClient.Create(nil);
end;

destructor TZabbixLogger.Destroy;  
begin
  FHTTPClient.Free;
  inherited;
end;

procedure TZabbixLogger.SendMetric(const Key: string; Value: Variant);  
var
  JSONObj: TJSONObject;
  JSONArray: TJSONArray;
  DataObj: TJSONObject;
  Payload: string;
  RequestStream: TStringStream;
  ResponseStream: TStringStream;
begin
  JSONObj := TJSONObject.Create;
  try
    JSONObj.Add('request', 'sender data');

    JSONArray := TJSONArray.Create;
    DataObj := TJSONObject.Create;
    DataObj.Add('host', FHostname);
    DataObj.Add('key', Key);
    DataObj.Add('value', VarToStr(Value));
    DataObj.Add('clock', DateTimeToUnix(Now));
    JSONArray.Add(DataObj);

    JSONObj.Add('data', JSONArray);

    Payload := JSONObj.AsJSON;

    // Envoyer √† Zabbix via TFPHTTPClient
    RequestStream := TStringStream.Create(Payload);
    ResponseStream := TStringStream.Create('');
    try
      FHTTPClient.RequestBody := RequestStream;
      FHTTPClient.AddHeader('Content-Type', 'application/json');
      FHTTPClient.Post(FZabbixServer + '/api/v1/sender', ResponseStream);

      // Log aussi dans journald
      WriteLn(Format('[METRIC] %s=%s', [Key, VarToStr(Value)]));
    except
      on E: Exception do
        WriteLn(Format('[ERROR] Failed to send metric to Zabbix: %s', [E.Message]));
    end;
    RequestStream.Free;
    ResponseStream.Free;
  finally
    JSONObj.Free;
  end;
end;

procedure TZabbixLogger.LogMetric(const Key: string; Value: Integer);  
begin
  SendMetric(Key, Value);
end;

procedure TZabbixLogger.LogMetric(const Key: string; Value: Double);  
begin
  SendMetric(Key, Value);
end;

procedure TZabbixLogger.LogMetric(const Key: string; Value: string);  
begin
  SendMetric(Key, Value);
end;

procedure TZabbixLogger.LogError(const Message: string);  
begin
  SendMetric('application.errors', 1);
  WriteLn(StdErr, Format('[ERROR] %s', [Message]));
end;

end.
```

## Patterns avanc√©s de logging

### Pattern Circuit Breaker pour logs

```pascal
unit CircuitBreakerLogger;

interface

uses
  SysUtils, DateUtils;

type
  TCircuitState = (csOpen, csHalfOpen, csClosed);

  TCircuitBreakerLogger = class
  private
    FState: TCircuitState;
    FFailureCount: Integer;
    FFailureThreshold: Integer;
    FResetTimeout: Integer; // secondes
    FLastFailureTime: TDateTime;
    FHalfOpenRequests: Integer;
    FMaxHalfOpenRequests: Integer;

    procedure OpenCircuit;
    procedure CloseCircuit;
    procedure CheckCircuitState;
  public
    constructor Create(FailureThreshold: Integer = 5;
                      ResetTimeout: Integer = 60);

    procedure Log(const Level, Message: string);
    procedure LogSuccess(const Message: string);
    procedure LogFailure(const Message: string);

    property State: TCircuitState read FState;
  end;

implementation

constructor TCircuitBreakerLogger.Create(FailureThreshold, ResetTimeout: Integer);  
begin
  FState := csClosed;
  FFailureCount := 0;
  FFailureThreshold := FailureThreshold;
  FResetTimeout := ResetTimeout;
  FMaxHalfOpenRequests := 3;
  FHalfOpenRequests := 0;
end;

procedure TCircuitBreakerLogger.OpenCircuit;  
begin
  FState := csOpen;
  FLastFailureTime := Now;
  WriteLn('[CIRCUIT] Circuit opened due to excessive failures');
end;

procedure TCircuitBreakerLogger.CloseCircuit;  
begin
  FState := csClosed;
  FFailureCount := 0;
  FHalfOpenRequests := 0;
  WriteLn('[CIRCUIT] Circuit closed - normal operation resumed');
end;

procedure TCircuitBreakerLogger.CheckCircuitState;  
var
  SecondsSinceFailure: Integer;
begin
  if FState = csOpen then
  begin
    SecondsSinceFailure := SecondsBetween(Now, FLastFailureTime);
    if SecondsSinceFailure >= FResetTimeout then
    begin
      FState := csHalfOpen;
      FHalfOpenRequests := 0;
      WriteLn('[CIRCUIT] Circuit half-open - testing recovery');
    end;
  end;
end;

procedure TCircuitBreakerLogger.Log(const Level, Message: string);  
begin
  CheckCircuitState;

  case FState of
    csClosed:
      WriteLn(Format('[%s] %s', [Level, Message]));

    csHalfOpen:
      begin
        Inc(FHalfOpenRequests);
        WriteLn(Format('[%s][HALF-OPEN:%d/%d] %s',
          [Level, FHalfOpenRequests, FMaxHalfOpenRequests, Message]));

        if FHalfOpenRequests >= FMaxHalfOpenRequests then
          CloseCircuit;
      end;

    csOpen:
      // En circuit ouvert, on log minimalement
      WriteLn(Format('[%s][CIRCUIT-OPEN] Log suppressed', [Level]));
  end;
end;

procedure TCircuitBreakerLogger.LogSuccess(const Message: string);  
begin
  if FState = csHalfOpen then
    CloseCircuit;

  Log('INFO', Message);
end;

procedure TCircuitBreakerLogger.LogFailure(const Message: string);  
begin
  Inc(FFailureCount);

  if FFailureCount >= FFailureThreshold then
    OpenCircuit
  else if FState = csHalfOpen then
    OpenCircuit;

  Log('ERROR', Message);
end;

end.
```

### Pattern de log asynchrone

```pascal
unit AsyncLogger;

interface

uses
  SysUtils, Classes, SyncObjs;

type
  TLogMessage = record
    Timestamp: TDateTime;
    Level: string;
    Message: string;
  end;

  TAsyncLogger = class(TThread)
  private
    FQueue: TThreadList;
    FEvent: TEvent;
    FTerminating: Boolean;
    FMaxQueueSize: Integer;
    FDroppedMessages: Integer;

    procedure ProcessQueue;
    procedure WriteLog(const LogMsg: TLogMessage);
  protected
    procedure Execute; override;
  public
    constructor Create(MaxQueueSize: Integer = 10000);
    destructor Destroy; override;

    procedure Log(const Level, Message: string);
    procedure Flush;
    procedure Stop;

    property DroppedMessages: Integer read FDroppedMessages;
  end;

implementation

constructor TAsyncLogger.Create(MaxQueueSize: Integer);  
begin
  inherited Create(False);
  FQueue := TThreadList.Create;
  FEvent := TEvent.Create(nil, False, False, '');
  FMaxQueueSize := MaxQueueSize;
  FDroppedMessages := 0;
  FTerminating := False;
end;

destructor TAsyncLogger.Destroy;  
begin
  Stop;
  FQueue.Free;
  FEvent.Free;
  inherited;
end;

procedure TAsyncLogger.Execute;  
begin
  while not FTerminating do
  begin
    if FEvent.WaitFor(100) = wrSignaled then
      ProcessQueue;
  end;

  // Traiter les messages restants
  ProcessQueue;
end;

procedure TAsyncLogger.ProcessQueue;  
var
  List: TList;
  i: Integer;
  LogMsg: ^TLogMessage;
begin
  List := FQueue.LockList;
  try
    for i := 0 to List.Count - 1 do
    begin
      LogMsg := List[i];
      WriteLog(LogMsg^);
      Dispose(LogMsg);
    end;
    List.Clear;
  finally
    FQueue.UnlockList;
  end;
end;

procedure TAsyncLogger.WriteLog(const LogMsg: TLogMessage);  
begin
  WriteLn(Format('[%s] %s - %s',
    [FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', LogMsg.Timestamp),
     LogMsg.Level,
     LogMsg.Message]));
end;

procedure TAsyncLogger.Log(const Level, Message: string);  
var
  List: TList;
  LogMsg: ^TLogMessage;
begin
  List := FQueue.LockList;
  try
    if List.Count >= FMaxQueueSize then
    begin
      Inc(FDroppedMessages);
      Exit;
    end;

    New(LogMsg);
    LogMsg^.Timestamp := Now;
    LogMsg^.Level := Level;
    LogMsg^.Message := Message;
    List.Add(LogMsg);
  finally
    FQueue.UnlockList;
  end;

  FEvent.SetEvent;
end;

procedure TAsyncLogger.Flush;  
begin
  ProcessQueue;
end;

procedure TAsyncLogger.Stop;  
begin
  FTerminating := True;
  FEvent.SetEvent;
  WaitFor;
end;

end.
```

## R√©solution de probl√®mes courants

### Probl√®me : Logs manquants

```bash
# V√©rifier si le service √©crit des logs
systemctl status monservice  
ps aux | grep monservice

# V√©rifier la configuration de journald
journalctl --verify  
systemd-analyze verify monservice.service

# V√©rifier l'espace disque
df -h /var/log  
journalctl --disk-usage

# V√©rifier les permissions
ls -la /var/log/journal/
```

### Probl√®me : Trop de logs

```pascal
unit RateLimitedLogger;

interface

uses
  SysUtils, DateUtils;

type
  TRateLimitedLogger = class
  private
    FLastLogTime: TDateTime;
    FLogCount: Integer;
    FMaxLogsPerSecond: Integer;
    FSuppressedCount: Integer;
    FWindowStart: TDateTime;

    function CanLog: Boolean;
  public
    constructor Create(MaxLogsPerSecond: Integer = 10);

    procedure Log(const Level, Message: string);
    procedure ResetWindow;

    property SuppressedCount: Integer read FSuppressedCount;
  end;

implementation

constructor TRateLimitedLogger.Create(MaxLogsPerSecond: Integer);  
begin
  FMaxLogsPerSecond := MaxLogsPerSecond;
  FWindowStart := Now;
  FLogCount := 0;
  FSuppressedCount := 0;
end;

function TRateLimitedLogger.CanLog: Boolean;  
var
  ElapsedSeconds: Double;
begin
  ElapsedSeconds := SecondsBetween(Now, FWindowStart);

  if ElapsedSeconds >= 1 then
  begin
    // Nouvelle fen√™tre
    FWindowStart := Now;
    FLogCount := 0;

    if FSuppressedCount > 0 then
    begin
      WriteLn(Format('[INFO] %d messages suppressed in last window',
        [FSuppressedCount]));
      FSuppressedCount := 0;
    end;
  end;

  Result := FLogCount < FMaxLogsPerSecond;

  if Result then
    Inc(FLogCount)
  else
    Inc(FSuppressedCount);
end;

procedure TRateLimitedLogger.Log(const Level, Message: string);  
begin
  if CanLog then
    WriteLn(Format('[%s] %s', [Level, Message]));
end;

procedure TRateLimitedLogger.ResetWindow;  
begin
  FWindowStart := Now;
  FLogCount := 0;
  FSuppressedCount := 0;
end;

end.
```

### Probl√®me : Performance des logs

```ini
# Optimisation dans le service
[Service]
# Buffer les logs
StandardOutput=journal  
StandardError=journal  
LogLevelMax=info  # Pas de debug en production

# Limitation du d√©bit
LogRateLimitIntervalSec=30s  
LogRateLimitBurst=1000
```

## Check-list finale pour les logs

### ‚úÖ D√©veloppement

- [ ] Logs informatifs avec contexte
- [ ] Niveaux de log appropri√©s
- [ ] Pas de donn√©es sensibles dans les logs
- [ ] Gestion des erreurs logg√©es
- [ ] IDs de corr√©lation pour tracer les requ√™tes

### ‚úÖ D√©ploiement

- [ ] Configuration journald adapt√©e
- [ ] Rotation des logs configur√©e
- [ ] Monitoring des logs en place
- [ ] Alertes configur√©es
- [ ] Backup des logs critiques

### ‚úÖ Maintenance

- [ ] Documentation des formats de log
- [ ] Scripts d'analyse pr√™ts
- [ ] Proc√©dures de debug document√©es
- [ ] R√©tention des logs d√©finie
- [ ] Conformit√© RGPD v√©rifi√©e

## Conclusion

Ma√Ætriser journalctl et le logging est essentiel pour maintenir vos services FreePascal/Lazarus en production. Avec les techniques pr√©sent√©es, vous pouvez :

- Capturer efficacement les √©v√©nements de vos applications
- D√©boguer rapidement les probl√®mes
- Monitorer la sant√© de vos services
- Respecter la s√©curit√© et la vie priv√©e
- Int√©grer vos logs avec des outils d'analyse modernes

Les logs sont votre fen√™tre sur le comportement de vos applications en production. Investissez du temps pour bien les impl√©menter, vous vous remercierez lors du prochain incident √† r√©soudre !

Prochaine √©tape : Apprendre √† interagir avec D-Bus pour la communication inter-processus sous Linux.

‚è≠Ô∏è [D-Bus et communication inter-processus](/07-specificites-linux-ubuntu/03-dbus-communication-inter-processus.md)
