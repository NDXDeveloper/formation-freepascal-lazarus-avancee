üîù Retour au [Sommaire](/SOMMAIRE.md)

# 7.2.1 Cr√©ation d'unit√©s systemd

## Introduction : Votre premi√®re unit√© systemd

Maintenant que vous comprenez ce qu'est systemd, passons √† la pratique ! Dans cette section, vous apprendrez √† cr√©er des fichiers d'unit√© systemd pour vos applications FreePascal/Lazarus. √Ä la fin, votre application pourra d√©marrer automatiquement, √™tre g√©r√©e professionnellement et tourner de mani√®re fiable 24h/24.

## Anatomie compl√®te d'un fichier d'unit√©

### Structure g√©n√©rale

Un fichier d'unit√© systemd est un simple fichier texte avec l'extension `.service`. Il est divis√© en sections entre crochets, chaque section ayant un r√¥le sp√©cifique :

```ini
[Unit]
# M√©tadonn√©es et d√©pendances

[Service]
# Configuration du service lui-m√™me

[Install]
# Instructions d'installation/activation
```

Analysons chaque section en d√©tail.

### Section [Unit] : M√©tadonn√©es et relations

Cette section d√©crit votre service et ses relations avec d'autres unit√©s.

```ini
[Unit]
# Description lisible par les humains
Description=Mon Application de Gestion FreePascal

# Documentation (optionnel mais recommand√©)
Documentation=https://monsite.com/docs
Documentation=man:monapp(8)
Documentation=file:///usr/share/doc/monapp/README.md

# D√©pendances temporelles (ordre de d√©marrage)
After=network.target postgresql.service
Before=nginx.service

# D√©pendances fonctionnelles
Requires=postgresql.service        # Arr√™te si PostgreSQL s'arr√™te
Wants=redis.service                # Souhaite Redis mais continue sans
Requisite=network.target           # Ne d√©marre que si le r√©seau est pr√™t

# Conflits
Conflicts=monapp-old.service       # Ne peut pas tourner en m√™me temps

# Conditions de d√©marrage
ConditionPathExists=/etc/monapp/config.ini
ConditionFileNotEmpty=/etc/monapp/license.key
```

#### Directives principales de [Unit]

| Directive | Description | Exemple |
|-----------|-------------|---------|
| **Description** | Description courte du service | `Description=API REST MonApp` |
| **Documentation** | Liens vers la doc | `Documentation=https://...` |
| **After** | D√©marre apr√®s ces unit√©s | `After=network.target` |
| **Before** | D√©marre avant ces unit√©s | `Before=nginx.service` |
| **Requires** | D√©pendance stricte | `Requires=mysql.service` |
| **Wants** | D√©pendance souple | `Wants=redis.service` |
| **Conflicts** | Ne peut coexister avec | `Conflicts=apache2.service` |
| **ConditionPathExists** | D√©marre si le chemin existe | `ConditionPathExists=/data` |

### Section [Service] : Configuration du service

C'est le c≈ìur de votre unit√©, o√π vous d√©finissez comment votre application s'ex√©cute.

```ini
[Service]
# Type de service
Type=simple                         # simple, forking, oneshot, notify, dbus

# Commande principale
ExecStart=/usr/local/bin/monapp --config /etc/monapp/config.ini

# Commandes additionnelles (optionnel)
ExecStartPre=/usr/local/bin/monapp-check-config
ExecStartPost=/usr/bin/notify-send "MonApp d√©marr√©e"
ExecReload=/bin/kill -HUP $MAINPID
ExecStop=/usr/local/bin/monapp-shutdown
ExecStopPost=/usr/local/bin/monapp-cleanup

# Utilisateur et groupe
User=monapp
Group=monapp

# R√©pertoire de travail
WorkingDirectory=/var/lib/monapp

# Variables d'environnement
Environment="LOG_LEVEL=info"
Environment="DB_HOST=localhost"
EnvironmentFile=/etc/monapp/environment

# Red√©marrage automatique
Restart=always                      # no, always, on-success, on-failure
RestartSec=10                       # Attendre 10s avant red√©marrage
StartLimitBurst=5                   # Max 5 tentatives
StartLimitIntervalSec=600           # Dans une fen√™tre de 10 minutes

# Timeouts
TimeoutStartSec=90                  # Timeout pour le d√©marrage
TimeoutStopSec=30                   # Timeout pour l'arr√™t

# Gestion de la sortie
StandardOutput=journal               # ou file:/var/log/monapp.log
StandardError=journal                # ou inherit, null
SyslogIdentifier=monapp             # Nom dans les logs

# Limites de ressources
MemoryMax=512M
CPUQuota=50%
TasksMax=100

# S√©curit√© et isolation
PrivateTmp=true                     # /tmp isol√©
ProtectSystem=strict                # Syst√®me en lecture seule
ProtectHome=true                    # Pas d'acc√®s aux homes
NoNewPrivileges=true                # Pas d'√©l√©vation de privil√®ges
ReadWritePaths=/var/lib/monapp      # Exceptions en √©criture
```

#### Directives essentielles de [Service]

| Directive | Description | Valeurs communes |
|-----------|-------------|------------------|
| **Type** | Type de d√©marrage | `simple`, `forking`, `oneshot` |
| **ExecStart** | Commande principale | Chemin absolu obligatoire |
| **User/Group** | Identit√© d'ex√©cution | Nom d'utilisateur/groupe |
| **Restart** | Politique de red√©marrage | `always`, `on-failure` |
| **WorkingDirectory** | Dossier de travail | Chemin absolu |
| **Environment** | Variables d'environnement | `KEY=value` |

### Section [Install] : Activation du service

Cette section d√©termine comment et quand votre service est activ√©.

```ini
[Install]
# Target principal d'installation
WantedBy=multi-user.target         # D√©marrage en mode console
# ou
WantedBy=graphical.target          # D√©marrage avec interface graphique

# Alias (optionnel)
Alias=monapp.service
Alias=app-gestion.service

# D√©pendances inverses
RequiredBy=backup.service          # backup.service n√©cessite ce service
```

## Cr√©er votre premier fichier service

### √âtape 1 : Pr√©parer votre application FreePascal

Cr√©ons d'abord une application simple mais compl√®te :

```pascal
program MonPremierService;

uses
  SysUtils, DateUtils, BaseUnix, Classes;

var
  Terminated: Boolean = False;
  LogFile: TextFile;

procedure OpenLogFile;
var
  LogPath: string;
begin
  LogPath := '/var/log/monservice.log';
  AssignFile(LogFile, LogPath);
  if FileExists(LogPath) then
    Append(LogFile)
  else
    Rewrite(LogFile);
end;

procedure LogMessage(const Msg: string);
var
  Timestamp: string;
begin
  Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss', Now);
  WriteLn(LogFile, '[', Timestamp, '] ', Msg);
  Flush(LogFile);
  WriteLn('[', Timestamp, '] ', Msg); // Aussi vers stdout pour journald
end;

procedure SignalHandler(sig: longint); cdecl;
begin
  case sig of
    SIGTERM, SIGINT:
      begin
        LogMessage('Signal d''arr√™t re√ßu');
        Terminated := True;
      end;
    SIGHUP:
      LogMessage('Signal HUP re√ßu - rechargement configuration');
  end;
end;

procedure DoWork;
begin
  // Simulation de travail
  LogMessage('Traitement en cours...');
  Sleep(5000); // 5 secondes de "travail"
end;

begin
  // Configuration des signaux
  FpSignal(SIGTERM, @SignalHandler);
  FpSignal(SIGINT, @SignalHandler);
  FpSignal(SIGHUP, @SignalHandler);

  // Ouverture du fichier de log
  OpenLogFile;

  // Message de d√©marrage
  LogMessage('=== Service d√©marr√© ===');
  LogMessage('PID: ' + IntToStr(GetProcessID));

  // Boucle principale
  while not Terminated do
  begin
    try
      DoWork;
    except
      on E: Exception do
        LogMessage('Erreur: ' + E.Message);
    end;
  end;

  // Nettoyage
  LogMessage('=== Service arr√™t√© ===');
  CloseFile(LogFile);
end.
```

### √âtape 2 : Compiler et installer l'application

```bash
# Compiler l'application
fpc -O3 monpremierservice.pas

# Copier le binaire dans un emplacement syst√®me
sudo cp monpremierservice /usr/local/bin/
sudo chmod 755 /usr/local/bin/monpremierservice

# Cr√©er un utilisateur syst√®me pour le service
sudo useradd -r -s /bin/false -d /var/lib/monservice monservice

# Cr√©er les r√©pertoires n√©cessaires
sudo mkdir -p /var/lib/monservice
sudo mkdir -p /var/log
sudo touch /var/log/monservice.log
sudo chown monservice:monservice /var/log/monservice.log
```

### √âtape 3 : Cr√©er le fichier d'unit√©

Cr√©ez le fichier `/etc/systemd/system/monservice.service` :

```ini
[Unit]
Description=Mon Premier Service FreePascal
Documentation=https://mon-projet.com/docs
After=network.target

[Service]
Type=simple
User=monservice
Group=monservice
ExecStart=/usr/local/bin/monpremierservice
Restart=always
RestartSec=10

# Logs
StandardOutput=journal
StandardError=journal
SyslogIdentifier=monservice

# S√©curit√© basique
PrivateTmp=true
NoNewPrivileges=true

[Install]
WantedBy=multi-user.target
```

### √âtape 4 : Activer et d√©marrer le service

```bash
# Recharger la configuration systemd
sudo systemctl daemon-reload

# D√©marrer le service
sudo systemctl start monservice

# V√©rifier le statut
sudo systemctl status monservice

# Activer au d√©marrage
sudo systemctl enable monservice

# Voir les logs
sudo journalctl -u monservice -f
```

## Exemples de services pour diff√©rents cas d'usage

### Service Web/API REST

```ini
[Unit]
Description=API REST de Gestion des Stocks
Documentation=https://api.monentreprise.com/docs
After=network.target postgresql.service
Requires=postgresql.service

[Service]
Type=simple
User=api-stocks
Group=api-stocks

# Configuration
Environment="API_PORT=8080"
Environment="API_HOST=0.0.0.0"
Environment="DB_CONNECTION=postgresql://localhost/stocks"
EnvironmentFile=/etc/api-stocks/env

# Ex√©cution
WorkingDirectory=/opt/api-stocks
ExecStart=/opt/api-stocks/bin/api-server
ExecReload=/bin/kill -USR1 $MAINPID

# Red√©marrage
Restart=always
RestartSec=5
StartLimitBurst=3
StartLimitIntervalSec=60

# Logs
StandardOutput=append:/var/log/api-stocks/access.log
StandardError=append:/var/log/api-stocks/error.log

# Ressources
MemoryMax=1G
CPUQuota=200%

# S√©curit√©
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
NoNewPrivileges=true
ReadWritePaths=/var/lib/api-stocks /var/log/api-stocks

[Install]
WantedBy=multi-user.target
```

### Service de traitement batch

```ini
[Unit]
Description=Processeur de T√¢ches Batch
After=network.target redis.service

[Service]
Type=simple
User=batch-processor
Group=batch-processor

# Le service lit les t√¢ches depuis Redis
ExecStartPre=/usr/bin/redis-cli ping
ExecStart=/usr/local/bin/batch-processor --queue=tasks

# Arr√™t gracieux avec timeout g√©n√©reux
TimeoutStopSec=300
KillMode=mixed
KillSignal=SIGTERM

# Red√©marrage uniquement sur √©chec
Restart=on-failure
RestartSec=30

# Environnement
Environment="REDIS_HOST=localhost"
Environment="REDIS_PORT=6379"
Environment="WORKER_THREADS=4"

# Nice level pour basse priorit√©
Nice=10

# Isolation
PrivateDevices=true
ProtectKernelTunables=true
ProtectControlGroups=true

[Install]
WantedBy=multi-user.target
```

### Service de monitoring

```ini
[Unit]
Description=Agent de Monitoring Syst√®me
Documentation=man:system-monitor(1)
After=network.target

[Service]
Type=notify
NotifyAccess=main
User=monitor
Group=monitor

ExecStart=/usr/local/bin/system-monitor --interval=60
ExecReload=/bin/kill -HUP $MAINPID

# Red√©marrage important pour un moniteur
Restart=always
RestartSec=10

# Permissions pour lire les m√©triques syst√®me
SupplementaryGroups=systemd-journal
CapabilityBoundingSet=CAP_DAC_READ_SEARCH CAP_SYS_PTRACE

# Peut avoir besoin d'acc√©der √† /proc et /sys
ProtectSystem=false
PrivateTmp=true

# Logs structur√©s
StandardOutput=journal
StandardError=journal
SyslogIdentifier=system-monitor

[Install]
WantedBy=multi-user.target
```

### Service avec timer (t√¢che planifi√©e)

Fichier `backup.service` :
```ini
[Unit]
Description=Sauvegarde de la Base de Donn√©es
After=postgresql.service
Requires=postgresql.service

[Service]
Type=oneshot
User=backup
Group=backup

# Variables pour le script
Environment="BACKUP_DIR=/var/backups/postgres"
Environment="DB_NAME=production"

# Le script de backup
ExecStart=/usr/local/bin/db-backup.sh

# Logs
StandardOutput=journal
StandardError=journal

# Timeout g√©n√©reux pour les grosses bases
TimeoutStartSec=3600

[Install]
WantedBy=multi-user.target
```

Fichier `backup.timer` associ√© :
```ini
[Unit]
Description=Planification de sauvegarde quotidienne
Requires=backup.service

[Timer]
# Tous les jours √† 2h du matin
OnCalendar=daily
AccuracySec=1h
Persistent=true

[Install]
WantedBy=timers.target
```

## Techniques avanc√©es

### Utilisation de templates

Les templates permettent de cr√©er plusieurs instances d'un m√™me service. Cr√©ez un fichier `worker@.service` :

```ini
[Unit]
Description=Worker de traitement - Instance %i
After=network.target

[Service]
Type=simple
User=worker
Group=worker

# %i est remplac√© par l'identifiant d'instance
ExecStart=/usr/local/bin/worker --id=%i --port=808%i
Environment="WORKER_ID=%i"

Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

Utilisation :
```bash
# D√©marrer 3 instances
sudo systemctl start worker@1
sudo systemctl start worker@2
sudo systemctl start worker@3

# Ou activer au d√©marrage
sudo systemctl enable worker@{1..3}
```

### Notification de statut (Type=notify)

Pour une int√©gration plus pouss√©e, votre application peut notifier systemd :

```pascal
program ServiceWithNotify;

uses
  SysUtils, BaseUnix, DynLibs;

type
  TSDNotify = function(unset_environment: Integer; state: PChar): Integer; cdecl;

var
  SDNotify: TSDNotify;
  LibHandle: TLibHandle;

procedure NotifySystemd(const State: string);
begin
  if Assigned(SDNotify) then
    SDNotify(0, PChar(State));
end;

begin
  // Charger la biblioth√®que systemd
  LibHandle := LoadLibrary('libsystemd.so.0');
  if LibHandle <> NilHandle then
  begin
    SDNotify := TSDNotify(GetProcAddress(LibHandle, 'sd_notify'));

    // Notifier que le service est pr√™t
    NotifySystemd('READY=1');

    // Pendant l'ex√©cution, envoyer des statuts
    NotifySystemd('STATUS=Traitement des requ√™tes');

    // Heartbeat p√©riodique
    NotifySystemd('WATCHDOG=1');
  end;

  // Votre code de service...
end.
```

### D√©pendances conditionnelles

```ini
[Unit]
# Ne d√©marre que si le fichier de licence existe
ConditionPathExists=/etc/monapp/license.key

# Ne d√©marre que si on a assez de m√©moire (512M)
ConditionMemory=>512M

# Ne d√©marre que si on est sur architecture 64 bits
ConditionArchitecture=x86-64

# Ne d√©marre que si le noyau est r√©cent
ConditionKernelVersion=>=5.0

# Ne d√©marre pas en virtualisation
ConditionVirtualization=no
```

### S√©curit√© renforc√©e

Pour un service expos√© √† Internet :

```ini
[Service]
# Isolation r√©seau
PrivateNetwork=false
RestrictAddressFamilies=AF_INET AF_INET6
IPAddressDeny=any
IPAddressAllow=192.168.1.0/24 10.0.0.0/8

# Protection syst√®me
ProtectSystem=strict
ProtectHome=true
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
PrivateTmp=true
PrivateDevices=true

# Syst√®me de fichiers
ReadOnlyPaths=/
ReadWritePaths=/var/lib/monapp /var/log/monapp
TemporaryFileSystem=/var:ro
BindReadOnlyPaths=/etc/monapp

# Capacit√©s
NoNewPrivileges=true
CapabilityBoundingSet=
AmbientCapabilities=

# Appels syst√®me
SystemCallFilter=@system-service
SystemCallErrorNumber=EPERM
SystemCallArchitectures=native

# Namespaces
PrivateUsers=true
RemoveIPC=true

# Montages
MountFlags=slave
```

## Gestion des logs

### Configuration des logs dans le service

```ini
[Service]
# Vers journald (par d√©faut)
StandardOutput=journal
StandardError=journal

# Vers un fichier
StandardOutput=file:/var/log/monapp.log
StandardError=file:/var/log/monapp-error.log

# Append au lieu d'√©craser
StandardOutput=append:/var/log/monapp.log

# Vers syslog avec identifiant
StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=monapp
SyslogFacility=local0
SyslogLevel=info

# Limiter la verbosit√©
LogLevelMax=info
LogRateLimitIntervalSec=30s
LogRateLimitBurst=1000
```

### Rotation des logs avec logrotate

Cr√©ez `/etc/logrotate.d/monapp` :

```
/var/log/monapp/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 0640 monapp monapp
    sharedscripts
    postrotate
        systemctl reload monapp || true
    endscript
}
```

## D√©bogage et diagnostic

### Commandes de diagnostic

```bash
# V√©rifier la syntaxe d'un fichier service
systemd-analyze verify /etc/systemd/system/monservice.service

# Voir pourquoi un service ne d√©marre pas
systemctl status monservice.service -l
journalctl -xe -u monservice

# Analyser les d√©pendances
systemctl list-dependencies monservice
systemd-analyze dot monservice | dot -Tpng > dependencies.png

# Voir l'environnement d'ex√©cution
systemctl show-environment
systemctl show monservice

# Mode debug
SYSTEMD_LOG_LEVEL=debug systemctl start monservice
```

### Messages d'erreur courants

| Erreur | Cause | Solution |
|--------|-------|----------|
| `code=exited, status=203/EXEC` | Binaire non trouv√© | V√©rifier le chemin dans ExecStart |
| `code=exited, status=217/USER` | Utilisateur n'existe pas | Cr√©er l'utilisateur syst√®me |
| `Failed to parse service` | Erreur de syntaxe | V√©rifier le fichier .service |
| `Start request repeated too quickly` | Boucle de crash | V√©rifier RestartSec et les logs |
| `Timed out` | D√©marrage trop long | Augmenter TimeoutStartSec |

## Bonnes pratiques

### 1. Toujours utiliser des chemins absolus

```ini
# BON
ExecStart=/usr/local/bin/monapp

# MAUVAIS
ExecStart=monapp
ExecStart=./bin/monapp
```

### 2. Cr√©er un utilisateur d√©di√©

```bash
# Utilisateur syst√®me sans shell
sudo useradd -r -s /bin/false -d /var/lib/monapp monapp
```

### 3. Documenter votre service

```ini
[Unit]
Description=Service de gestion des commandes
Documentation=https://docs.monapp.com
Documentation=man:monapp(8)
Documentation=file:///usr/share/doc/monapp/README.md
```

### 4. G√©rer les √©checs intelligemment

```ini
[Service]
# Red√©marrer sur √©chec, pas sur arr√™t normal
Restart=on-failure
RestartSec=10

# Limiter les tentatives
StartLimitBurst=5
StartLimitIntervalSec=600

# Notifier l'admin
ExecStopPost=/usr/local/bin/notify-admin.sh
```

### 5. Logs structur√©s

Dans votre code FreePascal :
```pascal
procedure LogStructured(Level, Message: string; Fields: TStringList);
var
  i: Integer;
  Output: string;
begin
  Output := Format('<%s> %s', [Level, Message]);
  for i := 0 to Fields.Count - 1 do
    Output := Output + ' ' + Fields[i];
  WriteLn(Output);
end;

// Utilisation
var
  Fields: TStringList;
begin
  Fields := TStringList.Create;
  try
    Fields.Add('user_id=42');
    Fields.Add('action=login');
    Fields.Add('ip=192.168.1.100');
    LogStructured('INFO', 'User login', Fields);
  finally
    Fields.Free;
  end;
end;
```

## Migration depuis d'autres syst√®mes

### Depuis un script init.d

Si vous avez un ancien script `/etc/init.d/monapp` :

```bash
#!/bin/sh
case "$1" in
  start)
    /usr/local/bin/monapp &
    ;;
  stop)
    killall monapp
    ;;
esac
```

√âquivalent systemd :
```ini
[Service]
Type=forking
ExecStart=/usr/local/bin/monapp
ExecStop=/usr/bin/killall monapp
```

### Depuis cron

Crontab :
```
0 2 * * * /usr/local/bin/backup.sh
```

√âquivalent avec timer systemd :
```ini
# backup.timer
[Timer]
OnCalendar=daily
OnCalendar=*-*-* 02:00:00
```

### Depuis supervisor

Configuration supervisor :
```ini
[program:monapp]
command=/usr/local/bin/monapp
autostart=true
autorestart=true
user=monapp
```

√âquivalent systemd :
```ini
[Service]
ExecStart=/usr/local/bin/monapp
Restart=always
User=monapp

[Install]
WantedBy=multi-user.target
```

## Conclusion

Vous ma√Ætrisez maintenant la cr√©ation d'unit√©s systemd pour vos applications FreePascal/Lazarus ! Vous pouvez cr√©er des services robustes, s√©curis√©s et faciles √† g√©rer. N'oubliez pas :

- Commencez simple, ajoutez des fonctionnalit√©s progressivement
- Testez toujours avec `systemd-analyze verify`
- Utilisez `journalctl` pour d√©boguer
- Documentez vos services pour votre √©quipe
- Appliquez le principe du moindre privil√®ge

Vos applications FreePascal sont maintenant pr√™tes √† tourner 24/7 comme de vrais services syst√®me professionnels !

‚è≠Ô∏è [Journalctl et logging](/07-specificites-linux-ubuntu/02.2-journalctl-logging.md)
