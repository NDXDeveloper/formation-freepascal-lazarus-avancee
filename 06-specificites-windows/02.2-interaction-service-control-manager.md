üîù Retour au [Sommaire](/SOMMAIRE.md)

# Interaction avec le Service Control Manager (SCM)

## Introduction : Qu'est-ce que le Service Control Manager ?

Le Service Control Manager (SCM) est le chef d'orchestre de tous les services Windows. C'est un composant syst√®me qui g√®re le cycle de vie de tous les services : il les d√©marre, les arr√™te, les surveille et g√®re leurs interactions. Comprendre comment votre service communique avec le SCM est essentiel pour cr√©er des services robustes.

### Analogie simple

Imaginez le SCM comme le directeur d'un h√¥tel qui g√®re tout le personnel de service :
- Il **embauche** les employ√©s (installe les services)
- Il leur dit **quand commencer** leur travail (d√©marre les services)
- Il **surveille** qu'ils travaillent correctement
- Il leur demande de **faire une pause** si n√©cessaire
- Il leur dit quand **arr√™ter** leur service
- Il peut les **licencier** (d√©sinstaller les services)
- Il **communique** avec eux via des messages standardis√©s

## Architecture de la communication SCM-Service

### Le flux de communication

```
     Service Control Manager (SCM)
              |
              | Messages de contr√¥le
              | (Start, Stop, Pause, etc.)
              ‚Üì
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ   Votre Service      ‚îÇ
     ‚îÇ                      ‚îÇ
     ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
     ‚îÇ  ‚îÇ Handler SCM   ‚îÇ  ‚îÇ‚îÄ‚îÄ‚Üí R√©ponses d'√©tat
     ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ    (Running, Stopped, etc.)
     ‚îÇ          ‚Üì          ‚îÇ
     ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
     ‚îÇ  ‚îÇ Logique m√©tier‚îÇ  ‚îÇ
     ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Les acteurs principaux

1. **Le SCM (services.exe)** : Le processus syst√®me qui g√®re tous les services
2. **Votre service** : Votre application qui s'enregistre aupr√®s du SCM
3. **Le handler de contr√¥le** : La fonction dans votre service qui re√ßoit les commandes du SCM
4. **La table de dispatch** : La structure qui lie votre service au SCM

## Les messages du SCM

Le SCM envoie diff√©rents types de messages √† votre service. Voici les principaux :

### Messages de contr√¥le de base

```pascal
const
  // Messages principaux
  SERVICE_CONTROL_STOP           = $00000001;  // Arr√™ter le service
  SERVICE_CONTROL_PAUSE          = $00000002;  // Mettre en pause
  SERVICE_CONTROL_CONTINUE       = $00000003;  // Reprendre apr√®s pause
  SERVICE_CONTROL_INTERROGATE    = $00000004;  // Demander l'√©tat actuel
  SERVICE_CONTROL_SHUTDOWN       = $00000005;  // Windows s'arr√™te

  // Messages √©tendus
  SERVICE_CONTROL_PARAMCHANGE    = $00000006;  // Param√®tres chang√©s
  SERVICE_CONTROL_NETBINDADD     = $00000007;  // Binding r√©seau ajout√©
  SERVICE_CONTROL_NETBINDREMOVE  = $00000008;  // Binding r√©seau retir√©
  SERVICE_CONTROL_NETBINDENABLE  = $00000009;  // Binding r√©seau activ√©
  SERVICE_CONTROL_NETBINDDISABLE = $0000000A;  // Binding r√©seau d√©sactiv√©
```

### Messages de gestion d'alimentation

```pascal
const
  SERVICE_CONTROL_POWEREVENT     = $0000000D;  // √âv√©nement d'alimentation

  // Sous-types d'√©v√©nements d'alimentation
  PBT_APMSUSPEND                = $0004;  // Syst√®me entre en veille
  PBT_APMRESUMESUSPEND          = $0007;  // Syst√®me sort de veille
  PBT_APMBATTERYLOW             = $0009;  // Batterie faible
  PBT_APMPOWERSTATUSCHANGE      = $000A;  // Changement alimentation AC/Batterie
```

### Messages de session utilisateur

```pascal
const
  SERVICE_CONTROL_SESSIONCHANGE  = $0000000E;  // Changement de session

  // Types de changements de session
  WTS_SESSION_LOGON     = $05;  // Un utilisateur se connecte
  WTS_SESSION_LOGOFF    = $06;  // Un utilisateur se d√©connecte
  WTS_SESSION_LOCK      = $07;  // Session verrouill√©e
  WTS_SESSION_UNLOCK    = $08;  // Session d√©verrouill√©e
```

## Impl√©mentation de base avec FreePascal

### Structure minimale d'interaction

```pascal
unit ServiceSCMHandler;

{$mode objfpc}{$H+}

interface

uses
  Windows, Classes, SysUtils;

type
  TServiceController = class
  private
    FServiceStatus: SERVICE_STATUS;
    FStatusHandle: SERVICE_STATUS_HANDLE;
    FServiceName: string;

    procedure UpdateServiceStatus(State: DWORD);
    function RegisterWithSCM: Boolean;

  public
    constructor Create(const ServiceName: string);
    destructor Destroy; override;

    procedure ReportStatus(CurrentState, ExitCode, WaitHint: DWORD);
    procedure HandleControlMessage(ControlCode: DWORD);
  end;

implementation

constructor TServiceController.Create(const ServiceName: string);
begin
  inherited Create;
  FServiceName := ServiceName;

  // Initialiser la structure de statut
  FillChar(FServiceStatus, SizeOf(FServiceStatus), 0);
  FServiceStatus.dwServiceType := SERVICE_WIN32_OWN_PROCESS;
  FServiceStatus.dwCurrentState := SERVICE_START_PENDING;
  FServiceStatus.dwControlsAccepted := SERVICE_ACCEPT_STOP or
                                       SERVICE_ACCEPT_PAUSE_CONTINUE;

  RegisterWithSCM;
end;

function TServiceController.RegisterWithSCM: Boolean;
begin
  // Enregistrer le handler aupr√®s du SCM
  FStatusHandle := RegisterServiceCtrlHandler(
    PChar(FServiceName),
    @ServiceControlHandler
  );

  Result := FStatusHandle <> 0;

  if Result then
    WriteLn('Service enregistr√© avec succ√®s aupr√®s du SCM')
  else
    WriteLn('Erreur lors de l''enregistrement : ', GetLastError);
end;

procedure TServiceController.ReportStatus(CurrentState, ExitCode, WaitHint: DWORD);
begin
  FServiceStatus.dwCurrentState := CurrentState;
  FServiceStatus.dwWin32ExitCode := ExitCode;
  FServiceStatus.dwWaitHint := WaitHint;

  // Incr√©menter le checkpoint pour montrer la progression
  if CurrentState = SERVICE_START_PENDING then
    Inc(FServiceStatus.dwCheckPoint)
  else
    FServiceStatus.dwCheckPoint := 0;

  // Envoyer le statut au SCM
  if not SetServiceStatus(FStatusHandle, @FServiceStatus) then
    WriteLn('Erreur lors de la mise √† jour du statut : ', GetLastError);
end;

procedure TServiceController.HandleControlMessage(ControlCode: DWORD);
begin
  case ControlCode of
    SERVICE_CONTROL_STOP:
      begin
        WriteLn('SCM demande l''arr√™t du service');
        ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 3000);
        // Effectuer l'arr√™t
        // ...
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_PAUSE:
      begin
        WriteLn('SCM demande la pause du service');
        ReportStatus(SERVICE_PAUSE_PENDING, NO_ERROR, 1000);
        // Effectuer la pause
        // ...
        ReportStatus(SERVICE_PAUSED, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_CONTINUE:
      begin
        WriteLn('SCM demande la reprise du service');
        ReportStatus(SERVICE_CONTINUE_PENDING, NO_ERROR, 1000);
        // Effectuer la reprise
        // ...
        ReportStatus(SERVICE_RUNNING, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_INTERROGATE:
      begin
        // Le SCM demande juste l'√©tat actuel
        ReportStatus(FServiceStatus.dwCurrentState, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_SHUTDOWN:
      begin
        WriteLn('Windows s''arr√™te - arr√™t rapide du service');
        // Arr√™t d'urgence - sauvegarder rapidement l'√©tat
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;
  end;
end;
```

## √âtats du service et transitions

### Les √©tats possibles

Un service peut √™tre dans l'un de ces √©tats :

```pascal
const
  SERVICE_STOPPED          = $00000001;  // Arr√™t√©
  SERVICE_START_PENDING    = $00000002;  // D√©marrage en cours
  SERVICE_STOP_PENDING     = $00000003;  // Arr√™t en cours
  SERVICE_RUNNING          = $00000004;  // En cours d'ex√©cution
  SERVICE_CONTINUE_PENDING = $00000005;  // Reprise en cours
  SERVICE_PAUSE_PENDING    = $00000006;  // Pause en cours
  SERVICE_PAUSED           = $00000007;  // En pause
```

### Diagramme des transitions d'√©tat

```
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   STOPPED   ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ Start
                           ‚Üì
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ START_PENDING    ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                           ‚Üì
        Pause      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      Stop
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   RUNNING    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚Üì              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PAUSE_PENDING  ‚îÇ                      ‚îÇ STOP_PENDING ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì                                      ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         Continue          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ PAUSED  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí         ‚îÇ STOPPED ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    CONTINUE_PENDING       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Gestion correcte des transitions

```pascal
type
  TServiceStateManager = class
  private
    FCurrentState: DWORD;
    FStatusHandle: SERVICE_STATUS_HANDLE;
    FLogger: TLogger;
    FCriticalSection: TCriticalSection;

    procedure SetState(NewState: DWORD);
    function ValidateTransition(FromState, ToState: DWORD): Boolean;

  public
    constructor Create(StatusHandle: SERVICE_STATUS_HANDLE);
    destructor Destroy; override;

    procedure TransitionTo(NewState: DWORD);
    property CurrentState: DWORD read FCurrentState;
  end;

implementation

procedure TServiceStateManager.TransitionTo(NewState: DWORD);
begin
  FCriticalSection.Enter;
  try
    // V√©rifier que la transition est valide
    if not ValidateTransition(FCurrentState, NewState) then
    begin
      FLogger.LogError(Format('Transition invalide : %s -> %s',
        [StateToString(FCurrentState), StateToString(NewState)]));
      Exit;
    end;

    FLogger.Log(Format('Transition d''√©tat : %s -> %s',
      [StateToString(FCurrentState), StateToString(NewState)]));

    // Effectuer la transition
    SetState(NewState);

    // Notifier le SCM
    ReportStatusToSCM(NewState);

  finally
    FCriticalSection.Leave;
  end;
end;

function TServiceStateManager.ValidateTransition(FromState, ToState: DWORD): Boolean;
begin
  Result := False;

  case FromState of
    SERVICE_STOPPED:
      Result := (ToState = SERVICE_START_PENDING);

    SERVICE_START_PENDING:
      Result := (ToState in [SERVICE_RUNNING, SERVICE_STOPPED]);

    SERVICE_RUNNING:
      Result := (ToState in [SERVICE_PAUSE_PENDING, SERVICE_STOP_PENDING]);

    SERVICE_PAUSE_PENDING:
      Result := (ToState in [SERVICE_PAUSED, SERVICE_RUNNING]);

    SERVICE_PAUSED:
      Result := (ToState in [SERVICE_CONTINUE_PENDING, SERVICE_STOP_PENDING]);

    SERVICE_CONTINUE_PENDING:
      Result := (ToState in [SERVICE_RUNNING, SERVICE_PAUSED]);

    SERVICE_STOP_PENDING:
      Result := (ToState = SERVICE_STOPPED);
  end;
end;
```

## Communication avanc√©e avec le SCM

### Envoi d'informations d√©taill√©es

```pascal
type
  TExtendedServiceStatus = class
  private
    FServiceStatus: SERVICE_STATUS_EX;
    FStatusHandle: SERVICE_STATUS_HANDLE;

  public
    procedure ReportProgress(PercentComplete: Integer; Message: string);
    procedure ReportCheckpoint(CheckPoint: DWORD; WaitHint: DWORD);
    procedure ReportError(ErrorCode: DWORD; ErrorMessage: string);
  end;

implementation

procedure TExtendedServiceStatus.ReportProgress(PercentComplete: Integer;
                                                Message: string);
var
  EventLog: THandle;
  Messages: array[0..1] of PChar;
begin
  // Mettre √† jour le checkpoint pour montrer la progression
  FServiceStatus.dwCheckPoint := PercentComplete;
  FServiceStatus.dwWaitHint := 3000; // 3 secondes avant le prochain update

  SetServiceStatus(FStatusHandle, @FServiceStatus.ServiceStatus);

  // Logger dans l'Event Log Windows
  EventLog := RegisterEventSource(nil, PChar(FServiceName));
  if EventLog <> 0 then
  begin
    Messages[0] := PChar(Format('Progression : %d%%', [PercentComplete]));
    Messages[1] := PChar(Message);

    ReportEvent(EventLog,
                EVENTLOG_INFORMATION_TYPE,
                0,     // Category
                1000,  // Event ID
                nil,   // User SID
                2,     // Number of strings
                0,     // Data size
                @Messages,
                nil);  // Raw data

    DeregisterEventSource(EventLog);
  end;
end;

procedure TExtendedServiceStatus.ReportCheckpoint(CheckPoint: DWORD;
                                                  WaitHint: DWORD);
begin
  // Le checkpoint indique la progression pendant START_PENDING ou STOP_PENDING
  FServiceStatus.dwCheckPoint := CheckPoint;
  FServiceStatus.dwWaitHint := WaitHint;

  if not SetServiceStatus(FStatusHandle, @FServiceStatus.ServiceStatus) then
  begin
    // Erreur critique - le SCM pourrait tuer notre service
    RaiseLastOSError;
  end;
end;
```

### Gestion des messages personnalis√©s

Windows permet d'envoyer des messages personnalis√©s aux services (codes 128-255) :

```pascal
const
  // Messages personnalis√©s (128-255)
  SERVICE_CONTROL_CUSTOM_RELOAD_CONFIG = 128;
  SERVICE_CONTROL_CUSTOM_DUMP_STATE    = 129;
  SERVICE_CONTROL_CUSTOM_CLEAR_CACHE   = 130;

type
  TCustomMessageHandler = class
  private
    FHandlers: TDictionary<DWORD, TServiceControlHandler>;

  public
    constructor Create;
    destructor Destroy; override;

    procedure RegisterHandler(ControlCode: DWORD;
                            Handler: TServiceControlHandler);
    procedure ProcessMessage(ControlCode: DWORD);
  end;

implementation

procedure TCustomMessageHandler.RegisterHandler(ControlCode: DWORD;
                                               Handler: TServiceControlHandler);
begin
  if (ControlCode >= 128) and (ControlCode <= 255) then
    FHandlers.Add(ControlCode, Handler)
  else
    raise Exception.Create('Code de contr√¥le invalide (doit √™tre 128-255)');
end;

procedure TCustomMessageHandler.ProcessMessage(ControlCode: DWORD);
var
  Handler: TServiceControlHandler;
begin
  if FHandlers.TryGetValue(ControlCode, Handler) then
  begin
    WriteLn(Format('Traitement du message personnalis√© %d', [ControlCode]));
    Handler(ControlCode);
  end
  else if (ControlCode >= 128) and (ControlCode <= 255) then
  begin
    WriteLn(Format('Message personnalis√© non g√©r√© : %d', [ControlCode]));
  end;
end;

// Utilisation
procedure InitializeCustomHandlers;
var
  CustomHandler: TCustomMessageHandler;
begin
  CustomHandler := TCustomMessageHandler.Create;

  // Enregistrer un handler pour recharger la configuration
  CustomHandler.RegisterHandler(SERVICE_CONTROL_CUSTOM_RELOAD_CONFIG,
    procedure(ControlCode: DWORD)
    begin
      WriteLn('Rechargement de la configuration...');
      ReloadConfiguration;
      WriteLn('Configuration recharg√©e');
    end
  );

  // Enregistrer un handler pour vider le cache
  CustomHandler.RegisterHandler(SERVICE_CONTROL_CUSTOM_CLEAR_CACHE,
    procedure(ControlCode: DWORD)
    begin
      WriteLn('Vidage du cache...');
      ClearAllCaches;
      WriteLn('Cache vid√©');
    end
  );
end;
```

### Envoi de commandes personnalis√©es au service

```pascal
program SendCustomCommand;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils;

procedure SendControlToService(const ServiceName: string; ControlCode: DWORD);
var
  SCManager, Service: SC_HANDLE;
  ServiceStatus: SERVICE_STATUS;
begin
  // Ouvrir le gestionnaire de services
  SCManager := OpenSCManager(nil, nil, SC_MANAGER_CONNECT);
  if SCManager = 0 then
  begin
    WriteLn('Erreur : Impossible d''ouvrir le SCM');
    Exit;
  end;

  try
    // Ouvrir le service
    Service := OpenService(SCManager, PChar(ServiceName),
                          SERVICE_USER_DEFINED_CONTROL);
    if Service = 0 then
    begin
      WriteLn('Erreur : Service non trouv√©');
      Exit;
    end;

    try
      // Envoyer la commande
      if ControlService(Service, ControlCode, ServiceStatus) then
      begin
        WriteLn(Format('Commande %d envoy√©e avec succ√®s', [ControlCode]));
        WriteLn(Format('√âtat actuel du service : %d',
                      [ServiceStatus.dwCurrentState]));
      end
      else
        WriteLn('Erreur lors de l''envoi de la commande : ', GetLastError);

    finally
      CloseServiceHandle(Service);
    end;

  finally
    CloseServiceHandle(SCManager);
  end;
end;

begin
  if ParamCount < 2 then
  begin
    WriteLn('Usage : SendCustomCommand <ServiceName> <ControlCode>');
    WriteLn('Exemple : SendCustomCommand MonService 128');
    Exit;
  end;

  SendControlToService(ParamStr(1), StrToInt(ParamStr(2)));
end.
```

## Gestion des d√©pendances de services

### D√©claration des d√©pendances

```pascal
type
  TServiceDependencyManager = class
  private
    FServiceName: string;
    FDependencies: TStringList;

  public
    constructor Create(const ServiceName: string);
    destructor Destroy; override;

    procedure AddDependency(const DependencyName: string);
    function CheckDependencies: Boolean;
    function WaitForDependencies(TimeoutSeconds: Integer): Boolean;
  end;

implementation

function TServiceDependencyManager.CheckDependencies: Boolean;
var
  i: Integer;
  SCManager, Service: SC_HANDLE;
  ServiceStatus: SERVICE_STATUS;
begin
  Result := True;

  SCManager := OpenSCManager(nil, nil, SC_MANAGER_ENUMERATE_SERVICE);
  if SCManager = 0 then
    Exit(False);

  try
    for i := 0 to FDependencies.Count - 1 do
    begin
      Service := OpenService(SCManager, PChar(FDependencies[i]),
                           SERVICE_QUERY_STATUS);
      if Service = 0 then
      begin
        WriteLn(Format('Service d√©pendant non trouv√© : %s',
                      [FDependencies[i]]));
        Result := False;
        Continue;
      end;

      try
        if QueryServiceStatus(Service, ServiceStatus) then
        begin
          if ServiceStatus.dwCurrentState <> SERVICE_RUNNING then
          begin
            WriteLn(Format('Service d√©pendant pas d√©marr√© : %s (√©tat=%d)',
                          [FDependencies[i], ServiceStatus.dwCurrentState]));
            Result := False;
          end;
        end;
      finally
        CloseServiceHandle(Service);
      end;
    end;
  finally
    CloseServiceHandle(SCManager);
  end;
end;

function TServiceDependencyManager.WaitForDependencies(TimeoutSeconds: Integer): Boolean;
var
  StartTime: TDateTime;
  ElapsedSeconds: Integer;
begin
  StartTime := Now;

  WriteLn('Attente des services d√©pendants...');

  repeat
    if CheckDependencies then
    begin
      WriteLn('Tous les services d√©pendants sont d√©marr√©s');
      Exit(True);
    end;

    Sleep(1000); // Attendre 1 seconde

    ElapsedSeconds := SecondsBetween(Now, StartTime);

    // Informer le SCM qu'on est toujours en d√©marrage
    ReportCheckpoint(ElapsedSeconds, 3000);

  until ElapsedSeconds >= TimeoutSeconds;

  WriteLn('Timeout : tous les services d√©pendants ne sont pas d√©marr√©s');
  Result := False;
end;
```

## Gestion des √©v√©nements syst√®me

### R√©action aux changements de session

```pascal
type
  TSessionChangeHandler = class
  private
    FLogger: TLogger;
    FActiveUsers: Integer;

    procedure HandleSessionChange(EventType: DWORD; SessionId: DWORD);

  public
    constructor Create(Logger: TLogger);
    procedure ProcessSessionChangeMessage(EventType, SessionId: DWORD);
  end;

implementation

procedure TSessionChangeHandler.ProcessSessionChangeMessage(EventType,
                                                           SessionId: DWORD);
begin
  case EventType of
    WTS_SESSION_LOGON:
      begin
        Inc(FActiveUsers);
        FLogger.Log(Format('Utilisateur connect√© (Session %d). Total actifs : %d',
                          [SessionId, FActiveUsers]));

        // Adapter le comportement du service
        if FActiveUsers = 1 then
        begin
          // Premier utilisateur connect√©
          FLogger.Log('Premier utilisateur - activation des fonctionnalit√©s interactives');
          EnableInteractiveFeatures;
        end;
      end;

    WTS_SESSION_LOGOFF:
      begin
        Dec(FActiveUsers);
        FLogger.Log(Format('Utilisateur d√©connect√© (Session %d). Total actifs : %d',
                          [SessionId, FActiveUsers]));

        if FActiveUsers = 0 then
        begin
          // Plus aucun utilisateur
          FLogger.Log('Aucun utilisateur - mode maintenance');
          EnterMaintenanceMode;
        end;
      end;

    WTS_SESSION_LOCK:
      begin
        FLogger.Log(Format('Session %d verrouill√©e', [SessionId]));
        // Peut-√™tre suspendre certaines op√©rations sensibles
      end;

    WTS_SESSION_UNLOCK:
      begin
        FLogger.Log(Format('Session %d d√©verrouill√©e', [SessionId]));
        // Reprendre les op√©rations
      end;

    WTS_REMOTE_CONNECT:
      begin
        FLogger.Log(Format('Connexion Bureau √† distance (Session %d)', [SessionId]));
        // Adapter pour connexion distante (performances, s√©curit√©)
      end;
  end;
end;
```

### Gestion des √©v√©nements d'alimentation

```pascal
type
  TPowerEventHandler = class
  private
    FLogger: TLogger;
    FOnBattery: Boolean;
    FSuspending: Boolean;

    procedure SaveStateBeforeSuspend;
    procedure RestoreStateAfterResume;

  public
    procedure HandlePowerEvent(EventType: DWORD; EventData: DWORD);
  end;

implementation

procedure TPowerEventHandler.HandlePowerEvent(EventType: DWORD; EventData: DWORD);
var
  PowerStatus: SYSTEM_POWER_STATUS;
begin
  case EventType of
    PBT_APMSUSPEND:
      begin
        FLogger.Log('Syst√®me entre en veille - sauvegarde de l''√©tat');
        FSuspending := True;

        // Sauvegarder l'√©tat critique
        SaveStateBeforeSuspend;

        // Fermer les connexions r√©seau
        CloseNetworkConnections;

        // Lib√©rer les ressources non essentielles
        ReleaseNonEssentialResources;
      end;

    PBT_APMRESUMESUSPEND:
      begin
        FLogger.Log('Syst√®me sort de veille - restauration');
        FSuspending := False;

        // Restaurer l'√©tat
        RestoreStateAfterResume;

        // Reconnecter au r√©seau
        ReestablishNetworkConnections;

        // V√©rifier l'int√©grit√©
        PerformIntegrityCheck;
      end;

    PBT_APMBATTERYLOW:
      begin
        FLogger.LogWarning('Batterie faible d√©tect√©e');
        FOnBattery := True;

        // Passer en mode √©conomie d'√©nergie
        EnterPowerSavingMode;

        // R√©duire la fr√©quence des op√©rations
        ReduceOperationFrequency;
      end;

    PBT_APMPOWERSTATUSCHANGE:
      begin
        // V√©rifier si on est sur secteur ou batterie
        if GetSystemPowerStatus(PowerStatus) then
        begin
          FOnBattery := PowerStatus.ACLineStatus = 0;

          if FOnBattery then
            FLogger.Log('Passage sur batterie')
          else
          begin
            FLogger.Log('Passage sur secteur');
            // Reprendre les op√©rations normales
            ResumeNormalOperations;
          end;
        end;
      end;
  end;
end;
```

## Optimisation de la communication SCM

### R√©ponse rapide aux commandes

```pascal
type
  TOptimizedSCMHandler = class
  private
    FCommandQueue: TThreadSafeQueue<DWORD>;
    FWorkerThread: TThread;
    FQuickResponse: Boolean;

    procedure ProcessCommandAsync(Command: DWORD);

  public
    constructor Create;
    destructor Destroy; override;

    procedure HandleSCMCommand(Command: DWORD);
  end;

implementation

procedure TOptimizedSCMHandler.HandleSCMCommand(Command: DWORD);
begin
  // R√©pondre imm√©diatement au SCM pour √©viter les timeouts
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // R√©pondre imm√©diatement que l'arr√™t est en cours
        ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 5000);

        // Traiter l'arr√™t de mani√®re asynchrone
        FCommandQueue.Enqueue(Command);
      end;

    SERVICE_CONTROL_PAUSE:
      begin
        ReportStatus(SERVICE_PAUSE_PENDING, NO_ERROR, 2000);
        FCommandQueue.Enqueue(Command);
      end;

    SERVICE_CONTROL_INTERROGATE:
      begin
        // R√©ponse imm√©diate requise
        ReportCurrentStatus;
      end;

    else
      // Autres commandes trait√©es de mani√®re asynchrone
      FCommandQueue.Enqueue(Command);
  end;
end;

procedure TOptimizedSCMHandler.ProcessCommandAsync(Command: DWORD);
begin
  // Traitement r√©el de la commande (peut prendre du temps)
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // Arr√™t propre du service
        StopAllOperations;
        SaveState;
        CloseAllConnections;

        // Informer le SCM que l'arr√™t est termin√©
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;

    SERVICE_CONTROL_PAUSE:
      begin
        // Mise en pause
        PauseAllOperations;
        ReportStatus(SERVICE_PAUSED, NO_ERROR, 0);
      end;
  end;
end;
```

## D√©bogage de l'interaction SCM

### Logger tous les messages SCM

```pascal
type
  TSCMDebugger = class
  private
    FLogFile: TextFile;
    FEnabled: Boolean;

    function ControlCodeToString(Code: DWORD): string;
    function StateToString(State: DWORD): string;

  public
    constructor Create(const LogFileName: string);
    destructor Destroy; override;

    procedure LogSCMMessage(ControlCode: DWORD);
    procedure LogStatusChange(OldState, NewState: DWORD);
    procedure LogError(const Operation: string; ErrorCode: DWORD);
  end;

implementation

function TSCMDebugger.ControlCodeToString(Code: DWORD): string;
begin
  case Code of
    SERVICE_CONTROL_STOP:           Result := 'STOP';
    SERVICE_CONTROL_PAUSE:          Result := 'PAUSE';
    SERVICE_CONTROL_CONTINUE:       Result := 'CONTINUE';
    SERVICE_CONTROL_INTERROGATE:    Result := 'INTERROGATE';
    SERVICE_CONTROL_SHUTDOWN:       Result := 'SHUTDOWN';
    SERVICE_CONTROL_PARAMCHANGE:    Result := 'PARAMCHANGE';
    SERVICE_CONTROL_NETBINDADD:     Result := 'NETBINDADD';
    SERVICE_CONTROL_NETBINDREMOVE:  Result := 'NETBINDREMOVE';
    SERVICE_CONTROL_NETBINDENABLE:  Result := 'NETBINDENABLE';
    SERVICE_CONTROL_NETBINDDISABLE: Result := 'NETBINDDISABLE';
    SERVICE_CONTROL_DEVICEEVENT:    Result := 'DEVICEEVENT';
    SERVICE_CONTROL_HARDWAREPROFILECHANGE: Result := 'HARDWAREPROFILECHANGE';
    SERVICE_CONTROL_POWEREVENT:     Result := 'POWEREVENT';
    SERVICE_CONTROL_SESSIONCHANGE:  Result := 'SESSIONCHANGE';
    SERVICE_CONTROL_PRESHUTDOWN:    Result := 'PRESHUTDOWN';
    SERVICE_CONTROL_TIMECHANGE:     Result := 'TIMECHANGE';
    128..255: Result := Format('CUSTOM_%d', [Code]);
  else
    Result := Format('UNKNOWN_%d', [Code]);
  end;
end;

function TSCMDebugger.StateToString(State: DWORD): string;
begin
  case State of
    SERVICE_STOPPED:          Result := 'STOPPED';
    SERVICE_START_PENDING:    Result := 'START_PENDING';
    SERVICE_STOP_PENDING:     Result := 'STOP_PENDING';
    SERVICE_RUNNING:          Result := 'RUNNING';
    SERVICE_CONTINUE_PENDING: Result := 'CONTINUE_PENDING';
    SERVICE_PAUSE_PENDING:    Result := 'PAUSE_PENDING';
    SERVICE_PAUSED:           Result := 'PAUSED';
  else
    Result := Format('UNKNOWN_%d', [State]);
  end;
end;

constructor TSCMDebugger.Create(const LogFileName: string);
begin
  inherited Create;
  AssignFile(FLogFile, LogFileName);

  if FileExists(LogFileName) then
    Append(FLogFile)
  else
    Rewrite(FLogFile);

  FEnabled := True;

  WriteLn(FLogFile, '=== SCM Debug Log Started: ' +
                    FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' ===');
  Flush(FLogFile);
end;

destructor TSCMDebugger.Destroy;
begin
  if FEnabled then
  begin
    WriteLn(FLogFile, '=== SCM Debug Log Ended: ' +
                      FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' ===');
    CloseFile(FLogFile);
  end;
  inherited;
end;

procedure TSCMDebugger.LogSCMMessage(ControlCode: DWORD);
var
  Timestamp: string;
  ThreadId: DWORD;
begin
  if not FEnabled then Exit;

  Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now);
  ThreadId := GetCurrentThreadId;

  WriteLn(FLogFile, Format('[%s] [Thread %d] SCM Message: %s (0x%x)',
    [Timestamp, ThreadId, ControlCodeToString(ControlCode), ControlCode]));

  // Si c'est un message avec donn√©es suppl√©mentaires
  if ControlCode = SERVICE_CONTROL_POWEREVENT then
    WriteLn(FLogFile, '  -> Power event details needed')
  else if ControlCode = SERVICE_CONTROL_SESSIONCHANGE then
    WriteLn(FLogFile, '  -> Session change details needed');

  Flush(FLogFile);
end;

procedure TSCMDebugger.LogStatusChange(OldState, NewState: DWORD);
var
  Timestamp: string;
begin
  if not FEnabled then Exit;

  Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now);

  WriteLn(FLogFile, Format('[%s] Status Change: %s -> %s',
    [Timestamp, StateToString(OldState), StateToString(NewState)]));

  // V√©rifier si la transition est valide
  if not IsValidTransition(OldState, NewState) then
    WriteLn(FLogFile, '  WARNING: This transition may be invalid!');

  Flush(FLogFile);
end;

procedure TSCMDebugger.LogError(const Operation: string; ErrorCode: DWORD);
var
  Timestamp: string;
  ErrorMessage: string;
begin
  if not FEnabled then Exit;

  Timestamp := FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now);
  ErrorMessage := SysErrorMessage(ErrorCode);

  WriteLn(FLogFile, Format('[%s] ERROR in %s: %d - %s',
    [Timestamp, Operation, ErrorCode, ErrorMessage]));

  // Ajouter des conseils de r√©solution pour les erreurs courantes
  case ErrorCode of
    ERROR_SERVICE_REQUEST_TIMEOUT:
      WriteLn(FLogFile, '  -> HINT: Service took too long to respond. ' +
                        'Consider using asynchronous processing.');
    ERROR_SERVICE_NO_THREAD:
      WriteLn(FLogFile, '  -> HINT: Cannot create thread. ' +
                        'Check system resources.');
    ERROR_SERVICE_DATABASE_LOCKED:
      WriteLn(FLogFile, '  -> HINT: Service database is locked. ' +
                        'Another installation may be in progress.');
  end;

  Flush(FLogFile);
end;
```

### Simulateur SCM pour tests

```pascal
program SCMSimulator;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils, Classes;

type
  TSCMSimulator = class
  private
    FServiceHandle: THandle;
    FServiceName: string;
    FCurrentState: DWORD;
    FLogger: TStringList;

    procedure SimulateStartSequence;
    procedure SimulateStopSequence;
    procedure SimulatePauseResumeSequence;
    procedure SimulateFailureScenarios;

  public
    constructor Create(const ServiceName: string);
    destructor Destroy; override;

    procedure RunSimulation;
    procedure SaveLog(const FileName: string);
  end;

implementation

constructor TSCMSimulator.Create(const ServiceName: string);
begin
  inherited Create;
  FServiceName := ServiceName;
  FLogger := TStringList.Create;
  FCurrentState := SERVICE_STOPPED;

  FLogger.Add('=== SCM Simulator Started ===');
  FLogger.Add('Service: ' + ServiceName);
  FLogger.Add('Time: ' + DateTimeToStr(Now));
  FLogger.Add('');
end;

destructor TSCMSimulator.Destroy;
begin
  FLogger.Free;
  inherited;
end;

procedure TSCMSimulator.SimulateStartSequence;
var
  i: Integer;
begin
  FLogger.Add('--- Simulating Normal Start Sequence ---');

  // 1. Envoi de la commande START
  FLogger.Add('SCM -> Service: START command');
  FCurrentState := SERVICE_START_PENDING;
  FLogger.Add('Service -> SCM: Status = START_PENDING');

  // 2. Simulation des checkpoints pendant le d√©marrage
  for i := 1 to 5 do
  begin
    Sleep(500);
    FLogger.Add(Format('Service -> SCM: Checkpoint %d/5, WaitHint=3000ms', [i]));
  end;

  // 3. Service d√©marr√©
  FCurrentState := SERVICE_RUNNING;
  FLogger.Add('Service -> SCM: Status = RUNNING');
  FLogger.Add('Start sequence completed successfully');
  FLogger.Add('');
end;

procedure TSCMSimulator.SimulateStopSequence;
begin
  FLogger.Add('--- Simulating Normal Stop Sequence ---');

  // 1. Envoi de la commande STOP
  FLogger.Add('SCM -> Service: STOP command');
  FCurrentState := SERVICE_STOP_PENDING;
  FLogger.Add('Service -> SCM: Status = STOP_PENDING');

  // 2. Simulation de l'arr√™t progressif
  FLogger.Add('Service: Saving state...');
  Sleep(1000);
  FLogger.Add('Service -> SCM: Checkpoint 1, WaitHint=5000ms');

  FLogger.Add('Service: Closing connections...');
  Sleep(1000);
  FLogger.Add('Service -> SCM: Checkpoint 2, WaitHint=3000ms');

  FLogger.Add('Service: Cleanup...');
  Sleep(500);

  // 3. Service arr√™t√©
  FCurrentState := SERVICE_STOPPED;
  FLogger.Add('Service -> SCM: Status = STOPPED');
  FLogger.Add('Stop sequence completed successfully');
  FLogger.Add('');
end;

procedure TSCMSimulator.SimulatePauseResumeSequence;
begin
  FLogger.Add('--- Simulating Pause/Resume Sequence ---');

  // Pause
  FLogger.Add('SCM -> Service: PAUSE command');
  FCurrentState := SERVICE_PAUSE_PENDING;
  FLogger.Add('Service -> SCM: Status = PAUSE_PENDING');
  Sleep(1000);
  FCurrentState := SERVICE_PAUSED;
  FLogger.Add('Service -> SCM: Status = PAUSED');

  // Interrogate pendant la pause
  FLogger.Add('SCM -> Service: INTERROGATE command');
  FLogger.Add('Service -> SCM: Status = PAUSED (current status)');

  // Resume
  Sleep(2000);
  FLogger.Add('SCM -> Service: CONTINUE command');
  FCurrentState := SERVICE_CONTINUE_PENDING;
  FLogger.Add('Service -> SCM: Status = CONTINUE_PENDING');
  Sleep(1000);
  FCurrentState := SERVICE_RUNNING;
  FLogger.Add('Service -> SCM: Status = RUNNING');
  FLogger.Add('Pause/Resume sequence completed');
  FLogger.Add('');
end;

procedure TSCMSimulator.SimulateFailureScenarios;
begin
  FLogger.Add('--- Simulating Failure Scenarios ---');

  // Sc√©nario 1 : Timeout au d√©marrage
  FLogger.Add('Scenario 1: Start timeout');
  FLogger.Add('SCM -> Service: START command');
  FLogger.Add('Service -> SCM: Status = START_PENDING');
  FLogger.Add('... 30 seconds pass without update ...');
  FLogger.Add('SCM: ERROR - Service did not start in time (Error 1053)');
  FLogger.Add('SCM: Killing service process');
  FLogger.Add('');

  // Sc√©nario 2 : Service ne r√©pond pas √† STOP
  FLogger.Add('Scenario 2: Stop not responding');
  FLogger.Add('SCM -> Service: STOP command');
  FLogger.Add('Service -> SCM: Status = STOP_PENDING');
  FLogger.Add('... No further updates ...');
  FLogger.Add('SCM: WARNING - Service not responding to stop');
  FLogger.Add('SCM: Force terminating process after timeout');
  FLogger.Add('');

  // Sc√©nario 3 : Transition invalide
  FLogger.Add('Scenario 3: Invalid state transition');
  FLogger.Add('Current state: PAUSED');
  FLogger.Add('Service attempts: Status = RUNNING (invalid!)');
  FLogger.Add('SCM: ERROR - Invalid state transition');
  FLogger.Add('SCM: Service state inconsistent');
  FLogger.Add('');
end;

procedure TSCMSimulator.RunSimulation;
begin
  FLogger.Add('Starting complete SCM interaction simulation...');
  FLogger.Add('');

  SimulateStartSequence;
  Sleep(2000);

  SimulatePauseResumeSequence;
  Sleep(2000);

  SimulateStopSequence;
  Sleep(1000);

  SimulateFailureScenarios;

  FLogger.Add('=== Simulation Complete ===');
end;

procedure TSCMSimulator.SaveLog(const FileName: string);
begin
  FLogger.SaveToFile(FileName);
  WriteLn('Simulation log saved to: ', FileName);
end;

// Programme principal
var
  Simulator: TSCMSimulator;
begin
  Simulator := TSCMSimulator.Create('TestService');
  try
    Simulator.RunSimulation;
    Simulator.SaveLog('scm_simulation.log');
  finally
    Simulator.Free;
  end;

  WriteLn('Press Enter to exit...');
  ReadLn;
end.
```

## Cas pratiques d'interaction SCM

### Cas 1 : Service avec d√©marrage long

```pascal
type
  TLongStartupService = class(TCustomDaemon)
  private
    FInitThread: TThread;
    FInitProgress: Integer;
    FStatusHandle: SERVICE_STATUS_HANDLE;

    procedure ReportInitProgress;

  public
    function Start: Boolean; override;
    function Stop: Boolean; override;
  end;

implementation

function TLongStartupService.Start: Boolean;
begin
  Result := True;

  // Informer le SCM que le d√©marrage va prendre du temps
  ReportStatus(SERVICE_START_PENDING, NO_ERROR, 30000); // 30 secondes

  // Cr√©er un thread pour l'initialisation longue
  FInitThread := TThread.CreateAnonymousThread(
    procedure
    var
      i: Integer;
    begin
      try
        // Phase 1 : Chargement de la configuration
        FInitProgress := 10;
        ReportInitProgress;
        LoadComplexConfiguration;

        // Phase 2 : Connexion aux bases de donn√©es
        FInitProgress := 30;
        ReportInitProgress;
        ConnectToMultipleDatabases;

        // Phase 3 : Chargement du cache
        FInitProgress := 50;
        ReportInitProgress;
        LoadLargeCache;

        // Phase 4 : Initialisation des composants
        FInitProgress := 70;
        ReportInitProgress;
        InitializeComponents;

        // Phase 5 : V√©rifications finales
        FInitProgress := 90;
        ReportInitProgress;
        PerformStartupChecks;

        // D√©marrage termin√©
        FInitProgress := 100;
        ReportStatus(SERVICE_RUNNING, NO_ERROR, 0);

      except
        on E: Exception do
        begin
          LogError('Startup failed: ' + E.Message);
          ReportStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR, 0);
        end;
      end;
    end
  );

  FInitThread.Start;
end;

procedure TLongStartupService.ReportInitProgress;
var
  ServiceStatus: SERVICE_STATUS;
begin
  FillChar(ServiceStatus, SizeOf(ServiceStatus), 0);
  ServiceStatus.dwServiceType := SERVICE_WIN32_OWN_PROCESS;
  ServiceStatus.dwCurrentState := SERVICE_START_PENDING;
  ServiceStatus.dwControlsAccepted := 0; // Pas de contr√¥le pendant le d√©marrage
  ServiceStatus.dwWin32ExitCode := NO_ERROR;
  ServiceStatus.dwCheckPoint := FInitProgress;
  ServiceStatus.dwWaitHint := 5000; // 5 secondes avant le prochain update

  SetServiceStatus(FStatusHandle, @ServiceStatus);

  // Logger la progression
  EventLog(etInfo, Format('Startup progress: %d%%', [FInitProgress]));
end;
```

### Cas 2 : Service avec arr√™t complexe

```pascal
type
  TComplexShutdownService = class(TCustomDaemon)
  private
    FShutdownRequested: Boolean;
    FActiveOperations: Integer;
    FShutdownTimeout: Integer;

    procedure WaitForOperationsToComplete;
    procedure ForceTerminateOperations;

  public
    function Stop: Boolean; override;
    procedure GracefulShutdown;
  end;

implementation

function TComplexShutdownService.Stop: Boolean;
var
  StartTime: TDateTime;
  Phase: Integer;
  ElapsedTime: Integer;
begin
  Result := True;
  FShutdownRequested := True;
  StartTime := Now;
  Phase := 0;

  // Informer le SCM que l'arr√™t va prendre du temps
  ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 20000);

  try
    // Phase 1 : Arr√™ter l'acceptation de nouvelles requ√™tes
    Inc(Phase);
    ReportCheckpoint(Phase, 5000);
    StopAcceptingNewRequests;
    EventLog(etInfo, 'Phase 1: Stopped accepting new requests');

    // Phase 2 : Attendre la fin des op√©rations en cours
    Inc(Phase);
    ReportCheckpoint(Phase, 10000);
    WaitForOperationsToComplete;
    EventLog(etInfo, Format('Phase 2: %d operations completed',
                            [FActiveOperations]));

    // Phase 3 : Sauvegarder l'√©tat
    Inc(Phase);
    ReportCheckpoint(Phase, 5000);
    SaveServiceState;
    EventLog(etInfo, 'Phase 3: State saved');

    // Phase 4 : Fermer les connexions
    Inc(Phase);
    ReportCheckpoint(Phase, 5000);
    CloseAllConnections;
    EventLog(etInfo, 'Phase 4: Connections closed');

    // Phase 5 : Nettoyage final
    Inc(Phase);
    ReportCheckpoint(Phase, 3000);
    PerformFinalCleanup;
    EventLog(etInfo, 'Phase 5: Cleanup completed');

    // Arr√™t termin√©
    ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);

    ElapsedTime := SecondsBetween(Now, StartTime);
    EventLog(etInfo, Format('Service stopped gracefully in %d seconds',
                            [ElapsedTime]));

  except
    on E: Exception do
    begin
      EventLog(etError, 'Error during shutdown: ' + E.Message);

      // Forcer l'arr√™t si l'arr√™t gracieux √©choue
      ForceTerminateOperations;

      ReportStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR, 0);
      Result := False;
    end;
  end;
end;

procedure TComplexShutdownService.WaitForOperationsToComplete;
var
  WaitStart: TDateTime;
  WaitTime: Integer;
begin
  WaitStart := Now;
  FShutdownTimeout := 15; // 15 secondes max

  while (FActiveOperations > 0) and
        (SecondsBetween(Now, WaitStart) < FShutdownTimeout) do
  begin
    Sleep(500);

    // Mettre √† jour le SCM
    WaitTime := FShutdownTimeout - SecondsBetween(Now, WaitStart);
    ReportCheckpoint(2, WaitTime * 1000);

    EventLog(etInfo, Format('Waiting for %d operations (timeout in %d sec)',
                           [FActiveOperations, WaitTime]));
  end;

  if FActiveOperations > 0 then
  begin
    EventLog(etWarning, Format('%d operations still active after timeout',
                              [FActiveOperations]));
    ForceTerminateOperations;
  end;
end;
```

### Cas 3 : Service interactif avec le bureau

```pascal
type
  TInteractiveService = class(TCustomDaemon)
  private
    FCanInteractWithDesktop: Boolean;
    FSessionMonitor: TSessionMonitor;

    procedure CheckInteractiveCapability;
    procedure ShowUserNotification(const Message: string);

  public
    function Start: Boolean; override;
    procedure NotifyUser(SessionId: DWORD; const Message: string);
  end;

implementation

function TInteractiveService.Start: Boolean;
begin
  Result := inherited Start;

  // V√©rifier si le service peut interagir avec le bureau
  CheckInteractiveCapability;

  if FCanInteractWithDesktop then
  begin
    EventLog(etInfo, 'Service has interactive capability');

    // Cr√©er un moniteur de sessions
    FSessionMonitor := TSessionMonitor.Create;
    FSessionMonitor.OnSessionChange := HandleSessionChange;
  end
  else
  begin
    EventLog(etWarning, 'Service cannot interact with desktop - ' +
                        'running in isolated mode');
  end;
end;

procedure TInteractiveService.CheckInteractiveCapability;
var
  SCManager, Service: SC_HANDLE;
  ServiceConfig: LPQUERY_SERVICE_CONFIG;
  BytesNeeded: DWORD;
begin
  FCanInteractWithDesktop := False;

  SCManager := OpenSCManager(nil, nil, SC_MANAGER_CONNECT);
  if SCManager = 0 then Exit;

  try
    Service := OpenService(SCManager, PChar(ServiceName), SERVICE_QUERY_CONFIG);
    if Service = 0 then Exit;

    try
      // Obtenir la configuration du service
      QueryServiceConfig(Service, nil, 0, BytesNeeded);
      GetMem(ServiceConfig, BytesNeeded);
      try
        if QueryServiceConfig(Service, ServiceConfig, BytesNeeded, BytesNeeded) then
        begin
          // V√©rifier le flag SERVICE_INTERACTIVE_PROCESS
          FCanInteractWithDesktop :=
            (ServiceConfig^.dwServiceType and SERVICE_INTERACTIVE_PROCESS) <> 0;
        end;
      finally
        FreeMem(ServiceConfig);
      end;
    finally
      CloseServiceHandle(Service);
    end;
  finally
    CloseServiceHandle(SCManager);
  end;
end;

procedure TInteractiveService.NotifyUser(SessionId: DWORD; const Message: string);
var
  Response: DWORD;
begin
  if not FCanInteractWithDesktop then
  begin
    EventLog(etWarning, 'Cannot show notification - not interactive');
    Exit;
  end;

  // Utiliser WTSSendMessage pour envoyer un message √† une session
  WTSSendMessage(
    WTS_CURRENT_SERVER,
    SessionId,
    PChar('Service Notification'),
    Length('Service Notification') * SizeOf(Char),
    PChar(Message),
    Length(Message) * SizeOf(Char),
    MB_OK or MB_ICONINFORMATION,
    0, // Timeout (0 = pas de timeout)
    Response,
    False // Don't wait for response
  );

  EventLog(etInfo, Format('Notification sent to session %d: %s',
                          [SessionId, Message]));
end;
```

## Gestion avanc√©e des privil√®ges

### Ajustement des privil√®ges du service

```pascal
type
  TServicePrivilegeManager = class
  private
    FRequiredPrivileges: TStringList;

    function EnablePrivilege(const PrivilegeName: string): Boolean;
    function CheckPrivilege(const PrivilegeName: string): Boolean;

  public
    constructor Create;
    destructor Destroy; override;

    procedure RequirePrivilege(const PrivilegeName: string);
    function ValidateAllPrivileges: Boolean;
    procedure AdjustServicePrivileges;
  end;

implementation

const
  // Privil√®ges Windows courants
  SE_BACKUP_NAME           = 'SeBackupPrivilege';
  SE_RESTORE_NAME          = 'SeRestorePrivilege';
  SE_SHUTDOWN_NAME         = 'SeShutdownPrivilege';
  SE_DEBUG_NAME            = 'SeDebugPrivilege';
  SE_SYSTEM_ENVIRONMENT_NAME = 'SeSystemEnvironmentPrivilege';
  SE_CHANGE_NOTIFY_NAME    = 'SeChangeNotifyPrivilege';
  SE_UNDOCK_NAME          = 'SeUndockPrivilege';
  SE_MANAGE_VOLUME_NAME   = 'SeManageVolumePrivilege';

procedure TServicePrivilegeManager.AdjustServicePrivileges;
var
  i: Integer;
  PrivName: string;
begin
  EventLog(etInfo, 'Adjusting service privileges...');

  for i := 0 to FRequiredPrivileges.Count - 1 do
  begin
    PrivName := FRequiredPrivileges[i];

    if EnablePrivilege(PrivName) then
      EventLog(etInfo, Format('Privilege enabled: %s', [PrivName]))
    else
      EventLog(etWarning, Format('Failed to enable privilege: %s', [PrivName]));
  end;
end;

function TServicePrivilegeManager.EnablePrivilege(const PrivilegeName: string): Boolean;
var
  Token: THandle;
  TokenPriv: TOKEN_PRIVILEGES;
  PrevTokenPriv: TOKEN_PRIVILEGES;
  ReturnLength: Cardinal;
begin
  Result := False;

  // Ouvrir le token du processus
  if not OpenProcessToken(GetCurrentProcess(),
                          TOKEN_ADJUST_PRIVILEGES or TOKEN_QUERY,
                          Token) then
    Exit;

  try
    // Rechercher le LUID du privil√®ge
    if not LookupPrivilegeValue(nil, PChar(PrivilegeName),
                                TokenPriv.Privileges[0].Luid) then
      Exit;

    TokenPriv.PrivilegeCount := 1;
    TokenPriv.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;

    // Ajuster les privil√®ges
    Result := AdjustTokenPrivileges(Token, False, TokenPriv,
                                   SizeOf(PrevTokenPriv),
                                   PrevTokenPriv, ReturnLength);

    // V√©rifier que l'ajustement a r√©ussi
    Result := Result and (GetLastError() = ERROR_SUCCESS);

  finally
    CloseHandle(Token);
  end;
end;
```

## Bonnes pratiques pour l'interaction SCM

### 1. Toujours r√©pondre rapidement

```pascal
// MAUVAIS - Risque de timeout
procedure HandleSCMCommand(Command: DWORD);
begin
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // Traitement long sans feedback
        PerformLongShutdownProcess; // 45 secondes
        ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
      end;
  end;
end;

// BON - R√©ponse imm√©diate avec updates
procedure HandleSCMCommand(Command: DWORD);
begin
  case Command of
    SERVICE_CONTROL_STOP:
      begin
        // Informer imm√©diatement le SCM
        ReportStatus(SERVICE_STOP_PENDING, NO_ERROR, 10000);

        // Lancer l'arr√™t en asynchrone
        TThread.CreateAnonymousThread(
          procedure
          begin
            PerformLongShutdownProcess;
            ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);
          end
        ).Start;
      end;
  end;
end;
```

### 2. G√©rer les checkpoints correctement

```pascal
procedure PerformLongOperation;
var
  TotalSteps: Integer;
  CurrentStep: Integer;
begin
  TotalSteps := 10;

  for CurrentStep := 1 to TotalSteps do
  begin
    // Faire une partie du travail
    ProcessStep(CurrentStep);

    // Informer le SCM de la progression
    ReportCheckpoint(CurrentStep, 5000); // 5 secondes pour le prochain

    // Important : Le checkpoint doit augmenter
    // sinon le SCM pensera que le service est bloqu√©
  end;
end;
```

### 3. G√©rer proprement les arr√™ts d'urgence

```pascal
procedure HandleShutdown;
begin
  // Windows s'arr√™te - on a tr√®s peu de temps

  // 1. Sauvegarder seulement l'essentiel
  QuickSaveEssentialState;

  // 2. Pas de nettoyage complexe
  // Skip: CloseAllConnections, FreeAllResources, etc.

  // 3. Informer imm√©diatement le SCM
  ReportStatus(SERVICE_STOPPED, NO_ERROR, 0);

  // Windows forcera la terminaison de toute fa√ßon
end;
```

### 4. Logger sans bloquer

```pascal
type
  TAsyncLogger = class
  private
    FLogQueue: TThreadedQueue<string>;
    FLogThread: TThread;

  public
    procedure LogSCMInteraction(const Message: string);
  end;

procedure TAsyncLogger.LogSCMInteraction(const Message: string);
begin
  // Ne jamais bloquer dans le handler SCM
  FLogQueue.PushItem(FormatDateTime('hh:nn:ss.zzz', Now) + ' ' + Message);

  // Le thread de log √©crira quand il pourra
  // sans bloquer le traitement des messages SCM
end;
```

## R√©sum√© : Points cl√©s de l'interaction SCM

1. **Le SCM est impatient** : R√©pondez toujours rapidement (< 30 secondes)
2. **Les transitions d'√©tat doivent √™tre logiques** : Respectez le diagramme d'√©tats
3. **Les checkpoints sont vitaux** : Augmentez-les pendant les op√©rations longues
4. **L'asynchrone est votre ami** : Ne bloquez jamais le thread du handler SCM
5. **Loggez tout** : Les probl√®mes SCM sont difficiles √† d√©boguer sans logs
6. **G√©rez les cas d'urgence** : SHUTDOWN n√©cessite une r√©ponse imm√©diate
7. **Testez les sc√©narios d'√©chec** : Timeouts, crashes, arr√™ts forc√©s
8. **Respectez les privil√®ges** : Demandez seulement ce dont vous avez besoin

## Guide de r√©f√©rence rapide

### Codes de contr√¥le SCM essentiels

```pascal
// Messages de base (obligatoires √† g√©rer)
SERVICE_CONTROL_STOP           = $00000001;  // DOIT √™tre g√©r√©
SERVICE_CONTROL_INTERROGATE    = $00000004;  // DOIT √™tre g√©r√©
SERVICE_CONTROL_SHUTDOWN       = $00000005;  // DOIT √™tre g√©r√© si accept√©

// Messages optionnels
SERVICE_CONTROL_PAUSE          = $00000002;  // Si SERVICE_ACCEPT_PAUSE_CONTINUE
SERVICE_CONTROL_CONTINUE       = $00000003;  // Si SERVICE_ACCEPT_PAUSE_CONTINUE
SERVICE_CONTROL_PARAMCHANGE    = $00000006;  // Si SERVICE_ACCEPT_PARAMCHANGE

// Messages syst√®me
SERVICE_CONTROL_POWEREVENT     = $0000000D;  // Si SERVICE_ACCEPT_POWEREVENT
SERVICE_CONTROL_SESSIONCHANGE  = $0000000E;  // Si SERVICE_ACCEPT_SESSIONCHANGE
SERVICE_CONTROL_PRESHUTDOWN    = $0000000F;  // Si SERVICE_ACCEPT_PRESHUTDOWN

// Messages personnalis√©s
// 128-255 : Disponibles pour votre usage
```

### √âtats du service

```pascal
SERVICE_STOPPED          = $00000001;  // Initial et final
SERVICE_START_PENDING    = $00000002;  // D√©marrage en cours
SERVICE_STOP_PENDING     = $00000003;  // Arr√™t en cours
SERVICE_RUNNING          = $00000004;  // √âtat normal de fonctionnement
SERVICE_CONTINUE_PENDING = $00000005;  // Reprise apr√®s pause
SERVICE_PAUSE_PENDING    = $00000006;  // Mise en pause
SERVICE_PAUSED           = $00000007;  // En pause
```

### Drapeaux d'acceptation de contr√¥le

```pascal
// √Ä d√©finir dans dwControlsAccepted
SERVICE_ACCEPT_STOP                  = $00000001;  // Toujours recommand√©
SERVICE_ACCEPT_PAUSE_CONTINUE        = $00000002;  // Pour pause/reprise
SERVICE_ACCEPT_SHUTDOWN              = $00000004;  // Arr√™t Windows
SERVICE_ACCEPT_PARAMCHANGE           = $00000008;  // Changement param√®tres
SERVICE_ACCEPT_NETBINDCHANGE         = $00000010;  // Changements r√©seau
SERVICE_ACCEPT_HARDWAREPROFILECHANGE = $00000020;  // Profil mat√©riel
SERVICE_ACCEPT_POWEREVENT            = $00000040;  // √âv√©nements alimentation
SERVICE_ACCEPT_SESSIONCHANGE         = $00000080;  // Sessions utilisateur
SERVICE_ACCEPT_PRESHUTDOWN           = $00000100;  // Pr√©-arr√™t (Vista+)
SERVICE_ACCEPT_TIMECHANGE            = $00000200;  // Changement heure syst√®me
```

## Template complet d'interaction SCM

```pascal
unit ServiceSCMTemplate;

{$mode objfpc}{$H+}

interface

uses
  Windows, Classes, SysUtils, DaemonApp;

type
  { TServiceWithSCM }
  TServiceWithSCM = class(TCustomDaemon)
  private
    // SCM
    FStatusHandle: SERVICE_STATUS_HANDLE;
    FServiceStatus: SERVICE_STATUS;
    FServiceName: string;

    // √âtat
    FShutdownRequested: Boolean;
    FPaused: Boolean;

    // Debug et logs
    FSCMDebugger: TSCMDebugger;

    // Threads
    FMainThread: TThread;
    FShutdownThread: TThread;

    // M√©thodes SCM
    procedure RegisterWithSCM;
    procedure UpdateServiceStatus(NewState: DWORD; ExitCode: DWORD = NO_ERROR;
      WaitHint: DWORD = 0);
    procedure ReportCheckpoint(CheckPoint: DWORD; WaitHint: DWORD);

    // Handlers
    procedure HandleStart;
    procedure HandleStop;
    procedure HandlePause;
    procedure HandleContinue;
    procedure HandleShutdown;
    procedure HandleInterrogate;
    procedure HandleSessionChange(EventType, SessionId: DWORD);
    procedure HandlePowerEvent(EventType, EventData: DWORD);
    procedure HandleCustomCommand(Command: DWORD);

  protected
    function GetServiceControlHandler: TServiceControlHandler;

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    function Start: Boolean; override;
    function Stop: Boolean; override;
    function Pause: Boolean; override;
    function Continue: Boolean; override;
    function Execute: Boolean; override;

    procedure ServiceControlHandler(CtrlCode: DWORD); virtual;
  end;

implementation

{ TServiceWithSCM }

constructor TServiceWithSCM.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  FServiceName := 'MyServiceWithSCM';
  FShutdownRequested := False;
  FPaused := False;

  // Initialiser le debugger SCM
  FSCMDebugger := TSCMDebugger.Create(
    ExtractFilePath(ParamStr(0)) + 'scm_debug.log'
  );

  // Initialiser la structure de statut
  FillChar(FServiceStatus, SizeOf(FServiceStatus), 0);
  FServiceStatus.dwServiceType := SERVICE_WIN32_OWN_PROCESS;
  FServiceStatus.dwCurrentState := SERVICE_STOPPED;

  // D√©finir ce que le service accepte
  FServiceStatus.dwControlsAccepted :=
    SERVICE_ACCEPT_STOP or
    SERVICE_ACCEPT_PAUSE_CONTINUE or
    SERVICE_ACCEPT_SHUTDOWN or
    SERVICE_ACCEPT_SESSIONCHANGE or
    SERVICE_ACCEPT_POWEREVENT;
end;

destructor TServiceWithSCM.Destroy;
begin
  FSCMDebugger.Free;
  inherited;
end;

procedure TServiceWithSCM.RegisterWithSCM;
begin
  FSCMDebugger.Log('Registering with SCM...');

  FStatusHandle := RegisterServiceCtrlHandlerEx(
    PChar(FServiceName),
    @ServiceControlHandlerEx,
    Self  // Contexte pass√© au handler
  );

  if FStatusHandle = 0 then
  begin
    FSCMDebugger.LogError('RegisterServiceCtrlHandlerEx', GetLastError);
    raise Exception.Create('Failed to register with SCM');
  end;

  FSCMDebugger.Log('Successfully registered with SCM');
end;

procedure TServiceWithSCM.UpdateServiceStatus(NewState: DWORD;
  ExitCode: DWORD; WaitHint: DWORD);
var
  OldState: DWORD;
begin
  OldState := FServiceStatus.dwCurrentState;

  // Mettre √† jour la structure
  FServiceStatus.dwCurrentState := NewState;
  FServiceStatus.dwWin32ExitCode := ExitCode;
  FServiceStatus.dwWaitHint := WaitHint;

  // R√©initialiser le checkpoint si on n'est plus en pending
  if not (NewState in [SERVICE_START_PENDING, SERVICE_STOP_PENDING,
                       SERVICE_CONTINUE_PENDING, SERVICE_PAUSE_PENDING]) then
    FServiceStatus.dwCheckPoint := 0;

  // Ajuster les contr√¥les accept√©s selon l'√©tat
  case NewState of
    SERVICE_START_PENDING:
      FServiceStatus.dwControlsAccepted := 0;  // Rien pendant le d√©marrage

    SERVICE_STOP_PENDING:
      FServiceStatus.dwControlsAccepted := 0;  // Rien pendant l'arr√™t

    SERVICE_PAUSED:
      FServiceStatus.dwControlsAccepted :=
        SERVICE_ACCEPT_STOP or
        SERVICE_ACCEPT_CONTINUE;

    SERVICE_RUNNING:
      FServiceStatus.dwControlsAccepted :=
        SERVICE_ACCEPT_STOP or
        SERVICE_ACCEPT_PAUSE_CONTINUE or
        SERVICE_ACCEPT_SHUTDOWN or
        SERVICE_ACCEPT_SESSIONCHANGE or
        SERVICE_ACCEPT_POWEREVENT;
  end;

  // Envoyer au SCM
  if not SetServiceStatus(FStatusHandle, @FServiceStatus) then
    FSCMDebugger.LogError('SetServiceStatus', GetLastError)
  else
    FSCMDebugger.LogStatusChange(OldState, NewState);
end;

procedure TServiceWithSCM.ReportCheckpoint(CheckPoint: DWORD; WaitHint: DWORD);
begin
  FServiceStatus.dwCheckPoint := CheckPoint;
  FServiceStatus.dwWaitHint := WaitHint;

  if not SetServiceStatus(FStatusHandle, @FServiceStatus) then
    FSCMDebugger.LogError('ReportCheckpoint', GetLastError)
  else
    FSCMDebugger.Log(Format('Checkpoint %d reported (WaitHint=%dms)',
      [CheckPoint, WaitHint]));
end;

function TServiceWithSCM.Start: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Start method called');

  try
    // S'enregistrer aupr√®s du SCM
    RegisterWithSCM;

    // Informer le SCM que le d√©marrage commence
    UpdateServiceStatus(SERVICE_START_PENDING, NO_ERROR, 10000);

    // Lancer le d√©marrage asynchrone
    HandleStart;

  except
    on E: Exception do
    begin
      FSCMDebugger.LogError('Start', E.Message);
      UpdateServiceStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR);
      Result := False;
    end;
  end;
end;

procedure TServiceWithSCM.HandleStart;
begin
  FSCMDebugger.Log('HandleStart: Beginning startup sequence');

  // Cr√©er un thread pour l'initialisation
  FMainThread := TThread.CreateAnonymousThread(
    procedure
    var
      Step: Integer;
    begin
      try
        // Phase 1 : Initialisation de base
        Step := 1;
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Startup phase 1: Basic initialization');
        Sleep(1000); // Simuler initialisation

        // Phase 2 : Chargement de la configuration
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Startup phase 2: Loading configuration');
        LoadConfiguration;

        // Phase 3 : Connexions
        Inc(Step);
        ReportCheckpoint(Step, 8000);
        FSCMDebugger.Log('Startup phase 3: Establishing connections');
        EstablishConnections;

        // Phase 4 : D√©marrage des workers
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Startup phase 4: Starting workers');
        StartWorkers;

        // D√©marrage termin√©
        UpdateServiceStatus(SERVICE_RUNNING);
        FSCMDebugger.Log('Service started successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandleStart', E.Message);
          UpdateServiceStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR);
        end;
      end;
    end
  );

  FMainThread.Start;
end;

function TServiceWithSCM.Stop: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Stop method called');
  FShutdownRequested := True;

  HandleStop;
end;

procedure TServiceWithSCM.HandleStop;
begin
  FSCMDebugger.Log('HandleStop: Beginning shutdown sequence');

  // Informer le SCM
  UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 15000);

  // Cr√©er un thread pour l'arr√™t
  FShutdownThread := TThread.CreateAnonymousThread(
    procedure
    var
      Step: Integer;
    begin
      try
        Step := 1;

        // Phase 1 : Arr√™ter les nouveaux travaux
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Shutdown phase 1: Stopping new work');
        StopAcceptingWork;

        // Phase 2 : Attendre la fin des travaux en cours
        Inc(Step);
        ReportCheckpoint(Step, 10000);
        FSCMDebugger.Log('Shutdown phase 2: Waiting for current work');
        WaitForWorkCompletion;

        // Phase 3 : Sauvegarder l'√©tat
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Shutdown phase 3: Saving state');
        SaveState;

        // Phase 4 : Fermer les connexions
        Inc(Step);
        ReportCheckpoint(Step, 5000);
        FSCMDebugger.Log('Shutdown phase 4: Closing connections');
        CloseConnections;

        // Phase 5 : Nettoyage
        Inc(Step);
        ReportCheckpoint(Step, 3000);
        FSCMDebugger.Log('Shutdown phase 5: Cleanup');
        Cleanup;

        // Arr√™t termin√©
        UpdateServiceStatus(SERVICE_STOPPED);
        FSCMDebugger.Log('Service stopped successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandleStop', E.Message);
          // Forcer l'arr√™t m√™me en cas d'erreur
          UpdateServiceStatus(SERVICE_STOPPED, ERROR_SERVICE_SPECIFIC_ERROR);
        end;
      end;
    end
  );

  FShutdownThread.Start;
end;

function TServiceWithSCM.Pause: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Pause method called');

  HandlePause;
end;

procedure TServiceWithSCM.HandlePause;
begin
  FSCMDebugger.Log('HandlePause: Pausing service');

  UpdateServiceStatus(SERVICE_PAUSE_PENDING, NO_ERROR, 5000);

  TThread.CreateAnonymousThread(
    procedure
    begin
      try
        // Suspendre les op√©rations
        SuspendOperations;
        FPaused := True;

        UpdateServiceStatus(SERVICE_PAUSED);
        FSCMDebugger.Log('Service paused successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandlePause', E.Message);
          // Retourner √† l'√©tat running en cas d'√©chec
          UpdateServiceStatus(SERVICE_RUNNING);
        end;
      end;
    end
  ).Start;
end;

function TServiceWithSCM.Continue: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Continue method called');

  HandleContinue;
end;

procedure TServiceWithSCM.HandleContinue;
begin
  FSCMDebugger.Log('HandleContinue: Resuming service');

  UpdateServiceStatus(SERVICE_CONTINUE_PENDING, NO_ERROR, 5000);

  TThread.CreateAnonymousThread(
    procedure
    begin
      try
        // Reprendre les op√©rations
        ResumeOperations;
        FPaused := False;

        UpdateServiceStatus(SERVICE_RUNNING);
        FSCMDebugger.Log('Service resumed successfully');

      except
        on E: Exception do
        begin
          FSCMDebugger.LogError('HandleContinue', E.Message);
          // Rester en pause en cas d'√©chec
          UpdateServiceStatus(SERVICE_PAUSED);
        end;
      end;
    end
  ).Start;
end;

procedure TServiceWithSCM.HandleShutdown;
begin
  FSCMDebugger.Log('HandleShutdown: Windows is shutting down');

  // Arr√™t d'urgence - pas le temps pour un arr√™t gracieux
  UpdateServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 5000);

  TThread.CreateAnonymousThread(
    procedure
    begin
      // Sauvegarder seulement l'essentiel
      QuickSaveEssentialData;

      // Arr√™t imm√©diat
      UpdateServiceStatus(SERVICE_STOPPED);
      FSCMDebugger.Log('Emergency shutdown completed');
    end
  ).Start;
end;

procedure TServiceWithSCM.HandleInterrogate;
begin
  FSCMDebugger.Log('HandleInterrogate: SCM requesting current status');

  // Juste renvoyer l'√©tat actuel
  SetServiceStatus(FStatusHandle, @FServiceStatus);
end;

procedure TServiceWithSCM.HandleSessionChange(EventType, SessionId: DWORD);
var
  EventName: string;
begin
  case EventType of
    WTS_SESSION_LOGON:     EventName := 'LOGON';
    WTS_SESSION_LOGOFF:    EventName := 'LOGOFF';
    WTS_SESSION_LOCK:      EventName := 'LOCK';
    WTS_SESSION_UNLOCK:    EventName := 'UNLOCK';
    WTS_REMOTE_CONNECT:    EventName := 'REMOTE_CONNECT';
    WTS_REMOTE_DISCONNECT: EventName := 'REMOTE_DISCONNECT';
  else
    EventName := Format('UNKNOWN_%d', [EventType]);
  end;

  FSCMDebugger.Log(Format('HandleSessionChange: %s (Session %d)',
    [EventName, SessionId]));

  // Adapter le comportement selon l'√©v√©nement
  case EventType of
    WTS_SESSION_LOGON:
      OnUserLogon(SessionId);

    WTS_SESSION_LOGOFF:
      OnUserLogoff(SessionId);
  end;
end;

procedure TServiceWithSCM.HandlePowerEvent(EventType, EventData: DWORD);
var
  EventName: string;
begin
  case EventType of
    PBT_APMSUSPEND:           EventName := 'SUSPEND';
    PBT_APMRESUMESUSPEND:     EventName := 'RESUME';
    PBT_APMBATTERYLOW:        EventName := 'BATTERY_LOW';
    PBT_APMPOWERSTATUSCHANGE: EventName := 'POWER_STATUS_CHANGE';
    PBT_APMRESUMEAUTOMATIC:   EventName := 'RESUME_AUTOMATIC';
  else
    EventName := Format('UNKNOWN_%d', [EventType]);
  end;

  FSCMDebugger.Log(Format('HandlePowerEvent: %s', [EventName]));

  // Adapter le comportement
  case EventType of
    PBT_APMSUSPEND:
      PrepareForSuspend;

    PBT_APMRESUMESUSPEND:
      RecoverFromSuspend;

    PBT_APMBATTERYLOW:
      EnterLowPowerMode;
  end;
end;

procedure TServiceWithSCM.HandleCustomCommand(Command: DWORD);
begin
  FSCMDebugger.Log(Format('HandleCustomCommand: %d', [Command]));

  case Command of
    128: // Recharger configuration
      begin
        FSCMDebugger.Log('Custom command: Reload configuration');
        ReloadConfiguration;
      end;

    129: // Dump √©tat
      begin
        FSCMDebugger.Log('Custom command: Dump state');
        DumpServiceState;
      end;

    130: // Forcer garbage collection
      begin
        FSCMDebugger.Log('Custom command: Force GC');
        ForceGarbageCollection;
      end;

  else
    FSCMDebugger.Log(Format('Unknown custom command: %d', [Command]));
  end;
end;

procedure TServiceWithSCM.ServiceControlHandler(CtrlCode: DWORD);
begin
  FSCMDebugger.LogSCMMessage(CtrlCode);

  // Traiter le message selon son type
  case CtrlCode of
    SERVICE_CONTROL_STOP:
      HandleStop;

    SERVICE_CONTROL_PAUSE:
      HandlePause;

    SERVICE_CONTROL_CONTINUE:
      HandleContinue;

    SERVICE_CONTROL_INTERROGATE:
      HandleInterrogate;

    SERVICE_CONTROL_SHUTDOWN:
      HandleShutdown;

    SERVICE_CONTROL_SESSIONCHANGE:
      begin
        // Les d√©tails sont dans les param√®tres √©tendus
        // N√©cessite ServiceControlHandlerEx
      end;

    SERVICE_CONTROL_POWEREVENT:
      begin
        // Les d√©tails sont dans les param√®tres √©tendus
      end;

    128..255:
      HandleCustomCommand(CtrlCode);

  else
    FSCMDebugger.Log(Format('Unhandled control code: %d', [CtrlCode]));
  end;
end;

function TServiceWithSCM.Execute: Boolean;
begin
  Result := True;
  FSCMDebugger.Log('Execute: Main service loop started');

  while not FShutdownRequested do
  begin
    try
      if not FPaused then
      begin
        // Travail principal du service
        DoServiceWork;
      end
      else
      begin
        // En pause - juste attendre
        Sleep(100);
      end;

      // Permettre au thread de r√©pondre aux √©v√©nements
      CheckSynchronize(100);

    except
      on E: Exception do
      begin
        FSCMDebugger.LogError('Execute', E.Message);
        // Continuer malgr√© l'erreur
      end;
    end;
  end;

  FSCMDebugger.Log('Execute: Main service loop ended');
end;

end.
```

## Checklist finale pour l'interaction SCM

### ‚úÖ Avant la mise en production

- [ ] **Handler SCM enregistr√©** correctement avec RegisterServiceCtrlHandler(Ex)
- [ ] **Tous les √©tats obligatoires** g√©r√©s (STOP, INTERROGATE, SHUTDOWN)
- [ ] **Transitions d'√©tat** valides et logiques
- [ ] **Checkpoints** impl√©ment√©s pour les op√©rations longues
- [ ] **Timeouts** respect√©s (< 30 secondes pour les r√©ponses)
- [ ] **Logging SCM** complet pour le d√©bogage
- [ ] **Mode asynchrone** pour les op√©rations longues
- [ ] **Gestion d'erreur** robuste avec fallback
- [ ] **Tests de tous les sc√©narios** (normal, timeout, crash, shutdown)
- [ ] **Documentation** des commandes personnalis√©es

### ‚ö†Ô∏è Pi√®ges courants √† √©viter

1. **Ne jamais bloquer** dans le handler SCM
2. **Ne pas oublier** d'incr√©menter les checkpoints
3. **Ne pas ignorer** INTERROGATE
4. **Ne pas faire** d'op√©rations longues dans SHUTDOWN
5. **Ne pas oublier** de mettre dwControlsAccepted √† 0 pendant les transitions
6. **Ne pas n√©gliger** la journalisation
7. **Ne pas supposer** que Stop sera toujours appel√© (crash, kill process)
8. **Ne pas oublier** de tester avec des comptes de service limit√©s

## Conclusion

L'interaction avec le Service Control Manager est le c≈ìur de tout service Windows. Une impl√©mentation correcte garantit :
- Un service stable et fiable
- Une int√©gration parfaite avec Windows
- Une exp√©rience utilisateur professionnelle
- Un d√©bogage facilit√© en cas de probl√®me

Prenez le temps de bien comprendre et impl√©menter cette interaction. C'est la diff√©rence entre un service amateur et un service professionnel.

N'oubliez jamais : **Le SCM est votre patron, r√©pondez-lui rapidement et pr√©cis√©ment !**

‚è≠Ô∏è [Registry Windows](/06-specificites-windows/03-registry-windows.md)
