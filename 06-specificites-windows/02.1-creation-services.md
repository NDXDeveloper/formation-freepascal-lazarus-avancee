üîù Retour au [Sommaire](/SOMMAIRE.md)

# Cr√©ation de Services Windows avec FreePascal/Lazarus

## Introduction : Votre premier service Windows

Cr√©er un service Windows peut sembler intimidant au d√©but, mais FreePascal/Lazarus simplifie grandement le processus gr√¢ce √† son framework de services int√©gr√©. Dans ce tutoriel, nous allons cr√©er pas √† pas diff√©rents types de services, du plus simple au plus complexe.

## Pr√©paration de l'environnement

### V√©rifications pr√©alables

Avant de commencer, assurez-vous d'avoir :

1. **Lazarus install√©** avec les packages standards
2. **Droits administrateur** sur votre machine Windows (n√©cessaire pour installer des services)
3. **Le package daemonapp** (normalement inclus dans Lazarus)

Pour v√©rifier la pr√©sence du package :
- Ouvrez Lazarus
- Menu `Package` ‚Üí `Ouvrir un package`
- Cherchez `daemonapp` dans la liste

### Concepts de base FreePascal pour les services

FreePascal utilise plusieurs classes pour cr√©er des services :

- **TCustomDaemon** : La classe de base pour cr√©er un service
- **TCustomDaemonApplication** : L'application qui h√©berge le service
- **TDaemonMapper** : Fait le lien entre le service et l'application

## M√©thode 1 : Utiliser l'assistant Lazarus (Recommand√© pour d√©buter)

### √âtape 1 : Cr√©er un nouveau projet de service

1. Dans Lazarus : `Fichier` ‚Üí `Nouveau...`
2. Dans la fen√™tre qui s'ouvre, choisissez `Projet`
3. S√©lectionnez `Application Daemon (Service)`
4. Cliquez sur `OK`

Lazarus g√©n√®re automatiquement la structure de base :
- Un fichier projet (.lpr)
- Une unit√© pour le daemon
- Un mapper pour lier le tout

### √âtape 2 : Comprendre la structure g√©n√©r√©e

Voici ce que Lazarus a cr√©√© pour vous :

**Fichier projet (MonService.lpr) :**
```pascal
program MonService;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  DaemonApp, lazdaemonapp, daemonmapper, Unit1;

begin
  Application.Title := 'Mon Premier Service';
  Application.Initialize;

  // Cr√©e et enregistre le mapper
  Application.Run;
end.
```

**Unit√© du daemon (Unit1.pas) :**
```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, DaemonApp;

type
  TDaemon1 = class(TCustomDaemon)
    procedure DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);
    procedure DataModuleStop(Sender: TCustomDaemon; var OK: Boolean);
    procedure DataModuleExecute(Sender: TCustomDaemon);
  private
    // Variables priv√©es du service
  public
    // M√©thodes publiques du service
  end;

var
  Daemon1: TDaemon1;

implementation

procedure TDaemon1.DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);
begin
  // Code d'initialisation du service
  // Mettre OK √† False emp√™che le d√©marrage
  OK := True;
end;

procedure TDaemon1.DataModuleStop(Sender: TCustomDaemon; var OK: Boolean);
begin
  // Code de nettoyage du service
  OK := True;
end;

procedure TDaemon1.DataModuleExecute(Sender: TCustomDaemon);
begin
  // Boucle principale du service
  while not Terminated do
  begin
    // Votre code ici
    Sleep(1000); // Pause d'1 seconde pour ne pas surcharger le CPU
  end;
end;

end.
```

### √âtape 3 : Les √©v√©nements principaux du service

Chaque service a des √©v√©nements cl√©s que vous devez comprendre :

#### OnStart (DataModuleStart)
```pascal
procedure TDaemon1.DataModuleStart(Sender: TCustomDaemon; var OK: Boolean);
begin
  // Appel√© quand le service d√©marre
  // Utilis√© pour :
  // - Initialiser les variables
  // - Ouvrir les connexions (base de donn√©es, r√©seau)
  // - Cr√©er les threads de travail
  // - Charger la configuration

  try
    // Exemple : Charger la configuration
    LoadConfiguration;

    // Exemple : Se connecter √† une base de donn√©es
    ConnectToDatabase;

    OK := True; // Le service peut d√©marrer
  except
    on E: Exception do
    begin
      LogError('Erreur au d√©marrage : ' + E.Message);
      OK := False; // Emp√™che le d√©marrage du service
    end;
  end;
end;
```

#### OnExecute (DataModuleExecute)
```pascal
procedure TDaemon1.DataModuleExecute(Sender: TCustomDaemon);
begin
  // Boucle principale du service
  // IMPORTANT : Cette m√©thode doit :
  // - V√©rifier r√©guli√®rement Terminated
  // - Ne pas bloquer ind√©finiment
  // - G√©rer les erreurs proprement

  while not Terminated do
  begin
    try
      // Faire le travail du service
      ProcessTasks;

      // Pause pour ne pas consommer 100% CPU
      // Utilisez CheckSynchronize pour les threads
      Sleep(100);
      CheckSynchronize(100);
    except
      on E: Exception do
        LogError('Erreur dans Execute : ' + E.Message);
    end;
  end;
end;
```

#### OnStop (DataModuleStop)
```pascal
procedure TDaemon1.DataModuleStop(Sender: TCustomDaemon; var OK: Boolean);
begin
  // Appel√© quand le service s'arr√™te
  // Utilis√© pour :
  // - Sauvegarder l'√©tat
  // - Fermer les connexions
  // - Lib√©rer les ressources
  // - Arr√™ter les threads

  try
    // Signaler aux threads de s'arr√™ter
    StopAllThreads;

    // Fermer les connexions
    DisconnectFromDatabase;

    // Sauvegarder l'√©tat si n√©cessaire
    SaveState;

    OK := True;
  except
    on E: Exception do
    begin
      LogError('Erreur √† l''arr√™t : ' + E.Message);
      OK := True; // On arr√™te quand m√™me
    end;
  end;
end;
```

## M√©thode 2 : Cr√©ation manuelle (Pour mieux comprendre)

Si vous voulez comprendre ce qui se passe sous le capot, cr√©ons un service manuellement :

### Structure compl√®te d'un service manuel

```pascal
program ServiceManuel;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}cthreads,{$ENDIF}
  Classes, SysUtils, DaemonApp;

type
  { TMonService }
  TMonService = class(TCustomDaemon)
  private
    FLogFile: TextFile;
    procedure InitializeLog;
    procedure WriteLog(const Msg: string);
    procedure FinalizeLog;
  public
    function Start: Boolean; override;
    function Stop: Boolean; override;
    function Execute: Boolean; override;
  end;

  { TMonServiceMapper }
  TMonServiceMapper = class(TCustomDaemonMapper)
  end;

var
  MonService: TMonService;

{ TMonService }

procedure TMonService.InitializeLog;
var
  LogFileName: string;
begin
  // Cr√©er un fichier log dans le dossier du service
  LogFileName := ExtractFilePath(ParamStr(0)) + 'service.log';
  AssignFile(FLogFile, LogFileName);

  if FileExists(LogFileName) then
    Append(FLogFile)
  else
    Rewrite(FLogFile);

  WriteLog('=== Service initialis√© : ' + DateTimeToStr(Now) + ' ===');
end;

procedure TMonService.WriteLog(const Msg: string);
begin
  WriteLn(FLogFile, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' - ' + Msg);
  Flush(FLogFile); // Force l'√©criture imm√©diate
end;

procedure TMonService.FinalizeLog;
begin
  WriteLog('=== Service arr√™t√© : ' + DateTimeToStr(Now) + ' ===');
  CloseFile(FLogFile);
end;

function TMonService.Start: Boolean;
begin
  Result := True;
  try
    InitializeLog;
    WriteLog('D√©marrage du service...');

    // Initialisation de vos composants
    // Par exemple : connexion base de donn√©es, ouverture de ports, etc.

    WriteLog('Service d√©marr√© avec succ√®s');
  except
    on E: Exception do
    begin
      WriteLog('Erreur au d√©marrage : ' + E.Message);
      Result := False;
    end;
  end;
end;

function TMonService.Stop: Boolean;
begin
  Result := True;
  try
    WriteLog('Arr√™t du service...');

    // Nettoyage : fermeture des connexions, sauvegarde, etc.

    FinalizeLog;
  except
    on E: Exception do
    begin
      // En cas d'erreur, on essaie quand m√™me de fermer le log
      try
        WriteLog('Erreur lors de l''arr√™t : ' + E.Message);
        FinalizeLog;
      except
        // Ignorer les erreurs du log
      end;
    end;
  end;
end;

function TMonService.Execute: Boolean;
var
  Counter: Integer;
begin
  Result := True;
  Counter := 0;

  while not Terminated do
  begin
    try
      Inc(Counter);

      // Exemple de t√¢che : √©crire dans le log toutes les 10 secondes
      if (Counter mod 10) = 0 then
      begin
        WriteLog('Service en cours d''ex√©cution (compteur: ' + IntToStr(Counter) + ')');

        // Ici, vous mettriez votre vraie logique m√©tier
        // Par exemple : v√©rifier des fichiers, traiter des donn√©es, etc.
      end;

      // Pause d'1 seconde
      Sleep(1000);

    except
      on E: Exception do
      begin
        WriteLog('Erreur dans Execute : ' + E.Message);
        // Continuer malgr√© l'erreur
      end;
    end;
  end;
end;

{ Programme principal }

begin
  // Cr√©er l'application daemon
  Application := TCustomDaemonApplication.Create(nil);
  Application.Title := 'Mon Service Manuel';

  // Cr√©er et enregistrer le mapper
  with TMonServiceMapper.Create(nil) do
  begin
    DaemonDef.Name := 'MonServiceManuel';
    DaemonDef.DisplayName := 'Mon Service Manuel de Test';
    DaemonDef.Description := 'Un service cr√©√© manuellement pour comprendre';
    DaemonDef.DaemonClass := TMonService;
  end;

  // Lancer l'application
  Application.Initialize;
  Application.Run;
  Application.Free;
end.
```

## Ajout de fonctionnalit√©s essentielles

### 1. Journalisation (Logging)

Un service DOIT avoir un syst√®me de logs robuste :

```pascal
type
  TLogLevel = (llDebug, llInfo, llWarning, llError, llCritical);

  TServiceLogger = class
  private
    FLogFile: TextFile;
    FLogLevel: TLogLevel;
    FCriticalSection: TCriticalSection; // Pour thread-safety

    function LevelToString(Level: TLogLevel): string;
  public
    constructor Create(const FileName: string);
    destructor Destroy; override;

    procedure Log(Level: TLogLevel; const Message: string);
    procedure LogException(E: Exception; const Context: string = '');
  end;

implementation

constructor TServiceLogger.Create(const FileName: string);
begin
  inherited Create;
  FCriticalSection := TCriticalSection.Create;

  AssignFile(FLogFile, FileName);
  if FileExists(FileName) then
    Append(FLogFile)
  else
    Rewrite(FLogFile);

  FLogLevel := llInfo; // Niveau par d√©faut
end;

destructor TServiceLogger.Destroy;
begin
  CloseFile(FLogFile);
  FCriticalSection.Free;
  inherited;
end;

function TServiceLogger.LevelToString(Level: TLogLevel): string;
begin
  case Level of
    llDebug:    Result := 'DEBUG';
    llInfo:     Result := 'INFO';
    llWarning:  Result := 'WARN';
    llError:    Result := 'ERROR';
    llCritical: Result := 'CRITICAL';
  end;
end;

procedure TServiceLogger.Log(Level: TLogLevel; const Message: string);
var
  LogEntry: string;
begin
  if Level < FLogLevel then
    Exit; // Ne pas logger si en dessous du niveau configur√©

  LogEntry := Format('%s [%s] %s',
    [FormatDateTime('yyyy-mm-dd hh:nn:ss.zzz', Now),
     LevelToString(Level),
     Message]);

  // Thread-safe
  FCriticalSection.Enter;
  try
    WriteLn(FLogFile, LogEntry);
    Flush(FLogFile);
  finally
    FCriticalSection.Leave;
  end;
end;

procedure TServiceLogger.LogException(E: Exception; const Context: string);
var
  Msg: string;
begin
  Msg := Format('Exception %s: %s', [E.ClassName, E.Message]);
  if Context <> '' then
    Msg := Format('%s (Context: %s)', [Msg, Context]);

  Log(llError, Msg);
end;
```

### 2. Configuration du service

Un service doit pouvoir lire sa configuration :

```pascal
type
  TServiceConfig = class
  private
    FIniFile: TIniFile;
    FConfigFile: string;

    // Param√®tres de configuration
    FPollingInterval: Integer;
    FMaxRetries: Integer;
    FLogLevel: TLogLevel;
    FWorkingDirectory: string;
  public
    constructor Create(const ConfigFile: string);
    destructor Destroy; override;

    procedure Load;
    procedure Save;
    procedure SetDefaults;

    property PollingInterval: Integer read FPollingInterval write FPollingInterval;
    property MaxRetries: Integer read FMaxRetries write FMaxRetries;
    property LogLevel: TLogLevel read FLogLevel write FLogLevel;
    property WorkingDirectory: string read FWorkingDirectory write FWorkingDirectory;
  end;

implementation

constructor TServiceConfig.Create(const ConfigFile: string);
begin
  inherited Create;
  FConfigFile := ConfigFile;

  // Si le fichier n'existe pas, le cr√©er avec les valeurs par d√©faut
  if not FileExists(FConfigFile) then
  begin
    SetDefaults;
    Save;
  end
  else
    Load;
end;

procedure TServiceConfig.SetDefaults;
begin
  FPollingInterval := 5000; // 5 secondes
  FMaxRetries := 3;
  FLogLevel := llInfo;
  FWorkingDirectory := ExtractFilePath(ParamStr(0));
end;

procedure TServiceConfig.Load;
begin
  FIniFile := TIniFile.Create(FConfigFile);
  try
    FPollingInterval := FIniFile.ReadInteger('General', 'PollingInterval', 5000);
    FMaxRetries := FIniFile.ReadInteger('General', 'MaxRetries', 3);
    FLogLevel := TLogLevel(FIniFile.ReadInteger('General', 'LogLevel', Ord(llInfo)));
    FWorkingDirectory := FIniFile.ReadString('General', 'WorkingDirectory',
                                             ExtractFilePath(ParamStr(0)));
  finally
    FIniFile.Free;
  end;
end;

procedure TServiceConfig.Save;
begin
  FIniFile := TIniFile.Create(FConfigFile);
  try
    FIniFile.WriteInteger('General', 'PollingInterval', FPollingInterval);
    FIniFile.WriteInteger('General', 'MaxRetries', FMaxRetries);
    FIniFile.WriteInteger('General', 'LogLevel', Ord(FLogLevel));
    FIniFile.WriteString('General', 'WorkingDirectory', FWorkingDirectory);
  finally
    FIniFile.Free;
  end;
end;
```

### 3. Gestion des threads pour les t√¢ches longues

Les services utilisent souvent des threads pour les t√¢ches :

```pascal
type
  TWorkerThread = class(TThread)
  private
    FLogger: TServiceLogger;
    FTerminateEvent: TEvent;
    FWorkInterval: Integer;
  protected
    procedure Execute; override;
    procedure DoWork; virtual;
  public
    constructor Create(Logger: TServiceLogger; WorkInterval: Integer);
    destructor Destroy; override;

    procedure RequestTerminate;
  end;

implementation

constructor TWorkerThread.Create(Logger: TServiceLogger; WorkInterval: Integer);
begin
  inherited Create(True); // Cr√©√© suspendu
  FLogger := Logger;
  FWorkInterval := WorkInterval;
  FTerminateEvent := TEvent.Create(nil, False, False, '');
  FreeOnTerminate := False;
end;

destructor TWorkerThread.Destroy;
begin
  FTerminateEvent.Free;
  inherited;
end;

procedure TWorkerThread.RequestTerminate;
begin
  Terminate;
  FTerminateEvent.SetEvent; // R√©veiller le thread s'il est en attente
end;

procedure TWorkerThread.Execute;
begin
  FLogger.Log(llInfo, 'Thread de travail d√©marr√©');

  while not Terminated do
  begin
    try
      DoWork;

      // Attendre avec possibilit√© d'interruption
      if FTerminateEvent.WaitFor(FWorkInterval) = wrSignaled then
        Break;

    except
      on E: Exception do
      begin
        FLogger.LogException(E, 'WorkerThread.Execute');
        Sleep(1000); // Pause en cas d'erreur pour √©viter les boucles infinies
      end;
    end;
  end;

  FLogger.Log(llInfo, 'Thread de travail arr√™t√©');
end;

procedure TWorkerThread.DoWork;
begin
  // √Ä surcharger dans les classes d√©riv√©es
  // Exemple :
  FLogger.Log(llDebug, 'Ex√©cution du travail...');
end;
```

## Service complet avec surveillance de dossier

Voici un exemple concret d'un service qui surveille un dossier :

```pascal
unit FolderWatcherService;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, DaemonApp, IniFiles;

type
  TFolderWatcher = class(TCustomDaemon)
  private
    FWatchFolder: string;
    FProcessedFolder: string;
    FErrorFolder: string;
    FLogger: TServiceLogger;
    FConfig: TServiceConfig;

    procedure ProcessFile(const FileName: string);
    procedure MoveFile(const Source, DestFolder: string);
    procedure ScanFolder;
  public
    function Start: Boolean; override;
    function Stop: Boolean; override;
    function Execute: Boolean; override;
  end;

implementation

function TFolderWatcher.Start: Boolean;
var
  ConfigFile: string;
begin
  Result := True;

  try
    // Initialiser la configuration
    ConfigFile := ExtractFilePath(ParamStr(0)) + 'config.ini';
    FConfig := TServiceConfig.Create(ConfigFile);

    // Initialiser le logger
    FLogger := TServiceLogger.Create(
      ExtractFilePath(ParamStr(0)) + 'service.log');
    FLogger.Log(llInfo, 'Service de surveillance de dossier d√©marr√©');

    // Lire les dossiers depuis la configuration
    FWatchFolder := FConfig.IniFile.ReadString('Folders', 'Watch', 'C:\Watch');
    FProcessedFolder := FConfig.IniFile.ReadString('Folders', 'Processed', 'C:\Processed');
    FErrorFolder := FConfig.IniFile.ReadString('Folders', 'Error', 'C:\Error');

    // Cr√©er les dossiers s'ils n'existent pas
    ForceDirectories(FWatchFolder);
    ForceDirectories(FProcessedFolder);
    ForceDirectories(FErrorFolder);

    FLogger.Log(llInfo, Format('Surveillance du dossier : %s', [FWatchFolder]));

  except
    on E: Exception do
    begin
      if Assigned(FLogger) then
        FLogger.LogException(E, 'Start');
      Result := False;
    end;
  end;
end;

function TFolderWatcher.Stop: Boolean;
begin
  Result := True;

  try
    FLogger.Log(llInfo, 'Arr√™t du service de surveillance');

    FreeAndNil(FConfig);
    FreeAndNil(FLogger);

  except
    on E: Exception do
    begin
      // Essayer de logger si possible
      if Assigned(FLogger) then
        FLogger.LogException(E, 'Stop');
    end;
  end;
end;

function TFolderWatcher.Execute: Boolean;
var
  ScanInterval: Integer;
begin
  Result := True;
  ScanInterval := FConfig.PollingInterval;

  while not Terminated do
  begin
    try
      // Scanner le dossier pour de nouveaux fichiers
      ScanFolder;

      // Attendre avant le prochain scan
      Sleep(ScanInterval);

    except
      on E: Exception do
      begin
        FLogger.LogException(E, 'Execute');
        Sleep(5000); // Pause plus longue en cas d'erreur
      end;
    end;
  end;
end;

procedure TFolderWatcher.ScanFolder;
var
  SearchRec: TSearchRec;
  FilePath: string;
begin
  FLogger.Log(llDebug, 'Scan du dossier en cours...');

  if FindFirst(FWatchFolder + '\*.*', faAnyFile, SearchRec) = 0 then
  begin
    try
      repeat
        // Ignorer les dossiers et fichiers sp√©ciaux
        if (SearchRec.Name = '.') or (SearchRec.Name = '..') or
           ((SearchRec.Attr and faDirectory) <> 0) then
          Continue;

        FilePath := FWatchFolder + '\' + SearchRec.Name;

        // V√©rifier que le fichier n'est pas en cours d'√©criture
        // (attendre qu'il soit stable)
        if FileAge(FilePath) < (Now - (10 * OneSecond)) then
        begin
          FLogger.Log(llInfo, Format('Nouveau fichier d√©tect√© : %s', [SearchRec.Name]));
          ProcessFile(FilePath);
        end;

      until FindNext(SearchRec) <> 0;
    finally
      FindClose(SearchRec);
    end;
  end;
end;

procedure TFolderWatcher.ProcessFile(const FileName: string);
begin
  try
    FLogger.Log(llInfo, Format('Traitement du fichier : %s', [ExtractFileName(FileName)]));

    // Ici, vous mettriez votre logique de traitement
    // Par exemple : analyser le contenu, convertir le format, etc.

    // Simulation d'un traitement
    Sleep(1000);

    // Si tout va bien, d√©placer vers Processed
    MoveFile(FileName, FProcessedFolder);
    FLogger.Log(llInfo, 'Fichier trait√© avec succ√®s');

  except
    on E: Exception do
    begin
      FLogger.LogException(E, Format('ProcessFile(%s)', [FileName]));
      // En cas d'erreur, d√©placer vers Error
      try
        MoveFile(FileName, FErrorFolder);
      except
        // Si on ne peut pas d√©placer, au moins logger
        FLogger.Log(llError, 'Impossible de d√©placer le fichier en erreur');
      end;
    end;
  end;
end;

procedure TFolderWatcher.MoveFile(const Source, DestFolder: string);
var
  DestFile: string;
  Counter: Integer;
begin
  DestFile := DestFolder + '\' + ExtractFileName(Source);

  // Si le fichier existe d√©j√†, ajouter un compteur
  Counter := 1;
  while FileExists(DestFile) do
  begin
    DestFile := Format('%s\%s_%d%s',
      [DestFolder,
       ChangeFileExt(ExtractFileName(Source), ''),
       Counter,
       ExtractFileExt(Source)]);
    Inc(Counter);
  end;

  if not RenameFile(Source, DestFile) then
    raise Exception.CreateFmt('Impossible de d√©placer %s vers %s',
      [Source, DestFile]);
end;

end.
```

## Installation et test du service

### Installation en ligne de commande

Votre service compil√© peut √™tre install√© de plusieurs fa√ßons :

```batch
REM Installation simple
MonService.exe /install

REM Installation avec d√©marrage automatique
MonService.exe /install /auto

REM D√©sinstallation
MonService.exe /uninstall

REM Ex√©cution en mode console (pour debug)
MonService.exe /run
```

### Code pour g√©rer les param√®tres de ligne de commande

```pascal
program ServiceAvecParams;

uses
  Classes, SysUtils, DaemonApp;

procedure ProcessCommandLine;
var
  i: Integer;
  Param: string;
begin
  for i := 1 to ParamCount do
  begin
    Param := LowerCase(ParamStr(i));

    if (Param = '/run') or (Param = '-run') then
    begin
      // Mode console pour debug
      WriteLn('Ex√©cution en mode console...');
      WriteLn('Appuyez sur Ctrl+C pour arr√™ter');

      // Cr√©er et ex√©cuter le service manuellement
      with TMonService.Create(nil) do
      try
        Start;
        Execute;
        Stop;
      finally
        Free;
      end;

      Halt(0); // Terminer le programme
    end
    else if (Param = '/help') or (Param = '-h') then
    begin
      WriteLn('Utilisation :');
      WriteLn('  ', ExtractFileName(ParamStr(0)), ' [options]');
      WriteLn('Options :');
      WriteLn('  /install    : Installer le service');
      WriteLn('  /uninstall  : D√©sinstaller le service');
      WriteLn('  /run        : Ex√©cuter en mode console (debug)');
      WriteLn('  /help       : Afficher cette aide');
      Halt(0);
    end;
  end;

  // Si pas de param√®tre sp√©cial, laisser DaemonApp g√©rer
end;

begin
  ProcessCommandLine;

  // Code normal du service
  Application := TCustomDaemonApplication.Create(nil);
  Application.Initialize;
  Application.Run;
  Application.Free;
end;
```

### Script PowerShell pour g√©rer le service

```powershell
# InstallService.ps1
param(
    [Parameter(Mandatory=$false)]
    [string]$Action = "status"
)

$ServiceName = "MonServiceFPC"
$ServicePath = "$PSScriptRoot\MonService.exe"

switch ($Action) {
    "install" {
        Write-Host "Installation du service..." -ForegroundColor Green
        & $ServicePath /install

        # Configurer le service
        sc.exe config $ServiceName start= auto
        sc.exe failure $ServiceName reset= 86400 actions= restart/60000/restart/60000/restart/60000

        Write-Host "Service install√© et configur√©" -ForegroundColor Green
    }

    "start" {
        Write-Host "D√©marrage du service..." -ForegroundColor Green
        Start-Service $ServiceName
    }

    "stop" {
        Write-Host "Arr√™t du service..." -ForegroundColor Yellow
        Stop-Service $ServiceName
    }

    "uninstall" {
        Write-Host "D√©sinstallation du service..." -ForegroundColor Red
        Stop-Service $ServiceName -ErrorAction SilentlyContinue
        & $ServicePath /uninstall
    }

    "status" {
        Get-Service $ServiceName | Format-Table -AutoSize
    }

    "logs" {
        Get-Content "$PSScriptRoot\service.log" -Tail 50
    }
}
```

## D√©bogage d'un service

### Mode debug int√©gr√©

Ajoutez un mode debug √† votre service :

```pascal
type
  TMonService = class(TCustomDaemon)
  private
    FDebugMode: Boolean;

    procedure DebugOutput(const Msg: string);
  public
    constructor Create(AOwner: TComponent); override;
  end;

constructor TMonService.Create(AOwner: TComponent);
begin
  inherited;

  // D√©tection du mode debug
  FDebugMode := FindCmdLineSwitch('debug', ['-', '/'], True) or
                IsDebuggerPresent;
end;

procedure TMonService.DebugOutput(const Msg: string);
begin
  if FDebugMode then
  begin
    if IsConsole then
      WriteLn('[DEBUG] ', Msg)
    else
      OutputDebugString(PChar('[DEBUG] ' + Msg));
  end;

  // Logger aussi dans le fichier
  FLogger.Log(llDebug, Msg);
end;
```

### Attachement au service en cours d'ex√©cution

Pour d√©boguer un service d√©j√† d√©marr√© :

1. Compilez avec les informations de debug
2. D√©marrez le service normalement
3. Dans Lazarus : `Run` ‚Üí `Attach to Process`
4. Trouvez votre service dans la liste
5. Mettez des breakpoints

## Gestion des erreurs et r√©cup√©ration

### Strat√©gie de r√©cup√©ration automatique

```pascal
type
  TRetryManager = class
  private
    FMaxRetries: Integer;
    FRetryDelay: Integer;
    FRetryCount: Integer;
    FLastError: TDateTime;
    FLogger: TServiceLogger;

    procedure ResetCounterIfNeeded;
  public
    constructor Create(Logger: TServiceLogger; MaxRetries, RetryDelayMs: Integer);

    function ShouldRetry: Boolean;
    procedure RecordSuccess;
    procedure RecordFailure(const ErrorMsg: string);
    procedure WaitBeforeRetry;
  end;

implementation

constructor TRetryManager.Create(Logger: TServiceLogger; MaxRetries, RetryDelayMs: Integer);
begin
  inherited Create;
  FLogger := Logger;
  FMaxRetries := MaxRetries;
  FRetryDelay := RetryDelayMs;
  FRetryCount := 0;
  FLastError := 0;
end;

procedure TRetryManager.ResetCounterIfNeeded;
begin
  // R√©initialiser le compteur si la derni√®re erreur date de plus d'1 heure
  if (FLastError > 0) and (Now - FLastError > OneHour) then
  begin
    FRetryCount := 0;
    FLogger.Log(llInfo, 'Compteur de tentatives r√©initialis√© (derni√®re erreur > 1h)');
  end;
end;

function TRetryManager.ShouldRetry: Boolean;
begin
  ResetCounterIfNeeded;
  Result := FRetryCount < FMaxRetries;

  if not Result then
    FLogger.Log(llError, Format('Nombre maximum de tentatives atteint (%d)', [FMaxRetries]));
end;

procedure TRetryManager.RecordSuccess;
begin
  if FRetryCount > 0 then
  begin
    FLogger.Log(llInfo, Format('Op√©ration r√©ussie apr√®s %d tentative(s)', [FRetryCount]));
    FRetryCount := 0;
    FLastError := 0;
  end;
end;

procedure TRetryManager.RecordFailure(const ErrorMsg: string);
begin
  Inc(FRetryCount);
  FLastError := Now;

  FLogger.Log(llWarning, Format('Tentative %d/%d √©chou√©e : %s',
    [FRetryCount, FMaxRetries, ErrorMsg]));
end;

procedure TRetryManager.WaitBeforeRetry;
var
  WaitTime: Integer;
begin
  // Attente exponentielle : 1s, 2s, 4s, 8s...
  WaitTime := FRetryDelay * (1 shl (FRetryCount - 1));
  if WaitTime > 60000 then // Maximum 1 minute
    WaitTime := 60000;

  FLogger.Log(llDebug, Format('Attente de %d ms avant nouvelle tentative', [WaitTime]));
  Sleep(WaitTime);
end;
```

### Utilisation du gestionnaire de tentatives

```pascal
procedure TMonService.ConnectToDatabase;
var
  RetryManager: TRetryManager;
begin
  RetryManager := TRetryManager.Create(FLogger, 3, 1000);
  try
    repeat
      try
        // Tentative de connexion
        FDatabase.Connect;

        // Si r√©ussi, enregistrer le succ√®s
        RetryManager.RecordSuccess;
        FLogger.Log(llInfo, 'Connexion √† la base de donn√©es √©tablie');
        Break; // Sortir de la boucle

      except
        on E: Exception do
        begin
          RetryManager.RecordFailure(E.Message);

          if RetryManager.ShouldRetry then
            RetryManager.WaitBeforeRetry
          else
            raise; // Propager l'exception apr√®s toutes les tentatives
        end;
      end;
    until False;
  finally
    RetryManager.Free;
  end;
end;
```

## Surveillance de l'√©tat du service (Health Monitoring)

### Syst√®me de sant√© du service

```pascal
type
  THealthStatus = (hsHealthy, hsWarning, hsCritical, hsUnknown);

  THealthCheck = class
  private
    FName: string;
    FLastCheck: TDateTime;
    FStatus: THealthStatus;
    FMessage: string;
    FCheckInterval: Integer; // en secondes
  public
    constructor Create(const AName: string; AInterval: Integer);

    function NeedsCheck: Boolean;
    procedure UpdateStatus(AStatus: THealthStatus; const AMessage: string);

    property Name: string read FName;
    property Status: THealthStatus read FStatus;
    property Message: string read FMessage;
    property LastCheck: TDateTime read FLastCheck;
  end;

  THealthMonitor = class
  private
    FChecks: TList;
    FLogger: TServiceLogger;
    FOverallStatus: THealthStatus;

    procedure CalculateOverallStatus;
  public
    constructor Create(Logger: TServiceLogger);
    destructor Destroy; override;

    procedure RegisterCheck(Check: THealthCheck);
    procedure RunChecks;
    procedure WriteHealthReport;

    property OverallStatus: THealthStatus read FOverallStatus;
  end;

implementation

{ THealthCheck }

constructor THealthCheck.Create(const AName: string; AInterval: Integer);
begin
  inherited Create;
  FName := AName;
  FCheckInterval := AInterval;
  FStatus := hsUnknown;
  FMessage := 'Pas encore v√©rifi√©';
  FLastCheck := 0;
end;

function THealthCheck.NeedsCheck: Boolean;
begin
  Result := (FLastCheck = 0) or
            ((Now - FLastCheck) * SecsPerDay > FCheckInterval);
end;

procedure THealthCheck.UpdateStatus(AStatus: THealthStatus; const AMessage: string);
begin
  FStatus := AStatus;
  FMessage := AMessage;
  FLastCheck := Now;
end;

{ THealthMonitor }

constructor THealthMonitor.Create(Logger: TServiceLogger);
begin
  inherited Create;
  FLogger := Logger;
  FChecks := TList.Create;
  FOverallStatus := hsUnknown;
end;

destructor THealthMonitor.Destroy;
var
  i: Integer;
begin
  for i := 0 to FChecks.Count - 1 do
    THealthCheck(FChecks[i]).Free;
  FChecks.Free;
  inherited;
end;

procedure THealthMonitor.RegisterCheck(Check: THealthCheck);
begin
  FChecks.Add(Check);
  FLogger.Log(llInfo, Format('Health check enregistr√© : %s', [Check.Name]));
end;

procedure THealthMonitor.CalculateOverallStatus;
var
  i: Integer;
  Check: THealthCheck;
  HasCritical, HasWarning: Boolean;
begin
  HasCritical := False;
  HasWarning := False;

  for i := 0 to FChecks.Count - 1 do
  begin
    Check := THealthCheck(FChecks[i]);
    case Check.Status of
      hsCritical: HasCritical := True;
      hsWarning: HasWarning := True;
    end;
  end;

  if HasCritical then
    FOverallStatus := hsCritical
  else if HasWarning then
    FOverallStatus := hsWarning
  else
    FOverallStatus := hsHealthy;
end;

procedure THealthMonitor.RunChecks;
var
  i: Integer;
  Check: THealthCheck;
begin
  for i := 0 to FChecks.Count - 1 do
  begin
    Check := THealthCheck(FChecks[i]);
    if Check.NeedsCheck then
    begin
      // Ici, vous appelleriez la m√©thode de v√©rification sp√©cifique
      // Pour l'exemple, on simule
      FLogger.Log(llDebug, Format('Ex√©cution du check : %s', [Check.Name]));
    end;
  end;

  CalculateOverallStatus;
end;

procedure THealthMonitor.WriteHealthReport;
var
  i: Integer;
  Check: THealthCheck;
  StatusStr: string;
begin
  FLogger.Log(llInfo, '=== Rapport de sant√© du service ===');

  case FOverallStatus of
    hsHealthy: StatusStr := 'SAIN';
    hsWarning: StatusStr := 'AVERTISSEMENT';
    hsCritical: StatusStr := 'CRITIQUE';
    hsUnknown: StatusStr := 'INCONNU';
  end;

  FLogger.Log(llInfo, Format('√âtat global : %s', [StatusStr]));

  for i := 0 to FChecks.Count - 1 do
  begin
    Check := THealthCheck(FChecks[i]);
    case Check.Status of
      hsHealthy: StatusStr := '‚úì';
      hsWarning: StatusStr := '‚ö†';
      hsCritical: StatusStr := '‚úó';
      hsUnknown: StatusStr := '?';
    end;

    FLogger.Log(llInfo, Format('  [%s] %s : %s',
      [StatusStr, Check.Name, Check.Message]));
  end;

  FLogger.Log(llInfo, '================================');
end;
```

### Impl√©mentation des v√©rifications de sant√©

```pascal
type
  TDatabaseHealthCheck = class(THealthCheck)
  private
    FDatabase: TDatabase;
  public
    constructor Create(Database: TDatabase);
    procedure PerformCheck;
  end;

  TDiskSpaceHealthCheck = class(THealthCheck)
  private
    FPath: string;
    FMinimumGB: Integer;
  public
    constructor Create(const Path: string; MinimumGB: Integer);
    procedure PerformCheck;
  end;

  TMemoryHealthCheck = class(THealthCheck)
  private
    FMaxMemoryMB: Integer;
  public
    constructor Create(MaxMemoryMB: Integer);
    procedure PerformCheck;
  end;

implementation

{ TDatabaseHealthCheck }

constructor TDatabaseHealthCheck.Create(Database: TDatabase);
begin
  inherited Create('Base de donn√©es', 60); // Check toutes les 60 secondes
  FDatabase := Database;
end;

procedure TDatabaseHealthCheck.PerformCheck;
begin
  try
    if not FDatabase.Connected then
    begin
      FDatabase.Connect;
    end;

    // Test avec une requ√™te simple
    FDatabase.ExecuteQuery('SELECT 1');

    UpdateStatus(hsHealthy, 'Connexion OK');
  except
    on E: Exception do
      UpdateStatus(hsCritical, 'Erreur : ' + E.Message);
  end;
end;

{ TDiskSpaceHealthCheck }

constructor TDiskSpaceHealthCheck.Create(const Path: string; MinimumGB: Integer);
begin
  inherited Create('Espace disque', 300); // Check toutes les 5 minutes
  FPath := Path;
  FMinimumGB := MinimumGB;
end;

procedure TDiskSpaceHealthCheck.PerformCheck;
var
  FreeSpace, TotalSpace: Int64;
  FreeGB: Double;
begin
  if GetDiskFreeSpaceEx(PChar(FPath), FreeSpace, TotalSpace, nil) then
  begin
    FreeGB := FreeSpace / (1024 * 1024 * 1024);

    if FreeGB < FMinimumGB then
      UpdateStatus(hsCritical, Format('%.1f GB libre (minimum: %d GB)',
        [FreeGB, FMinimumGB]))
    else if FreeGB < (FMinimumGB * 2) then
      UpdateStatus(hsWarning, Format('%.1f GB libre', [FreeGB]))
    else
      UpdateStatus(hsHealthy, Format('%.1f GB libre', [FreeGB]));
  end
  else
    UpdateStatus(hsCritical, 'Impossible de v√©rifier l''espace disque');
end;

{ TMemoryHealthCheck }

constructor TMemoryHealthCheck.Create(MaxMemoryMB: Integer);
begin
  inherited Create('Utilisation m√©moire', 30); // Check toutes les 30 secondes
  FMaxMemoryMB := MaxMemoryMB;
end;

procedure TMemoryHealthCheck.PerformCheck;
var
  MemoryStatus: TMemoryStatusEx;
  UsedMB: Integer;
  ProcessMemory: SIZE_T;
begin
  // M√©moire du processus
  ProcessMemory := GetProcessMemoryInfo;
  UsedMB := ProcessMemory div (1024 * 1024);

  if UsedMB > FMaxMemoryMB then
    UpdateStatus(hsCritical, Format('%d MB utilis√©s (max: %d MB)',
      [UsedMB, FMaxMemoryMB]))
  else if UsedMB > (FMaxMemoryMB * 80 div 100) then
    UpdateStatus(hsWarning, Format('%d MB utilis√©s', [UsedMB]))
  else
    UpdateStatus(hsHealthy, Format('%d MB utilis√©s', [UsedMB]));
end;
```

## Communication avec le service

### Interface HTTP pour le monitoring

```pascal
type
  TServiceHttpServer = class(TThread)
  private
    FPort: Integer;
    FLogger: TServiceLogger;
    FHealthMonitor: THealthMonitor;
    FServer: TIdHTTPServer;

    procedure HandleRequest(AContext: TIdContext;
      ARequestInfo: TIdHTTPRequestInfo;
      AResponseInfo: TIdHTTPResponseInfo);
  protected
    procedure Execute; override;
  public
    constructor Create(Port: Integer; Logger: TServiceLogger;
      HealthMonitor: THealthMonitor);
    destructor Destroy; override;
  end;

implementation

uses
  IdHTTP, IdCustomHTTPServer, fpjson, jsonparser;

constructor TServiceHttpServer.Create(Port: Integer; Logger: TServiceLogger;
  HealthMonitor: THealthMonitor);
begin
  inherited Create(True);
  FPort := Port;
  FLogger := Logger;
  FHealthMonitor := HealthMonitor;
  FreeOnTerminate := False;
end;

procedure TServiceHttpServer.Execute;
begin
  FServer := TIdHTTPServer.Create(nil);
  try
    FServer.DefaultPort := FPort;
    FServer.OnCommandGet := @HandleRequest;

    FLogger.Log(llInfo, Format('Serveur HTTP d√©marr√© sur le port %d', [FPort]));
    FServer.Active := True;

    while not Terminated do
      Sleep(100);

  finally
    FServer.Active := False;
    FServer.Free;
    FLogger.Log(llInfo, 'Serveur HTTP arr√™t√©');
  end;
end;

procedure TServiceHttpServer.HandleRequest(AContext: TIdContext;
  ARequestInfo: TIdHTTPRequestInfo; AResponseInfo: TIdHTTPResponseInfo);
var
  JsonResponse: TJSONObject;
  JsonChecks: TJSONArray;
  i: Integer;
  Check: THealthCheck;
begin
  try
    if ARequestInfo.Document = '/health' then
    begin
      // Endpoint de sant√©
      FHealthMonitor.RunChecks;

      JsonResponse := TJSONObject.Create;
      try
        case FHealthMonitor.OverallStatus of
          hsHealthy:
            begin
              JsonResponse.Add('status', 'healthy');
              AResponseInfo.ResponseNo := 200;
            end;
          hsWarning:
            begin
              JsonResponse.Add('status', 'warning');
              AResponseInfo.ResponseNo := 200;
            end;
          hsCritical:
            begin
              JsonResponse.Add('status', 'critical');
              AResponseInfo.ResponseNo := 503; // Service Unavailable
            end;
          else
            begin
              JsonResponse.Add('status', 'unknown');
              AResponseInfo.ResponseNo := 503;
            end;
        end;

        JsonResponse.Add('timestamp', DateTimeToStr(Now));

        // Ajouter les d√©tails des checks
        JsonChecks := TJSONArray.Create;
        for i := 0 to FHealthMonitor.FChecks.Count - 1 do
        begin
          Check := THealthCheck(FHealthMonitor.FChecks[i]);
          JsonChecks.Add(TJSONObject.Create([
            'name', Check.Name,
            'status', Integer(Check.Status),
            'message', Check.Message,
            'lastCheck', DateTimeToStr(Check.LastCheck)
          ]));
        end;
        JsonResponse.Add('checks', JsonChecks);

        AResponseInfo.ContentType := 'application/json';
        AResponseInfo.ContentText := JsonResponse.AsJSON;

      finally
        JsonResponse.Free;
      end;
    end
    else if ARequestInfo.Document = '/status' then
    begin
      // Endpoint de statut simple
      AResponseInfo.ContentType := 'text/plain';
      AResponseInfo.ContentText := 'Service is running';
      AResponseInfo.ResponseNo := 200;
    end
    else if ARequestInfo.Document = '/metrics' then
    begin
      // Endpoint de m√©triques (format Prometheus)
      AResponseInfo.ContentType := 'text/plain';
      AResponseInfo.ContentText := GenerateMetrics;
      AResponseInfo.ResponseNo := 200;
    end
    else
    begin
      AResponseInfo.ResponseNo := 404;
      AResponseInfo.ContentText := 'Not Found';
    end;

  except
    on E: Exception do
    begin
      FLogger.LogException(E, 'HandleRequest');
      AResponseInfo.ResponseNo := 500;
      AResponseInfo.ContentText := 'Internal Server Error';
    end;
  end;
end;
```

### Named Pipes pour la communication locale

```pascal
type
  TNamedPipeServer = class(TThread)
  private
    FPipeName: string;
    FLogger: TServiceLogger;
    FPipeHandle: THandle;

    procedure ProcessCommand(const Command: string; var Response: string);
  protected
    procedure Execute; override;
  public
    constructor Create(const PipeName: string; Logger: TServiceLogger);
    destructor Destroy; override;
  end;

implementation

constructor TNamedPipeServer.Create(const PipeName: string; Logger: TServiceLogger);
begin
  inherited Create(True);
  FPipeName := PipeName;
  FLogger := Logger;
  FreeOnTerminate := False;
end;

procedure TNamedPipeServer.Execute;
const
  BUFFER_SIZE = 4096;
var
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Command, Response: string;
begin
  FLogger.Log(llInfo, Format('D√©marrage du serveur Named Pipe : %s', [FPipeName]));

  while not Terminated do
  begin
    // Cr√©er le Named Pipe
    FPipeHandle := CreateNamedPipe(
      PChar('\\.\pipe\' + FPipeName),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES,
      BUFFER_SIZE,
      BUFFER_SIZE,
      0,
      nil
    );

    if FPipeHandle = INVALID_HANDLE_VALUE then
    begin
      FLogger.Log(llError, 'Impossible de cr√©er le Named Pipe');
      Break;
    end;

    try
      // Attendre une connexion
      if ConnectNamedPipe(FPipeHandle, nil) or
         (GetLastError = ERROR_PIPE_CONNECTED) then
      begin
        // Lire la commande
        if ReadFile(FPipeHandle, Buffer, BUFFER_SIZE, BytesRead, nil) then
        begin
          SetString(Command, Buffer, BytesRead);
          FLogger.Log(llDebug, Format('Commande re√ßue : %s', [Command]));

          // Traiter la commande
          ProcessCommand(Command, Response);

          // Envoyer la r√©ponse
          WriteFile(FPipeHandle, PChar(Response)^,
                   Length(Response), BytesWritten, nil);
        end;

        DisconnectNamedPipe(FPipeHandle);
      end;

    finally
      CloseHandle(FPipeHandle);
    end;

    Sleep(100); // Petite pause avant la prochaine connexion
  end;

  FLogger.Log(llInfo, 'Arr√™t du serveur Named Pipe');
end;

procedure TNamedPipeServer.ProcessCommand(const Command: string; var Response: string);
var
  Cmd, Param: string;
  P: Integer;
begin
  // Parser la commande
  P := Pos(' ', Command);
  if P > 0 then
  begin
    Cmd := Copy(Command, 1, P-1);
    Param := Copy(Command, P+1, MaxInt);
  end
  else
  begin
    Cmd := Command;
    Param := '';
  end;

  Cmd := UpperCase(Trim(Cmd));

  // Traiter les commandes
  if Cmd = 'STATUS' then
    Response := 'SERVICE_RUNNING'
  else if Cmd = 'RELOAD' then
  begin
    // Recharger la configuration
    Response := 'CONFIG_RELOADED';
    FLogger.Log(llInfo, 'Configuration recharg√©e via Named Pipe');
  end
  else if Cmd = 'PROCESS' then
  begin
    // Traiter un fichier sp√©cifique
    Response := Format('PROCESSING %s', [Param]);
    FLogger.Log(llInfo, Format('Traitement forc√© de : %s', [Param]));
  end
  else
    Response := 'UNKNOWN_COMMAND';
end;
```

### Client pour communiquer avec le service

```pascal
program ServiceClient;

{$mode objfpc}{$H+}

uses
  Classes, SysUtils, Windows;

function SendCommandToPipe(const PipeName, Command: string): string;
const
  BUFFER_SIZE = 4096;
var
  PipeHandle: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
begin
  Result := '';

  // Se connecter au Named Pipe
  PipeHandle := CreateFile(
    PChar('\\.\pipe\' + PipeName),
    GENERIC_READ or GENERIC_WRITE,
    0,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  if PipeHandle = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur : Impossible de se connecter au service');
    WriteLn('Assurez-vous que le service est d√©marr√©');
    Exit;
  end;

  try
    // Envoyer la commande
    if WriteFile(PipeHandle, PChar(Command)^,
                Length(Command), BytesWritten, nil) then
    begin
      // Lire la r√©ponse
      if ReadFile(PipeHandle, Buffer, BUFFER_SIZE, BytesRead, nil) then
      begin
        SetString(Result, Buffer, BytesRead);
      end;
    end;
  finally
    CloseHandle(PipeHandle);
  end;
end;

var
  Command, Response: string;
begin
  WriteLn('Client de contr√¥le du service');
  WriteLn('Commandes disponibles : STATUS, RELOAD, PROCESS <fichier>, EXIT');
  WriteLn;

  repeat
    Write('> ');
    ReadLn(Command);

    if UpperCase(Command) = 'EXIT' then
      Break;

    Response := SendCommandToPipe('MonServicePipe', Command);

    if Response <> '' then
      WriteLn('R√©ponse : ', Response)
    else
      WriteLn('Pas de r√©ponse du service');

  until False;

  WriteLn('Au revoir!');
end.
```

## Optimisations et performances

### Pool de threads pour le traitement parall√®le

```pascal
type
  TWorkItem = class
  public
    Data: Pointer;
    ProcessProc: procedure(Data: Pointer);
  end;

  TThreadPool = class
  private
    FThreads: TList;
    FWorkQueue: TThreadList;
    FMaxThreads: Integer;
    FActiveThreads: Integer;
    FShutdown: Boolean;
    FLogger: TServiceLogger;

    procedure CreateWorkerThread;
  public
    constructor Create(MaxThreads: Integer; Logger: TServiceLogger);
    destructor Destroy; override;

    procedure QueueWork(Data: Pointer; ProcessProc: procedure(Data: Pointer));
    procedure Shutdown;

    property ActiveThreads: Integer read FActiveThreads;
  end;

  TPoolWorkerThread = class(TThread)
  private
    FPool: TThreadPool;
    FLogger: TServiceLogger;
  protected
    procedure Execute; override;
  public
    constructor Create(Pool: TThreadPool; Logger: TServiceLogger);
  end;

implementation

{ TThreadPool }

constructor TThreadPool.Create(MaxThreads: Integer; Logger: TServiceLogger);
var
  i: Integer;
begin
  inherited Create;
  FMaxThreads := MaxThreads;
  FLogger := Logger;
  FThreads := TList.Create;
  FWorkQueue := TThreadList.Create;
  FShutdown := False;
  FActiveThreads := 0;

  // Cr√©er les threads initiaux
  for i := 1 to MaxThreads do
    CreateWorkerThread;

  FLogger.Log(llInfo, Format('Pool de %d threads cr√©√©', [MaxThreads]));
end;

destructor TThreadPool.Destroy;
begin
  Shutdown;
  FWorkQueue.Free;
  FThreads.Free;
  inherited;
end;

procedure TThreadPool.CreateWorkerThread;
var
  Thread: TPoolWorkerThread;
begin
  Thread := TPoolWorkerThread.Create(Self, FLogger);
  FThreads.Add(Thread);
  Thread.Start;
end;

procedure TThreadPool.QueueWork(Data: Pointer; ProcessProc: procedure(Data: Pointer));
var
  WorkItem: TWorkItem;
begin
  if FShutdown then
    Exit;

  WorkItem := TWorkItem.Create;
  WorkItem.Data := Data;
  WorkItem.ProcessProc := ProcessProc;

  FWorkQueue.Add(WorkItem);
  FLogger.Log(llDebug, 'Travail ajout√© √† la file');
end;

procedure TThreadPool.Shutdown;
var
  i: Integer;
  Thread: TThread;
begin
  FShutdown := True;

  // Attendre que tous les threads se terminent
  for i := 0 to FThreads.Count - 1 do
  begin
    Thread := TThread(FThreads[i]);
    Thread.Terminate;
    Thread.WaitFor;
    Thread.Free;
  end;

  FThreads.Clear;
  FLogger.Log(llInfo, 'Pool de threads arr√™t√©');
end;

{ TPoolWorkerThread }

constructor TPoolWorkerThread.Create(Pool: TThreadPool; Logger: TServiceLogger);
begin
  inherited Create(True);
  FPool := Pool;
  FLogger := Logger;
  FreeOnTerminate := False;
end;

procedure TPoolWorkerThread.Execute;
var
  WorkItem: TWorkItem;
  List: TList;
begin
  while not Terminated and not FPool.FShutdown do
  begin
    // R√©cup√©rer un travail de la file
    List := FPool.FWorkQueue.LockList;
    try
      if List.Count > 0 then
      begin
        WorkItem := TWorkItem(List[0]);
        List.Delete(0);
      end
      else
        WorkItem := nil;
    finally
      FPool.FWorkQueue.UnlockList;
    end;

    if Assigned(WorkItem) then
    begin
      InterlockedIncrement(FPool.FActiveThreads);
      try
        // Ex√©cuter le travail
        WorkItem.ProcessProc(WorkItem.Data);
      except
        on E: Exception do
          FLogger.LogException(E, 'PoolWorkerThread.Execute');
      end;
      InterlockedDecrement(FPool.FActiveThreads);

      WorkItem.Free;
    end
    else
      Sleep(100); // Pas de travail, attendre un peu
  end;
end;
```

## Bonnes pratiques finales

### Structure de projet recommand√©e

```
MonService/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ MonService.lpr          # Point d'entr√©e principal
‚îÇ   ‚îú‚îÄ‚îÄ ServiceUnit.pas         # Logique du service
‚îÇ   ‚îú‚îÄ‚îÄ ConfigManager.pas       # Gestion de la configuration
‚îÇ   ‚îú‚îÄ‚îÄ Logger.pas              # Syst√®me de journalisation
‚îÇ   ‚îú‚îÄ‚îÄ HealthMonitor.pas       # Surveillance de sant√©
‚îÇ   ‚îî‚îÄ‚îÄ BusinessLogic.pas       # Logique m√©tier
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ service.ini             # Configuration par d√©faut
‚îÇ   ‚îî‚îÄ‚îÄ service.ini.example     # Exemple de configuration
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ install.bat             # Script d'installation Windows
‚îÇ   ‚îú‚îÄ‚îÄ uninstall.bat           # Script de d√©sinstallation
‚îÇ   ‚îî‚îÄ‚îÄ manage.ps1              # Script PowerShell de gestion
‚îú‚îÄ‚îÄ logs/
‚îÇ   ‚îî‚îÄ‚îÄ (fichiers de log g√©n√©r√©s)
‚îî‚îÄ‚îÄ README.md                    # Documentation
```

### Template de service complet

```pascal
program CompleteServiceTemplate;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}cthreads,{$ENDIF}
  Classes, SysUtils, DaemonApp, IniFiles, SyncObjs, DateUtils;

type
  TMyService = class(TCustomDaemon)
  private
    // Composants essentiels
    FLogger: TServiceLogger;
    FConfig: TServiceConfig;
    FHealthMonitor: THealthMonitor;
    FThreadPool: TThreadPool;
    FHttpServer: TServiceHttpServer;
    FPipeServer: TNamedPipeServer;

    // √âtat du service
    FStartTime: TDateTime;
    FProcessedCount: Integer;
    FErrorCount: Integer;
    FLastError: TDateTime;

    // Synchronisation
    FStatsCriticalSection: TCriticalSection;

    // M√©thodes priv√©es
    procedure InitializeComponents;
    procedure FinalizeComponents;
    procedure LoadConfiguration;
    procedure SetupHealthChecks;
    procedure UpdateStatistics(Success: Boolean);
    function GetUptime: string;

  public
    function Start: Boolean; override;
    function Stop: Boolean; override;
    function Pause: Boolean; override;
    function Continue: Boolean; override;
    function Execute: Boolean; override;
    function Install: Boolean; override;
    function Uninstall: Boolean; override;
  end;

  TMyServiceMapper = class(TCustomDaemonMapper)
  end;

{ TMyService }

procedure TMyService.InitializeComponents;
var
  LogPath, ConfigPath: string;
begin
  // Chemins de base
  LogPath := ExtractFilePath(ParamStr(0)) + 'logs\';
  ConfigPath := ExtractFilePath(ParamStr(0)) + 'config\';

  // Cr√©er les r√©pertoires n√©cessaires
  ForceDirectories(LogPath);
  ForceDirectories(ConfigPath);

  // Initialiser le logger
  FLogger := TServiceLogger.Create(LogPath + 'service_' +
    FormatDateTime('yyyymmdd', Now) + '.log');
  FLogger.Log(llInfo, '=== D√©marrage du service ===');
  FLogger.Log(llInfo, 'Version : 1.0.0');
  FLogger.Log(llInfo, 'PID : ' + IntToStr(GetCurrentProcessId));

  // Charger la configuration
  FConfig := TServiceConfig.Create(ConfigPath + 'service.ini');
  LoadConfiguration;

  // Initialiser le moniteur de sant√©
  FHealthMonitor := THealthMonitor.Create(FLogger);
  SetupHealthChecks;

  // Cr√©er le pool de threads
  FThreadPool := TThreadPool.Create(FConfig.MaxThreads, FLogger);

  // D√©marrer le serveur HTTP si configur√©
  if FConfig.EnableHttpServer then
  begin
    FHttpServer := TServiceHttpServer.Create(
      FConfig.HttpPort, FLogger, FHealthMonitor);
    FHttpServer.Start;
    FLogger.Log(llInfo, Format('Serveur HTTP d√©marr√© sur le port %d',
      [FConfig.HttpPort]));
  end;

  // D√©marrer le serveur Named Pipe si configur√©
  if FConfig.EnableNamedPipe then
  begin
    FPipeServer := TNamedPipeServer.Create(
      FConfig.PipeName, FLogger);
    FPipeServer.Start;
    FLogger.Log(llInfo, Format('Named Pipe cr√©√© : %s', [FConfig.PipeName]));
  end;

  // Initialiser les statistiques
  FStatsCriticalSection := TCriticalSection.Create;
  FStartTime := Now;
  FProcessedCount := 0;
  FErrorCount := 0;
  FLastError := 0;
end;

procedure TMyService.FinalizeComponents;
begin
  FLogger.Log(llInfo, 'Arr√™t des composants...');

  // Arr√™ter les serveurs
  if Assigned(FHttpServer) then
  begin
    FHttpServer.Terminate;
    FHttpServer.WaitFor;
    FHttpServer.Free;
  end;

  if Assigned(FPipeServer) then
  begin
    FPipeServer.Terminate;
    FPipeServer.WaitFor;
    FPipeServer.Free;
  end;

  // Arr√™ter le pool de threads
  if Assigned(FThreadPool) then
    FThreadPool.Free;

  // √âcrire les statistiques finales
  FLogger.Log(llInfo, Format('Statistiques finales : %d trait√©s, %d erreurs',
    [FProcessedCount, FErrorCount]));
  FLogger.Log(llInfo, Format('Dur√©e d''ex√©cution : %s', [GetUptime]));

  // Nettoyer
  FHealthMonitor.Free;
  FConfig.Free;
  FStatsCriticalSection.Free;

  FLogger.Log(llInfo, '=== Service arr√™t√© ===');
  FLogger.Free;
end;

procedure TMyService.LoadConfiguration;
begin
  FLogger.Log(llInfo, 'Chargement de la configuration...');

  FConfig.Load;

  // Appliquer la configuration au logger
  FLogger.SetLogLevel(FConfig.LogLevel);

  // Logger les param√®tres importants
  FLogger.Log(llInfo, Format('Intervalle de traitement : %d ms',
    [FConfig.PollingInterval]));
  FLogger.Log(llInfo, Format('Nombre max de threads : %d',
    [FConfig.MaxThreads]));
  FLogger.Log(llInfo, Format('Niveau de log : %s',
    [LogLevelToString(FConfig.LogLevel)]));
end;

procedure TMyService.SetupHealthChecks;
begin
  // Enregistrer les v√©rifications de sant√©
  FHealthMonitor.RegisterCheck(
    TDiskSpaceHealthCheck.Create(ExtractFileDrive(ParamStr(0)), 1)); // 1 GB minimum

  FHealthMonitor.RegisterCheck(
    TMemoryHealthCheck.Create(500)); // 500 MB max

  if Assigned(FConfig.Database) then
    FHealthMonitor.RegisterCheck(
      TDatabaseHealthCheck.Create(FConfig.Database));

  FLogger.Log(llInfo, 'V√©rifications de sant√© configur√©es');
end;

procedure TMyService.UpdateStatistics(Success: Boolean);
begin
  FStatsCriticalSection.Enter;
  try
    if Success then
      Inc(FProcessedCount)
    else
    begin
      Inc(FErrorCount);
      FLastError := Now;
    end;
  finally
    FStatsCriticalSection.Leave;
  end;
end;

function TMyService.GetUptime: string;
var
  Diff: TDateTime;
  Days, Hours, Mins: Integer;
begin
  Diff := Now - FStartTime;
  Days := Trunc(Diff);
  Hours := HoursBetween(Now, FStartTime) mod 24;
  Mins := MinutesBetween(Now, FStartTime) mod 60;

  Result := Format('%d jours, %d heures, %d minutes', [Days, Hours, Mins]);
end;

function TMyService.Start: Boolean;
begin
  Result := True;

  try
    InitializeComponents;
    FLogger.Log(llInfo, 'Service d√©marr√© avec succ√®s');
  except
    on E: Exception do
    begin
      if Assigned(FLogger) then
        FLogger.LogException(E, 'Start')
      else
        EventLog(etError, 'Erreur au d√©marrage : ' + E.Message);

      Result := False;
    end;
  end;
end;

function TMyService.Stop: Boolean;
begin
  Result := True;

  try
    FLogger.Log(llInfo, 'Arr√™t du service demand√©');
    FinalizeComponents;
  except
    on E: Exception do
    begin
      if Assigned(FLogger) then
        FLogger.LogException(E, 'Stop');
      // On retourne True quand m√™me pour permettre l'arr√™t
    end;
  end;
end;

function TMyService.Pause: Boolean;
begin
  Result := True;
  FLogger.Log(llInfo, 'Service mis en pause');

  // Mettre en pause les traitements
  if Assigned(FThreadPool) then
    FThreadPool.Pause;
end;

function TMyService.Continue: Boolean;
begin
  Result := True;
  FLogger.Log(llInfo, 'Service repris');

  // Reprendre les traitements
  if Assigned(FThreadPool) then
    FThreadPool.Resume;
end;

function TMyService.Execute: Boolean;
var
  CheckInterval: Integer;
  LastHealthCheck: TDateTime;
  WorkItems: TStringList;
  i: Integer;
begin
  Result := True;
  CheckInterval := 60; // V√©rification de sant√© toutes les 60 secondes
  LastHealthCheck := 0;

  while not Terminated do
  begin
    try
      // V√©rification de sant√© p√©riodique
      if SecondsBetween(Now, LastHealthCheck) >= CheckInterval then
      begin
        FHealthMonitor.RunChecks;
        LastHealthCheck := Now;

        // Logger un r√©sum√© toutes les heures
        if MinuteOf(Now) = 0 then
          FHealthMonitor.WriteHealthReport;
      end;

      // Traitement principal
      WorkItems := TStringList.Create;
      try
        // R√©cup√©rer le travail √† faire
        GetWorkItems(WorkItems);

        // Traiter chaque √©l√©ment
        for i := 0 to WorkItems.Count - 1 do
        begin
          if Terminated then
            Break;

          // Utiliser le pool de threads pour le traitement
          FThreadPool.QueueWork(
            Pointer(PChar(WorkItems[i])),
            @ProcessWorkItem);
        end;

      finally
        WorkItems.Free;
      end;

      // Attendre avant le prochain cycle
      if not Terminated then
        Sleep(FConfig.PollingInterval);

    except
      on E: Exception do
      begin
        FLogger.LogException(E, 'Execute');
        UpdateStatistics(False);

        // Attente plus longue en cas d'erreur
        if not Terminated then
          Sleep(5000);
      end;
    end;
  end;

  FLogger.Log(llInfo, 'Boucle principale termin√©e');
end;

function TMyService.Install: Boolean;
begin
  Result := inherited Install;

  if Result then
  begin
    // Configuration post-installation
    EventLog(etInfo, 'Service install√© avec succ√®s');

    // Cr√©er les r√©pertoires n√©cessaires
    ForceDirectories(ExtractFilePath(ParamStr(0)) + 'logs');
    ForceDirectories(ExtractFilePath(ParamStr(0)) + 'config');

    // Cr√©er un fichier de configuration par d√©faut si n√©cessaire
    CreateDefaultConfig;
  end;
end;

function TMyService.Uninstall: Boolean;
begin
  // Nettoyer avant la d√©sinstallation
  EventLog(etInfo, 'D√©sinstallation du service');

  Result := inherited Uninstall;
end;

{ Programme principal }

procedure RunInConsoleMode;
var
  Service: TMyService;
begin
  WriteLn('=== Mode Console (Debug) ===');
  WriteLn('Appuyez sur Ctrl+C pour arr√™ter');
  WriteLn;

  Service := TMyService.Create(nil);
  try
    // Simuler le cycle de vie du service
    if Service.Start then
    begin
      WriteLn('Service d√©marr√© en mode console');

      // Installer un gestionnaire Ctrl+C
      SetConsoleCtrlHandler(@ConsoleCtrlHandler, True);

      // Ex√©cuter
      Service.Execute;

      // Arr√™ter
      Service.Stop;
      WriteLn('Service arr√™t√©');
    end
    else
      WriteLn('Erreur au d√©marrage du service');

  finally
    Service.Free;
  end;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end;

procedure ShowHelp;
begin
  WriteLn('Utilisation : ', ExtractFileName(ParamStr(0)), ' [options]');
  WriteLn;
  WriteLn('Options :');
  WriteLn('  /install       Installer le service');
  WriteLn('  /uninstall     D√©sinstaller le service');
  WriteLn('  /console       Ex√©cuter en mode console (debug)');
  WriteLn('  /help          Afficher cette aide');
  WriteLn;
  WriteLn('Sans param√®tre, le programme s''ex√©cute comme service Windows');
end;

begin
  // Traiter les param√®tres de ligne de commande
  if FindCmdLineSwitch('console', ['-', '/'], True) then
  begin
    RunInConsoleMode;
    Exit;
  end;

  if FindCmdLineSwitch('help', ['-', '/'], True) or
     FindCmdLineSwitch('?', ['-', '/'], True) then
  begin
    ShowHelp;
    Exit;
  end;

  // Cr√©er l'application daemon
  Application := TCustomDaemonApplication.Create(nil);
  Application.Title := 'Mon Service Complet';
  Application.EventLog.DefaultEventType := etInfo;

  // Cr√©er et configurer le mapper
  with TMyServiceMapper.Create(nil) do
  begin
    DaemonDef.Name := 'MyCompleteService';
    DaemonDef.DisplayName := 'Mon Service Complet FreePascal';
    DaemonDef.Description := 'Service Windows complet avec monitoring et gestion avanc√©e';
    DaemonDef.ServiceType := stWin32;
    DaemonDef.StartType := stAuto; // D√©marrage automatique
    DaemonDef.ErrorSeverity := esNormal;
    DaemonDef.DaemonClass := TMyService;

    // Options de r√©cup√©ration en cas de crash
    DaemonDef.WinBindings.Dependencies.Add('EventLog'); // D√©pendance
    DaemonDef.Options := [doAllowStop, doAllowPause];
  end;

  // Lancer l'application
  Application.Initialize;
  Application.Run;
  Application.Free;
end.
```

## Scripts de d√©ploiement et installation

### Script d'installation complet (install.bat)

```batch
@echo off
setlocal EnableDelayedExpansion

:: V√©rifier les droits administrateur
net session >nul 2>&1
if %errorlevel% neq 0 (
    echo Ce script n√©cessite les droits administrateur.
    echo Relancez-le en tant qu'administrateur.
    pause
    exit /b 1
)

:: Variables
set SERVICE_NAME=MyCompleteService
set SERVICE_EXE=%~dp0MonService.exe
set SERVICE_CONFIG=%~dp0config\service.ini

echo ========================================
echo Installation du Service Windows
echo ========================================
echo.

:: V√©rifier l'existence du fichier exe
if not exist "%SERVICE_EXE%" (
    echo ERREUR : Le fichier %SERVICE_EXE% n'existe pas.
    pause
    exit /b 1
)

:: Arr√™ter le service s'il est en cours
echo V√©rification de l'√©tat du service...
sc query %SERVICE_NAME% >nul 2>&1
if %errorlevel% equ 0 (
    echo Service trouv√©. Arr√™t en cours...
    net stop %SERVICE_NAME% >nul 2>&1
    timeout /t 2 /nobreak >nul

    echo D√©sinstallation de l'ancienne version...
    "%SERVICE_EXE%" /uninstall
    timeout /t 2 /nobreak >nul
)

:: Cr√©er les r√©pertoires n√©cessaires
echo Cr√©ation des r√©pertoires...
if not exist "%~dp0logs" mkdir "%~dp0logs"
if not exist "%~dp0config" mkdir "%~dp0config"
if not exist "%~dp0backup" mkdir "%~dp0backup"

:: Cr√©er un fichier de configuration par d√©faut si n√©cessaire
if not exist "%SERVICE_CONFIG%" (
    echo Cr√©ation du fichier de configuration par d√©faut...
    (
        echo [General]
        echo PollingInterval=5000
        echo MaxThreads=4
        echo LogLevel=1
        echo WorkingDirectory=%~dp0
        echo.
        echo [Network]
        echo EnableHttpServer=true
        echo HttpPort=8080
        echo EnableNamedPipe=true
        echo PipeName=%SERVICE_NAME%Pipe
        echo.
        echo [Database]
        echo ConnectionString=
        echo Timeout=30
    ) > "%SERVICE_CONFIG%"
)

:: Installer le service
echo Installation du service...
"%SERVICE_EXE%" /install

if %errorlevel% neq 0 (
    echo ERREUR lors de l'installation du service.
    pause
    exit /b 1
)

:: Configurer le service
echo Configuration du service...

:: D√©finir le d√©marrage automatique
sc config %SERVICE_NAME% start= auto >nul 2>&1

:: D√©finir la r√©cup√©ration en cas d'√©chec
sc failure %SERVICE_NAME% reset= 86400 actions= restart/60000/restart/60000/restart/60000 >nul 2>&1

:: D√©finir la description
sc description %SERVICE_NAME% "Service Windows complet avec monitoring et gestion avanc√©e" >nul 2>&1

:: D√©finir les d√©pendances (exemple : EventLog)
sc config %SERVICE_NAME% depend= EventLog >nul 2>&1

:: D√©marrer le service
echo D√©marrage du service...
net start %SERVICE_NAME%

if %errorlevel% equ 0 (
    echo.
    echo ========================================
    echo Installation termin√©e avec succ√®s !
    echo ========================================
    echo.
    echo Le service %SERVICE_NAME% est maintenant install√© et d√©marr√©.
    echo.
    echo Monitoring HTTP : http://localhost:8080/health
    echo Logs : %~dp0logs\
    echo Configuration : %SERVICE_CONFIG%
    echo.
) else (
    echo.
    echo ATTENTION : Le service est install√© mais n'a pas pu d√©marrer.
    echo V√©rifiez les logs pour plus d'informations.
    echo.
)

pause
```

### Script PowerShell avanc√© (manage.ps1)

```powershell
<#
.SYNOPSIS
    Script de gestion du service Windows
.DESCRIPTION
    Permet d'installer, configurer, surveiller et g√©rer le service
.PARAMETER Action
    Action √† effectuer : install, uninstall, start, stop, restart, status, logs, config
#>

param(
    [Parameter(Mandatory=$true)]
    [ValidateSet("install", "uninstall", "start", "stop", "restart",
                 "status", "logs", "config", "health", "backup")]
    [string]$Action,

    [Parameter(Mandatory=$false)]
    [int]$Lines = 50
)

# Configuration
$ServiceName = "MyCompleteService"
$ServicePath = Join-Path $PSScriptRoot "MonService.exe"
$ConfigPath = Join-Path $PSScriptRoot "config\service.ini"
$LogPath = Join-Path $PSScriptRoot "logs"
$BackupPath = Join-Path $PSScriptRoot "backup"

# Couleurs pour l'affichage
function Write-ColorOutput($ForegroundColor) {
    $fc = $host.UI.RawUI.ForegroundColor
    $host.UI.RawUI.ForegroundColor = $ForegroundColor
    if ($args) {
        Write-Output $args
    }
    $host.UI.RawUI.ForegroundColor = $fc
}

# V√©rifier les droits administrateur
function Test-Administrator {
    $currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
    return $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

# Fonction pour installer le service
function Install-Service {
    Write-Host "Installation du service $ServiceName..." -ForegroundColor Green

    # V√©rifier l'existence du fichier
    if (-not (Test-Path $ServicePath)) {
        Write-Host "ERREUR : $ServicePath introuvable" -ForegroundColor Red
        return
    }

    # Cr√©er les r√©pertoires
    @($LogPath, (Split-Path $ConfigPath), $BackupPath) | ForEach-Object {
        if (-not (Test-Path $_)) {
            New-Item -ItemType Directory -Path $_ | Out-Null
            Write-Host "R√©pertoire cr√©√© : $_" -ForegroundColor Gray
        }
    }

    # Installer le service
    & $ServicePath /install

    if ($LASTEXITCODE -eq 0) {
        # Configurer le service
        Set-Service -Name $ServiceName -StartupType Automatic

        # Configurer la r√©cup√©ration
        $recoveryActions = @(
            New-Object System.ServiceProcess.ServiceRecoveryAction -ArgumentList "Restart", 60000
            New-Object System.ServiceProcess.ServiceRecoveryAction -ArgumentList "Restart", 60000
            New-Object System.ServiceProcess.ServiceRecoveryAction -ArgumentList "Restart", 60000
        )

        sc.exe failure $ServiceName reset= 86400 actions= restart/60000/restart/60000/restart/60000 | Out-Null

        Write-Host "Service install√© avec succ√®s" -ForegroundColor Green

        # D√©marrer le service
        Start-Service -Name $ServiceName
        Write-Host "Service d√©marr√©" -ForegroundColor Green
    } else {
        Write-Host "Erreur lors de l'installation" -ForegroundColor Red
    }
}

# Fonction pour d√©sinstaller le service
function Uninstall-Service {
    Write-Host "D√©sinstallation du service $ServiceName..." -ForegroundColor Yellow

    # Arr√™ter le service s'il est en cours
    $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
    if ($service) {
        if ($service.Status -eq 'Running') {
            Stop-Service -Name $ServiceName -Force
            Write-Host "Service arr√™t√©" -ForegroundColor Gray
        }

        & $ServicePath /uninstall
        Write-Host "Service d√©sinstall√©" -ForegroundColor Yellow
    } else {
        Write-Host "Service non trouv√©" -ForegroundColor Gray
    }
}

# Fonction pour afficher le statut
function Show-Status {
    $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue

    if ($service) {
        Write-Host "`n=== Statut du Service ===" -ForegroundColor Cyan
        Write-Host "Nom         : $($service.Name)"
        Write-Host "Nom affich√© : $($service.DisplayName)"

        $color = switch ($service.Status) {
            'Running' { 'Green' }
            'Stopped' { 'Red' }
            default { 'Yellow' }
        }

        Write-Host "√âtat        : " -NoNewline
        Write-Host $service.Status -ForegroundColor $color
        Write-Host "Type d√©mar. : $($service.StartType)"

        # Informations suppl√©mentaires via WMI
        $wmiService = Get-WmiObject -Class Win32_Service -Filter "Name='$ServiceName'"
        if ($wmiService) {
            Write-Host "PID         : $($wmiService.ProcessId)"
            Write-Host "Compte      : $($wmiService.StartName)"
            Write-Host "Chemin      : $($wmiService.PathName)"
        }

        # Statistiques de performance si le service est en cours
        if ($service.Status -eq 'Running' -and $wmiService.ProcessId) {
            $process = Get-Process -Id $wmiService.ProcessId -ErrorAction SilentlyContinue
            if ($process) {
                Write-Host "`n=== Performance ===" -ForegroundColor Cyan
                Write-Host "CPU         : $([math]::Round($process.CPU, 2)) secondes"
                Write-Host "M√©moire     : $([math]::Round($process.WorkingSet / 1MB, 2)) MB"
                Write-Host "Threads     : $($process.Threads.Count)"
                Write-Host "Handles     : $($process.HandleCount)"
                Write-Host "D√©marr√©     : $($process.StartTime)"

                $uptime = (Get-Date) - $process.StartTime
                Write-Host "Uptime      : $($uptime.Days)j $($uptime.Hours)h $($uptime.Minutes)m"
            }
        }
    } else {
        Write-Host "Service $ServiceName non trouv√©" -ForegroundColor Red
    }
}

# Fonction pour afficher les logs
function Show-Logs {
    $logFile = Get-ChildItem $LogPath -Filter "*.log" |
               Sort-Object LastWriteTime -Descending |
               Select-Object -First 1

    if ($logFile) {
        Write-Host "`n=== Derni√®res lignes du log ===" -ForegroundColor Cyan
        Write-Host "Fichier : $($logFile.FullName)" -ForegroundColor Gray
        Write-Host ""

        Get-Content $logFile.FullName -Tail $Lines | ForEach-Object {
            if ($_ -match "ERROR|CRITICAL") {
                Write-Host $_ -ForegroundColor Red
            } elseif ($_ -match "WARNING") {
                Write-Host $_ -ForegroundColor Yellow
            } elseif ($_ -match "INFO") {
                Write-Host $_ -ForegroundColor Green
            } else {
                Write-Host $_
            }
        }
    } else {
        Write-Host "Aucun fichier de log trouv√©" -ForegroundColor Yellow
    }
}

# Fonction pour v√©rifier la sant√©
function Check-Health {
    Write-Host "`n=== V√©rification de sant√© ===" -ForegroundColor Cyan

    try {
        $response = Invoke-RestMethod -Uri "http://localhost:8080/health" -Method Get

        $color = switch ($response.status) {
            'healthy' { 'Green' }
            'warning' { 'Yellow' }
            'critical' { 'Red' }
            default { 'Gray' }
        }

        Write-Host "√âtat global : " -NoNewline
        Write-Host $response.status.ToUpper() -ForegroundColor $color
        Write-Host "Timestamp   : $($response.timestamp)"

        if ($response.checks) {
            Write-Host "`nV√©rifications d√©taill√©es :" -ForegroundColor Cyan
            foreach ($check in $response.checks) {
                $checkColor = switch ($check.status) {
                    0 { 'Green' }   # Healthy
                    1 { 'Yellow' }  # Warning
                    2 { 'Red' }     # Critical
                    default { 'Gray' }
                }

                Write-Host "  - $($check.name) : " -NoNewline
                Write-Host $check.message -ForegroundColor $checkColor
            }
        }
    } catch {
        Write-Host "Impossible de contacter le service (http://localhost:8080/health)" -ForegroundColor Red
        Write-Host "Erreur : $_" -ForegroundColor Red
    }
}

# Fonction pour cr√©er une sauvegarde
function Backup-Service {
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $backupFolder = Join-Path $BackupPath "backup_$timestamp"

    Write-Host "Cr√©ation d'une sauvegarde..." -ForegroundColor Cyan

    # Cr√©er le dossier de sauvegarde
    New-Item -ItemType Directory -Path $backupFolder | Out-Null

    # Copier les fichiers
    @(
        @{Source = $ConfigPath; Dest = "config"},
        @{Source = $LogPath; Dest = "logs"}
    ) | ForEach-Object {
        if (Test-Path $_.Source) {
            $destination = Join-Path $backupFolder $_.Dest
            Copy-Item -Path $_.Source -Destination $destination -Recurse
            Write-Host "  Sauvegard√© : $($_.Dest)" -ForegroundColor Gray
        }
    }

    # Cr√©er un fichier ZIP
    $zipFile = Join-Path $BackupPath "backup_$timestamp.zip"
    Compress-Archive -Path $backupFolder -DestinationPath $zipFile
    Remove-Item $backupFolder -Recurse -Force

    Write-Host "Sauvegarde cr√©√©e : $zipFile" -ForegroundColor Green
}

# Programme principal
if (-not (Test-Administrator)) {
    Write-Host "Ce script n√©cessite les droits administrateur" -ForegroundColor Red
    exit 1
}

switch ($Action) {
    "install"   { Install-Service }
    "uninstall" { Uninstall-Service }
    "start"     {
        Start-Service -Name $ServiceName
        Write-Host "Service d√©marr√©" -ForegroundColor Green
    }
    "stop"      {
        Stop-Service -Name $ServiceName -Force
        Write-Host "Service arr√™t√©" -ForegroundColor Yellow
    }
    "restart"   {
        Restart-Service -Name $ServiceName
        Write-Host "Service red√©marr√©" -ForegroundColor Green
    }
    "status"    { Show-Status }
    "logs"      { Show-Logs }
    "config"    {
        if (Test-Path $ConfigPath) {
            notepad.exe $ConfigPath
        } else {
            Write-Host "Fichier de configuration introuvable" -ForegroundColor Red
        }
    }
    "health"    { Check-Health }
    "backup"    { Backup-Service }
}
```

## Checklist de mise en production

### Avant le d√©ploiement

- [ ] **Tests complets**
  - Tests unitaires pass√©s
  - Tests d'int√©gration r√©ussis
  - Tests de charge effectu√©s
  - Tests de r√©cup√©ration d'erreur valid√©s

- [ ] **Documentation**
  - README.md √† jour
  - Guide d'installation r√©dig√©
  - Guide de configuration document√©
  - Proc√©dures de d√©pannage √©crites
  - Changelog mis √† jour

- [ ] **Configuration**
  - Fichier de configuration par d√©faut cr√©√©
  - Variables d'environnement document√©es
  - Chemins relatifs utilis√©s (pas de chemins absolus)
  - Param√®tres sensibles externalis√©s

- [ ] **S√©curit√©**
  - Compte de service avec privil√®ges minimaux
  - Mots de passe chiffr√©s dans la configuration
  - Communications s√©curis√©es (HTTPS/TLS si applicable)
  - Validation des entr√©es impl√©ment√©e
  - Pas d'informations sensibles dans les logs

- [ ] **Performance**
  - Fuites m√©moire v√©rifi√©es
  - Gestion des ressources optimis√©e
  - Limites de threads configur√©es
  - Timeouts appropri√©s d√©finis

- [ ] **Logging**
  - Rotation des logs configur√©e
  - Niveaux de log appropri√©s
  - Informations suffisantes pour le d√©bogage
  - Pas d'informations sensibles logg√©es

### Pendant le d√©ploiement

- [ ] **Pr√©paration de l'environnement**
  - Serveur de production pr√©par√©
  - Pr√©requis install√©s (.NET Framework si n√©cessaire)
  - Antivirus configur√© pour exclure les dossiers du service
  - Pare-feu configur√© si n√©cessaire

- [ ] **Installation**
  - Service install√© avec le bon compte
  - D√©marrage automatique configur√©
  - R√©cup√©ration automatique en cas d'√©chec
  - D√©pendances configur√©es

- [ ] **V√©rification post-installation**
  - Service d√©marre correctement
  - Logs cr√©√©s au bon endroit
  - Connexions √©tablies (base de donn√©es, r√©seau)
  - Monitoring accessible

### Apr√®s le d√©ploiement

- [ ] **Monitoring**
  - Alertes configur√©es
  - Tableaux de bord cr√©√©s
  - M√©triques collect√©es
  - Sauvegardes automatiques configur√©es

- [ ] **Documentation finale**
  - Proc√©dures op√©rationnelles document√©es
  - Contacts d'urgence list√©s
  - Historique des d√©ploiements maintenu

## Guide de d√©pannage

### Probl√®mes courants et solutions

#### 1. Le service ne d√©marre pas

**Sympt√¥me** : Erreur 1053 "Le service n'a pas r√©pondu √† la demande de d√©marrage"

**Causes possibles et solutions** :

```pascal
// PROBL√àME : Initialisation trop longue
// MAUVAIS
function TMyService.Start: Boolean;
begin
  // Traitement long de 30 secondes
  LoadHugeDatabase;  // Windows timeout apr√®s 30 secondes
  Result := True;
end;

// BON : d√©marrer un thread pour le traitement long
// Note : en mode ObjFPC, les proc√©dures anonymes n√©cessitent
// {$modeswitch anonymousfunctions} (FPC 3.3.1+)
function TMyService.Start: Boolean;
begin
  // Initialisation rapide
  Result := True;

  // D√©marrer un thread pour le traitement long
  TThread.CreateAnonymousThread(
    procedure
    begin
      LoadHugeDatabase;
    end
  ).Start;
end;
```

**Script de diagnostic** :
```batch
@echo off
echo Diagnostic du service qui ne d√©marre pas
echo ========================================

:: V√©rifier l'Event Log
echo.
echo Derni√®res erreurs dans l'Event Log :
wevtutil qe Application /q:"*[System[Provider[@Name='MyService']]]" /f:text /c:5

:: V√©rifier les permissions
echo.
echo V√©rification des permissions :
icacls "%~dp0"

:: V√©rifier les d√©pendances
echo.
echo Services d√©pendants :
sc qc MyService | findstr DEPENDENCIES

:: Test en mode console
echo.
echo Test en mode console :
"%~dp0MonService.exe" /console

pause
```

#### 2. Le service s'arr√™te imm√©diatement

**Sympt√¥me** : Le service d√©marre puis s'arr√™te aussit√¥t

**V√©rification du probl√®me** :
```pascal
// Ajouter des logs d√©taill√©s au d√©marrage
function TMyService.Start: Boolean;
begin
  Result := True;

  try
    EventLog(etInfo, 'Start: D√©but');

    // Test 1 : Configuration
    EventLog(etInfo, 'Start: Chargement configuration');
    LoadConfig;

    // Test 2 : Connexions
    EventLog(etInfo, 'Start: Test connexions');
    TestConnections;

    // Test 3 : Permissions
    EventLog(etInfo, 'Start: V√©rification permissions');
    CheckPermissions;

    EventLog(etInfo, 'Start: Succ√®s');

  except
    on E: Exception do
    begin
      EventLog(etError, 'Start: Erreur - ' + E.Message);
      Result := False;
    end;
  end;
end;
```

#### 3. Fuite m√©moire

**Sympt√¥me** : La m√©moire augmente continuellement

**Outil de d√©tection** :
```pascal
type
  TMemoryMonitor = class
  private
    FInitialMemory: Int64;
    FLogger: TServiceLogger;
    FCheckInterval: Integer;
    FLastCheck: TDateTime;

  public
    constructor Create(Logger: TServiceLogger);
    procedure CheckMemory;
    procedure LogMemoryStatus;
  end;

implementation

procedure TMemoryMonitor.CheckMemory;
var
  CurrentMemory: Int64;
  Increase: Int64;
  IncreasePercent: Double;
begin
  if SecondsBetween(Now, FLastCheck) < FCheckInterval then
    Exit;

  CurrentMemory := GetProcessMemoryUsage;
  Increase := CurrentMemory - FInitialMemory;
  IncreasePercent := (Increase / FInitialMemory) * 100;

  if IncreasePercent > 50 then
  begin
    FLogger.Log(llWarning, Format(
      'Augmentation m√©moire significative : %.1f%% (Initial: %d MB, Actuel: %d MB)',
      [IncreasePercent, FInitialMemory div 1048576, CurrentMemory div 1048576]
    ));

    // Forcer un garbage collection si disponible
    {$IFDEF FPC}
    // FreePascal n'a pas de GC mais on peut vider les caches
    SetHeapTraceOutput('heap.trc');
    {$ENDIF}
  end;

  FLastCheck := Now;
end;

function GetProcessMemoryUsage: Int64;
var
  ProcessMemoryCounters: TProcessMemoryCounters;
begin
  ProcessMemoryCounters.cb := SizeOf(ProcessMemoryCounters);
  if GetProcessMemoryInfo(GetCurrentProcess, @ProcessMemoryCounters,
                          SizeOf(ProcessMemoryCounters)) then
    Result := ProcessMemoryCounters.WorkingSetSize
  else
    Result := 0;
end;
```

#### 4. Le service ne r√©pond plus (freeze)

**D√©tection de deadlock** :
```pascal
type
  TWatchdog = class(TThread)
  private
    FLastHeartbeat: TDateTime;
    FTimeout: Integer;
    FLogger: TServiceLogger;
    FOnTimeout: TNotifyEvent;

  protected
    procedure Execute; override;
  public
    constructor Create(TimeoutSeconds: Integer; Logger: TServiceLogger);
    procedure Heartbeat;
  end;

implementation

procedure TWatchdog.Execute;
begin
  while not Terminated do
  begin
    if SecondsBetween(Now, FLastHeartbeat) > FTimeout then
    begin
      FLogger.Log(llCritical, 'WATCHDOG: Timeout d√©tect√©!');

      // G√©n√©rer un dump pour analyse
      CreateMiniDump;

      // Notifier ou red√©marrer
      if Assigned(FOnTimeout) then
        FOnTimeout(Self);
    end;

    Sleep(1000);
  end;
end;

procedure CreateMiniDump;
var
  DumpFile: THandle;
  DumpFileName: string;
  ProcessId: DWORD;
  ProcessHandle: THandle;
begin
  DumpFileName := Format('crash_%s.dmp',
                        [FormatDateTime('yyyymmdd_hhnnss', Now)]);

  DumpFile := CreateFile(PChar(DumpFileName), GENERIC_WRITE, 0, nil,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

  if DumpFile <> INVALID_HANDLE_VALUE then
  begin
    ProcessId := GetCurrentProcessId;
    ProcessHandle := OpenProcess(PROCESS_ALL_ACCESS, False, ProcessId);

    MiniDumpWriteDump(ProcessHandle, ProcessId, DumpFile,
                     MiniDumpNormal, nil, nil, nil);

    CloseHandle(DumpFile);
    CloseHandle(ProcessHandle);
  end;
end;
```

## Monitoring avanc√©

### Int√©gration avec Windows Performance Monitor

> **Note** : FreePascal n'int√®gre pas de wrapper natif pour les compteurs de performance Windows. L'approche recommand√©e est d'exposer vos m√©triques via un endpoint HTTP (comme `/metrics` au format Prometheus) ou d'√©crire dans l'Observateur d'√©v√©nements Windows.

```pascal
type
  TServiceMetrics = class
  private
    FCS: TCriticalSection;
    FRequestsTotal: Int64;
    FErrorsTotal: Int64;
    FActiveConnections: Integer;
    FStartTime: TDateTime;
  public
    constructor Create;
    destructor Destroy; override;

    procedure IncrementRequests;
    procedure IncrementErrors;
    procedure UpdateConnections(Count: Integer);
    function GeneratePrometheusMetrics: string;
  end;

implementation

constructor TServiceMetrics.Create;
begin
  inherited Create;
  FCS := TCriticalSection.Create;
  FStartTime := Now;
  FRequestsTotal := 0;
  FErrorsTotal := 0;
  FActiveConnections := 0;
end;

destructor TServiceMetrics.Destroy;
begin
  FCS.Free;
  inherited;
end;

procedure TServiceMetrics.IncrementRequests;
begin
  FCS.Enter;
  try
    Inc(FRequestsTotal);
  finally
    FCS.Leave;
  end;
end;

procedure TServiceMetrics.IncrementErrors;
begin
  FCS.Enter;
  try
    Inc(FErrorsTotal);
  finally
    FCS.Leave;
  end;
end;

procedure TServiceMetrics.UpdateConnections(Count: Integer);
begin
  FCS.Enter;
  try
    FActiveConnections := Count;
  finally
    FCS.Leave;
  end;
end;

function TServiceMetrics.GeneratePrometheusMetrics: string;
var
  UptimeSeconds: Int64;
begin
  UptimeSeconds := SecondsBetween(Now, FStartTime);

  FCS.Enter;
  try
    Result := Format(
      '# HELP service_requests_total Total requests processed' + LineEnding +
      'service_requests_total %d' + LineEnding +
      '# HELP service_errors_total Total errors' + LineEnding +
      'service_errors_total %d' + LineEnding +
      '# HELP service_active_connections Current active connections' + LineEnding +
      'service_active_connections %d' + LineEnding +
      '# HELP service_uptime_seconds Service uptime in seconds' + LineEnding +
      'service_uptime_seconds %d' + LineEnding,
      [FRequestsTotal, FErrorsTotal, FActiveConnections, UptimeSeconds]);
  finally
    FCS.Leave;
  end;
end;
```

### Dashboard de monitoring web

```html
<!-- dashboard.html - Interface de monitoring -->
<!DOCTYPE html>
<html>
<head>
    <title>Monitoring - Mon Service</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .status-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status-healthy { color: #28a745; }
        .status-warning { color: #ffc107; }
        .status-critical { color: #dc3545; }
        .metric {
            display: inline-block;
            margin: 10px 20px;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
        }
        .metric-label {
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Monitoring - Mon Service FreePascal</h1>

        <div class="status-card">
            <h2>√âtat du Service</h2>
            <div id="service-status">Chargement...</div>
        </div>

        <div class="status-card">
            <h2>M√©triques</h2>
            <div id="metrics">
                <div class="metric">
                    <div class="metric-value" id="uptime">-</div>
                    <div class="metric-label">Uptime</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memory">-</div>
                    <div class="metric-label">M√©moire (MB)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="threads">-</div>
                    <div class="metric-label">Threads</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="processed">-</div>
                    <div class="metric-label">Trait√©s</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="errors">-</div>
                    <div class="metric-label">Erreurs</div>
                </div>
            </div>
        </div>

        <div class="status-card">
            <h2>V√©rifications de Sant√©</h2>
            <div id="health-checks">Chargement...</div>
        </div>

        <div class="status-card">
            <h2>Logs R√©cents</h2>
            <pre id="recent-logs" style="max-height: 300px; overflow-y: auto;">
Chargement...
            </pre>
        </div>
    </div>

    <script>
        function updateStatus() {
            // R√©cup√©rer le statut
            fetch('http://localhost:8080/status')
                .then(response => response.json())
                .then(data => {
                    // Mettre √† jour l'√©tat g√©n√©ral
                    const statusEl = document.getElementById('service-status');
                    statusEl.className = 'status-' + data.status;
                    statusEl.textContent = data.status.toUpperCase() + ' - ' + data.message;

                    // Mettre √† jour les m√©triques
                    document.getElementById('uptime').textContent = data.uptime;
                    document.getElementById('memory').textContent = data.memory_mb;
                    document.getElementById('threads').textContent = data.threads;
                    document.getElementById('processed').textContent = data.processed_count;
                    document.getElementById('errors').textContent = data.error_count;
                })
                .catch(error => {
                    document.getElementById('service-status').textContent =
                        'ERREUR - Impossible de contacter le service';
                });

            // R√©cup√©rer les v√©rifications de sant√©
            fetch('http://localhost:8080/health')
                .then(response => response.json())
                .then(data => {
                    const checksEl = document.getElementById('health-checks');
                    checksEl.innerHTML = '';

                    data.checks.forEach(check => {
                        const checkDiv = document.createElement('div');
                        checkDiv.className = 'health-check';

                        const statusClass = check.status === 0 ? 'healthy' :
                                           check.status === 1 ? 'warning' : 'critical';

                        checkDiv.innerHTML = `
                            <span class="status-${statusClass}">‚óè</span>
                            <strong>${check.name}:</strong> ${check.message}
                        `;

                        checksEl.appendChild(checkDiv);
                    });
                });

            // R√©cup√©rer les logs r√©cents
            fetch('http://localhost:8080/logs?lines=20')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('recent-logs').textContent = data;
                });
        }

        // Mettre √† jour toutes les 5 secondes
        updateStatus();
        setInterval(updateStatus, 5000);
    </script>
</body>
</html>
```

## Maintenance et √©volution

### Script de mise √† jour automatique

```pascal
program ServiceUpdater;

{$mode objfpc}{$H+}

uses
  Classes, SysUtils, Windows, Process;

type
  TServiceUpdater = class
  private
    FServiceName: string;
    FUpdatePath: string;
    FBackupPath: string;
    FLogger: TLogger;

    function StopService: Boolean;
    function BackupCurrentVersion: Boolean;
    function ApplyUpdate: Boolean;
    function StartService: Boolean;
    procedure RollbackUpdate;

  public
    constructor Create(const ServiceName, UpdatePath: string);
    function PerformUpdate: Boolean;
  end;

implementation

function TServiceUpdater.PerformUpdate: Boolean;
var
  UpdateVersion, CurrentVersion: string;
begin
  Result := False;

  FLogger.Log('D√©but de la mise √† jour du service ' + FServiceName);

  try
    // 1. V√©rifier la version
    UpdateVersion := GetFileVersion(FUpdatePath + '\MonService.exe');
    CurrentVersion := GetFileVersion(ExtractFilePath(ParamStr(0)) + '\MonService.exe');

    if CompareVersion(UpdateVersion, CurrentVersion) <= 0 then
    begin
      FLogger.Log('Version d√©j√† √† jour ou plus r√©cente');
      Exit(True);
    end;

    FLogger.Log(Format('Mise √† jour de %s vers %s',
                      [CurrentVersion, UpdateVersion]));

    // 2. Arr√™ter le service
    if not StopService then
    begin
      FLogger.LogError('Impossible d''arr√™ter le service');
      Exit;
    end;

    // 3. Sauvegarder la version actuelle
    if not BackupCurrentVersion then
    begin
      FLogger.LogError('Impossible de cr√©er la sauvegarde');
      StartService; // Red√©marrer le service
      Exit;
    end;

    // 4. Appliquer la mise √† jour
    if not ApplyUpdate then
    begin
      FLogger.LogError('Impossible d''appliquer la mise √† jour');
      RollbackUpdate;
      StartService;
      Exit;
    end;

    // 5. Red√©marrer le service
    if not StartService then
    begin
      FLogger.LogError('Impossible de red√©marrer le service');
      FLogger.Log('Tentative de rollback...');
      RollbackUpdate;
      StartService;
      Exit;
    end;

    // 6. V√©rifier que le service fonctionne
    Sleep(5000); // Attendre 5 secondes

    if not IsServiceRunning(FServiceName) then
    begin
      FLogger.LogError('Le service ne fonctionne pas apr√®s la mise √† jour');
      RollbackUpdate;
      StartService;
      Exit;
    end;

    FLogger.Log('Mise √† jour r√©ussie!');
    Result := True;

    // 7. Nettoyer les anciennes sauvegardes (garder les 3 derni√®res)
    CleanOldBackups(3);

  except
    on E: Exception do
    begin
      FLogger.LogError('Erreur lors de la mise √† jour : ' + E.Message);
      RollbackUpdate;
      StartService;
    end;
  end;
end;

function TServiceUpdater.BackupCurrentVersion: Boolean;
var
  BackupDir: string;
begin
  BackupDir := Format('%s\backup_%s',
                      [FBackupPath, FormatDateTime('yyyymmdd_hhnnss', Now)]);

  Result := CreateDir(BackupDir) and
            CopyDirectory(ExtractFilePath(ParamStr(0)), BackupDir);

  if Result then
    FLogger.Log('Sauvegarde cr√©√©e : ' + BackupDir);
end;

procedure TServiceUpdater.RollbackUpdate;
var
  LastBackup: string;
begin
  FLogger.Log('Rollback en cours...');

  // Trouver la derni√®re sauvegarde
  LastBackup := GetLatestBackup(FBackupPath);

  if LastBackup <> '' then
  begin
    // Restaurer depuis la sauvegarde
    if CopyDirectory(LastBackup, ExtractFilePath(ParamStr(0))) then
      FLogger.Log('Rollback r√©ussi depuis : ' + LastBackup)
    else
      FLogger.LogError('√âchec du rollback');
  end
  else
    FLogger.LogError('Aucune sauvegarde trouv√©e pour le rollback');
end;
```

### Plan de disaster recovery

```yaml
# disaster-recovery-plan.yaml
service_name: MonServiceFreePascal
recovery_time_objective: 1h
recovery_point_objective: 24h

backup_strategy:
  frequency: daily
  retention: 30_days
  locations:
    - local: C:\Backups\Service
    - network: \\backup-server\services
    - cloud: azure-blob-storage

  components:
    - executables: true
    - configuration: true
    - logs: true
    - data: true

recovery_procedures:

  corruption_service:
    steps:
      1: Arr√™ter le service imm√©diatement
      2: Identifier la derni√®re sauvegarde valide
      3: Restaurer les fichiers du service
      4: V√©rifier la configuration
      5: Red√©marrer le service
      6: V√©rifier le fonctionnement

  perte_donnees:
    steps:
      1: Arr√™ter le service
      2: Restaurer la base de donn√©es depuis la sauvegarde
      3: Rejouer les transactions depuis les logs si possible
      4: V√©rifier l'int√©grit√© des donn√©es
      5: Red√©marrer le service

  serveur_hs:
    steps:
      1: Provisionner un nouveau serveur
      2: Installer les pr√©requis
      3: Restaurer le service depuis la sauvegarde
      4: Restaurer la configuration
      5: Restaurer les donn√©es
      6: Tester le service
      7: Rediriger le trafic

contacts:
  responsable_technique: jean.dupont@societe.com
  equipe_infrastructure: infra@societe.com
  support_24_7: +33 1 23 45 67 89

verification_checklist:
  - [ ] Service d√©marre correctement
  - [ ] Connexions base de donn√©es OK
  - [ ] API r√©pond aux requ√™tes
  - [ ] Logs g√©n√©r√©s correctement
  - [ ] Monitoring actif
  - [ ] Alertes configur√©es
  - [ ] Performance acceptable
```

## Conclusion et bonnes pratiques finales

### Les 10 commandements du service Windows

1. **Tu loggeras tout** : Un service sans logs est un service aveugle
2. **Tu g√©reras les erreurs** : Toute exception doit √™tre captur√©e et trait√©e
3. **Tu ne bloqueras point** : Utilise des timeouts et du code asynchrone
4. **Tu surveilleras la m√©moire** : Les fuites m√©moire tuent les services
5. **Tu testeras en production** : L'environnement de dev n'est jamais identique
6. **Tu documenteras ton code** : Ton successeur te remerciera
7. **Tu configureras externellement** : Pas de valeurs en dur dans le code
8. **Tu s√©curiseras ton service** : Principe du moindre privil√®ge toujours
9. **Tu automatiseras le d√©ploiement** : Les installations manuelles g√©n√®rent des erreurs
10. **Tu monitoreras activement** : Un service non surveill√© tombera au pire moment

### Ressources additionnelles

- **Documentation Microsoft** : [Windows Service Applications](https://docs.microsoft.com/en-us/dotnet/framework/windows-services/)
- **FreePascal Wiki** : [Daemon/Service Application](https://wiki.freepascal.org/Daemon_application)
- **Outils de monitoring** :
  - Zabbix (gratuit, open source)
  - Prometheus + Grafana (gratuit, open source)
  - Datadog (payant, tr√®s complet)
  - New Relic (payant, excellent pour les performances)

### Message final

Cr√©er un service Windows robuste avec FreePascal/Lazarus demande de la rigueur et de la patience, mais le r√©sultat en vaut la peine. Un service bien con√ßu peut tourner des ann√©es sans intervention, traitant silencieusement des millions d'op√©rations.

N'oubliez jamais : un service est comme un moteur de voiture - il doit √™tre fiable, bien entretenu, et surveill√© r√©guli√®rement. Avec les bonnes pratiques et les outils pr√©sent√©s dans ce tutoriel, vous avez tout ce qu'il faut pour cr√©er des services Windows professionnels et robustes.

Bon d√©veloppement !

‚è≠Ô∏è [Interaction avec le Service Control Manager](/06-specificites-windows/02.2-interaction-service-control-manager.md)
