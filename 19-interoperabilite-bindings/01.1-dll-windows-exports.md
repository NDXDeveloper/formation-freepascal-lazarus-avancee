üîù Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.1 DLL Windows et exports

## Introduction aux DLL Windows

Une **DLL (Dynamic Link Library)** est le format de biblioth√®que partag√©e utilis√© par Microsoft Windows. C'est un fichier ex√©cutable (format PE - Portable Executable) qui contient du code, des donn√©es et des ressources utilisables par plusieurs programmes simultan√©ment.

### Historique et contexte

Les DLL ont √©t√© introduites avec Windows 1.0 en 1985 pour :
- √âconomiser la m√©moire (tr√®s limit√©e √† l'√©poque)
- Partager du code entre applications
- Permettre les mises √† jour syst√®me sans recompiler les applications

Aujourd'hui, Windows repose massivement sur les DLL :
- `kernel32.dll` : fonctions syst√®me de base
- `user32.dll` : interface utilisateur
- `gdi32.dll` : graphiques
- `msvcrt.dll` : runtime C/C++
- Et des milliers d'autres...

### Structure d'une DLL

Une DLL Windows contient plusieurs sections :

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         En-t√™te PE (PE Header)      ‚îÇ  ‚Üê M√©tadonn√©es du fichier
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Table d'export (Export Table)  ‚îÇ  ‚Üê Fonctions disponibles
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      Table d'import (Import Table)  ‚îÇ  ‚Üê DLL dont elle d√©pend
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Section .text               ‚îÇ  ‚Üê Code ex√©cutable
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Section .data               ‚îÇ  ‚Üê Donn√©es initialis√©es
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Section .bss                ‚îÇ  ‚Üê Donn√©es non initialis√©es
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Section .rsrc               ‚îÇ  ‚Üê Ressources (ic√¥nes, etc.)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Section .reloc              ‚îÇ  ‚Üê Relocations
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Pourquoi cr√©er des DLL avec FreePascal ?

1. **Interop√©rabilit√© Windows** : Cr√©er des composants utilisables par n'importe quelle application Windows
2. **Plugins** : Syst√®mes extensibles (comme les plugins Photoshop, VST audio, etc.)
3. **ActiveX/COM** : Technologies Windows n√©cessitant des DLL
4. **Wrapping** : Exposer du code Pascal √† d'autres langages (C#, VB, Python)
5. **Performance** : Code natif optimis√© accessible depuis des langages manag√©s

## Cr√©er votre premi√®re DLL

### Structure de base

Voici le squelette minimal d'une DLL en FreePascal :

```pascal
library MaPremiereLib;

{$mode objfpc}{$H+}

uses
  SysUtils;

// D√©claration des fonctions √† exporter
function Addition(a, b: Integer): Integer; stdcall;  
begin
  Result := a + b;
end;

// Section exports - OBLIGATOIRE pour une DLL
exports
  Addition;

begin
  // Code d'initialisation (optionnel)
end.
```

**Points cl√©s** :
- Le mot-cl√© `library` au lieu de `program`
- Directive `exports` pour lister les fonctions accessibles
- Convention d'appel `stdcall` (standard Windows)
- Pas de `begin..end` final obligatoire si pas d'initialisation

### Compilation

Pour compiler cette DLL :

```batch
fpc -oMaPremiereLib.dll MaPremiereLib.pas
```

Options utiles :
- `-O3` : optimisation maximale
- `-WG` : g√©n√®re une application GUI (pas de console)
- `-Xs` : strip symbols (r√©duction de taille)
- `-XX` : smart linking

**Exemple complet** :
```batch
fpc -oMaPremiereLib.dll -O3 -WG -Xs -XX MaPremiereLib.pas
```

### Utilisation depuis FreePascal

Pour utiliser votre DLL depuis une autre application Pascal :

```pascal
program TestDLL;

{$mode objfpc}{$H+}

// D√©claration de la fonction externe
function Addition(a, b: Integer): Integer; stdcall;
  external 'MaPremiereLib.dll';

var
  resultat: Integer;
begin
  resultat := Addition(10, 32);
  WriteLn('10 + 32 = ', resultat);
  ReadLn;
end.
```

### Utilisation depuis C/C++

La m√™me DLL peut √™tre utilis√©e depuis C :

```c
// test.c
#include <stdio.h>
#include <windows.h>

// D√©finition du type de fonction
typedef int (__stdcall *AdditionFunc)(int, int);

int main() {
    // Charger la DLL
    HMODULE dll = LoadLibrary("MaPremiereLib.dll");
    if (dll == NULL) {
        printf("Erreur: impossible de charger la DLL\n");
        return 1;
    }

    // Obtenir l'adresse de la fonction
    AdditionFunc Addition = (AdditionFunc)GetProcAddress(dll, "Addition");
    if (Addition == NULL) {
        printf("Erreur: fonction Addition non trouv√©e\n");
        FreeLibrary(dll);
        return 1;
    }

    // Utiliser la fonction
    int result = Addition(10, 32);
    printf("10 + 32 = %d\n", result);

    // Lib√©rer la DLL
    FreeLibrary(dll);
    return 0;
}
```

Compilation C :
```batch
gcc test.c -o test.exe
```

## La directive exports

### Syntaxe de base

La directive `exports` liste les symboles (fonctions, proc√©dures, variables) accessibles depuis l'ext√©rieur de la DLL.

```pascal
exports
  Fonction1,
  Fonction2,
  Fonction3;
```

### Export avec alias

Vous pouvez exporter une fonction sous un nom diff√©rent :

```pascal
function CalculerSomme(a, b: Integer): Integer; stdcall;  
begin
  Result := a + b;
end;

exports
  CalculerSomme name 'Add';  // Export√©e sous le nom "Add"
```

Depuis C, vous l'appellerez `Add`, pas `CalculerSomme`.

### Export par index

Windows permet d'exporter par num√©ro (ordinal) au lieu du nom :

```pascal
exports
  Fonction1 index 1,
  Fonction2 index 2,
  Fonction3 index 3;
```

**Avantages** :
- L√©g√®rement plus rapide (pas de recherche par nom)
- Fichier DLL plus petit (pas de noms stock√©s)

**Inconv√©nients** :
- Plus difficile √† d√©boguer
- Fragile (changer l'ordre casse la compatibilit√©)

**Recommandation** : Utilisez les noms sauf si vous avez une raison sp√©cifique d'utiliser des index.

### Export de variables

On peut aussi exporter des variables globales :

```pascal
var
  CompteurGlobal: Integer = 0;

procedure Incr√©menterCompteur; stdcall;  
begin
  Inc(CompteurGlobal);
end;

function ObtenirCompteur: Integer; stdcall;  
begin
  Result := CompteurGlobal;
end;

exports
  Incr√©menterCompteur,
  ObtenirCompteur;
```

**Attention** : Exporter directement des variables est d√©licat. Il est pr√©f√©rable d'utiliser des fonctions get/set.

## Conventions d'appel sur Windows

Windows supporte plusieurs conventions d'appel. Le choix est crucial pour la compatibilit√©.

### stdcall (WINAPI)

La convention standard de l'API Windows.

**Caract√©ristiques** :
- Param√®tres pass√©s sur la pile de droite √† gauche
- La fonction appel√©e nettoie la pile
- Noms d√©cor√©s : `_NomFonction@NombreOctets`

```pascal
function MaFonction(x: Integer; y: Integer): Integer; stdcall;
```

**Name mangling** : `_MaFonction@8` (8 = 2 param√®tres √ó 4 octets)

**Quand l'utiliser** :
- Pour l'API Windows (obligatoire)
- Pour la compatibilit√© avec VB6, C# P/Invoke
- Pour les callbacks Windows

### cdecl

La convention C standard.

**Caract√©ristiques** :
- Param√®tres pass√©s sur la pile de droite √† gauche
- L'appelant nettoie la pile
- Support des fonctions variadiques
- Noms d√©cor√©s : `_NomFonction`

```pascal
function MaFonction(x: Integer; y: Integer): Integer; cdecl;
```

**Quand l'utiliser** :
- Pour la compatibilit√© C/C++
- Quand vous avez besoin de fonctions variadiques
- Pour les biblioth√®ques multi-plateformes

### register (Pascal)

Convention native de Pascal.

**Caract√©ristiques** :
- Utilise les registres CPU (EAX, EDX, ECX)
- Tr√®s efficace
- Non portable vers d'autres langages

```pascal
function MaFonction(x: Integer; y: Integer): Integer; register;
```

**Quand l'utiliser** :
- DLL uniquement pour FreePascal/Delphi
- Performance maximale
- Pas d'interop√©rabilit√© requise

### Tableau r√©capitulatif

| Convention | Nettoyage pile | Variadique | Registres | D√©coration | Usage |
|------------|---------------|------------|-----------|------------|-------|
| stdcall | Appel√© | Non | Non | Oui | API Windows, VB |
| cdecl | Appelant | Oui | Non | Oui | C/C++, portable |
| register | Appel√© | Non | Oui | Oui | Pascal uniquement |

## Gestion de la m√©moire dans les DLL

La m√©moire est le point le plus d√©licat lors de l'√©change de donn√©es entre une DLL et son client.

### Probl√®me du "heap mismatch"

Chaque module (EXE, DLL) peut utiliser son propre gestionnaire de m√©moire (heap) :

```
Application.exe                    MaLib.dll
     ‚îÇ                                 ‚îÇ
     ‚îú‚îÄ Heap A                         ‚îú‚îÄ Heap B
     ‚îÇ   (allocateur FPC)              ‚îÇ   (allocateur FPC)
     ‚îÇ                                 ‚îÇ
```

**Danger** : Si la DLL alloue avec Heap B et l'application lib√®re avec Heap A ‚Üí **CRASH**

### Solutions

#### Solution 1 : L'appelant alloue le buffer

La m√©thode la plus s√ªre.

```pascal
// Dans la DLL
procedure RemplirBuffer(buffer: PByte; taille: Integer); stdcall;  
var
  i: Integer;
begin
  if buffer = nil then Exit;
  for i := 0 to taille - 1 do
    buffer[i] := i mod 256;
end;

exports
  RemplirBuffer;
```

Utilisation :
```pascal
// Dans l'application cliente
var
  buffer: array[0..99] of Byte;
begin
  RemplirBuffer(@buffer[0], Length(buffer));
end;
```

**Avantages** :
- Pas de probl√®me de heap
- Simple et s√ªr

**Inconv√©nients** :
- Le client doit conna√Ætre la taille
- Pas de taille dynamique

#### Solution 2 : Paire allocation/lib√©ration

La DLL fournit les deux fonctions.

```pascal
// Allocation dans la DLL
function AllouerDonnees(taille: Integer): Pointer; stdcall;  
begin
  GetMem(Result, taille);
end;

// Lib√©ration dans la DLL
procedure LibererDonnees(p: Pointer); stdcall;  
begin
  FreeMem(p);
end;

exports
  AllouerDonnees,
  LibererDonnees;
```

Utilisation :
```pascal
var
  donnees: Pointer;
begin
  donnees := AllouerDonnees(1024);
  try
    // Utilisation
  finally
    LibererDonnees(donnees);
  end;
end;
```

**Avantages** :
- Taille dynamique
- Pas de heap mismatch

**Inconv√©nients** :
- Deux fonctions n√©cessaires
- Le client doit penser √† lib√©rer

#### Solution 3 : API Windows (GlobalAlloc/GlobalFree)

Utiliser l'allocateur Windows global.

```pascal
uses
  Windows;

function AllouerDonnees(taille: Integer): Pointer; stdcall;  
begin
  Result := GlobalAlloc(GMEM_FIXED, taille);
end;

procedure LibererDonnees(p: Pointer); stdcall;  
begin
  GlobalFree(HGLOBAL(p));
end;
```

**Avantages** :
- Compatible avec tous les modules Windows
- Standard pour COM/OLE

**Inconv√©nients** :
- Sp√©cifique Windows
- L√©g√®rement plus lent

#### Solution 4 : Handles opaques

La DLL cache compl√®tement la gestion m√©moire.

```pascal
type
  TMonObjet = record
    donnees: array[0..999] of Byte;
    taille: Integer;
  end;
  PMonObjet = ^TMonObjet;

  THandle = type Pointer;  // Type opaque

function CreerObjet: THandle; stdcall;  
var
  obj: PMonObjet;
begin
  New(obj);
  obj^.taille := 0;
  Result := THandle(obj);
end;

procedure DetruireObjet(h: THandle); stdcall;  
var
  obj: PMonObjet;
begin
  if h <> nil then
  begin
    obj := PMonObjet(h);
    Dispose(obj);
  end;
end;

function TailleObjet(h: THandle): Integer; stdcall;  
var
  obj: PMonObjet;
begin
  if h = nil then
    Result := 0
  else
  begin
    obj := PMonObjet(h);
    Result := obj^.taille;
  end;
end;

exports
  CreerObjet,
  DetruireObjet,
  TailleObjet;
```

**Avantages** :
- Encapsulation totale
- Type-safe
- Flexible pour l'√©volution

**Inconv√©nients** :
- Plus verbeux
- Overhead d'indirection

### Cha√Ænes de caract√®res

Les cha√Ænes Pascal (`string`) ne doivent **JAMAIS** √™tre expos√©es directement.

#### Mauvais exemple

```pascal
// ‚ùå NE FAITES PAS √áA
function ObtenirNom: string; stdcall;  
begin
  Result := 'Hello World';
end;
```

Pourquoi ? La structure interne de `string` est sp√©cifique √† FreePascal et g√®re la m√©moire automatiquement.

#### Bon exemple 1 : Buffer pr√©d√©fini

```pascal
// ‚úÖ Approche buffer
procedure ObtenirNom(buffer: PChar; tailleBuffer: Integer); stdcall;  
const
  NOM = 'Hello World';
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(NOM), tailleBuffer - 1);
end;

exports
  ObtenirNom;
```

Utilisation :
```pascal
var
  buffer: array[0..255] of Char;
begin
  ObtenirNom(@buffer[0], Length(buffer));
  WriteLn(buffer);
end;
```

#### Bon exemple 2 : Retour PChar (lecture seule)

```pascal
var
  NomGlobal: string = 'Hello World';

function ObtenirNom: PChar; stdcall;  
begin
  Result := PChar(NomGlobal);
end;

exports
  ObtenirNom;
```

**Attention** : Le pointeur reste valide tant que `NomGlobal` existe. Ne pas lib√©rer ce pointeur !

#### Bon exemple 3 : Allocation par l'appelant avec taille dynamique

```pascal
function ObtenirTailleNom: Integer; stdcall;  
const
  NOM = 'Hello World';
begin
  Result := Length(NOM) + 1;  // +1 pour le #0 terminal
end;

procedure ObtenirNom(buffer: PChar; tailleBuffer: Integer); stdcall;  
const
  NOM = 'Hello World';
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(NOM), tailleBuffer - 1);
end;

exports
  ObtenirTailleNom,
  ObtenirNom;
```

Utilisation :
```pascal
var
  taille: Integer;
  buffer: PChar;
begin
  taille := ObtenirTailleNom();
  GetMem(buffer, taille);
  try
    ObtenirNom(buffer, taille);
    WriteLn(buffer);
  finally
    FreeMem(buffer);
  end;
end;
```

## Gestion des erreurs

Les exceptions Pascal ne traversent pas les fronti√®res des DLL de mani√®re fiable.

### Approche 1 : Codes de retour

M√©thode classique C/Windows.

```pascal
const
  SUCCESS = 0;
  ERROR_INVALID_PARAMETER = 1;
  ERROR_OUT_OF_MEMORY = 2;
  ERROR_FILE_NOT_FOUND = 3;

function FaireQuelqueChose(param: Integer): Integer; stdcall;  
begin
  Result := SUCCESS;

  if param < 0 then
  begin
    Result := ERROR_INVALID_PARAMETER;
    Exit;
  end;

  try
    // Code qui peut √©chouer
  except
    Result := ERROR_OUT_OF_MEMORY;
  end;
end;

exports
  FaireQuelqueChose;
```

Utilisation :
```pascal
var
  code: Integer;
begin
  code := FaireQuelqueChose(42);
  if code <> SUCCESS then
    WriteLn('Erreur : ', code);
end;
```

### Approche 2 : Dernier code d'erreur (style GetLastError)

Comme l'API Windows.

```pascal
var
  DernierCodeErreur: Integer = 0;

function FaireQuelqueChose(param: Integer): Boolean; stdcall;  
begin
  DernierCodeErreur := SUCCESS;
  Result := True;

  if param < 0 then
  begin
    DernierCodeErreur := ERROR_INVALID_PARAMETER;
    Result := False;
    Exit;
  end;

  // ... reste du code
end;

function ObtenirDernierCodeErreur: Integer; stdcall;  
begin
  Result := DernierCodeErreur;
end;

exports
  FaireQuelqueChose,
  ObtenirDernierCodeErreur;
```

### Approche 3 : Messages d'erreur

Retourner un message lisible.

```pascal
var
  DernierMessageErreur: string = '';

function FaireQuelqueChose(param: Integer): Boolean; stdcall;  
begin
  DernierMessageErreur := '';
  Result := True;

  try
    if param < 0 then
      raise Exception.Create('Param√®tre invalide');
    // ... code
  except
    on E: Exception do
    begin
      DernierMessageErreur := E.Message;
      Result := False;
    end;
  end;
end;

procedure ObtenirDernierMessageErreur(buffer: PChar; taille: Integer); stdcall;  
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(DernierMessageErreur), taille - 1);
end;

exports
  FaireQuelqueChose,
  ObtenirDernierMessageErreur;
```

## Initialisation et finalisation

Une DLL peut avoir du code ex√©cut√© au chargement et au d√©chargement.

### Structure compl√®te

```pascal
library MaLib;

{$mode objfpc}{$H+}

uses
  SysUtils, Windows;

var
  InitialisationReussie: Boolean = False;
  CompteurInstances: Integer = 0;

function Initialiser: Boolean; stdcall;  
begin
  Result := False;
  try
    // Initialisation des ressources
    WriteLn('Initialisation de la DLL');
    InitialisationReussie := True;
    Result := True;
  except
    InitialisationReussie := False;
  end;
end;

procedure Finaliser; stdcall;  
begin
  WriteLn('Finalisation de la DLL');
  // Lib√©ration des ressources
end;

exports
  Initialiser,
  Finaliser;

// Point d'entr√©e DLL (optionnel)
procedure DLLMain(Reason: DWORD);  
begin
  case Reason of
    DLL_PROCESS_ATTACH:
      begin
        Inc(CompteurInstances);
        WriteLn('DLL charg√©e par un processus. Instances : ', CompteurInstances);
      end;
    DLL_PROCESS_DETACH:
      begin
        Dec(CompteurInstances);
        WriteLn('DLL d√©charg√©e par un processus. Instances : ', CompteurInstances);
      end;
    DLL_THREAD_ATTACH:
      begin
        WriteLn('Nouveau thread a charg√© la DLL');
      end;
    DLL_THREAD_DETACH:
      begin
        WriteLn('Un thread a d√©charg√© la DLL');
      end;
  end;
end;

begin
  // Code d'initialisation de la DLL
  DLLProc := @DLLMain;
  DLLMain(DLL_PROCESS_ATTACH);
end.
```

**Constantes Windows** :
- `DLL_PROCESS_ATTACH` (1) : DLL charg√©e par un processus
- `DLL_PROCESS_DETACH` (0) : DLL d√©charg√©e par un processus
- `DLL_THREAD_ATTACH` (2) : Nouveau thread dans un processus qui a charg√© la DLL
- `DLL_THREAD_DETACH` (3) : Thread se termine

## Callbacks depuis la DLL

Une DLL peut appeler des fonctions fournies par l'application cliente.

### D√©finition du callback

```pascal
library CallbackDemo;

{$mode objfpc}{$H+}

type
  // Type du callback
  TProgressCallback = procedure(progression: Integer); stdcall;

// Fonction qui utilise le callback
procedure TraiterDonnees(callback: TProgressCallback); stdcall;  
var
  i: Integer;
begin
  for i := 0 to 100 do
  begin
    // Simulation de traitement
    Sleep(50);

    // Appeler le callback si fourni
    if Assigned(callback) then
      callback(i);
  end;
end;

exports
  TraiterDonnees;

begin  
end.
```

### Utilisation du callback

```pascal
program TestCallback;

{$mode objfpc}{$H+}

uses
  SysUtils;

// D√©claration du type callback
type
  TProgressCallback = procedure(progression: Integer); stdcall;

// D√©claration de la fonction DLL
procedure TraiterDonnees(callback: TProgressCallback); stdcall;
  external 'CallbackDemo.dll';

// Impl√©mentation du callback
procedure MonCallback(progression: Integer); stdcall;  
begin
  WriteLn('Progression : ', progression, '%');
end;

begin
  WriteLn('D√©but du traitement...');
  TraiterDonnees(@MonCallback);
  WriteLn('Traitement termin√© !');
  ReadLn;
end.
```

### Callbacks avec contexte utilisateur

Souvent, vous voulez passer des donn√©es au callback.

```pascal
type
  TProgressCallbackEx = procedure(progression: Integer;
    userData: Pointer); stdcall;

procedure TraiterDonneesEx(callback: TProgressCallbackEx;
  userData: Pointer); stdcall;
var
  i: Integer;
begin
  for i := 0 to 100 do
  begin
    Sleep(50);
    if Assigned(callback) then
      callback(i, userData);
  end;
end;

exports
  TraiterDonneesEx;
```

Utilisation :
```pascal
type
  TMonContexte = record
    nom: string[50];
    compteur: Integer;
  end;
  PMonContexte = ^TMonContexte;

procedure CallbackAvecContexte(progression: Integer; userData: Pointer); stdcall;  
var
  ctx: PMonContexte;
begin
  ctx := PMonContexte(userData);
  Inc(ctx^.compteur);
  WriteLn(ctx^.nom, ' - Progression : ', progression,
    '% (appel #', ctx^.compteur, ')');
end;

var
  contexte: TMonContexte;
begin
  contexte.nom := 'MonTraitement';
  contexte.compteur := 0;
  TraiterDonneesEx(@CallbackAvecContexte, @contexte);
end;
```

## D√©bogage des DLL

### V√©rifier les exports

Utilisez l'outil `dumpbin` (fourni avec Visual Studio) :

```batch
dumpbin /EXPORTS MaPremiereLib.dll
```

Ou `objdump` (fourni avec MinGW) :

```batch
objdump -x MaPremiereLib.dll | findstr "Export"
```

Sortie exemple :
```
ordinal hint RVA      name
      1    0 00001000 Addition
      2    1 00001020 Soustraction
```

### Dependency Walker

**Dependency Walker** est un outil graphique Windows tr√®s utile :
- Liste toutes les fonctions export√©es
- Montre les d√©pendances (autres DLL)
- D√©tecte les DLL manquantes
- Affiche l'ordre de chargement

T√©l√©chargeable gratuitement sur [dependencywalker.com](http://www.dependencywalker.com/)

### D√©boguer avec GDB

Compiler la DLL avec les symboles de d√©bogage :

```batch
fpc -g -oMaLib.dll MaLib.pas
```

Lancer GDB :
```batch
gdb MonApplication.exe
(gdb) break Addition
(gdb) run
(gdb) step
```

## Exemple complet : Biblioth√®que math√©matique

Cr√©ons une DLL compl√®te avec plusieurs fonctions math√©matiques.

```pascal
library MathLib;

{$mode objfpc}{$H+}

uses
  SysUtils, Math;

const
  MATHLIB_SUCCESS = 0;
  MATHLIB_ERROR_DIVISION_BY_ZERO = 1;
  MATHLIB_ERROR_NEGATIVE_ROOT = 2;

var
  LastError: Integer = MATHLIB_SUCCESS;
  LastErrorMessage: string = '';

// Addition
function Add(a, b: Double): Double; stdcall;  
begin
  LastError := MATHLIB_SUCCESS;
  Result := a + b;
end;

// Soustraction
function Subtract(a, b: Double): Double; stdcall;  
begin
  LastError := MATHLIB_SUCCESS;
  Result := a - b;
end;

// Multiplication
function Multiply(a, b: Double): Double; stdcall;  
begin
  LastError := MATHLIB_SUCCESS;
  Result := a * b;
end;

// Division avec gestion d'erreur
function Divide(a, b: Double; out result: Double): Integer; stdcall;  
begin
  LastError := MATHLIB_SUCCESS;
  LastErrorMessage := '';

  if b = 0 then
  begin
    LastError := MATHLIB_ERROR_DIVISION_BY_ZERO;
    LastErrorMessage := 'Division par z√©ro';
    result := 0;
    Result := LastError;
    Exit;
  end;

  result := a / b;
  Result := MATHLIB_SUCCESS;
end;

// Racine carr√©e avec gestion d'erreur
function SquareRoot(x: Double; out result: Double): Integer; stdcall;  
begin
  LastError := MATHLIB_SUCCESS;
  LastErrorMessage := '';

  if x < 0 then
  begin
    LastError := MATHLIB_ERROR_NEGATIVE_ROOT;
    LastErrorMessage := 'Racine carr√©e d''un nombre n√©gatif';
    result := 0;
    Result := LastError;
    Exit;
  end;

  result := Sqrt(x);
  Result := MATHLIB_SUCCESS;
end;

// Puissance
function Power(base, exponent: Double): Double; stdcall;  
begin
  LastError := MATHLIB_SUCCESS;
  Result := Math.Power(base, exponent);
end;

// Obtenir le dernier code d'erreur
function GetLastError: Integer; stdcall;  
begin
  Result := LastError;
end;

// Obtenir le dernier message d'erreur
procedure GetLastErrorMessage(buffer: PChar; bufferSize: Integer); stdcall;  
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(LastErrorMessage), bufferSize - 1);
end;

// Version de la biblioth√®que
function GetVersion: PChar; stdcall;  
const
  VERSION = '1.0.0';
begin
  Result := VERSION;
end;

exports
  Add,
  Subtract,
  Multiply,
  Divide,
  SquareRoot,
  Power,
  GetLastError,
  GetLastErrorMessage,
  GetVersion;

begin
  // Initialisation
end.
```

### Programme de test

```pascal
program TestMathLib;

{$mode objfpc}{$H+}

uses
  SysUtils;

// D√©clarations externes
function Add(a, b: Double): Double; stdcall; external 'MathLib.dll';  
function Subtract(a, b: Double): Double; stdcall; external 'MathLib.dll';  
function Multiply(a, b: Double): Double; stdcall; external 'MathLib.dll';  
function Divide(a, b: Double; out result: Double): Integer; stdcall;
  external 'MathLib.dll';
function SquareRoot(x: Double; out result: Double): Integer; stdcall;
  external 'MathLib.dll';
function Power(base, exponent: Double): Double; stdcall; external 'MathLib.dll';  
function GetLastError: Integer; stdcall; external 'MathLib.dll';  
procedure GetLastErrorMessage(buffer: PChar; bufferSize: Integer); stdcall;
  external 'MathLib.dll';
function GetVersion: PChar; stdcall; external 'MathLib.dll';

procedure TestOperations;  
var
  result: Double;
  errorCode: Integer;
  errorMsg: array[0..255] of Char;
begin
  WriteLn('=== Test de MathLib ===');
  WriteLn('Version : ', GetVersion);
  WriteLn;

  // Tests simples
  WriteLn('10 + 5 = ', Add(10, 5):0:2);
  WriteLn('10 - 5 = ', Subtract(10, 5):0:2);
  WriteLn('10 * 5 = ', Multiply(10, 5):0:2);
  WriteLn('2^8 = ', Power(2, 8):0:2);
  WriteLn;

  // Test division normale
  errorCode := Divide(10, 2, result);
  if errorCode = 0 then
    WriteLn('10 / 2 = ', result:0:2)
  else
  begin
    GetLastErrorMessage(@errorMsg[0], Length(errorMsg));
    WriteLn('Erreur : ', errorMsg);
  end;

  // Test division par z√©ro
  WriteLn;
  WriteLn('Test division par z√©ro :');
  errorCode := Divide(10, 0, result);
  if errorCode <> 0 then
  begin
    GetLastErrorMessage(@errorMsg[0], Length(errorMsg));
    WriteLn('Code erreur : ', errorCode);
    WriteLn('Message : ', errorMsg);
  end;

  // Test racine carr√©e normale
  WriteLn;
  errorCode := SquareRoot(16, result);
  if errorCode = 0 then
    WriteLn('Racine carr√©e de 16 = ', result:0:2);

  // Test racine carr√©e n√©gative
  WriteLn;
  WriteLn('Test racine carr√©e d''un nombre n√©gatif :');
  errorCode := SquareRoot(-16, result);
  if errorCode <> 0 then
  begin
    GetLastErrorMessage(@errorMsg[0], Length(errorMsg));
    WriteLn('Code erreur : ', errorCode);
    WriteLn('Message : ', errorMsg);
  end;
end;

begin
  try
    TestOperations;
  except
    on E: Exception do
      WriteLn('Exception : ', E.Message);
  end;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

**Sortie attendue** :
```
=== Test de MathLib ===
Version : 1.0.0

10 + 5 = 15.00
10 - 5 = 5.00
10 * 5 = 50.00
2^8 = 256.00

10 / 2 = 5.00

Test division par z√©ro :  
Code erreur : 1  
Message : Division par z√©ro

Racine carr√©e de 16 = 4.00

Test racine carr√©e d'un nombre n√©gatif :  
Code erreur : 2  
Message : Racine carr√©e d'un nombre n√©gatif

Appuyez sur Entr√©e pour quitter...
```

## Fichiers de d√©finition de module (.def)

Un fichier `.def` (Module Definition File) permet de contr√¥ler finement les exports d'une DLL.

### Pourquoi utiliser un fichier .def ?

- Contr√¥le pr√©cis sur les noms export√©s (√©viter le name mangling)
- Sp√©cifier des ordinaux (index)
- Exporter des variables
- Documentation centralis√©e des exports

### Syntaxe de base

Cr√©ez un fichier `MathLib.def` :

```
LIBRARY MathLib  
DESCRIPTION 'Biblioth√®que math√©matique pour FreePascal'

EXPORTS
    Add             @1
    Subtract        @2
    Multiply        @3
    Divide          @4
    SquareRoot      @5
    Power           @6
    GetLastError    @7
    GetLastErrorMessage @8
    GetVersion      @9
```

### Utilisation avec FreePascal

Pour utiliser un fichier `.def` lors de la compilation :

```batch
fpc -oMathLib.dll MathLib.pas MathLib.def
```

Ou cr√©ez un fichier de lien :

```batch
# link.res
EXPORTS  
Add  
Subtract  
Multiply
```

Et compilez :
```batch
fpc -oMathLib.dll MathLib.pas link.res
```

### Avantages du fichier .def

**Sans .def** : Le compilateur peut d√©corer les noms
```
_Add@16
_Subtract@16
```

**Avec .def** : Les noms restent propres
```
Add  
Subtract
```

## M√©tadonn√©es et ressources de DLL

Une DLL peut contenir des m√©tadonn√©es (version, copyright, etc.).

### Fichier de ressources (.rc)

Cr√©ez un fichier `MathLib.rc` :

```rc
#include <windows.h>

VS_VERSION_INFO VERSIONINFO  
FILEVERSION 1,0,0,0  
PRODUCTVERSION 1,0,0,0  
FILEFLAGSMASK 0x3fL  
FILEFLAGS 0x0L  
FILEOS VOS_NT_WINDOWS32  
FILETYPE VFT_DLL  
FILESUBTYPE 0x0L  
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040c04b0"
        BEGIN
            VALUE "CompanyName", "Votre Soci√©t√©"
            VALUE "FileDescription", "Biblioth√®que Math√©matique"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "MathLib"
            VALUE "LegalCopyright", "Copyright (C) 2025"
            VALUE "OriginalFilename", "MathLib.dll"
            VALUE "ProductName", "MathLib"
            VALUE "ProductVersion", "1.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x40c, 1200
    END
END
```

### Compiler les ressources

1. Compilez le fichier `.rc` en `.res` :
```batch
windres MathLib.rc -O coff -o MathLib.res
```

2. Liez avec la DLL :
```batch
fpc -oMathLib.dll MathLib.pas MathLib.res
```

### Inclure dans le code Pascal

Vous pouvez aussi inclure directement dans le code :

```pascal
library MathLib;

{$R MathLib.res}  // Inclusion du fichier de ressources

// ... reste du code
```

### V√©rifier les m√©tadonn√©es

Clic droit sur `MathLib.dll` ‚Üí Propri√©t√©s ‚Üí D√©tails

Vous verrez :
- Version du fichier
- Description
- Copyright
- Etc.

## Threading et DLL

Les DLL peuvent √™tre utilis√©es par plusieurs threads simultan√©ment.

### Variables globales et thread-safety

**Probl√®me** : Les variables globales sont partag√©es entre tous les threads.

```pascal
var
  CompteurGlobal: Integer = 0;  // DANGEREUX en multithreading

function Incrementer: Integer; stdcall;  
begin
  Inc(CompteurGlobal);  // Race condition !
  Result := CompteurGlobal;
end;
```

**Probl√®me** : Si deux threads appellent `Incrementer` simultan√©ment :

```
Thread 1: Lit CompteurGlobal (0)  
Thread 2: Lit CompteurGlobal (0)  
Thread 1: Incr√©mente ‚Üí 1  
Thread 2: Incr√©mente ‚Üí 1  (devrait √™tre 2 !)
```

### Solution 1 : Section critique

```pascal
uses
  Windows;

var
  CompteurGlobal: Integer = 0;
  CS: TRTLCriticalSection;

function Incrementer: Integer; stdcall;  
begin
  EnterCriticalSection(CS);
  try
    Inc(CompteurGlobal);
    Result := CompteurGlobal;
  finally
    LeaveCriticalSection(CS);
  end;
end;

initialization
  InitializeCriticalSection(CS);

finalization
  DeleteCriticalSection(CS);
```

### Solution 2 : Op√©rations atomiques

```pascal
uses
  Windows;

var
  CompteurGlobal: Integer = 0;

function Incrementer: Integer; stdcall;  
begin
  Result := InterlockedIncrement(CompteurGlobal);
end;
```

**Fonctions atomiques Windows** :
- `InterlockedIncrement` : Incr√©mentation atomique
- `InterlockedDecrement` : D√©cr√©mentation atomique
- `InterlockedExchange` : √âchange atomique
- `InterlockedCompareExchange` : Compare et √©change

### Solution 3 : Thread-Local Storage (TLS)

Chaque thread a sa propre copie de la variable.

```pascal
uses
  Windows;

var
  TLSIndex: DWORD;

function ObtenirValeurTLS: Integer;  
begin
  Result := Integer(TlsGetValue(TLSIndex));
end;

procedure DefinirValeurTLS(valeur: Integer);  
begin
  TlsSetValue(TLSIndex, Pointer(valeur));
end;

function IncrementerTLS: Integer; stdcall;  
var
  val: Integer;
begin
  val := ObtenirValeurTLS;
  Inc(val);
  DefinirValeurTLS(val);
  Result := val;
end;

exports
  IncrementerTLS;

procedure DLLMain(Reason: DWORD);  
begin
  case Reason of
    DLL_PROCESS_ATTACH:
      TLSIndex := TlsAlloc();
    DLL_PROCESS_DETACH:
      TlsFree(TLSIndex);
  end;
end;

begin
  DLLProc := @DLLMain;
  DLLMain(DLL_PROCESS_ATTACH);
end.
```

## Chargement dynamique de DLL

Plut√¥t que de lier statiquement, vous pouvez charger une DLL √† la demande.

### Avantages du chargement dynamique

- La DLL n'est pas obligatoire au d√©marrage
- Choix de la DLL au runtime
- Gestion gracieuse si la DLL est absente
- Plugins optionnels

### Exemple complet

```pascal
program ChargementDynamique;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils;

type
  // D√©finition des types de fonction
  TAddFunc = function(a, b: Double): Double; stdcall;
  TGetVersionFunc = function: PChar; stdcall;

var
  hLib: HMODULE;
  Add: TAddFunc;
  GetVersion: TGetVersionFunc;

function ChargerDLL: Boolean;  
begin
  Result := False;

  // Charger la DLL
  hLib := LoadLibrary('MathLib.dll');
  if hLib = 0 then
  begin
    WriteLn('Erreur : impossible de charger MathLib.dll');
    WriteLn('Code erreur : ', GetLastError);
    Exit;
  end;

  // Obtenir l'adresse de la fonction Add
  Add := TAddFunc(GetProcAddress(hLib, 'Add'));
  if not Assigned(Add) then
  begin
    WriteLn('Erreur : fonction Add non trouv√©e');
    FreeLibrary(hLib);
    Exit;
  end;

  // Obtenir l'adresse de la fonction GetVersion
  GetVersion := TGetVersionFunc(GetProcAddress(hLib, 'GetVersion'));
  if not Assigned(GetVersion) then
  begin
    WriteLn('Erreur : fonction GetVersion non trouv√©e');
    FreeLibrary(hLib);
    Exit;
  end;

  Result := True;
end;

procedure DechargerDLL;  
begin
  if hLib <> 0 then
  begin
    FreeLibrary(hLib);
    hLib := 0;
    Add := nil;
    GetVersion := nil;
  end;
end;

begin
  hLib := 0;

  if not ChargerDLL then
  begin
    WriteLn('Impossible de charger la DLL');
    ReadLn;
    Exit;
  end;

  try
    WriteLn('DLL charg√©e avec succ√®s !');
    WriteLn('Version : ', GetVersion);
    WriteLn('5 + 3 = ', Add(5, 3):0:2);
  finally
    DechargerDLL;
    WriteLn('DLL d√©charg√©e');
  end;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

### Recherche de DLL par Windows

Windows cherche les DLL dans cet ordre :

1. **Le r√©pertoire de l'application**
2. Le r√©pertoire syst√®me (`C:\Windows\System32`)
3. Le r√©pertoire Windows (`C:\Windows`)
4. Le r√©pertoire courant
5. Les r√©pertoires list√©s dans la variable `PATH`

**Bonnes pratiques** :
- Placez vos DLL dans le m√™me r√©pertoire que votre EXE
- Ou sp√©cifiez le chemin complet : `LoadLibrary('C:\MonApp\MathLib.dll')`

### Pr√©charger une DLL sp√©cifique

```pascal
function ChargerDLLDepuisRepertoire(const nomDLL, repertoire: string): HMODULE;  
var
  cheminComplet: string;
begin
  cheminComplet := IncludeTrailingPathDelimiter(repertoire) + nomDLL;
  Result := LoadLibrary(PChar(cheminComplet));
end;

// Utilisation
hLib := ChargerDLLDepuisRepertoire('MathLib.dll', 'C:\MonApp\libs');
```

## DLL et gestion des exceptions

### Exceptions Pascal ne traversent pas les DLL

**R√®gle importante** : Les exceptions Pascal lev√©es dans une DLL ne peuvent pas √™tre attrap√©es dans l'application appelante (et vice-versa).

```pascal
// ‚ùå NE FONCTIONNERA PAS comme pr√©vu
function DiviserDanger(a, b: Integer): Integer; stdcall;  
begin
  Result := a div b;  // L√®ve une exception si b = 0
end;

// ‚úÖ BON : G√©rer l'exception dans la DLL
function DiviserSafe(a, b: Integer; out result: Integer): Boolean; stdcall;  
begin
  try
    result := a div b;
    Result := True;
  except
    result := 0;
    Result := False;
  end;
end;
```

### Wrapper avec try..except

Encapsulez toutes les fonctions export√©es :

```pascal
function OperationComplexe(param: Integer): Integer; stdcall;  
begin
  Result := -1;  // Valeur d'erreur par d√©faut
  try
    // Code qui peut lever des exceptions
    Result := FaireCalculComplexe(param);
  except
    on E: Exception do
    begin
      // Logger l'erreur
      LogError(E.Message);
      // D√©finir le code d'erreur
      SetLastError(ERROR_EXCEPTION);
    end;
  end;
end;
```

## Optimisations sp√©cifiques aux DLL

### Smart Linking

Activez le smart linking pour r√©duire la taille :

```pascal
{$SMARTLINK ON}
```

Ou en ligne de commande :
```batch
fpc -XX -CX -oMathLib.dll MathLib.pas
```

R√©duction typique : 20-40% de la taille du fichier.

### Strip des symboles

Retirez les symboles de d√©bogage pour la version finale :

```batch
fpc -Xs -oMathLib.dll MathLib.pas
```

Ou apr√®s compilation :
```batch
strip --strip-all MathLib.dll
```

### Utiliser -Os pour la taille

```batch
fpc -Os -XX -Xs -oMathLib.dll MathLib.pas
```

Options :
- `-Os` : Optimise pour la taille
- `-O2` : Optimise pour la vitesse
- `-O3` : Optimisations agressives

### Comparaison des tailles

```
Compilation normale :           150 KB  
Avec smart linking :            100 KB  (-33%)
+ strip :                        80 KB  (-47%)
+ optimisation taille :          65 KB  (-57%)
```

## Compatibilit√© 32/64 bits

### Compilation pour les deux architectures

**32 bits** :
```batch
fpc -Twin32 -oMathLib32.dll MathLib.pas
```

**64 bits** :
```batch
fpc -Twin64 -oMathLib64.dll MathLib.pas
```

### Nommage recommand√©

```
MathLib.dll         (64 bits par d√©faut)  
MathLib32.dll       (explicitement 32 bits)  
MathLib64.dll       (explicitement 64 bits)
```

### Chargement conditionnel

```pascal
function ChargerDLLAppropriee: HMODULE;  
begin
  {$IFDEF CPU64}
  Result := LoadLibrary('MathLib64.dll');
  {$ELSE}
  Result := LoadLibrary('MathLib32.dll');
  {$ENDIF}
end;
```

### Diff√©rences importantes 32/64

**Types affect√©s** :
- `Pointer` : 4 octets (32-bit) vs 8 octets (64-bit)
- `NativeInt` : 4 octets (32-bit) vs 8 octets (64-bit)
- `NativeUInt` : 4 octets (32-bit) vs 8 octets (64-bit)

**Utilisez toujours** :
- `Integer` : toujours 32 bits
- `Int64` : toujours 64 bits
- `PtrInt`, `PtrUInt` : taille du pointeur

## S√©curit√© et signature de code

### Pourquoi signer une DLL ?

- **Authenticit√©** : Prouver l'origine du code
- **Int√©grit√©** : Garantir que le fichier n'a pas √©t√© modifi√©
- **Confiance** : Windows SmartScreen et antivirus
- **Obligations** : Certains contextes (drivers kernel) l'exigent

### Obtenir un certificat

Sources de certificats de signature de code :
- **Autorit√©s de certification commerciales** : DigiCert, Sectigo, GlobalSign
- **Certificat auto-sign√©** : Pour tests uniquement

### Signer avec SignTool

```batch
signtool sign /f MonCertificat.pfx /p MotDePasse /t http://timestamp.digicert.com MathLib.dll
```

Options :
- `/f` : Fichier certificat (.pfx)
- `/p` : Mot de passe du certificat
- `/t` : Serveur de timestamp (horodatage)
- `/d` : Description de la DLL

### V√©rifier la signature

```batch
signtool verify /pa MathLib.dll
```

Ou clic droit sur le fichier ‚Üí Propri√©t√©s ‚Üí Signatures num√©riques

## Bonnes pratiques r√©capitulatives

### ‚úÖ √Ä faire

1. **Toujours utiliser `stdcall` ou `cdecl`** pour l'interop√©rabilit√©
2. **G√©rer toutes les exceptions** dans les fonctions export√©es
3. **Documenter l'API** compl√®tement
4. **Versionner correctement** (SemVer)
5. **Fournir des paires create/destroy** pour les objets
6. **Utiliser des types simples** dans l'API publique
7. **Tester sur toutes les versions de Windows** cibl√©es
8. **Fournir des exemples** d'utilisation
9. **Logger les erreurs** en interne
10. **V√©rifier la thread-safety** si applicable

### ‚ùå √Ä √©viter

1. **Exposer des `string` Pascal** directement
2. **M√©langer les gestionnaires de m√©moire** (heap mismatch)
3. **Laisser les exceptions se propager** hors de la DLL
4. **Casser la compatibilit√© binaire** sans changer la version majeure
5. **Utiliser des variables globales mutables** sans protection
6. **Oublier de tester le chargement dynamique**
7. **N√©gliger la documentation** des codes d'erreur
8. **Ignorer les probl√®mes d'encodage** (ANSI/Unicode)
9. **Ne pas fournir de fonction de version**
10. **Compiler sans optimisations** pour la production

## Checklist de d√©ploiement

Avant de distribuer votre DLL :

- [ ] Test√©e sur toutes les versions Windows cibl√©es (7, 8, 10, 11)
- [ ] Test√©e 32 et 64 bits si applicable
- [ ] Documentation compl√®te de l'API
- [ ] Exemples de code fonctionnels
- [ ] Fichier de version/changelog
- [ ] Tests de performance effectu√©s
- [ ] Tests de thread-safety si applicable
- [ ] Pas de d√©pendances manquantes
- [ ] Sign√©e num√©riquement (recommand√©)
- [ ] Licence clairement d√©finie
- [ ] Support technique disponible

## Conclusion

Cr√©er des DLL Windows avec FreePascal est un processus puissant qui permet :
- **R√©utilisation maximale** du code Pascal
- **Interop√©rabilit√©** avec tous les langages Windows
- **Architecture modulaire** et extensible
- **Performance optimale** avec du code natif

Les points essentiels √† retenir :
- ‚úÖ Convention `stdcall` pour l'API Windows
- ‚úÖ Gestion rigoureuse de la m√©moire
- ‚úÖ Traitement des erreurs sans exceptions
- ‚úÖ Types compatibles C
- ‚úÖ Documentation et tests complets

Avec ces connaissances, vous pouvez cr√©er des DLL professionnelles, robustes et largement utilisables sur la plateforme Windows.

‚è≠Ô∏è [Shared Objects (.so) Linux](/19-interoperabilite-bindings/01.2-shared-objects-so-linux.md)
