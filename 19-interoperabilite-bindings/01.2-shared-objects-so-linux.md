ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 19.1.2 Shared Objects (.so) Linux

## Introduction aux Shared Objects

Un **Shared Object** (objet partagÃ©) est le format de bibliothÃ¨que partagÃ©e utilisÃ© par Linux et les systÃ¨mes Unix. C'est l'Ã©quivalent Linux des DLL Windows. Ces fichiers portent gÃ©nÃ©ralement l'extension `.so` et suivent des conventions de nommage spÃ©cifiques.

### Philosophie Unix/Linux

Sur Linux, tout repose sur les bibliothÃ¨ques partagÃ©es :
- La bibliothÃ¨que C standard : `libc.so.6`
- Les bibliothÃ¨ques graphiques : `libX11.so`, `libgtk-3.so`
- Les pilotes : `libGL.so` (OpenGL)
- Et des milliers d'autres...

Cette approche favorise :
- La modularitÃ© du systÃ¨me
- Les mises Ã  jour de sÃ©curitÃ© centralisÃ©es
- L'Ã©conomie de ressources

### Format ELF (Executable and Linkable Format)

Les `.so` utilisent le format **ELF**, standard sur Linux :

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       En-tÃªte ELF (ELF Header)      â”‚  â† MÃ©tadonnÃ©es du fichier
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Table des en-tÃªtes de programme  â”‚  â† Segments pour l'exÃ©cution
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Table des symboles (.symtab)     â”‚  â† Symboles de dÃ©bogage
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Table des symboles dynamiques      â”‚  â† Symboles exportÃ©s
â”‚         (.dynsym)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Section .text                    â”‚  â† Code exÃ©cutable
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Section .data                    â”‚  â† DonnÃ©es initialisÃ©es
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Section .bss                     â”‚  â† DonnÃ©es non initialisÃ©es
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Section .rodata                  â”‚  â† DonnÃ©es en lecture seule
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    Autres sections...               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Conventions de nommage Linux

### Structure typique d'un nom de bibliothÃ¨que

Les bibliothÃ¨ques Linux suivent une convention stricte :

```
lib<nom>.so.<version majeure>.<version mineure>.<version patch>
```

**Exemples** :
- `libmath.so.1.2.3`
- `libcurl.so.4.6.0`
- `libpthread.so.0`

### Anatomie du nom

```
libmylib.so.2.5.1
â”‚   â”‚    â”‚  â”‚ â”‚ â”‚
â”‚   â”‚    â”‚  â”‚ â”‚ â””â”€ Patch (corrections de bugs)
â”‚   â”‚    â”‚  â”‚ â””â”€â”€â”€ Mineure (nouvelles fonctionnalitÃ©s)
â”‚   â”‚    â”‚  â””â”€â”€â”€â”€â”€ Majeure (incompatibilitÃ©s)
â”‚   â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€ Extension Shared Object
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Nom de la bibliothÃ¨que
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PrÃ©fixe standard
```

### Liens symboliques (symlinks)

Linux utilise des liens symboliques pour la gestion des versions :

```
libmylib.so.2.5.1    â† Fichier rÃ©el  
libmylib.so.2        â†’ libmylib.so.2.5.1  (lien symbolique)  
libmylib.so          â†’ libmylib.so.2      (lien symbolique)
```

**UtilitÃ©** :
- `libmylib.so` : UtilisÃ© lors de la compilation (dÃ©veloppement)
- `libmylib.so.2` : UtilisÃ© lors de l'exÃ©cution (runtime)
- `libmylib.so.2.5.1` : Fichier rÃ©el avec version complÃ¨te

**Exemple** :
```bash
ls -la /usr/lib/x86_64-linux-gnu/libz.so*  
lrwxrwxrwx 1 root root     13 libz.so -> libz.so.1.2.11  
lrwxrwxrwx 1 root root     13 libz.so.1 -> libz.so.1.2.11
-rw-r--r-- 1 root root 116960 libz.so.1.2.11
```

## CrÃ©er votre premiÃ¨re Shared Object

### Structure de base

Contrairement Ã  Windows, pas besoin de directive spÃ©ciale. Toutes les fonctions publiques sont exportÃ©es par dÃ©faut.

```pascal
library libmylib;

{$mode objfpc}{$H+}

uses
  SysUtils;

// Fonction Ã  exporter
function Addition(a, b: Integer): Integer; cdecl; public;  
begin
  Result := a + b;
end;

// ProcÃ©dure Ã  exporter
procedure AfficherMessage(msg: PChar); cdecl; public;  
begin
  WriteLn('Message reÃ§u : ', msg);
end;

// Fonction de version
function GetVersion: PChar; cdecl; public;  
begin
  Result := '1.0.0';
end;

// Section exports - OBLIGATOIRE
exports
  Addition,
  AfficherMessage,
  GetVersion;

begin
  // Initialisation (optionnel)
end.
```

**Points clÃ©s** :
- Convention `cdecl` (standard C sur Linux)
- Mot-clÃ© `public` pour rendre visible
- Directive `exports` liste les symboles exportÃ©s
- Pas de dÃ©coration de noms comme sur Windows

### Compilation basique

Pour compiler une bibliothÃ¨que partagÃ©e :

```bash
fpc -olibmylib.so libmylib.pas
```

Le compilateur gÃ©nÃ¨re automatiquement :
- Le fichier `.so` principal
- Position Independent Code (PIC) nÃ©cessaire

### Compilation avec options recommandÃ©es

```bash
fpc -olibmylib.so -CX -XX -Xs libmylib.pas
```

Options :
- `-CX` : Smart linking
- `-XX` : Smart linking plus agressif
- `-Xs` : Strip des symboles de dÃ©bogage

**Pour la version de dÃ©veloppement** :
```bash
fpc -g -olibmylib.so libmylib.pas
```
L'option `-g` inclut les symboles de dÃ©bogage.

### CrÃ©er les liens symboliques

CrÃ©ez manuellement les liens de version :

```bash
# CrÃ©er le lien pour le dÃ©veloppement
ln -s libmylib.so libmylib.so.1

# CrÃ©er le lien pour le runtime
ln -s libmylib.so.1 libmylib.so.1.0.0

# Ou inversement (plus logique)
# Fichier rÃ©el
mv libmylib.so libmylib.so.1.0.0

# Liens symboliques
ln -s libmylib.so.1.0.0 libmylib.so.1  
ln -s libmylib.so.1 libmylib.so
```

### VÃ©rifier la bibliothÃ¨que

**Lister les symboles exportÃ©s** :
```bash
nm -D libmylib.so | grep "T "
```

Sortie exemple :
```
0000000000001150 T Addition
0000000000001170 T AfficherMessage
0000000000001190 T GetVersion
```

**Afficher les informations ELF** :
```bash
readelf -h libmylib.so
```

**VÃ©rifier les dÃ©pendances** :
```bash
ldd libmylib.so
```

Sortie exemple :
```
linux-vdso.so.1 (0x00007ffd2e3f1000)  
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8b9c200000)
/lib64/ld-linux-x86-64.so.2 (0x00007f8b9c600000)
```

## Utilisation depuis FreePascal

### Liaison statique (Ã  la compilation)

```pascal
program TestLib;

{$mode objfpc}{$H+}

uses
  SysUtils;

// DÃ©claration des fonctions externes
function Addition(a, b: Integer): Integer; cdecl; external 'mylib';  
procedure AfficherMessage(msg: PChar); cdecl; external 'mylib';  
function GetVersion: PChar; cdecl; external 'mylib';

begin
  WriteLn('Version de la bibliothÃ¨que : ', GetVersion);
  WriteLn('5 + 3 = ', Addition(5, 3));
  AfficherMessage('Hello depuis l''application !');
end.
```

**Compilation** :
```bash
fpc -o testlib testlib.pas
```

**ExÃ©cution** :
```bash
./testlib
```

**Note** : Le nom `'mylib'` sera transformÃ© en `libmylib.so` automatiquement.

### SpÃ©cifier le chemin complet

Si la bibliothÃ¨que n'est pas dans les chemins standards :

```pascal
function Addition(a, b: Integer): Integer; cdecl;
  external '/home/user/libs/libmylib.so';
```

Ou avec une constante :

```pascal
const
  {$IFDEF CPUX64}
  MYLIB_PATH = '/usr/lib/x86_64-linux-gnu/libmylib.so';
  {$ELSE}
  MYLIB_PATH = '/usr/lib/i386-linux-gnu/libmylib.so';
  {$ENDIF}

function Addition(a, b: Integer): Integer; cdecl; external MYLIB_PATH;
```

### Liaison dynamique (au runtime)

Pour charger la bibliothÃ¨que dynamiquement :

```pascal
program ChargementDynamique;

{$mode objfpc}{$H+}

uses
  SysUtils, dl;

type
  TAdditionFunc = function(a, b: Integer): Integer; cdecl;
  TGetVersionFunc = function: PChar; cdecl;

var
  LibHandle: Pointer;
  Addition: TAdditionFunc;
  GetVersion: TGetVersionFunc;
  Erreur: PChar;

begin
  // Charger la bibliothÃ¨que
  LibHandle := dlopen('libmylib.so', RTLD_LAZY);

  if LibHandle = nil then
  begin
    Erreur := dlerror();
    WriteLn('Erreur lors du chargement : ', Erreur);
    Halt(1);
  end;

  try
    // Charger les fonctions
    Addition := TAdditionFunc(dlsym(LibHandle, 'Addition'));
    if Addition = nil then
    begin
      WriteLn('Fonction Addition non trouvÃ©e');
      Halt(1);
    end;

    GetVersion := TGetVersionFunc(dlsym(LibHandle, 'GetVersion'));
    if GetVersion = nil then
    begin
      WriteLn('Fonction GetVersion non trouvÃ©e');
      Halt(1);
    end;

    // Utilisation
    WriteLn('Version : ', GetVersion);
    WriteLn('10 + 15 = ', Addition(10, 15));

  finally
    // DÃ©charger la bibliothÃ¨que
    dlclose(LibHandle);
  end;
end.
```

**Fonctions dlopen** :
- `dlopen()` : Charge la bibliothÃ¨que
- `dlsym()` : RÃ©cupÃ¨re l'adresse d'un symbole
- `dlerror()` : RÃ©cupÃ¨re le dernier message d'erreur
- `dlclose()` : DÃ©charge la bibliothÃ¨que

**Flags pour dlopen** :
- `RTLD_LAZY` : RÃ©solution paresseuse (Ã  la demande)
- `RTLD_NOW` : RÃ©solution immÃ©diate (toutes les fonctions)
- `RTLD_GLOBAL` : Symboles disponibles pour les bibliothÃ¨ques chargÃ©es aprÃ¨s
- `RTLD_LOCAL` : Symboles privÃ©s (dÃ©faut)

## Chemins de recherche des bibliothÃ¨ques

### Ordre de recherche

Linux cherche les bibliothÃ¨ques dans cet ordre :

1. **RÃ©pertoires spÃ©cifiÃ©s dans RPATH** (compilÃ© dans l'exÃ©cutable)
2. **Variable d'environnement LD_LIBRARY_PATH**
3. **RÃ©pertoires dans /etc/ld.so.conf**
4. **RÃ©pertoires systÃ¨me standards** :
   - `/lib`
   - `/usr/lib`
   - `/lib64`
   - `/usr/lib64`
   - `/usr/local/lib`

### Voir les chemins actuels

```bash
ldconfig -v 2>/dev/null | grep -v ^$'\t'
```

### Variable LD_LIBRARY_PATH

Ajouter temporairement un chemin :

```bash
export LD_LIBRARY_PATH=/home/user/mylibs:$LD_LIBRARY_PATH
./mon_programme
```

**Pour un programme spÃ©cifique** :
```bash
LD_LIBRARY_PATH=/home/user/mylibs ./mon_programme
```

**Attention** : Ne modifiez pas LD_LIBRARY_PATH de maniÃ¨re permanente dans `.bashrc` - c'est une mauvaise pratique qui peut causer des problÃ¨mes systÃ¨me.

### RPATH et RUNPATH

IntÃ©grer le chemin directement dans l'exÃ©cutable :

**Avec fpc** :
```bash
fpc -k'-rpath=/home/user/mylibs' -o testlib testlib.pas
```

**VÃ©rifier le RPATH** :
```bash
readelf -d testlib | grep PATH
```

**RPATH vs RUNPATH** :
- **RPATH** : PrioritÃ© haute, cherchÃ© avant LD_LIBRARY_PATH
- **RUNPATH** : PrioritÃ© basse, cherchÃ© aprÃ¨s LD_LIBRARY_PATH

### Configuration systÃ¨me avec ldconfig

Pour installer une bibliothÃ¨que systÃ¨me :

1. **Copier la bibliothÃ¨que** :
```bash
sudo cp libmylib.so.1.0.0 /usr/local/lib/
```

2. **CrÃ©er les liens symboliques** :
```bash
cd /usr/local/lib  
sudo ln -s libmylib.so.1.0.0 libmylib.so.1  
sudo ln -s libmylib.so.1 libmylib.so
```

3. **Mettre Ã  jour le cache** :
```bash
sudo ldconfig
```

4. **VÃ©rifier** :
```bash
ldconfig -p | grep mylib
```

### Fichier de configuration personnalisÃ©

CrÃ©er `/etc/ld.so.conf.d/myapp.conf` :
```
/opt/myapp/lib
```

Puis :
```bash
sudo ldconfig
```

## Gestion des versions et compatibilitÃ©

### Versionnage SONAME

Le **SONAME** (Shared Object Name) est crucial pour la compatibilitÃ© binaire.

**Structure** :
```
libmylib.so.MAJOR
```

**RÃ¨gles de versionnage** :
- **MAJOR** : IncrÃ©mentÃ© pour incompatibilitÃ© ABI
- **MINOR** : IncrÃ©mentÃ© pour nouvelles fonctionnalitÃ©s compatibles
- **PATCH** : IncrÃ©mentÃ© pour corrections de bugs

### DÃ©finir le SONAME Ã  la compilation

Avec l'Ã©diteur de liens :

```bash
fpc -k'-soname,libmylib.so.1' -olibmylib.so.1.0.0 libmylib.pas
```

**VÃ©rifier le SONAME** :
```bash
readelf -d libmylib.so.1.0.0 | grep SONAME
```

Sortie :
```
0x000000000000000e (SONAME)    Library soname: [libmylib.so.1]
```

### Installer plusieurs versions

Vous pouvez avoir plusieurs versions majeures simultanÃ©ment :

```
/usr/lib/
â”œâ”€â”€ libmylib.so.1.5.2  (ancienne version)
â”œâ”€â”€ libmylib.so.1 â†’ libmylib.so.1.5.2
â”œâ”€â”€ libmylib.so.2.0.0  (nouvelle version)
â”œâ”€â”€ libmylib.so.2 â†’ libmylib.so.2.0.0
â””â”€â”€ libmylib.so â†’ libmylib.so.2  (dÃ©veloppement)
```

Les anciennes applications utilisent `libmylib.so.1`, les nouvelles `libmylib.so.2`.

### Script de gestion des versions

```bash
#!/bin/bash
# install_lib.sh

LIB_NAME=$1  
MAJOR=$2  
MINOR=$3  
PATCH=$4

FULL_NAME="${LIB_NAME}.so.${MAJOR}.${MINOR}.${PATCH}"  
SONAME="${LIB_NAME}.so.${MAJOR}"  
LINKNAME="${LIB_NAME}.so"

# Copier le fichier
sudo cp $FULL_NAME /usr/local/lib/

# CrÃ©er les liens
cd /usr/local/lib  
sudo ln -sf $FULL_NAME $SONAME  
sudo ln -sf $SONAME $LINKNAME

# Mettre Ã  jour le cache
sudo ldconfig

echo "BibliothÃ¨que installÃ©e :"  
ls -l /usr/local/lib/${LIB_NAME}.so*
```

Utilisation :
```bash
./install_lib.sh libmylib 1 0 0
```

## VisibilitÃ© des symboles

### ContrÃ´le de l'export

Par dÃ©faut, tous les symboles publics sont exportÃ©s. Vous pouvez contrÃ´ler cela.

#### MÃ©thode 1 : Attribut de visibilitÃ©

```pascal
// Visible depuis l'extÃ©rieur
function FonctionPublique: Integer; cdecl; public;

// CachÃ© (usage interne uniquement)
function FonctionPrivee: Integer; cdecl;
  attribute(visibility('hidden'));
```

#### MÃ©thode 2 : Version script

CrÃ©ez un fichier `version.map` :

```
VERS_1.0 {
    global:
        Addition;
        AfficherMessage;
        GetVersion;
    local:
        *;  # Tout le reste est privÃ©
};
```

Compilation :
```bash
fpc -k'--version-script=version.map' -olibmylib.so libmylib.pas
```

**Avantages** :
- RÃ©duction de la taille de la table des symboles
- AmÃ©lioration des performances de chargement
- PrÃ©vention des conflits de symboles
- Meilleure encapsulation

### VÃ©rifier les symboles exportÃ©s

```bash
# Tous les symboles
nm -D libmylib.so

# Uniquement les symboles publics
nm -D libmylib.so | grep " T "

# Symboles avec dÃ©mangling C++
nm -DC libmylib.so
```

Types de symboles :
- `T` : Code (text section)
- `D` : DonnÃ©es initialisÃ©es
- `B` : DonnÃ©es non initialisÃ©es (BSS)
- `U` : Undefined (nÃ©cessite une autre bibliothÃ¨que)

## Position Independent Code (PIC)

### Qu'est-ce que le PIC ?

Le **Position Independent Code** permet Ã  une bibliothÃ¨que d'Ãªtre chargÃ©e Ã  n'importe quelle adresse mÃ©moire.

**Pourquoi c'est important** :
- SÃ©curitÃ© : ASLR (Address Space Layout Randomization)
- Partage en mÃ©moire entre processus
- FlexibilitÃ© du chargeur systÃ¨me

### FreePascal et PIC

FreePascal gÃ©nÃ¨re automatiquement du PIC pour les bibliothÃ¨ques partagÃ©es sur Linux.

**VÃ©rifier si une bibliothÃ¨que utilise PIC** :
```bash
readelf -d libmylib.so | grep TEXTREL
```

Si la sortie est vide, c'est bon (PIC activÃ©). Si vous voyez `TEXTREL`, le PIC n'est pas complet.

### Forcer la gÃ©nÃ©ration PIC

```bash
fpc -Cg -olibmylib.so libmylib.pas
```

L'option `-Cg` force la gÃ©nÃ©ration PIC.

### Performance du PIC

Le PIC a un lÃ©ger coÃ»t en performance (environ 2-5%) dÃ» Ã  :
- Indirection supplÃ©mentaire pour accÃ©der aux donnÃ©es globales
- Utilisation de la GOT (Global Offset Table)

Ce coÃ»t est nÃ©gligeable par rapport aux bÃ©nÃ©fices de sÃ©curitÃ© et flexibilitÃ©.

## Exemple complet : BibliothÃ¨que de calcul matriciel

CrÃ©ons une bibliothÃ¨que complÃ¨te pour les opÃ©rations sur les matrices.

### Code de la bibliothÃ¨que

```pascal
library libmatrix;

{$mode objfpc}{$H+}

uses
  SysUtils;

type
  PMatrix = ^TMatrix;
  TMatrix = record
    rows: Integer;
    cols: Integer;
    data: PDouble;
  end;

const
  MATRIX_SUCCESS = 0;
  MATRIX_ERROR_NULL_POINTER = -1;
  MATRIX_ERROR_INVALID_DIMENSIONS = -2;
  MATRIX_ERROR_OUT_OF_MEMORY = -3;

var
  LastError: Integer = MATRIX_SUCCESS;
  LastErrorMsg: string = '';

// CrÃ©er une matrice
function matrix_create(rows, cols: Integer): PMatrix; cdecl; public;  
var
  m: PMatrix;
begin
  Result := nil;
  LastError := MATRIX_SUCCESS;

  if (rows <= 0) or (cols <= 0) then
  begin
    LastError := MATRIX_ERROR_INVALID_DIMENSIONS;
    LastErrorMsg := 'Dimensions invalides';
    Exit;
  end;

  try
    New(m);
    m^.rows := rows;
    m^.cols := cols;
    GetMem(m^.data, rows * cols * SizeOf(Double));
    FillChar(m^.data^, rows * cols * SizeOf(Double), 0);
    Result := m;
  except
    LastError := MATRIX_ERROR_OUT_OF_MEMORY;
    LastErrorMsg := 'MÃ©moire insuffisante';
  end;
end;

// DÃ©truire une matrice
procedure matrix_destroy(m: PMatrix); cdecl; public;  
begin
  if m = nil then Exit;

  if m^.data <> nil then
    FreeMem(m^.data);
  Dispose(m);
end;

// DÃ©finir une valeur
function matrix_set(m: PMatrix; row, col: Integer; value: Double): Integer;
  cdecl; public;
begin
  LastError := MATRIX_SUCCESS;
  Result := MATRIX_SUCCESS;

  if m = nil then
  begin
    LastError := MATRIX_ERROR_NULL_POINTER;
    Result := LastError;
    Exit;
  end;

  if (row < 0) or (row >= m^.rows) or (col < 0) or (col >= m^.cols) then
  begin
    LastError := MATRIX_ERROR_INVALID_DIMENSIONS;
    Result := LastError;
    Exit;
  end;

  PDouble(m^.data + (row * m^.cols + col) * SizeOf(Double))^ := value;
end;

// Obtenir une valeur
function matrix_get(m: PMatrix; row, col: Integer; out value: Double): Integer;
  cdecl; public;
begin
  LastError := MATRIX_SUCCESS;
  Result := MATRIX_SUCCESS;
  value := 0;

  if m = nil then
  begin
    LastError := MATRIX_ERROR_NULL_POINTER;
    Result := LastError;
    Exit;
  end;

  if (row < 0) or (row >= m^.rows) or (col < 0) or (col >= m^.cols) then
  begin
    LastError := MATRIX_ERROR_INVALID_DIMENSIONS;
    Result := LastError;
    Exit;
  end;

  value := PDouble(m^.data + (row * m^.cols + col) * SizeOf(Double))^;
end;

// Addition de matrices
function matrix_add(a, b: PMatrix): PMatrix; cdecl; public;  
var
  result_matrix: PMatrix;
  i, j: Integer;
  val_a, val_b: Double;
begin
  Result := nil;
  LastError := MATRIX_SUCCESS;

  if (a = nil) or (b = nil) then
  begin
    LastError := MATRIX_ERROR_NULL_POINTER;
    Exit;
  end;

  if (a^.rows <> b^.rows) or (a^.cols <> b^.cols) then
  begin
    LastError := MATRIX_ERROR_INVALID_DIMENSIONS;
    LastErrorMsg := 'Dimensions incompatibles';
    Exit;
  end;

  result_matrix := matrix_create(a^.rows, a^.cols);
  if result_matrix = nil then Exit;

  for i := 0 to a^.rows - 1 do
    for j := 0 to a^.cols - 1 do
    begin
      matrix_get(a, i, j, val_a);
      matrix_get(b, i, j, val_b);
      matrix_set(result_matrix, i, j, val_a + val_b);
    end;

  Result := result_matrix;
end;

// Afficher une matrice (pour dÃ©bogage)
procedure matrix_print(m: PMatrix); cdecl; public;  
var
  i, j: Integer;
  value: Double;
begin
  if m = nil then
  begin
    WriteLn('Matrix is NULL');
    Exit;
  end;

  WriteLn(Format('Matrix %dx%d:', [m^.rows, m^.cols]));
  for i := 0 to m^.rows - 1 do
  begin
    Write('[');
    for j := 0 to m^.cols - 1 do
    begin
      matrix_get(m, i, j, value);
      Write(Format('%8.2f', [value]));
      if j < m^.cols - 1 then Write(' ');
    end;
    WriteLn(']');
  end;
end;

// Obtenir le dernier code d'erreur
function matrix_get_last_error: Integer; cdecl; public;  
begin
  Result := LastError;
end;

// Obtenir le dernier message d'erreur
procedure matrix_get_last_error_message(buffer: PChar; size: Integer);
  cdecl; public;
begin
  if buffer <> nil then
    StrLCopy(buffer, PChar(LastErrorMsg), size - 1);
end;

// Version de la bibliothÃ¨que
function matrix_version: PChar; cdecl; public;  
begin
  Result := '1.0.0';
end;

exports
  matrix_create,
  matrix_destroy,
  matrix_set,
  matrix_get,
  matrix_add,
  matrix_print,
  matrix_get_last_error,
  matrix_get_last_error_message,
  matrix_version;

begin  
end.
```

### Compilation

```bash
fpc -olibmatrix.so.1.0.0 -CX -XX libmatrix.pas

# CrÃ©er les liens
ln -s libmatrix.so.1.0.0 libmatrix.so.1  
ln -s libmatrix.so.1 libmatrix.so
```

### Programme de test

```pascal
program test_matrix;

{$mode objfpc}{$H+}

uses
  SysUtils;

type
  PMatrix = ^TMatrix;
  TMatrix = record
    rows: Integer;
    cols: Integer;
    data: PDouble;
  end;

// DÃ©clarations externes
function matrix_create(rows, cols: Integer): PMatrix; cdecl; external 'matrix';  
procedure matrix_destroy(m: PMatrix); cdecl; external 'matrix';  
function matrix_set(m: PMatrix; row, col: Integer; value: Double): Integer;
  cdecl; external 'matrix';
function matrix_get(m: PMatrix; row, col: Integer; out value: Double): Integer;
  cdecl; external 'matrix';
function matrix_add(a, b: PMatrix): PMatrix; cdecl; external 'matrix';  
procedure matrix_print(m: PMatrix); cdecl; external 'matrix';  
function matrix_version: PChar; cdecl; external 'matrix';

var
  m1, m2, m3: PMatrix;
begin
  WriteLn('libmatrix version : ', matrix_version);
  WriteLn;

  // CrÃ©er deux matrices 2x2
  m1 := matrix_create(2, 2);
  m2 := matrix_create(2, 2);

  // Remplir la premiÃ¨re matrice
  matrix_set(m1, 0, 0, 1.0);
  matrix_set(m1, 0, 1, 2.0);
  matrix_set(m1, 1, 0, 3.0);
  matrix_set(m1, 1, 1, 4.0);

  // Remplir la deuxiÃ¨me matrice
  matrix_set(m2, 0, 0, 5.0);
  matrix_set(m2, 0, 1, 6.0);
  matrix_set(m2, 1, 0, 7.0);
  matrix_set(m2, 1, 1, 8.0);

  // Afficher
  WriteLn('Matrice 1 :');
  matrix_print(m1);
  WriteLn;

  WriteLn('Matrice 2 :');
  matrix_print(m2);
  WriteLn;

  // Addition
  m3 := matrix_add(m1, m2);
  WriteLn('Matrice 1 + Matrice 2 :');
  matrix_print(m3);

  // LibÃ©ration
  matrix_destroy(m1);
  matrix_destroy(m2);
  matrix_destroy(m3);

  WriteLn;
  WriteLn('Test terminÃ© !');
end.
```

### Compilation et exÃ©cution

```bash
# Compiler le test
fpc -o test_matrix test_matrix.pas

# ExÃ©cuter (si la bibliothÃ¨que est dans le rÃ©pertoire courant)
LD_LIBRARY_PATH=. ./test_matrix
```

**Sortie attendue** :
```
libmatrix version : 1.0.0

Matrice 1 :
[    1.00     2.00]
[    3.00     4.00]

Matrice 2 :
[    5.00     6.00]
[    7.00     8.00]

Matrice 1 + Matrice 2 :
[    6.00     8.00]
[   10.00    12.00]

Test terminÃ© !
```

## Utilisation depuis C/C++

Une des forces des bibliothÃ¨ques Linux est l'interopÃ©rabilitÃ© parfaite avec C.

### CrÃ©er un fichier d'en-tÃªte C

Fichier `matrix.h` :

```c
#ifndef MATRIX_H
#define MATRIX_H

#ifdef __cplusplus
extern "C" {
#endif

// Structure opaque
typedef struct Matrix Matrix;

// Codes d'erreur
#define MATRIX_SUCCESS 0
#define MATRIX_ERROR_NULL_POINTER -1
#define MATRIX_ERROR_INVALID_DIMENSIONS -2
#define MATRIX_ERROR_OUT_OF_MEMORY -3

// Fonctions de la bibliothÃ¨que
Matrix* matrix_create(int rows, int cols);  
void matrix_destroy(Matrix* m);  
int matrix_set(Matrix* m, int row, int col, double value);  
int matrix_get(Matrix* m, int row, int col, double* value);  
Matrix* matrix_add(Matrix* a, Matrix* b);  
void matrix_print(Matrix* m);  
int matrix_get_last_error(void);  
void matrix_get_last_error_message(char* buffer, int size);  
const char* matrix_version(void);

#ifdef __cplusplus
}
#endif

#endif // MATRIX_H
```

### Programme C utilisant la bibliothÃ¨que

Fichier `test_matrix.c` :

```c
#include <stdio.h>
#include <stdlib.h>
#include "matrix.h"

int main() {
    Matrix *m1, *m2, *m3;

    printf("libmatrix version : %s\n\n", matrix_version());

    // CrÃ©er les matrices
    m1 = matrix_create(2, 2);
    m2 = matrix_create(2, 2);

    // Remplir m1
    matrix_set(m1, 0, 0, 1.0);
    matrix_set(m1, 0, 1, 2.0);
    matrix_set(m1, 1, 0, 3.0);
    matrix_set(m1, 1, 1, 4.0);

    // Remplir m2
    matrix_set(m2, 0, 0, 5.0);
    matrix_set(m2, 0, 1, 6.0);
    matrix_set(m2, 1, 0, 7.0);
    matrix_set(m2, 1, 1, 8.0);

    // Afficher
    printf("Matrice 1 :\n");
    matrix_print(m1);
    printf("\nMatrice 2 :\n");
    matrix_print(m2);

    // Addition
    m3 = matrix_add(m1, m2);
    printf("\nMatrice 1 + Matrice 2 :\n");
    matrix_print(m3);

    // LibÃ©ration
    matrix_destroy(m1);
    matrix_destroy(m2);
    matrix_destroy(m3);

    printf("\nTest terminÃ© !\n");
    return 0;
}
```

### Compilation du programme C

```bash
# Compiler avec liaison dynamique
gcc -o test_matrix_c test_matrix.c -L. -lmatrix -Wl,-rpath,.

# Ou spÃ©cifier le chemin de recherche au runtime
gcc -o test_matrix_c test_matrix.c -L. -lmatrix  
LD_LIBRARY_PATH=. ./test_matrix_c
```

Options :
- `-L.` : Chercher les bibliothÃ¨ques dans le rÃ©pertoire courant
- `-lmatrix` : Lier avec libmatrix.so
- `-Wl,-rpath,.` : Ajouter le rÃ©pertoire courant au RPATH

### Utilisation depuis Python avec ctypes

Fichier `test_matrix.py` :

```python
#!/usr/bin/env python3
import ctypes  
from ctypes import c_int, c_double, c_char_p, POINTER

# Charger la bibliothÃ¨que
lib = ctypes.CDLL('./libmatrix.so')

# DÃ©finir les types
class Matrix(ctypes.Structure):
    pass

MatrixPtr = POINTER(Matrix)

# DÃ©clarer les fonctions
lib.matrix_create.argtypes = [c_int, c_int]  
lib.matrix_create.restype = MatrixPtr

lib.matrix_destroy.argtypes = [MatrixPtr]  
lib.matrix_destroy.restype = None

lib.matrix_set.argtypes = [MatrixPtr, c_int, c_int, c_double]  
lib.matrix_set.restype = c_int

lib.matrix_get.argtypes = [MatrixPtr, c_int, c_int, POINTER(c_double)]  
lib.matrix_get.restype = c_int

lib.matrix_add.argtypes = [MatrixPtr, MatrixPtr]  
lib.matrix_add.restype = MatrixPtr

lib.matrix_print.argtypes = [MatrixPtr]  
lib.matrix_print.restype = None

lib.matrix_version.argtypes = []  
lib.matrix_version.restype = c_char_p

# Utilisation
def main():
    print(f"libmatrix version : {lib.matrix_version().decode()}\n")

    # CrÃ©er les matrices
    m1 = lib.matrix_create(2, 2)
    m2 = lib.matrix_create(2, 2)

    # Remplir m1
    lib.matrix_set(m1, 0, 0, 1.0)
    lib.matrix_set(m1, 0, 1, 2.0)
    lib.matrix_set(m1, 1, 0, 3.0)
    lib.matrix_set(m1, 1, 1, 4.0)

    # Remplir m2
    lib.matrix_set(m2, 0, 0, 5.0)
    lib.matrix_set(m2, 0, 1, 6.0)
    lib.matrix_set(m2, 1, 0, 7.0)
    lib.matrix_set(m2, 1, 1, 8.0)

    # Afficher
    print("Matrice 1 :")
    lib.matrix_print(m1)
    print("\nMatrice 2 :")
    lib.matrix_print(m2)

    # Addition
    m3 = lib.matrix_add(m1, m2)
    print("\nMatrice 1 + Matrice 2 :")
    lib.matrix_print(m3)

    # LibÃ©ration
    lib.matrix_destroy(m1)
    lib.matrix_destroy(m2)
    lib.matrix_destroy(m3)

    print("\nTest terminÃ© !")

if __name__ == "__main__":
    main()
```

ExÃ©cution :
```bash
chmod +x test_matrix.py
./test_matrix.py
```

## DÃ©bogage des bibliothÃ¨ques partagÃ©es

### Outils essentiels

#### ldd - DÃ©pendances

Afficher les dÃ©pendances d'une bibliothÃ¨que :

```bash
ldd libmatrix.so
```

Sortie exemple :
```
linux-vdso.so.1 (0x00007ffc8b3e2000)  
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f9a2c400000)
/lib64/ld-linux-x86-64.so.2 (0x00007f9a2c800000)
```

**Signification** :
- `linux-vdso.so.1` : BibliothÃ¨que virtuelle du kernel
- `libc.so.6` : BibliothÃ¨que C standard
- `/lib64/ld-linux-x86-64.so.2` : Chargeur dynamique

**DÃ©tecter les dÃ©pendances manquantes** :
```bash
ldd libmatrix.so | grep "not found"
```

#### nm - Symboles

Lister tous les symboles :

```bash
nm libmatrix.so
```

Filtrer les symboles exportÃ©s :
```bash
nm -D libmatrix.so | grep " T "
```

Avec dÃ©mangling (pour C++) :
```bash
nm -DC libmatrix.so
```

**Types de symboles** :
- `T` : Symbole dans la section text (code)
- `D` : Symbole dans la section data (donnÃ©es initialisÃ©es)
- `B` : Symbole dans la section BSS (donnÃ©es non initialisÃ©es)
- `U` : Symbole non dÃ©fini (externe)
- `W` : Symbole faible
- `t`, `d`, `b` : Versions locales (minuscules)

#### objdump - DÃ©sassemblage

Afficher les informations de l'en-tÃªte :
```bash
objdump -f libmatrix.so
```

DÃ©sassembler une fonction :
```bash
objdump -d libmatrix.so | grep -A 20 "matrix_create"
```

Afficher toutes les sections :
```bash
objdump -h libmatrix.so
```

#### readelf - Format ELF

Informations gÃ©nÃ©rales :
```bash
readelf -h libmatrix.so
```

Symboles dynamiques :
```bash
readelf -s libmatrix.so
```

Sections :
```bash
readelf -S libmatrix.so
```

Segments :
```bash
readelf -l libmatrix.so
```

Informations dynamiques :
```bash
readelf -d libmatrix.so
```

#### strace - Tracer les appels systÃ¨me

Voir quelles bibliothÃ¨ques sont chargÃ©es :

```bash
strace -e openat ./test_matrix 2>&1 | grep ".so"
```

Tracer tous les appels liÃ©s aux fichiers :
```bash
strace -e trace=file ./test_matrix
```

#### ltrace - Tracer les appels de bibliothÃ¨que

```bash
ltrace ./test_matrix
```

Filtrer pour une bibliothÃ¨que spÃ©cifique :
```bash
ltrace -l libmatrix.so ./test_matrix
```

### GDB avec bibliothÃ¨ques partagÃ©es

Compiler avec symboles de dÃ©bogage :

```bash
fpc -g -olibmatrix.so libmatrix.pas  
fpc -g -o test_matrix test_matrix.pas
```

DÃ©boguer :
```bash
gdb ./test_matrix
```

Commandes GDB utiles :

```gdb
# Lister les bibliothÃ¨ques chargÃ©es
info sharedlibrary

# Mettre un point d'arrÃªt dans la bibliothÃ¨que
break matrix_create

# ExÃ©cuter
run

# Afficher la pile d'appels
backtrace

# Examiner les symboles
info functions matrix_

# Charger les symboles d'une bibliothÃ¨que
sharedlibrary libmatrix.so
```

### Valgrind - DÃ©tection de fuites mÃ©moire

VÃ©rifier les fuites :

```bash
valgrind --leak-check=full ./test_matrix
```

Sortie exemple :
```
==12345== HEAP SUMMARY:
==12345==     in use at exit: 0 bytes in 0 blocks
==12345==   total heap usage: 10 allocs, 10 frees, 1,234 bytes allocated
==12345==
==12345== All heap blocks were freed -- no leaks are possible
```

Options utiles :
- `--leak-check=full` : DÃ©tails complets sur les fuites
- `--show-leak-kinds=all` : Tous les types de fuites
- `--track-origins=yes` : Origine des valeurs non initialisÃ©es
- `--verbose` : Mode verbeux

### ProblÃ¨mes courants et solutions

#### ProblÃ¨me 1 : BibliothÃ¨que non trouvÃ©e

**Erreur** :
```
error while loading shared libraries: libmatrix.so: cannot open shared object file
```

**Solutions** :
```bash
# Solution 1 : LD_LIBRARY_PATH
export LD_LIBRARY_PATH=/chemin/vers/lib:$LD_LIBRARY_PATH

# Solution 2 : RPATH
fpc -k'-rpath=/chemin/vers/lib' -o test_matrix test_matrix.pas

# Solution 3 : Installation systÃ¨me
sudo cp libmatrix.so /usr/local/lib/  
sudo ldconfig

# Solution 4 : Chemin absolu
# Dans le code
external '/chemin/complet/libmatrix.so';
```

#### ProblÃ¨me 2 : Symbole non trouvÃ©

**Erreur** :
```
undefined symbol: matrix_create
```

**Diagnostic** :
```bash
# VÃ©rifier que le symbole existe
nm -D libmatrix.so | grep matrix_create
```

**Solutions** :
- VÃ©rifier que la fonction est dans la directive `exports`
- VÃ©rifier l'orthographe exacte
- S'assurer que la convention d'appel est correcte
- Recompiler la bibliothÃ¨que

#### ProblÃ¨me 3 : Version incompatible

**Erreur** :
```
version `GLIBC_2.34' not found
```

**Diagnostic** :
```bash
ldd --version  
ldd libmatrix.so
```

**Solutions** :
- Compiler sur la version cible du systÃ¨me
- Utiliser des bibliothÃ¨ques statiques pour certaines dÃ©pendances
- Lier statiquement avec libc si nÃ©cessaire

#### ProblÃ¨me 4 : Crash au chargement

**Diagnostic avec ldd** :
```bash
ldd -r libmatrix.so
```

L'option `-r` affiche les symboles non rÃ©solus.

**Diagnostic avec GDB** :
```bash
gdb ./test_matrix
(gdb) run
# Note le backtrace
(gdb) bt
```

## Packaging et distribution

### CrÃ©er un paquet Debian (.deb)

Structure du rÃ©pertoire :

```
libmatrix-1.0.0/
â”œâ”€â”€ DEBIAN/
â”‚   â””â”€â”€ control
â”œâ”€â”€ usr/
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ libmatrix.so.1.0.0
â”‚   â”‚   â”œâ”€â”€ libmatrix.so.1 -> libmatrix.so.1.0.0
â”‚   â”‚   â””â”€â”€ libmatrix.so -> libmatrix.so.1
â”‚   â”œâ”€â”€ include/
â”‚   â”‚   â””â”€â”€ matrix.h
â”‚   â””â”€â”€ share/
â”‚       â””â”€â”€ doc/
â”‚           â””â”€â”€ libmatrix/
â”‚               â”œâ”€â”€ README
â”‚               â””â”€â”€ copyright
```

Fichier `DEBIAN/control` :

```
Package: libmatrix  
Version: 1.0.0  
Section: libs  
Priority: optional  
Architecture: amd64  
Depends: libc6 (>= 2.31)  
Maintainer: Votre Nom <email@example.com>  
Description: BibliothÃ¨que de calcul matriciel
 Une bibliothÃ¨que pour effectuer des opÃ©rations
 sur des matrices en FreePascal.
```

CrÃ©er le paquet :

```bash
dpkg-deb --build libmatrix-1.0.0
```

Installer :
```bash
sudo dpkg -i libmatrix-1.0.0.deb
```

DÃ©sinstaller :
```bash
sudo dpkg -r libmatrix
```

### CrÃ©er un paquet RPM

Fichier `libmatrix.spec` :

```spec
Name:           libmatrix  
Version:        1.0.0  
Release:        1%{?dist}  
Summary:        BibliothÃ¨que de calcul matriciel  
License:        MIT  
URL:            https://example.com/libmatrix  
Source0:        libmatrix-%{version}.tar.gz

%description
Une bibliothÃ¨que pour effectuer des opÃ©rations  
sur des matrices en FreePascal.

%prep
%setup -q

%build
fpc -olibmatrix.so.1.0.0 libmatrix.pas

%install
mkdir -p %{buildroot}/usr/lib64  
cp libmatrix.so.1.0.0 %{buildroot}/usr/lib64/  
ln -s libmatrix.so.1.0.0 %{buildroot}/usr/lib64/libmatrix.so.1  
ln -s libmatrix.so.1 %{buildroot}/usr/lib64/libmatrix.so

%files
/usr/lib64/libmatrix.so.1.0.0
/usr/lib64/libmatrix.so.1
/usr/lib64/libmatrix.so

%post
/sbin/ldconfig

%postun
/sbin/ldconfig

%changelog
* Mon Jan 01 2025 Votre Nom <email@example.com> - 1.0.0-1
- Version initiale
```

Construire :
```bash
rpmbuild -ba libmatrix.spec
```

### AppImage (portable)

CrÃ©er un AppImage autonome :

```bash
#!/bin/bash
# build_appimage.sh

APP_NAME="MyMatrixApp"  
APP_DIR="${APP_NAME}.AppDir"

# CrÃ©er la structure
mkdir -p $APP_DIR/usr/{bin,lib}

# Copier l'exÃ©cutable
cp test_matrix $APP_DIR/usr/bin/

# Copier les bibliothÃ¨ques
cp libmatrix.so.1.0.0 $APP_DIR/usr/lib/  
ln -s libmatrix.so.1.0.0 $APP_DIR/usr/lib/libmatrix.so.1

# CrÃ©er le fichier .desktop
cat > $APP_DIR/${APP_NAME}.desktop << EOF
[Desktop Entry]
Name=MyMatrixApp  
Exec=test_matrix  
Icon=matrix  
Type=Application  
Categories=Utility;  
EOF

# CrÃ©er le fichier AppRun
cat > $APP_DIR/AppRun << 'EOF'
#!/bin/bash
SELF=$(readlink -f "$0")  
HERE=${SELF%/*}  
export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"  
exec "${HERE}/usr/bin/test_matrix" "$@"  
EOF  
chmod +x $APP_DIR/AppRun

# GÃ©nÃ©rer l'AppImage
appimagetool $APP_DIR
```

### Distribution via PPA (Ubuntu)

Pour distribuer via un PPA Ubuntu :

1. **CrÃ©er un compte Launchpad**
2. **PrÃ©parer les fichiers source**
3. **CrÃ©er le paquet source** :
```bash
debuild -S -sa
```
4. **Uploader vers Launchpad** :
```bash
dput ppa:votre-compte/ppa libmatrix_1.0.0_source.changes
```

## Optimisations spÃ©cifiques Linux

### Link-Time Optimization (LTO)

Activer LTO pour de meilleures optimisations :

```bash
fpc -olibmatrix.so -CX -XX -O3 -Cg -k'-flto' libmatrix.pas
```

**Avantages** :
- Inlining entre unitÃ©s de compilation
- Ã‰limination de code mort
- Optimisations globales

**InconvÃ©nients** :
- Temps de compilation plus long
- Taille de fichiers intermÃ©diaires plus importante

### Strip agressif

RÃ©duire la taille au minimum :

```bash
# Strip standard
strip --strip-unneeded libmatrix.so

# Strip agressif
strip --strip-all libmatrix.so

# Conserver uniquement les symboles dynamiques
strip --strip-debug libmatrix.so
```

Comparaison :
```
Original :                200 KB
--strip-unneeded :        150 KB (-25%)
--strip-all :             120 KB (-40%)
--strip-debug :           180 KB (-10%)
```

### Compression UPX

Compresser avec UPX (Universal Packer for eXecutables) :

```bash
upx --best libmatrix.so
```

**Attention** : Peut poser problÃ¨me avec certains systÃ¨mes de sÃ©curitÃ©.

### Optimisations de compilation

Options recommandÃ©es pour production :

```bash
fpc -olibmatrix.so \
    -O3 \           # Optimisation maximale
    -CX \           # Smart linking
    -XX \           # Smart linking Ã©tendu
    -Xs \           # Strip symboles
    -Si \           # Inline automatique
    -Sc \           # Assertions dÃ©sactivÃ©es
    -Sg \           # Goto supportÃ©
    -vew \          # Warnings complets
    libmatrix.pas
```

Pour la taille minimale :
```bash
fpc -olibmatrix.so -Os -CX -XX -Xs libmatrix.pas
```

Pour la vitesse maximale :
```bash
fpc -olibmatrix.so -O3 -Ooregvar -Si libmatrix.pas
```

## SÃ©curitÃ©

### Hardening du compilateur

Activer les protections de sÃ©curitÃ© :

```bash
fpc -olibmatrix.so \
    -k'-Wl,-z,relro' \        # RELRO (Relocation Read-Only)
    -k'-Wl,-z,now' \          # Bind now (pas de lazy binding)
    -k'-fstack-protector-strong' \  # Protection de pile
    libmatrix.pas
```

### VÃ©rifier les protections

Utiliser checksec :

```bash
checksec --file=libmatrix.so
```

Sortie :
```
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH  
Partial RELRO   Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH
```

**Protections importantes** :
- **RELRO** : Protection contre l'Ã©crasure de la GOT
- **Stack Canary** : DÃ©tection de dÃ©bordement de pile
- **NX** : Non-Executable stack
- **PIE** : Position Independent Executable
- **No RPATH** : Pas de chemins codÃ©s en dur (sÃ©curitÃ©)

### Audit avec scanelf

```bash
scanelf -e libmatrix.so
```

### Analyse de sÃ©curitÃ©

Scanner les vulnÃ©rabilitÃ©s connues :

```bash
# Analyser les dÃ©pendances
ldd libmatrix.so | while read lib; do
    dpkg -S $(echo $lib | awk '{print $3}') 2>/dev/null
done

# VÃ©rifier les CVE connus
sudo apt install apt-listbugs  
apt-listbugs list libmatrix
```

## Multi-architecture

### Support 32/64 bits

Compiler pour diffÃ©rentes architectures :

**64 bits (x86_64)** :
```bash
fpc -Px86_64 -olibmatrix.so libmatrix.pas
```

**32 bits (i386)** :
```bash
fpc -Pi386 -olibmatrix.so.32 libmatrix.pas
```

**ARM 64 bits (aarch64)** :
```bash
fpc -Paarch64 -olibmatrix.so.arm64 libmatrix.pas
```

### Installation multi-arch sur Debian/Ubuntu

Structure :
```
/usr/lib/
â”œâ”€â”€ x86_64-linux-gnu/
â”‚   â””â”€â”€ libmatrix.so.1.0.0
â”œâ”€â”€ i386-linux-gnu/
â”‚   â””â”€â”€ libmatrix.so.1.0.0
â””â”€â”€ aarch64-linux-gnu/
    â””â”€â”€ libmatrix.so.1.0.0
```

### Cross-compilation

Depuis Ubuntu x86_64 vers ARM :

```bash
# Installer le cross-compilateur
sudo apt install fpc-3.2.2-arm-linux

# Compiler
fpc -Parm -olibmatrix.so.arm libmatrix.pas
```

## Bonnes pratiques rÃ©capitulatives

### âœ… Ã€ faire

1. **Utiliser `cdecl`** pour la compatibilitÃ© C
2. **Suivre les conventions de nommage** (lib*.so.*)
3. **DÃ©finir un SONAME** appropriÃ©
4. **CrÃ©er les liens symboliques** correctement
5. **Documenter l'API** (fichiers .h)
6. **GÃ©rer les erreurs** sans exceptions
7. **Tester sur plusieurs distributions**
8. **Utiliser ldconfig** aprÃ¨s installation
9. **Fournir des fichiers pkg-config**
10. **Versionner sÃ©mantiquement**

### âŒ Ã€ Ã©viter

1. **Exporter des types Pascal** complexes
2. **Oublier d'exÃ©cuter ldconfig**
3. **Modifier l'ABI** sans changer SONAME
4. **Utiliser RPATH** avec chemins absolus
5. **NÃ©gliger la thread-safety**
6. **Ignorer les warnings** du compilateur
7. **Oublier les symboles** de dÃ©bogage en dev
8. **Ne pas tester** la liaison dynamique
9. **Distribuer sans documentation**
10. **Coder en dur** des chemins systÃ¨me

## Checklist de distribution

Avant de distribuer votre bibliothÃ¨que partagÃ©e :

- [ ] TestÃ©e sur Ubuntu, Debian, Fedora, Arch
- [ ] Versions 32 et 64 bits si nÃ©cessaire
- [ ] SONAME correctement dÃ©fini
- [ ] Liens symboliques crÃ©Ã©s
- [ ] Fichiers .h fournis pour C/C++
- [ ] Documentation API complÃ¨te
- [ ] Exemples de code pour plusieurs langages
- [ ] Fichier pkg-config (.pc)
- [ ] Tests automatisÃ©s
- [ ] Pas de fuites mÃ©moire (Valgrind)
- [ ] Protections de sÃ©curitÃ© activÃ©es
- [ ] Paquet .deb ou .rpm disponible
- [ ] Licence clairement dÃ©finie
- [ ] Changelog maintenu

## Conclusion

CrÃ©er des Shared Objects sur Linux avec FreePascal permet :
- **IntÃ©gration parfaite** dans l'Ã©cosystÃ¨me Linux
- **CompatibilitÃ©** avec tous les langages via l'ABI C
- **Distribution facile** via les gestionnaires de paquets
- **Performance native** optimale

Points essentiels Ã  retenir :
- âœ… Convention `cdecl` obligatoire
- âœ… Nommage `lib*.so.*` standard
- âœ… SONAME pour la gestion des versions
- âœ… Liens symboliques appropriÃ©s
- âœ… Installation via ldconfig
- âœ… Documentation multilingue

Avec ces connaissances, vous pouvez crÃ©er des bibliothÃ¨ques partagÃ©es Linux professionnelles, robustes et largement utilisables dans tout l'Ã©cosystÃ¨me open source.

â­ï¸ [Bindings C/C++ avancÃ©s](/19-interoperabilite-bindings/02-bindings-c-cpp-avances.md)
