üîù Retour au [Sommaire](/SOMMAIRE.md)

# 10.8.1 Named Pipes (Windows)

## Introduction

Les Named Pipes (tubes nomm√©s) sont un m√©canisme IPC (Inter-Process Communication) de Windows permettant √† des processus de communiquer entre eux. Ils sont appel√©s "nomm√©s" car ils poss√®dent un nom unique dans le syst√®me, contrairement aux pipes anonymes qui n'existent que le temps d'une ex√©cution.

Les Named Pipes Windows sont particuli√®rement puissants car ils supportent :
- La communication locale (sur la m√™me machine)
- La communication r√©seau (entre machines diff√©rentes)
- La communication bidirectionnelle
- La s√©curit√© int√©gr√©e (permissions Windows)

## Qu'est-ce qu'un Named Pipe ?

### Analogie

Imaginez un tuyau (pipe) qui relie deux processus :

```
Process Serveur          Named Pipe           Process Client
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ         ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  PIPE  ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ         ‚îÇ
  ‚îÇ Lecture ‚îÇ           ‚îÇ  Nom:  ‚îÇ             ‚îÇ √âcriture‚îÇ
  ‚îÇ         ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ MyPipe ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂         ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚ñ≤                                             ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Les donn√©es circulent ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Le pipe poss√®de un **nom** (par exemple : `\\.\pipe\MyPipe`) qui permet aux processus de s'y connecter.

### Caract√©ristiques

- **Bidirectionnel** : Communication dans les deux sens
- **Nomm√©** : Identifi√© par un nom unique
- **Local ou r√©seau** : `\\.\pipe\nom` (local) ou `\\serveur\pipe\nom` (r√©seau)
- **Orient√© message ou flux** : Deux modes disponibles
- **S√©curit√©** : Permissions Windows (ACL)
- **Multi-instance** : Plusieurs clients peuvent se connecter au m√™me pipe

### Syntaxe du nom

```
Format local :
\\.\pipe\NomDuPipe

Format r√©seau :
\\NomServeur\pipe\NomDuPipe

Exemples :
\\.\pipe\MyApp           ‚Üí Local
\\.\pipe\ServiceDB       ‚Üí Local
\\SERVEUR1\pipe\MyApp    ‚Üí R√©seau vers SERVEUR1
```

## Modes de fonctionnement

### Mode Message vs Mode Byte Stream

#### Mode Message (PIPE_TYPE_MESSAGE)

```
Serveur √©crit :          Client re√ßoit :
  "Message 1"      ‚Üí       "Message 1"
  "Message 2"      ‚Üí       "Message 2"

Les messages sont pr√©serv√©s en tant qu'unit√©s distinctes
```

**Utilisation :** Quand vous voulez envoyer des messages d√©limit√©s

#### Mode Byte Stream (PIPE_TYPE_BYTE)

```
Serveur √©crit :          Client re√ßoit :
  "Hello"          ‚Üí       "HelloWorld"
  "World"          ‚Üí       (flux continu)

Les donn√©es sont un flux continu, sans d√©limitation
```

**Utilisation :** Quand vous envoyez un flux de donn√©es continu

### Mode Bloquant vs Non-bloquant

#### Mode Bloquant (PIPE_WAIT)

```pascal
// L'appel attend qu'une connexion arrive
ConnectNamedPipe(Pipe, nil); // Bloque ici jusqu'√† connexion
WriteLn('Client connect√© !');
```

#### Mode Non-bloquant (PIPE_NOWAIT)

```pascal
// L'appel retourne imm√©diatement
if not ConnectNamedPipe(Pipe, nil) then
  WriteLn('Pas de client en attente');
```

## Cr√©ation d'un Named Pipe (Serveur)

### Fonction CreateNamedPipe

Voici la fonction Windows pour cr√©er un pipe :

```pascal
function CreateNamedPipe(
  lpName: LPCWSTR;                // Nom du pipe
  dwOpenMode: DWORD;              // Mode d'ouverture
  dwPipeMode: DWORD;              // Mode du pipe
  nMaxInstances: DWORD;           // Nombre max d'instances
  nOutBufferSize: DWORD;          // Taille buffer sortie
  nInBufferSize: DWORD;           // Taille buffer entr√©e
  nDefaultTimeOut: DWORD;         // Timeout par d√©faut
  lpSecurityAttributes: LPSECURITY_ATTRIBUTES // S√©curit√©
): THandle;
```

### Param√®tres expliqu√©s

**dwOpenMode** (Direction) :
- `PIPE_ACCESS_DUPLEX` : Bidirectionnel (lecture et √©criture)
- `PIPE_ACCESS_INBOUND` : Serveur lit, client √©crit
- `PIPE_ACCESS_OUTBOUND` : Serveur √©crit, client lit

**dwPipeMode** (Mode) :
- `PIPE_TYPE_BYTE` : Mode flux d'octets
- `PIPE_TYPE_MESSAGE` : Mode message
- `PIPE_READMODE_BYTE` : Lecture par octets
- `PIPE_READMODE_MESSAGE` : Lecture par messages
- `PIPE_WAIT` : Mode bloquant
- `PIPE_NOWAIT` : Mode non-bloquant

**nMaxInstances** :
- Nombre de clients simultan√©s (1 √† `PIPE_UNLIMITED_INSTANCES`)

**Buffers** :
- Taille des buffers en octets (g√©n√©ralement 4096 ou 8192)

## Serveur Named Pipe simple

Cr√©ons un serveur qui accepte des connexions :

```pascal
program NamedPipeServer;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils;

const
  PIPE_NAME = '\\.\pipe\MyTestPipe';
  BUFFER_SIZE = 4096;

var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Success: Boolean;

begin
  WriteLn('=== Serveur Named Pipe ===');
  WriteLn('Cr√©ation du pipe : ', PIPE_NAME);

  // Cr√©ation du pipe
  hPipe := CreateNamedPipe(
    PChar(PIPE_NAME),                    // Nom du pipe
    PIPE_ACCESS_DUPLEX,                  // Bidirectionnel
    PIPE_TYPE_MESSAGE or                 // Mode message
    PIPE_READMODE_MESSAGE or
    PIPE_WAIT,                           // Bloquant
    1,                                   // 1 instance (1 client √† la fois)
    BUFFER_SIZE,                         // Buffer sortie
    BUFFER_SIZE,                         // Buffer entr√©e
    0,                                   // Timeout par d√©faut
    nil                                  // S√©curit√© par d√©faut
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur cr√©ation pipe : ', GetLastError);
    Exit;
  end;

  WriteLn('Pipe cr√©√© avec succ√®s');
  WriteLn('En attente de connexion client...');

  // Attente d'une connexion
  Success := ConnectNamedPipe(hPipe, nil);

  if not Success and (GetLastError <> ERROR_PIPE_CONNECTED) then
  begin
    WriteLn('Erreur connexion : ', GetLastError);
    CloseHandle(hPipe);
    Exit;
  end;

  WriteLn('Client connect√© !');

  // Lecture d'un message du client
  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(
    hPipe,
    Buffer,
    SizeOf(Buffer),
    BytesRead,
    nil
  );

  if Success then
  begin
    WriteLn('Message re√ßu : ', Buffer);

    // Envoi d'une r√©ponse
    Success := WriteFile(
      hPipe,
      PChar('Message re√ßu par le serveur'),
      Length('Message re√ßu par le serveur'),
      BytesWritten,
      nil
    );

    if Success then
      WriteLn('R√©ponse envoy√©e au client');
  end;

  // D√©connexion et fermeture
  DisconnectNamedPipe(hPipe);
  CloseHandle(hPipe);

  WriteLn('Pipe ferm√©');
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

## Client Named Pipe simple

Cr√©ons maintenant un client qui se connecte au serveur :

```pascal
program NamedPipeClient;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils;

const
  PIPE_NAME = '\\.\pipe\MyTestPipe';
  BUFFER_SIZE = 4096;

var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Success: Boolean;
  Message: string;

begin
  WriteLn('=== Client Named Pipe ===');
  WriteLn('Connexion au pipe : ', PIPE_NAME);

  // Attente que le pipe soit disponible
  if not WaitNamedPipe(PChar(PIPE_NAME), 5000) then // 5 secondes max
  begin
    WriteLn('Le pipe n''est pas disponible');
    Exit;
  end;

  // Connexion au pipe
  hPipe := CreateFile(
    PChar(PIPE_NAME),              // Nom du pipe
    GENERIC_READ or GENERIC_WRITE, // Lecture et √©criture
    0,                             // Pas de partage
    nil,                           // S√©curit√© par d√©faut
    OPEN_EXISTING,                 // Ouvrir existant
    0,                             // Attributs par d√©faut
    0                              // Pas de template
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur connexion : ', GetLastError);
    Exit;
  end;

  WriteLn('Connect√© au serveur !');

  // Envoi d'un message
  Message := 'Bonjour depuis le client !';
  Success := WriteFile(
    hPipe,
    PChar(Message),
    Length(Message),
    BytesWritten,
    nil
  );

  if Success then
    WriteLn('Message envoy√© : ', Message);

  // Lecture de la r√©ponse
  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(
    hPipe,
    Buffer,
    SizeOf(Buffer),
    BytesRead,
    nil
  );

  if Success then
    WriteLn('R√©ponse re√ßue : ', Buffer);

  // Fermeture
  CloseHandle(hPipe);

  WriteLn('Connexion ferm√©e');
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

### Test des programmes

1. Compilez les deux programmes
2. Lancez d'abord le **serveur**
3. Lancez ensuite le **client**
4. Observez l'√©change de messages

## Serveur multi-clients

Pour accepter plusieurs clients simultan√©ment, cr√©ons plusieurs instances du pipe :

```pascal
program MultiClientServer;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils, Classes;

const
  PIPE_NAME = '\\.\pipe\MyMultiPipe';
  BUFFER_SIZE = 4096;
  MAX_CLIENTS = 5;

type
  TClientThread = class(TThread)
  private
    FPipeHandle: THandle;
    FClientID: Integer;
  protected
    procedure Execute; override;
  public
    constructor Create(APipeHandle: THandle; AClientID: Integer);
  end;

constructor TClientThread.Create(APipeHandle: THandle; AClientID: Integer);
begin
  inherited Create(False);
  FreeOnTerminate := True;
  FPipeHandle := APipeHandle;
  FClientID := AClientID;
end;

procedure TClientThread.Execute;
var
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Success: Boolean;
  Response: string;
begin
  WriteLn('[Client ', FClientID, '] Thread d√©marr√©');

  try
    // Lecture du message
    FillChar(Buffer, SizeOf(Buffer), 0);
    Success := ReadFile(FPipeHandle, Buffer, SizeOf(Buffer), BytesRead, nil);

    if Success then
    begin
      WriteLn('[Client ', FClientID, '] Message re√ßu : ', Buffer);

      // R√©ponse
      Response := Format('R√©ponse du serveur pour le client %d', [FClientID]);
      WriteFile(FPipeHandle, PChar(Response), Length(Response), BytesWritten, nil);

      WriteLn('[Client ', FClientID, '] R√©ponse envoy√©e');
    end;

  finally
    // D√©connexion et fermeture
    FlushFileBuffers(FPipeHandle);
    DisconnectNamedPipe(FPipeHandle);
    CloseHandle(FPipeHandle);
    WriteLn('[Client ', FClientID, '] D√©connect√©');
  end;
end;

var
  ClientCount: Integer;
  hPipe: THandle;
  Success: Boolean;

begin
  WriteLn('=== Serveur Multi-Clients ===');
  WriteLn('En attente de connexions...');
  WriteLn('Appuyez sur Ctrl+C pour arr√™ter');
  WriteLn;

  ClientCount := 0;

  while True do
  begin
    // Cr√©ation d'une nouvelle instance du pipe
    hPipe := CreateNamedPipe(
      PChar(PIPE_NAME),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES,  // Instances illimit√©es
      BUFFER_SIZE,
      BUFFER_SIZE,
      0,
      nil
    );

    if hPipe = INVALID_HANDLE_VALUE then
    begin
      WriteLn('Erreur cr√©ation pipe');
      Break;
    end;

    // Attente d'une connexion
    Success := ConnectNamedPipe(hPipe, nil);

    if Success or (GetLastError = ERROR_PIPE_CONNECTED) then
    begin
      Inc(ClientCount);
      WriteLn('Nouveau client connect√© (ID: ', ClientCount, ')');

      // Cr√©ation d'un thread pour g√©rer ce client
      TClientThread.Create(hPipe, ClientCount);
    end
    else
    begin
      CloseHandle(hPipe);
    end;
  end;
end.
```

## Communication bidirectionnelle

Exemple avec √©change de plusieurs messages :

```pascal
program BidirectionalPipe;

{$mode objfpc}{$H+}
{$APPTYPE CONSOLE}

uses
  Windows, SysUtils;

const
  PIPE_NAME = '\\.\pipe\ChatPipe';
  BUFFER_SIZE = 4096;

procedure RunServer;
var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Message: string;
  Continue: Boolean;
begin
  WriteLn('=== Mode Serveur ===');

  hPipe := CreateNamedPipe(
    PChar(PIPE_NAME),
    PIPE_ACCESS_DUPLEX,
    PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
    1, BUFFER_SIZE, BUFFER_SIZE, 0, nil
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur cr√©ation pipe');
    Exit;
  end;

  WriteLn('En attente de connexion...');
  ConnectNamedPipe(hPipe, nil);
  WriteLn('Client connect√© !');
  WriteLn('Tapez vos messages (QUIT pour quitter)');
  WriteLn;

  Continue := True;

  while Continue do
  begin
    // Lecture du message client
    FillChar(Buffer, SizeOf(Buffer), 0);
    if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
    begin
      WriteLn('[Client] ', Buffer);

      if UpperCase(string(Buffer)) = 'QUIT' then
      begin
        Continue := False;
        Continue;
      end;
    end;

    // Envoi de notre message
    Write('[Vous] ');
    ReadLn(Message);

    WriteFile(hPipe, PChar(Message), Length(Message), BytesWritten, nil);

    if UpperCase(Message) = 'QUIT' then
      Continue := False;
  end;

  DisconnectNamedPipe(hPipe);
  CloseHandle(hPipe);
  WriteLn('Connexion ferm√©e');
end;

procedure RunClient;
var
  hPipe: THandle;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead, BytesWritten: DWORD;
  Message: string;
  Continue: Boolean;
begin
  WriteLn('=== Mode Client ===');

  if not WaitNamedPipe(PChar(PIPE_NAME), 5000) then
  begin
    WriteLn('Pipe non disponible');
    Exit;
  end;

  hPipe := CreateFile(
    PChar(PIPE_NAME),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if hPipe = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur connexion');
    Exit;
  end;

  WriteLn('Connect√© au serveur !');
  WriteLn('Tapez vos messages (QUIT pour quitter)');
  WriteLn;

  Continue := True;

  while Continue do
  begin
    // Envoi de notre message
    Write('[Vous] ');
    ReadLn(Message);

    WriteFile(hPipe, PChar(Message), Length(Message), BytesWritten, nil);

    if UpperCase(Message) = 'QUIT' then
    begin
      Continue := False;
      Continue;
    end;

    // Lecture de la r√©ponse
    FillChar(Buffer, SizeOf(Buffer), 0);
    if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
    begin
      WriteLn('[Serveur] ', Buffer);

      if UpperCase(string(Buffer)) = 'QUIT' then
        Continue := False;
    end;
  end;

  CloseHandle(hPipe);
  WriteLn('Connexion ferm√©e');
end;

var
  Choice: string;

begin
  WriteLn('=== Application Chat via Named Pipe ===');
  WriteLn('1. Serveur');
  WriteLn('2. Client');
  Write('Votre choix : ');
  ReadLn(Choice);
  WriteLn;

  if Choice = '1' then
    RunServer
  else if Choice = '2' then
    RunClient
  else
    WriteLn('Choix invalide');

  WriteLn;
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

## Gestion des erreurs

### Codes d'erreur courants

```pascal
procedure CheckPipeError;
var
  ErrorCode: DWORD;
begin
  ErrorCode := GetLastError;

  case ErrorCode of
    ERROR_PIPE_BUSY:
      WriteLn('Le pipe est occup√©, r√©essayez plus tard');

    ERROR_PIPE_NOT_CONNECTED:
      WriteLn('Le pipe n''est pas connect√©');

    ERROR_BROKEN_PIPE:
      WriteLn('Le pipe est cass√© (connexion ferm√©e)');

    ERROR_NO_DATA:
      WriteLn('Le pipe est en cours de fermeture');

    ERROR_PIPE_LISTENING:
      WriteLn('Le pipe est en √©coute (pas encore de client)');

    ERROR_FILE_NOT_FOUND:
      WriteLn('Le pipe n''existe pas');

    ERROR_ACCESS_DENIED:
      WriteLn('Acc√®s refus√© (permissions insuffisantes)');
  else
    WriteLn('Erreur : ', ErrorCode);
  end;
end;
```

### Gestion robuste

```pascal
function SafeReadFromPipe(hPipe: THandle; out Data: string): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Success: Boolean;
begin
  Result := False;
  Data := '';

  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil);

  if Success then
  begin
    if BytesRead > 0 then
    begin
      Data := Buffer;
      Result := True;
    end;
  end
  else
  begin
    case GetLastError of
      ERROR_BROKEN_PIPE:
        WriteLn('Le client s''est d√©connect√©');
      ERROR_NO_DATA:
        WriteLn('Pipe en cours de fermeture');
    else
      CheckPipeError;
    end;
  end;
end;

function SafeWriteToPipe(hPipe: THandle; const Data: string): Boolean;
var
  BytesWritten: DWORD;
begin
  Result := WriteFile(
    hPipe,
    PChar(Data),
    Length(Data),
    BytesWritten,
    nil
  );

  if not Result then
    CheckPipeError;
end;
```

## Timeouts

### Configuration du timeout

```pascal
procedure SetPipeTimeout(hPipe: THandle; TimeoutMS: DWORD);
var
  Mode: DWORD;
begin
  Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;

  SetNamedPipeHandleState(
    hPipe,
    @Mode,
    nil,        // Pas de changement de buffer
    @TimeoutMS  // Timeout en millisecondes
  );
end;

// Utilisation
SetPipeTimeout(hPipe, 5000); // 5 secondes
```

### Lecture avec timeout

```pascal
function ReadWithTimeout(hPipe: THandle; TimeoutMS: DWORD; out Data: string): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Mode: DWORD;
begin
  Result := False;
  Data := '';

  // Configuration du timeout
  Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;
  SetNamedPipeHandleState(hPipe, @Mode, nil, @TimeoutMS);

  // Lecture
  FillChar(Buffer, SizeOf(Buffer), 0);
  if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
  begin
    Data := Buffer;
    Result := True;
  end
  else
  begin
    if GetLastError = ERROR_TIMEOUT then
      WriteLn('Timeout lors de la lecture')
    else
      CheckPipeError;
  end;
end;
```

## S√©curit√© et permissions

### Cr√©ation avec permissions personnalis√©es

```pascal
uses
  Windows, SysUtils, AccCtrl, AclAPI;

function CreateSecurePipe(const PipeName: string): THandle;
var
  SA: TSecurityAttributes;
  SD: PSECURITY_DESCRIPTOR;
  EA: EXPLICIT_ACCESS;
  ACL: PACL;
begin
  // Allocation du descripteur de s√©curit√©
  SD := nil;
  ACL := nil;

  try
    // Initialisation
    InitializeSecurityDescriptor(@SD, SECURITY_DESCRIPTOR_REVISION);

    // Cr√©ation d'une ACL (Access Control List)
    // Ici : acc√®s complet pour l'utilisateur courant
    FillChar(EA, SizeOf(EA), 0);
    EA.grfAccessPermissions := GENERIC_ALL;
    EA.grfAccessMode := SET_ACCESS;
    EA.grfInheritance := NO_INHERITANCE;
    EA.Trustee.TrusteeForm := TRUSTEE_IS_NAME;
    EA.Trustee.ptstrName := PChar('CURRENT_USER');

    // D√©finition des attributs de s√©curit√©
    SA.nLength := SizeOf(TSecurityAttributes);
    SA.lpSecurityDescriptor := SD;
    SA.bInheritHandle := False;

    // Cr√©ation du pipe avec s√©curit√©
    Result := CreateNamedPipe(
      PChar(PipeName),
      PIPE_ACCESS_DUPLEX,
      PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
      PIPE_UNLIMITED_INSTANCES,
      4096, 4096, 0,
      @SA  // Attributs de s√©curit√© personnalis√©s
    );

  finally
    if ACL <> nil then
      LocalFree(HLOCAL(ACL));
  end;
end;
```

## Named Pipes r√©seau

### Connexion √† un pipe distant

```pascal
const
  // Format : \\NomServeur\pipe\NomPipe
  REMOTE_PIPE = '\\SERVEUR1\pipe\MyPipe';

procedure ConnectToRemotePipe;
var
  hPipe: THandle;
begin
  WriteLn('Connexion au pipe distant : ', REMOTE_PIPE);

  if not WaitNamedPipe(PChar(REMOTE_PIPE), 10000) then
  begin
    WriteLn('Timeout ou pipe indisponible');
    Exit;
  end;

  hPipe := CreateFile(
    PChar(REMOTE_PIPE),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if hPipe <> INVALID_HANDLE_VALUE then
  begin
    WriteLn('Connect√© au serveur distant !');
    // Utiliser le pipe...
    CloseHandle(hPipe);
  end
  else
    WriteLn('Erreur connexion : ', GetLastError);
end;
```

**Note :** Pour les pipes r√©seau, assurez-vous que :
1. Le partage de fichiers est activ√©
2. Le pare-feu autorise les connexions
3. Vous avez les permissions n√©cessaires

## Performance et optimisations

### Buffers optimis√©s

```pascal
const
  // Tailles recommand√©es selon l'usage
  SMALL_BUFFER = 1024;      // Messages courts
  MEDIUM_BUFFER = 4096;     // Usage g√©n√©ral
  LARGE_BUFFER = 65536;     // Gros transferts

procedure CreateOptimizedPipe(BufferSize: DWORD);
var
  hPipe: THandle;
begin
  hPipe := CreateNamedPipe(
    '\\.\pipe\OptimizedPipe',
    PIPE_ACCESS_DUPLEX,
    PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
    PIPE_UNLIMITED_INSTANCES,
    BufferSize,  // Buffer sortie
    BufferSize,  // Buffer entr√©e
    0,
    nil
  );

  // Utiliser le pipe...
end;
```

### Mode non-bloquant pour performance

```pascal
procedure NonBlockingRead(hPipe: THandle);
var
  Buffer: array[0..4095] of Char;
  BytesRead, TotalBytes, BytesLeft: DWORD;
  Success: Boolean;
begin
  // V√©rifier si des donn√©es sont disponibles
  Success := PeekNamedPipe(
    hPipe,
    nil,           // Pas de lecture
    0,
    nil,
    @TotalBytes,   // Octets disponibles
    @BytesLeft
  );

  if Success and (TotalBytes > 0) then
  begin
    // Des donn√©es sont disponibles, on peut lire
    ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil);
    WriteLn('Lu : ', BytesRead, ' octets');
  end
  else
    WriteLn('Pas de donn√©es disponibles');
end;
```

## Debugging et diagnostic

### Affichage des informations du pipe

```pascal
procedure ShowPipeInfo(hPipe: THandle);
var
  Flags, OutBufferSize, InBufferSize, MaxInstances: DWORD;
begin
  if GetNamedPipeInfo(hPipe, @Flags, @OutBufferSize, @InBufferSize, @MaxInstances) then
  begin
    WriteLn('=== Informations du Pipe ===');

    Write('Type : ');
    if (Flags and PIPE_TYPE_MESSAGE) <> 0 then
      WriteLn('Message')
    else
      WriteLn('Byte Stream');

    Write('Direction : ');
    if (Flags and PIPE_SERVER_END) <> 0 then
      WriteLn('Serveur')
    else
      WriteLn('Client');

    WriteLn('Buffer sortie : ', OutBufferSize, ' octets');
    WriteLn('Buffer entr√©e : ', InBufferSize, ' octets');
    WriteLn('Instances max : ', MaxInstances);
  end;
end;
```

### Liste des pipes disponibles

```pascal
uses
  Windows, SysUtils;

procedure ListAllPipes;
var
  FindData: TWin32FindData;
  hFind: THandle;
begin
  WriteLn('=== Pipes nomm√©s disponibles ===');

  hFind := FindFirstFile('\\.\pipe\*', FindData);

  if hFind <> INVALID_HANDLE_VALUE then
  begin
    repeat
      WriteLn('  ', FindData.cFileName);
    until not FindNextFile(hFind, FindData);

    Windows.FindClose(hFind);
  end
  else
    WriteLn('Aucun pipe trouv√© ou erreur');
end;
```

## Bonnes pratiques

### Checklist pour Named Pipes

‚úÖ **Cr√©ation**
- Choisir le bon mode (message vs byte stream)
- D√©finir des buffers adapt√©s √† l'usage (4096 octets minimum)
- Utiliser `PIPE_UNLIMITED_INSTANCES` pour multi-clients
- Configurer un timeout raisonnable

‚úÖ **Connexion**
- Toujours utiliser `WaitNamedPipe` c√¥t√© client avant `CreateFile`
- G√©rer le cas o√π le pipe n'existe pas encore
- Impl√©menter des m√©canismes de retry avec backoff

‚úÖ **Communication**
- V√©rifier le retour de toutes les fonctions (`ReadFile`, `WriteFile`)
- Utiliser `FlushFileBuffers` avant de fermer pour assurer l'envoi
- Impl√©menter des timeouts pour √©viter les blocages

‚úÖ **Fermeture**
- Toujours appeler `DisconnectNamedPipe` (c√¥t√© serveur)
- Toujours appeler `CloseHandle` pour lib√©rer les ressources
- G√©rer proprement les d√©connexions brutales

‚úÖ **Erreurs**
- V√©rifier `GetLastError` en cas d'√©chec
- G√©rer `ERROR_BROKEN_PIPE` (d√©connexion)
- G√©rer `ERROR_PIPE_BUSY` (trop de clients)

‚úÖ **S√©curit√©**
- D√©finir des permissions appropri√©es
- Ne pas ex√©cuter avec des privil√®ges √©lev√©s sans raison
- Valider toutes les donn√©es re√ßues

### Exemple de code robuste

```pascal
unit RobustNamedPipe;

{$mode objfpc}{$H+}

interface

uses
  Windows, SysUtils;

type
  TNamedPipeServer = class
  private
    FPipeName: string;
    FPipeHandle: THandle;
    FBufferSize: DWORD;
    FMaxClients: DWORD;
    FConnected: Boolean;
    function GetLastErrorMessage: string;
  public
    constructor Create(const APipeName: string; ABufferSize: DWORD = 4096;
                      AMaxClients: DWORD = PIPE_UNLIMITED_INSTANCES);
    destructor Destroy; override;
    function Start: Boolean;
    function WaitForClient(TimeoutMS: DWORD = INFINITE): Boolean;
    function ReadMessage(out Message: string; TimeoutMS: DWORD = INFINITE): Boolean;
    function WriteMessage(const Message: string): Boolean;
    procedure Disconnect;
    property Connected: Boolean read FConnected;
  end;

  TNamedPipeClient = class
  private
    FPipeName: string;
    FPipeHandle: THandle;
    FConnected: Boolean;
    function GetLastErrorMessage: string;
  public
    constructor Create(const APipeName: string);
    destructor Destroy; override;
    function Connect(TimeoutMS: DWORD = 5000): Boolean;
    function ReadMessage(out Message: string; TimeoutMS: DWORD = INFINITE): Boolean;
    function WriteMessage(const Message: string): Boolean;
    procedure Disconnect;
    property Connected: Boolean read FConnected;
  end;

implementation

{ TNamedPipeServer }

constructor TNamedPipeServer.Create(const APipeName: string; ABufferSize: DWORD;
                                    AMaxClients: DWORD);
begin
  FPipeName := APipeName;
  FBufferSize := ABufferSize;
  FMaxClients := AMaxClients;
  FPipeHandle := INVALID_HANDLE_VALUE;
  FConnected := False;
end;

destructor TNamedPipeServer.Destroy;
begin
  Disconnect;
  inherited;
end;

function TNamedPipeServer.GetLastErrorMessage: string;
var
  ErrorCode: DWORD;
begin
  ErrorCode := GetLastError;
  Result := Format('Erreur %d: %s', [ErrorCode, SysErrorMessage(ErrorCode)]);
end;

function TNamedPipeServer.Start: Boolean;
begin
  Result := False;

  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    WriteLn('Le pipe est d√©j√† cr√©√©');
    Exit;
  end;

  FPipeHandle := CreateNamedPipe(
    PChar(FPipeName),
    PIPE_ACCESS_DUPLEX,
    PIPE_TYPE_MESSAGE or PIPE_READMODE_MESSAGE or PIPE_WAIT,
    FMaxClients,
    FBufferSize,
    FBufferSize,
    0,
    nil
  );

  if FPipeHandle = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur cr√©ation pipe: ', GetLastErrorMessage);
    Exit;
  end;

  Result := True;
end;

function TNamedPipeServer.WaitForClient(TimeoutMS: DWORD): Boolean;
var
  Success: Boolean;
  Overlapped: TOverlapped;
  WaitResult: DWORD;
begin
  Result := False;

  if FPipeHandle = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Le pipe n''est pas cr√©√©');
    Exit;
  end;

  if TimeoutMS = INFINITE then
  begin
    // Mode bloquant simple
    Success := ConnectNamedPipe(FPipeHandle, nil);

    if Success or (GetLastError = ERROR_PIPE_CONNECTED) then
    begin
      FConnected := True;
      Result := True;
    end
    else
      WriteLn('Erreur connexion: ', GetLastErrorMessage);
  end
  else
  begin
    // Mode avec timeout (n√©cessite overlapped I/O)
    FillChar(Overlapped, SizeOf(Overlapped), 0);
    Overlapped.hEvent := CreateEvent(nil, True, False, nil);

    try
      Success := ConnectNamedPipe(FPipeHandle, @Overlapped);

      if not Success then
      begin
        case GetLastError of
          ERROR_IO_PENDING:
            begin
              WaitResult := WaitForSingleObject(Overlapped.hEvent, TimeoutMS);
              if WaitResult = WAIT_OBJECT_0 then
              begin
                FConnected := True;
                Result := True;
              end
              else
                WriteLn('Timeout en attente de client');
            end;
          ERROR_PIPE_CONNECTED:
            begin
              FConnected := True;
              Result := True;
            end;
        else
          WriteLn('Erreur connexion: ', GetLastErrorMessage);
        end;
      end
      else
      begin
        FConnected := True;
        Result := True;
      end;

    finally
      CloseHandle(Overlapped.hEvent);
    end;
  end;
end;

function TNamedPipeServer.ReadMessage(out Message: string; TimeoutMS: DWORD): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Success: Boolean;
  Mode: DWORD;
begin
  Result := False;
  Message := '';

  if not FConnected then
  begin
    WriteLn('Aucun client connect√©');
    Exit;
  end;

  // Configuration du timeout si n√©cessaire
  if TimeoutMS <> INFINITE then
  begin
    Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;
    SetNamedPipeHandleState(FPipeHandle, @Mode, nil, @TimeoutMS);
  end;

  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(FPipeHandle, Buffer, SizeOf(Buffer), BytesRead, nil);

  if Success then
  begin
    if BytesRead > 0 then
    begin
      Message := Buffer;
      Result := True;
    end;
  end
  else
  begin
    case GetLastError of
      ERROR_BROKEN_PIPE:
        begin
          WriteLn('Le client s''est d√©connect√©');
          FConnected := False;
        end;
      ERROR_NO_DATA:
        begin
          WriteLn('Pipe en cours de fermeture');
          FConnected := False;
        end;
    else
      WriteLn('Erreur lecture: ', GetLastErrorMessage);
    end;
  end;
end;

function TNamedPipeServer.WriteMessage(const Message: string): Boolean;
var
  BytesWritten: DWORD;
begin
  Result := False;

  if not FConnected then
  begin
    WriteLn('Aucun client connect√©');
    Exit;
  end;

  Result := WriteFile(
    FPipeHandle,
    PChar(Message),
    Length(Message),
    BytesWritten,
    nil
  );

  if not Result then
    WriteLn('Erreur √©criture: ', GetLastErrorMessage)
  else
    FlushFileBuffers(FPipeHandle); // S'assurer que les donn√©es sont envoy√©es
end;

procedure TNamedPipeServer.Disconnect;
begin
  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    if FConnected then
    begin
      FlushFileBuffers(FPipeHandle);
      DisconnectNamedPipe(FPipeHandle);
      FConnected := False;
    end;

    CloseHandle(FPipeHandle);
    FPipeHandle := INVALID_HANDLE_VALUE;
  end;
end;

{ TNamedPipeClient }

constructor TNamedPipeClient.Create(const APipeName: string);
begin
  FPipeName := APipeName;
  FPipeHandle := INVALID_HANDLE_VALUE;
  FConnected := False;
end;

destructor TNamedPipeClient.Destroy;
begin
  Disconnect;
  inherited;
end;

function TNamedPipeClient.GetLastErrorMessage: string;
var
  ErrorCode: DWORD;
begin
  ErrorCode := GetLastError;
  Result := Format('Erreur %d: %s', [ErrorCode, SysErrorMessage(ErrorCode)]);
end;

function TNamedPipeClient.Connect(TimeoutMS: DWORD): Boolean;
begin
  Result := False;

  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    WriteLn('D√©j√† connect√©');
    Exit(True);
  end;

  // Attente que le pipe soit disponible
  if not WaitNamedPipe(PChar(FPipeName), TimeoutMS) then
  begin
    WriteLn('Le pipe n''est pas disponible: ', GetLastErrorMessage);
    Exit;
  end;

  // Connexion au pipe
  FPipeHandle := CreateFile(
    PChar(FPipeName),
    GENERIC_READ or GENERIC_WRITE,
    0,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  if FPipeHandle = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur connexion: ', GetLastErrorMessage);
    Exit;
  end;

  // Configuration en mode message
  var Mode: DWORD := PIPE_READMODE_MESSAGE or PIPE_WAIT;
  if not SetNamedPipeHandleState(FPipeHandle, @Mode, nil, nil) then
    WriteLn('Avertissement: Impossible de configurer le mode');

  FConnected := True;
  Result := True;
end;

function TNamedPipeClient.ReadMessage(out Message: string; TimeoutMS: DWORD): Boolean;
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Success: Boolean;
  Mode: DWORD;
begin
  Result := False;
  Message := '';

  if not FConnected then
  begin
    WriteLn('Non connect√©');
    Exit;
  end;

  // Configuration du timeout
  if TimeoutMS <> INFINITE then
  begin
    Mode := PIPE_READMODE_MESSAGE or PIPE_WAIT;
    SetNamedPipeHandleState(FPipeHandle, @Mode, nil, @TimeoutMS);
  end;

  FillChar(Buffer, SizeOf(Buffer), 0);
  Success := ReadFile(FPipeHandle, Buffer, SizeOf(Buffer), BytesRead, nil);

  if Success then
  begin
    if BytesRead > 0 then
    begin
      Message := Buffer;
      Result := True;
    end;
  end
  else
    WriteLn('Erreur lecture: ', GetLastErrorMessage);
end;

function TNamedPipeClient.WriteMessage(const Message: string): Boolean;
var
  BytesWritten: DWORD;
begin
  Result := False;

  if not FConnected then
  begin
    WriteLn('Non connect√©');
    Exit;
  end;

  Result := WriteFile(
    FPipeHandle,
    PChar(Message),
    Length(Message),
    BytesWritten,
    nil
  );

  if not Result then
    WriteLn('Erreur √©criture: ', GetLastErrorMessage)
  else
    FlushFileBuffers(FPipeHandle);
end;

procedure TNamedPipeClient.Disconnect;
begin
  if FPipeHandle <> INVALID_HANDLE_VALUE then
  begin
    if FConnected then
      FlushFileBuffers(FPipeHandle);

    CloseHandle(FPipeHandle);
    FPipeHandle := INVALID_HANDLE_VALUE;
    FConnected := False;
  end;
end;

end.
```

### Utilisation de la classe robuste

```pascal
program TestRobustPipe;

{$mode objfpc}{$H+}

uses
  SysUtils, RobustNamedPipe;

procedure TestServer;
var
  Server: TNamedPipeServer;
  Message: string;
begin
  WriteLn('=== Test Serveur ===');

  Server := TNamedPipeServer.Create('\\.\pipe\TestPipe');
  try
    if Server.Start then
    begin
      WriteLn('Serveur d√©marr√©, en attente de client...');

      if Server.WaitForClient(30000) then // 30 secondes max
      begin
        WriteLn('Client connect√© !');

        // Lecture d'un message
        if Server.ReadMessage(Message, 5000) then
          WriteLn('Message re√ßu: ', Message);

        // Envoi d'une r√©ponse
        Server.WriteMessage('Bonjour du serveur !');

        Sleep(1000);
        Server.Disconnect;
      end
      else
        WriteLn('Timeout: aucun client connect√©');
    end;

  finally
    Server.Free;
  end;
end;

procedure TestClient;
var
  Client: TNamedPipeClient;
  Message: string;
begin
  WriteLn('=== Test Client ===');

  Client := TNamedPipeClient.Create('\\.\pipe\TestPipe');
  try
    if Client.Connect(5000) then
    begin
      WriteLn('Connect√© au serveur !');

      // Envoi d'un message
      Client.WriteMessage('Bonjour du client !');

      // Lecture de la r√©ponse
      if Client.ReadMessage(Message, 5000) then
        WriteLn('R√©ponse re√ßue: ', Message);

      Client.Disconnect;
    end
    else
      WriteLn('Impossible de se connecter');

  finally
    Client.Free;
  end;
end;

var
  Choice: string;

begin
  WriteLn('1. Serveur');
  WriteLn('2. Client');
  Write('Choix: ');
  ReadLn(Choice);

  if Choice = '1' then
    TestServer
  else if Choice = '2' then
    TestClient;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

## Cas d'usage avanc√©s

### 1. Service de monitoring

Un service qui collecte des m√©triques des applications :

```pascal
// Service (Serveur)
program MonitoringService;

type
  TMetric = record
    AppName: string;
    CPU: Double;
    Memory: Int64;
    Timestamp: TDateTime;
  end;

procedure HandleClient(hPipe: THandle);
var
  Buffer: array[0..4095] of Char;
  BytesRead: DWORD;
  Metric: TMetric;
begin
  // Lecture des m√©triques
  if ReadFile(hPipe, Buffer, SizeOf(Buffer), BytesRead, nil) then
  begin
    // Parser les donn√©es JSON ou binaires
    WriteLn('M√©triques re√ßues de: ', Metric.AppName);
    WriteLn('  CPU: ', Metric.CPU:0:2, '%');
    WriteLn('  Memory: ', Metric.Memory div (1024*1024), ' MB');

    // Stocker dans une base de donn√©es...
  end;
end;
```

### 2. Interface de contr√¥le d'application

Contr√¥ler une application via un pipe :

```pascal
// Application contr√¥lable
program ControllableApp;

type
  TCommand = (cmdStart, cmdStop, cmdPause, cmdStatus, cmdQuit);

procedure ProcessCommand(const Cmd: string);
begin
  if Cmd = 'START' then
    StartProcess
  else if Cmd = 'STOP' then
    StopProcess
  else if Cmd = 'PAUSE' then
    PauseProcess
  else if Cmd = 'STATUS' then
    SendStatus
  else if Cmd = 'QUIT' then
    Application.Terminate;
end;

// Client de contr√¥le
program ControlClient;

var
  Client: TNamedPipeClient;

begin
  Client := TNamedPipeClient.Create('\\.\pipe\AppControl');
  try
    if Client.Connect then
    begin
      Client.WriteMessage('STATUS');

      var Status: string;
      if Client.ReadMessage(Status) then
        WriteLn('Status: ', Status);
    end;
  finally
    Client.Free;
  end;
end;
```

### 3. Logger centralis√©

Centraliser les logs de plusieurs applications :

```pascal
program CentralLogger;

uses
  Classes, SysUtils;

type
  TLogEntry = record
    AppName: string;
    Level: string;    // INFO, WARNING, ERROR
    Message: string;
    Timestamp: TDateTime;
  end;

procedure LogToFile(const Entry: TLogEntry);
var
  F: TextFile;
begin
  AssignFile(F, 'central.log');
  try
    if FileExists('central.log') then
      Append(F)
    else
      Rewrite(F);

    WriteLn(F, Format('[%s] [%s] [%s] %s',
      [FormatDateTime('yyyy-mm-dd hh:nn:ss', Entry.Timestamp),
       Entry.AppName,
       Entry.Level,
       Entry.Message]));

  finally
    CloseFile(F);
  end;
end;

procedure HandleLogClient(hPipe: THandle);
var
  Message: string;
  Entry: TLogEntry;
begin
  // Lecture du message de log
  if ReadMessage(hPipe, Message) then
  begin
    // Parser le message (JSON, XML, ou format custom)
    ParseLogEntry(Message, Entry);
    LogToFile(Entry);
  end;
end;
```

## D√©bogage avanc√©

### Outil de monitoring de pipes

```pascal
program PipeMonitor;

uses
  Windows, SysUtils;

type
  TPipeInfo = record
    Name: string;
    Instances: DWORD;
    InBufferSize: DWORD;
    OutBufferSize: DWORD;
  end;

procedure MonitorPipe(const PipeName: string);
var
  hPipe: THandle;
  Flags, OutBufSize, InBufSize, MaxInstances: DWORD;
  ClientCount: DWORD;
begin
  WriteLn('=== Monitoring: ', PipeName, ' ===');

  // Tentative de connexion pour obtenir des infos
  hPipe := CreateFile(
    PChar(PipeName),
    GENERIC_READ,
    FILE_SHARE_READ or FILE_SHARE_WRITE,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  if hPipe <> INVALID_HANDLE_VALUE then
  begin
    if GetNamedPipeInfo(hPipe, @Flags, @OutBufSize, @InBufSize, @MaxInstances) then
    begin
      WriteLn('Type: ', IfThen((Flags and PIPE_TYPE_MESSAGE) <> 0, 'Message', 'Byte'));
      WriteLn('Buffer sortie: ', OutBufSize, ' octets');
      WriteLn('Buffer entr√©e: ', InBufSize, ' octets');
      WriteLn('Instances max: ', MaxInstances);
    end;

    // Obtenir le nombre de clients
    if GetNamedPipeHandleState(hPipe, nil, @ClientCount, nil, nil, nil, 0) then
      WriteLn('Clients connect√©s: ', ClientCount);

    CloseHandle(hPipe);
  end
  else
    WriteLn('Impossible d''acc√©der au pipe');
end;

procedure ListAndMonitorAllPipes;
var
  FindData: TWin32FindData;
  hFind: THandle;
  PipeName: string;
begin
  WriteLn('=== Liste et monitoring de tous les pipes ===');
  WriteLn;

  hFind := FindFirstFile('\\.\pipe\*', FindData);

  if hFind <> INVALID_HANDLE_VALUE then
  begin
    repeat
      PipeName := '\\.\pipe\' + string(FindData.cFileName);
      MonitorPipe(PipeName);
      WriteLn;
    until not FindNextFile(hFind, FindData);

    Windows.FindClose(hFind);
  end;
end;

begin
  ListAndMonitorAllPipes;

  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

## Performance et benchmarks

### Test de performance

```pascal
program PipeBenchmark;

uses
  Windows, SysUtils, DateUtils;

procedure BenchmarkPipePerformance;
const
  MESSAGE_COUNT = 10000;
  MESSAGE_SIZE = 1024;
var
  Server: TNamedPipeServer;
  Client: TNamedPipeClient;
  i: Integer;
  StartTime, EndTime: TDateTime;
  Duration: Double;
  Message: string;
  Throughput: Double;
begin
  WriteLn('=== Benchmark Named Pipe ===');
  WriteLn('Messages: ', MESSAGE_COUNT);
  WriteLn('Taille message: ', MESSAGE_SIZE, ' octets');
  WriteLn;

  SetLength(Message, MESSAGE_SIZE);
  FillChar(Message[1], MESSAGE_SIZE, 'A');

  Server := TNamedPipeServer.Create('\\.\pipe\BenchPipe');
  Client := TNamedPipeClient.Create('\\.\pipe\BenchPipe');

  try
    // D√©marrage du serveur dans un thread...
    // (Code simplifi√© pour l'exemple)

    if Server.Start and Server.WaitForClient then
    begin
      if Client.Connect then
      begin
        WriteLn('D√©marrage du test...');
        StartTime := Now;

        for i := 1 to MESSAGE_COUNT do
        begin
          Client.WriteMessage(Message);

          var Received: string;
          Server.ReadMessage(Received);

          if (i mod 1000) = 0 then
            Write('.');
        end;

        EndTime := Now;
        Duration := MilliSecondsBetween(EndTime, StartTime) / 1000;

        WriteLn;
        WriteLn('Dur√©e: ', Duration:0:3, ' secondes');
        WriteLn('Messages/sec: ', (MESSAGE_COUNT / Duration):0:0);

        Throughput := (MESSAGE_COUNT * MESSAGE_SIZE) / (Duration * 1024 * 1024);
        WriteLn('D√©bit: ', Throughput:0:2, ' MB/s');
      end;
    end;

  finally
    Client.Free;
    Server.Free;
  end;
end;

begin
  BenchmarkPipePerformance;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

### R√©sultats typiques

Sur une machine Windows moderne :

```
Messages/sec: 50,000 - 100,000
D√©bit: 50 - 200 MB/s (selon taille des messages)
Latence: < 1 ms

Comparaison :
- Named Pipes (local): ‚ö°‚ö°‚ö°‚ö° (tr√®s rapide)
- TCP Sockets (local): ‚ö°‚ö°‚ö° (rapide)
- TCP Sockets (r√©seau): ‚ö°‚ö° (d√©pend du r√©seau)
```

## R√©sum√©

### Points cl√©s √† retenir

‚úÖ **Named Pipes Windows** sont excellents pour l'IPC locale  
‚úÖ **Support r√©seau** via `\\serveur\pipe\nom`  
‚úÖ **Deux modes** : Message (recommand√©) et Byte Stream  
‚úÖ **S√©curit√© int√©gr√©e** avec les ACL Windows  
‚úÖ **Multi-clients** avec `PIPE_UNLIMITED_INSTANCES`  
‚úÖ **Performance excellente** pour communication locale

### Quand utiliser les Named Pipes ?

**‚úÖ Utilisez Named Pipes pour :**
- Communication locale entre processus Windows
- Architecture client-serveur locale
- Services Windows et leurs clients
- Applications n√©cessitant s√©curit√© Windows
- Communication bidirectionnelle

**‚ùå Pr√©f√©rez d'autres solutions pour :**
- Communication cross-platform (utilisez TCP/UDP)
- Communication sur Internet (utilisez HTTP/REST)
- Tr√®s haute performance locale (utilisez Shared Memory)
- Communication Linux (utilisez Unix Domain Sockets)

### Comparaison rapide

| Besoin | Solution |
|--------|----------|
| IPC locale Windows | ‚úÖ Named Pipes |
| IPC cross-platform | TCP Sockets, HTTP |
| Maximum performance | Shared Memory |
| Communication r√©seau | TCP/UDP Sockets |
| APIs web | HTTP/REST |

## Ressources compl√©mentaires

### Documentation officielle Microsoft

- **Named Pipes** : https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes
- **CreateNamedPipe** : https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea
- **IPC Overview** : https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications

### Outils utiles

- **Process Explorer** (Sysinternals) : Voir les handles de pipes
- **PipeList** (Sysinternals) : Lister tous les pipes
- **Handle** (Sysinternals) : Trouver qui utilise un pipe

### Exemples de Named Pipes dans Windows

De nombreux composants Windows utilisent des Named Pipes :

```
\\.\pipe\InitShutdown          ‚Üí Shutdown system
\\.\pipe\lsass                 ‚Üí Local Security Authority
\\.\pipe\ntsvcs                ‚Üí Windows Services
\\.\pipe\sql\query             ‚Üí SQL Server
\\.\pipe\MSSQL$INSTANCE\sql\query ‚Üí SQL Server instance
```

Vous pouvez les voir avec :
```cmd
dir \\.\pipe\
```

---

Vous ma√Ætrisez maintenant les Named Pipes Windows ! Passons aux Unix Domain Sockets pour Linux dans la section suivante.

‚è≠Ô∏è [Unix Domain Sockets (Linux)](/10-programmation-reseau-avancee/08.2-unix-domain-sockets-linux.md)
