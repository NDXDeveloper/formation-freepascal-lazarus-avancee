üîù Retour au [Sommaire](/SOMMAIRE.md)

# 10.8.2 Unix Domain Sockets (Linux)

## Introduction

Les Unix Domain Sockets (UDS) sont un m√©canisme IPC (Inter-Process Communication) pour les syst√®mes Unix/Linux. Ils permettent √† des processus sur la m√™me machine de communiquer de mani√®re efficace en utilisant l'API des sockets, mais sans passer par la couche r√©seau TCP/IP.

Contrairement aux Named Pipes Windows, les Unix Domain Sockets :
- Utilisent le syst√®me de fichiers comme namespace
- Offrent une API similaire aux sockets r√©seau (TCP/IP)
- Sont plus rapides que les sockets TCP locaux
- Supportent les permissions Unix standard
- Peuvent transmettre des descripteurs de fichiers

## Qu'est-ce qu'un Unix Domain Socket ?

### Analogie

Imaginez une connexion t√©l√©phonique locale qui ne passe pas par le r√©seau t√©l√©phonique :

```
Process Serveur          Socket File            Process Client
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ         ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ /tmp/    ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ         ‚îÇ
  ‚îÇ Listen  ‚îÇ           ‚îÇ app.sock ‚îÇ             ‚îÇ Connect ‚îÇ
  ‚îÇ Accept  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂            ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  Send   ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚ñ≤                      ‚îÇ                        ‚îÇ
      ‚îÇ                      ‚îÇ                        ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Fichier sp√©cial dans /tmp ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Le socket est repr√©sent√© par un **fichier sp√©cial** dans le syst√®me de fichiers (par exemple : `/tmp/app.sock`).

### Caract√©ristiques

- **Local uniquement** : Communication sur la m√™me machine
- **API standard** : M√™me API que les sockets TCP/IP
- **Tr√®s rapide** : Pas de couche r√©seau, pas de checksum
- **Permissions Unix** : Contr√¥le d'acc√®s via chmod/chown
- **Deux types** :
  - **SOCK_STREAM** : Orient√© connexion (comme TCP)
  - **SOCK_DGRAM** : Sans connexion (comme UDP)

### Syntaxe du chemin

```
Exemples de chemins :
/tmp/app.sock            ‚Üí Socket temporaire
/var/run/myservice.sock  ‚Üí Socket de service
/home/user/.app.sock     ‚Üí Socket utilisateur
./local.sock             ‚Üí Socket relatif

Format d'adresse :  
struct sockaddr_un {
    sa_family_t sun_family;  // AF_UNIX
    char sun_path[108];      // Chemin du fichier
};
```

## Comparaison avec TCP Sockets

### Similitudes

```pascal
// TCP Socket (r√©seau)
Sock := fpSocket(AF_INET, SOCK_STREAM, 0);

// Unix Domain Socket (local)
Sock := fpSocket(AF_UNIX, SOCK_STREAM, 0);
//                ‚Üë Seule diff√©rence !
```

L'API est pratiquement identique :
- `fpSocket` : Cr√©er le socket
- `fpBind` : Lier √† une adresse
- `fpListen` : Mettre en √©coute
- `fpAccept` : Accepter une connexion
- `fpConnect` : Se connecter
- `fpSend` / `fpRecv` : Envoyer/Recevoir des donn√©es

### Diff√©rences cl√©s

| Aspect | TCP Sockets | Unix Domain Sockets |
|--------|-------------|---------------------|
| **Port√©e** | R√©seau (local ou Internet) | Local uniquement |
| **Adresse** | IP:Port (192.168.1.1:8080) | Chemin fichier (/tmp/app.sock) |
| **Performance** | ‚ö°‚ö°‚ö° | ‚ö°‚ö°‚ö°‚ö°‚ö° (2-3x plus rapide) |
| **S√©curit√©** | Firewall, filtres r√©seau | Permissions fichiers Unix |
| **Overhead** | Headers TCP/IP, checksum | Minimal |
| **Utilisation** | Communication r√©seau | IPC locale |

### Avantages des UDS

1. **Performance** : Pas de couche TCP/IP
2. **S√©curit√©** : Permissions fichiers Unix natives
3. **Simplicit√©** : API socket famili√®re
4. **Credentials** : R√©cup√©ration automatique du PID/UID du client
5. **File descriptor passing** : Transmission de descripteurs de fichiers

## Cr√©ation d'un Unix Domain Socket (Serveur)

### Serveur SOCK_STREAM (orient√© connexion)

```pascal
program UnixSocketServer;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, Sockets, SysUtils;

const
  SOCKET_PATH = '/tmp/myapp.sock';
  BUFFER_SIZE = 4096;

var
  ServerSocket, ClientSocket: Integer;
  ServerAddr, ClientAddr: TSockAddr;
  AddrLen: TSockLen;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead: ssize_t;

begin
  WriteLn('=== Serveur Unix Domain Socket ===');

  // 1. Supprimer le fichier socket s'il existe d√©j√†
  if FileExists(SOCKET_PATH) then
    DeleteFile(SOCKET_PATH);

  // 2. Cr√©ation du socket
  ServerSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);
  if ServerSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket : ', SocketError);
    Exit;
  end;

  WriteLn('Socket cr√©√©');

  // 3. Pr√©paration de l'adresse
  FillChar(ServerAddr, SizeOf(ServerAddr), 0);
  ServerAddr.sa_family := AF_UNIX;

  // Copie du chemin dans sun_path
  Move(SOCKET_PATH[1], ServerAddr.sa_data[0], Length(SOCKET_PATH));

  // 4. Liaison du socket au fichier
  if fpBind(ServerSocket, @ServerAddr, SizeOf(ServerAddr)) = -1 then
  begin
    WriteLn('Erreur bind : ', SocketError);
    fpClose(ServerSocket);
    Exit;
  end;

  WriteLn('Socket li√© √† : ', SOCKET_PATH);

  // 5. Configuration des permissions (optionnel)
  fpChmod(SOCKET_PATH, &666); // rw-rw-rw-

  // 6. Mise en √©coute
  if fpListen(ServerSocket, 5) = -1 then
  begin
    WriteLn('Erreur listen : ', SocketError);
    fpClose(ServerSocket);
    Exit;
  end;

  WriteLn('En √©coute...');
  WriteLn('Appuyez sur Ctrl+C pour arr√™ter');
  WriteLn;

  // 7. Boucle d'acceptation
  while True do
  begin
    AddrLen := SizeOf(ClientAddr);
    ClientSocket := fpAccept(ServerSocket, @ClientAddr, @AddrLen);

    if ClientSocket = -1 then
    begin
      WriteLn('Erreur accept : ', SocketError);
      Continue;
    end;

    WriteLn('Client connect√©');

    // 8. Lecture des donn√©es
    FillChar(Buffer, SizeOf(Buffer), 0);
    BytesRead := fpRecv(ClientSocket, @Buffer, SizeOf(Buffer), 0);

    if BytesRead > 0 then
    begin
      WriteLn('Message re√ßu : ', Buffer);

      // 9. Envoi d'une r√©ponse
      fpSend(ClientSocket, PChar('Message re√ßu par le serveur'),
             Length('Message re√ßu par le serveur'), 0);
    end;

    // 10. Fermeture de la connexion client
    fpClose(ClientSocket);
    WriteLn('Client d√©connect√©');
    WriteLn;
  end;

  // Nettoyage
  fpClose(ServerSocket);
  DeleteFile(SOCKET_PATH);
end.
```

## Client Unix Domain Socket

```pascal
program UnixSocketClient;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, Sockets, SysUtils;

const
  SOCKET_PATH = '/tmp/myapp.sock';
  BUFFER_SIZE = 4096;

var
  ClientSocket: Integer;
  ServerAddr: TSockAddr;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead: ssize_t;
  Message: string;

begin
  WriteLn('=== Client Unix Domain Socket ===');

  // 1. Cr√©ation du socket
  ClientSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);
  if ClientSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket : ', SocketError);
    Exit;
  end;

  WriteLn('Socket cr√©√©');

  // 2. Pr√©paration de l'adresse du serveur
  FillChar(ServerAddr, SizeOf(ServerAddr), 0);
  ServerAddr.sa_family := AF_UNIX;
  Move(SOCKET_PATH[1], ServerAddr.sa_data[0], Length(SOCKET_PATH));

  // 3. Connexion au serveur
  WriteLn('Connexion √† : ', SOCKET_PATH);

  if fpConnect(ClientSocket, @ServerAddr, SizeOf(ServerAddr)) = -1 then
  begin
    WriteLn('Erreur connexion : ', SocketError);
    WriteLn('Le serveur est-il d√©marr√© ?');
    fpClose(ClientSocket);
    Exit;
  end;

  WriteLn('Connect√© au serveur !');

  // 4. Envoi d'un message
  Message := 'Bonjour depuis le client !';
  fpSend(ClientSocket, PChar(Message), Length(Message), 0);
  WriteLn('Message envoy√© : ', Message);

  // 5. R√©ception de la r√©ponse
  FillChar(Buffer, SizeOf(Buffer), 0);
  BytesRead := fpRecv(ClientSocket, @Buffer, SizeOf(Buffer), 0);

  if BytesRead > 0 then
    WriteLn('R√©ponse re√ßue : ', Buffer);

  // 6. Fermeture
  fpClose(ClientSocket);
  WriteLn('Connexion ferm√©e');

  WriteLn;
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

### Test des programmes

```bash
# Terminal 1 : Compilation et lancement du serveur
fpc UnixSocketServer.pas
./UnixSocketServer

# Terminal 2 : Compilation et lancement du client
fpc UnixSocketClient.pas
./UnixSocketClient

# V√©rifier que le socket existe
ls -l /tmp/myapp.sock
# R√©sultat : srwxrwxrwx 1 user user 0 ... /tmp/myapp.sock
#            ‚Üë 's' indique un socket
```

## Socket DGRAM (mode datagramme)

Pour une communication sans connexion (comme UDP) :

### Serveur DGRAM

```pascal
program UnixSocketServerDGRAM;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, Sockets, SysUtils;

const
  SOCKET_PATH = '/tmp/myapp_dgram.sock';
  BUFFER_SIZE = 4096;

var
  ServerSocket: Integer;
  ServerAddr, ClientAddr: TSockAddr;
  AddrLen: TSockLen;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead: ssize_t;

begin
  WriteLn('=== Serveur DGRAM Unix Domain Socket ===');

  // Supprimer le fichier socket s'il existe
  if FileExists(SOCKET_PATH) then
    DeleteFile(SOCKET_PATH);

  // Cr√©ation du socket DGRAM
  ServerSocket := fpSocket(AF_UNIX, SOCK_DGRAM, 0);
  if ServerSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket');
    Exit;
  end;

  // Liaison
  FillChar(ServerAddr, SizeOf(ServerAddr), 0);
  ServerAddr.sa_family := AF_UNIX;
  Move(SOCKET_PATH[1], ServerAddr.sa_data[0], Length(SOCKET_PATH));

  if fpBind(ServerSocket, @ServerAddr, SizeOf(ServerAddr)) = -1 then
  begin
    WriteLn('Erreur bind : ', SocketError);
    fpClose(ServerSocket);
    Exit;
  end;

  WriteLn('En √©coute sur : ', SOCKET_PATH);
  WriteLn('Mode DGRAM (sans connexion)');
  WriteLn;

  // Pas besoin de Listen() ni Accept() en mode DGRAM

  while True do
  begin
    // R√©ception directe avec recvfrom
    AddrLen := SizeOf(ClientAddr);
    FillChar(Buffer, SizeOf(Buffer), 0);

    BytesRead := fpRecvFrom(ServerSocket, @Buffer, SizeOf(Buffer), 0,
                           @ClientAddr, @AddrLen);

    if BytesRead > 0 then
    begin
      WriteLn('Datagramme re√ßu : ', Buffer);

      // R√©ponse avec sendto
      fpSendTo(ServerSocket, PChar('R√©ponse du serveur'),
               Length('R√©ponse du serveur'), 0, @ClientAddr, AddrLen);
    end;
  end;

  fpClose(ServerSocket);
  DeleteFile(SOCKET_PATH);
end.
```

### Client DGRAM

```pascal
program UnixSocketClientDGRAM;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, Sockets, SysUtils;

const
  SERVER_PATH = '/tmp/myapp_dgram.sock';
  CLIENT_PATH = '/tmp/myapp_client.sock';
  BUFFER_SIZE = 4096;

var
  ClientSocket: Integer;
  ServerAddr, ClientAddr: TSockAddr;
  AddrLen: TSockLen;
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead: ssize_t;

begin
  WriteLn('=== Client DGRAM Unix Domain Socket ===');

  // Le client a aussi besoin d'un chemin pour recevoir les r√©ponses
  if FileExists(CLIENT_PATH) then
    DeleteFile(CLIENT_PATH);

  // Cr√©ation du socket
  ClientSocket := fpSocket(AF_UNIX, SOCK_DGRAM, 0);
  if ClientSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket');
    Exit;
  end;

  // Liaison du client (pour recevoir les r√©ponses)
  FillChar(ClientAddr, SizeOf(ClientAddr), 0);
  ClientAddr.sa_family := AF_UNIX;
  Move(CLIENT_PATH[1], ClientAddr.sa_data[0], Length(CLIENT_PATH));

  if fpBind(ClientSocket, @ClientAddr, SizeOf(ClientAddr)) = -1 then
  begin
    WriteLn('Erreur bind : ', SocketError);
    fpClose(ClientSocket);
    Exit;
  end;

  // Pr√©paration de l'adresse du serveur
  FillChar(ServerAddr, SizeOf(ServerAddr), 0);
  ServerAddr.sa_family := AF_UNIX;
  Move(SERVER_PATH[1], ServerAddr.sa_data[0], Length(SERVER_PATH));

  // Envoi d'un datagramme (pas de connexion)
  fpSendTo(ClientSocket, PChar('Bonjour en mode DGRAM !'),
           Length('Bonjour en mode DGRAM !'), 0,
           @ServerAddr, SizeOf(ServerAddr));

  WriteLn('Datagramme envoy√©');

  // R√©ception de la r√©ponse
  AddrLen := SizeOf(ServerAddr);
  FillChar(Buffer, SizeOf(Buffer), 0);

  BytesRead := fpRecvFrom(ClientSocket, @Buffer, SizeOf(Buffer), 0,
                         @ServerAddr, @AddrLen);

  if BytesRead > 0 then
    WriteLn('R√©ponse re√ßue : ', Buffer);

  // Nettoyage
  fpClose(ClientSocket);
  DeleteFile(CLIENT_PATH);

  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

## Serveur multi-clients avec threads

Pour g√©rer plusieurs clients simultan√©ment :

```pascal
program MultiClientUnixServer;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, Sockets, SysUtils, Classes, cthreads;

const
  SOCKET_PATH = '/tmp/multiclient.sock';
  BUFFER_SIZE = 4096;

type
  TClientThread = class(TThread)
  private
    FClientSocket: Integer;
    FClientID: Integer;
  protected
    procedure Execute; override;
  public
    constructor Create(AClientSocket, AClientID: Integer);
  end;

constructor TClientThread.Create(AClientSocket, AClientID: Integer);  
begin
  inherited Create(False);
  FreeOnTerminate := True;
  FClientSocket := AClientSocket;
  FClientID := AClientID;
end;

procedure TClientThread.Execute;  
var
  Buffer: array[0..BUFFER_SIZE-1] of Char;
  BytesRead: ssize_t;
  Response: string;
begin
  WriteLn('[Client ', FClientID, '] Thread d√©marr√©');

  try
    // Lecture du message
    FillChar(Buffer, SizeOf(Buffer), 0);
    BytesRead := fpRecv(FClientSocket, @Buffer, SizeOf(Buffer), 0);

    if BytesRead > 0 then
    begin
      WriteLn('[Client ', FClientID, '] Message : ', Buffer);

      // Traitement (simul√© par un sleep)
      Sleep(1000);

      // R√©ponse
      Response := Format('R√©ponse du serveur pour client %d', [FClientID]);
      fpSend(FClientSocket, PChar(Response), Length(Response), 0);

      WriteLn('[Client ', FClientID, '] R√©ponse envoy√©e');
    end;

  finally
    fpClose(FClientSocket);
    WriteLn('[Client ', FClientID, '] D√©connect√©');
  end;
end;

var
  ServerSocket, ClientSocket: Integer;
  ServerAddr, ClientAddr: TSockAddr;
  AddrLen: TSockLen;
  ClientCount: Integer;

begin
  WriteLn('=== Serveur Multi-Clients Unix Domain Socket ===');

  // Suppression et cr√©ation du socket
  if FileExists(SOCKET_PATH) then
    DeleteFile(SOCKET_PATH);

  ServerSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);
  if ServerSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket');
    Exit;
  end;

  // Bind et Listen
  FillChar(ServerAddr, SizeOf(ServerAddr), 0);
  ServerAddr.sa_family := AF_UNIX;
  Move(SOCKET_PATH[1], ServerAddr.sa_data[0], Length(SOCKET_PATH));

  if fpBind(ServerSocket, @ServerAddr, SizeOf(ServerAddr)) = -1 then
  begin
    WriteLn('Erreur bind');
    fpClose(ServerSocket);
    Exit;
  end;

  fpChmod(SOCKET_PATH, &666);

  if fpListen(ServerSocket, 10) = -1 then
  begin
    WriteLn('Erreur listen');
    fpClose(ServerSocket);
    Exit;
  end;

  WriteLn('En √©coute sur : ', SOCKET_PATH);
  WriteLn('Appuyez sur Ctrl+C pour arr√™ter');
  WriteLn;

  ClientCount := 0;

  // Boucle d'acceptation
  while True do
  begin
    AddrLen := SizeOf(ClientAddr);
    ClientSocket := fpAccept(ServerSocket, @ClientAddr, @AddrLen);

    if ClientSocket >= 0 then
    begin
      Inc(ClientCount);
      WriteLn('Nouveau client (ID: ', ClientCount, ')');

      // Cr√©ation d'un thread pour ce client
      TClientThread.Create(ClientSocket, ClientCount);
    end;
  end;

  fpClose(ServerSocket);
  DeleteFile(SOCKET_PATH);
end.
```

## R√©cup√©ration des credentials du client

Une fonctionnalit√© unique des Unix Domain Sockets :

```pascal
program ServerWithCredentials;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, Sockets, SysUtils, Linux;

type
  ucred = record
    pid: pid_t;
    uid: uid_t;
    gid: gid_t;
  end;

procedure GetPeerCredentials(Socket: Integer);  
var
  Cred: ucred;
  CredLen: TSockLen;
begin
  CredLen := SizeOf(ucred);

  if fpGetSockOpt(Socket, SOL_SOCKET, SO_PEERCRED, @Cred, @CredLen) = 0 then
  begin
    WriteLn('=== Informations du client ===');
    WriteLn('PID : ', Cred.pid);
    WriteLn('UID : ', Cred.uid);
    WriteLn('GID : ', Cred.gid);
    WriteLn;
  end
  else
    WriteLn('Impossible de r√©cup√©rer les credentials');
end;

const
  SOCKET_PATH = '/tmp/cred_server.sock';

var
  ServerSocket, ClientSocket: Integer;
  ServerAddr, ClientAddr: TSockAddr;
  AddrLen: TSockLen;

begin
  WriteLn('=== Serveur avec r√©cup√©ration des credentials ===');

  if FileExists(SOCKET_PATH) then
    DeleteFile(SOCKET_PATH);

  ServerSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);

  FillChar(ServerAddr, SizeOf(ServerAddr), 0);
  ServerAddr.sa_family := AF_UNIX;
  Move(SOCKET_PATH[1], ServerAddr.sa_data[0], Length(SOCKET_PATH));

  fpBind(ServerSocket, @ServerAddr, SizeOf(ServerAddr));
  fpListen(ServerSocket, 5);

  WriteLn('En √©coute...');
  WriteLn;

  while True do
  begin
    AddrLen := SizeOf(ClientAddr);
    ClientSocket := fpAccept(ServerSocket, @ClientAddr, @AddrLen);

    if ClientSocket >= 0 then
    begin
      WriteLn('Client connect√©');

      // R√©cup√©ration automatique du PID/UID/GID
      GetPeerCredentials(ClientSocket);

      fpClose(ClientSocket);
    end;
  end;

  fpClose(ServerSocket);
  DeleteFile(SOCKET_PATH);
end.
```

## Gestion des permissions

### Configuration des permissions du socket

```pascal
procedure CreateSecureSocket(const Path: string);  
var
  Sock: Integer;
  Addr: TSockAddr;
begin
  // Cr√©er le socket
  Sock := fpSocket(AF_UNIX, SOCK_STREAM, 0);

  // Bind
  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(Path[1], Addr.sa_data[0], Length(Path));
  fpBind(Sock, @Addr, SizeOf(Addr));

  // Permissions : lecture/√©criture pour propri√©taire uniquement
  fpChmod(Path, &600);  // rw-------

  // Ou pour un groupe sp√©cifique
  fpChmod(Path, &660);  // rw-rw----
  fpChown(Path, fpGetUID, fpGetGID);

  fpListen(Sock, 5);
end;
```

### V√©rification des permissions avant connexion

```pascal
function CanConnectToSocket(const Path: string): Boolean;  
var
  StatBuf: TStat;
begin
  Result := False;

  if not FileExists(Path) then
  begin
    WriteLn('Le socket n''existe pas');
    Exit;
  end;

  if fpStat(Path, StatBuf) = 0 then
  begin
    // V√©rifier que c'est bien un socket
    if not S_ISSOCK(StatBuf.st_mode) then
    begin
      WriteLn(Path, ' n''est pas un socket');
      Exit;
    end;

    // V√©rifier les permissions d'acc√®s
    if fpAccess(Path, R_OK or W_OK) = 0 then
      Result := True
    else
      WriteLn('Permissions insuffisantes sur ', Path);
  end;
end;

// Utilisation
if CanConnectToSocket('/tmp/myapp.sock') then
  WriteLn('Connexion possible')
else
  WriteLn('Connexion impossible');
```

## Socket abstrait (Linux sp√©cifique)

Linux supporte les "abstract sockets" qui n'existent pas dans le syst√®me de fichiers :

```pascal
program AbstractSocketExample;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, Sockets, SysUtils;

const
  // Le premier caract√®re est '\0' pour un abstract socket
  ABSTRACT_NAME = #0'myabstractsocket';

procedure CreateAbstractSocket;  
var
  Sock: Integer;
  Addr: TSockAddr;
begin
  Sock := fpSocket(AF_UNIX, SOCK_STREAM, 0);

  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;

  // Copie du nom (commence par \0)
  Move(ABSTRACT_NAME[1], Addr.sa_data[0], Length(ABSTRACT_NAME));

  if fpBind(Sock, @Addr, SizeOf(Addr.sa_family) + Length(ABSTRACT_NAME)) = 0 then
  begin
    WriteLn('Abstract socket cr√©√©');
    WriteLn('Nom: ', Copy(ABSTRACT_NAME, 2, Length(ABSTRACT_NAME)));
    WriteLn('Ce socket n''existe PAS dans le syst√®me de fichiers');

    fpListen(Sock, 5);

    // Le socket sera automatiquement supprim√© √† la fermeture
  end;
end;

begin
  CreateAbstractSocket;
  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

**Avantages des abstract sockets :**
- Pas de fichier √† supprimer
- Pas de probl√®me de permissions fichiers
- Pas de collision de noms dans `/tmp`
- Nettoyage automatique √† la fermeture

**Inconv√©nients :**
- Linux uniquement (pas portable sur BSD/macOS)
- Pas visible dans le syst√®me de fichiers

## Gestion des erreurs

### Erreurs courantes

```pascal
procedure HandleSocketError(ErrorCode: Integer);  
begin
  case ErrorCode of
    ESysENOENT:
      WriteLn('Le socket n''existe pas (ENOENT)');

    ESysECONNREFUSED:
      WriteLn('Connexion refus√©e (ECONNREFUSED)');

    ESysEACCES:
      WriteLn('Permission refus√©e (EACCES)');

    ESysEADDRINUSE:
      WriteLn('Adresse d√©j√† utilis√©e (EADDRINUSE)');

    ESysEPIPE:
      WriteLn('Broken pipe - connexion ferm√©e (EPIPE)');

    ESysECONNRESET:
      WriteLn('Connexion r√©initialis√©e (ECONNRESET)');

    ESysETIMEDOUT:
      WriteLn('Timeout (ETIMEDOUT)');
  else
    WriteLn('Erreur socket: ', ErrorCode, ' - ', StrError(ErrorCode));
  end;
end;

// Utilisation
if fpConnect(Sock, @Addr, SizeOf(Addr)) = -1 then
  HandleSocketError(fpGetErrno);
```

### Gestion robuste avec retry

```pascal
function ConnectWithRetry(Sock: Integer; const Path: string;
                         MaxRetries: Integer): Boolean;
var
  Addr: TSockAddr;
  Attempt: Integer;
begin
  Result := False;

  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(Path[1], Addr.sa_data[0], Length(Path));

  for Attempt := 1 to MaxRetries do
  begin
    if fpConnect(Sock, @Addr, SizeOf(Addr)) = 0 then
    begin
      Result := True;
      Exit;
    end;

    if Attempt < MaxRetries then
    begin
      WriteLn('Tentative ', Attempt, ' √©choul√©e, nouvelle tentative...');
      Sleep(1000 * Attempt); // Backoff exponentiel
    end;
  end;

  WriteLn('Impossible de se connecter apr√®s ', MaxRetries, ' tentatives');
end;
```

## Timeouts

### Configuration d'un timeout de r√©ception

```pascal
procedure SetReceiveTimeout(Sock: Integer; TimeoutSec: Integer);  
var
  TimeVal: TTimeVal;
begin
  TimeVal.tv_sec := TimeoutSec;
  TimeVal.tv_usec := 0;

  fpSetSockOpt(Sock, SOL_SOCKET, SO_RCVTIMEO, @TimeVal, SizeOf(TimeVal));
end;

// Utilisation
SetReceiveTimeout(ClientSocket, 5); // 5 secondes

BytesRead := fpRecv(ClientSocket, @Buffer, SizeOf(Buffer), 0);  
if BytesRead = -1 then  
begin
  if fpGetErrno = ESysEAGAIN then
    WriteLn('Timeout de r√©ception')
  else
    WriteLn('Erreur : ', StrError(fpGetErrno));
end;
```

### Timeout d'envoi

```pascal
procedure SetSendTimeout(Sock: Integer; TimeoutSec: Integer);  
var
  TimeVal: TTimeVal;
begin
  TimeVal.tv_sec := TimeoutSec;
  TimeVal.tv_usec := 0;

  fpSetSockOpt(Sock, SOL_SOCKET, SO_SNDTIMEO, @TimeVal, SizeOf(TimeVal));
end;
```

### Timeout de connexion avec select

```pascal
function ConnectWithTimeout(Sock: Integer; const Path: string;
                           TimeoutSec: Integer): Boolean;
var
  Addr: TSockAddr;
  Flags: Integer;
  ReadFDs: TFDSet;
  TimeVal: TTimeVal;
  Res: Integer;
begin
  Result := False;

  // 1. Mettre le socket en mode non-bloquant
  Flags := fpFcntl(Sock, F_GETFL, 0);
  fpFcntl(Sock, F_SETFL, Flags or O_NONBLOCK);

  // 2. Pr√©parer l'adresse
  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(Path[1], Addr.sa_data[0], Length(Path));

  // 3. Tentative de connexion
  if fpConnect(Sock, @Addr, SizeOf(Addr)) = 0 then
  begin
    // Connexion imm√©diate (rare pour Unix sockets)
    Result := True;
    Exit;
  end;

  // 4. Si EINPROGRESS, attendre avec select
  if fpGetErrno = ESysEINPROGRESS then
  begin
    fpFD_ZERO(ReadFDs);
    fpFD_SET(Sock, ReadFDs);

    TimeVal.tv_sec := TimeoutSec;
    TimeVal.tv_usec := 0;

    Res := fpSelect(Sock + 1, nil, @ReadFDs, nil, @TimeVal);

    if Res > 0 then
    begin
      // V√©rifier si la connexion a r√©ussi
      var Error: Integer;
      var ErrorLen: TSockLen := SizeOf(Error);

      if fpGetSockOpt(Sock, SOL_SOCKET, SO_ERROR, @Error, @ErrorLen) = 0 then
      begin
        if Error = 0 then
          Result := True
        else
          WriteLn('Erreur de connexion: ', StrError(Error));
      end;
    end
    else if Res = 0 then
      WriteLn('Timeout de connexion')
    else
      WriteLn('Erreur select: ', StrError(fpGetErrno));
  end;

  // 5. Remettre le socket en mode bloquant
  fpFcntl(Sock, F_SETFL, Flags);
end;
```

## Classe wrapper robuste

Cr√©ons une classe pour simplifier l'utilisation :

```pascal
unit UnixDomainSocket;

{$mode objfpc}{$H+}

interface

uses
  BaseUnix, Unix, Sockets, SysUtils, Classes;

type
  TUnixSocketServer = class
  private
    FSocketPath: string;
    FServerSocket: Integer;
    FConnected: Boolean;
    function GetLastErrorMessage: string;
  public
    constructor Create(const ASocketPath: string);
    destructor Destroy; override;
    function Start(Backlog: Integer = 5): Boolean;
    function WaitForClient: Integer; // Retourne le socket client
    procedure Stop;
    property Connected: Boolean read FConnected;
    property SocketPath: string read FSocketPath;
  end;

  TUnixSocketClient = class
  private
    FSocketPath: string;
    FClientSocket: Integer;
    FConnected: Boolean;
    function GetLastErrorMessage: string;
  public
    constructor Create(const ASocketPath: string);
    destructor Destroy; override;
    function Connect(TimeoutSec: Integer = 5): Boolean;
    function Send(const Data: string): Boolean;
    function Receive(out Data: string; MaxSize: Integer = 4096): Boolean;
    procedure Disconnect;
    property Connected: Boolean read FConnected;
  end;

implementation

{ TUnixSocketServer }

constructor TUnixSocketServer.Create(const ASocketPath: string);  
begin
  FSocketPath := ASocketPath;
  FServerSocket := -1;
  FConnected := False;
end;

destructor TUnixSocketServer.Destroy;  
begin
  Stop;
  inherited;
end;

function TUnixSocketServer.GetLastErrorMessage: string;  
var
  ErrNo: Integer;
begin
  ErrNo := fpGetErrno;
  Result := Format('Erreur %d: %s', [ErrNo, StrError(ErrNo)]);
end;

function TUnixSocketServer.Start(Backlog: Integer): Boolean;  
var
  Addr: TSockAddr;
begin
  Result := False;

  if FServerSocket <> -1 then
  begin
    WriteLn('Le serveur est d√©j√† d√©marr√©');
    Exit;
  end;

  // Supprimer le fichier socket s'il existe
  if FileExists(FSocketPath) then
    DeleteFile(FSocketPath);

  // Cr√©ation du socket
  FServerSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);
  if FServerSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket: ', GetLastErrorMessage);
    Exit;
  end;

  // Bind
  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(FSocketPath[1], Addr.sa_data[0], Length(FSocketPath));

  if fpBind(FServerSocket, @Addr, SizeOf(Addr)) = -1 then
  begin
    WriteLn('Erreur bind: ', GetLastErrorMessage);
    fpClose(FServerSocket);
    FServerSocket := -1;
    Exit;
  end;

  // Permissions par d√©faut (lecture/√©criture pour tous)
  fpChmod(FSocketPath, &666);

  // Listen
  if fpListen(FServerSocket, Backlog) = -1 then
  begin
    WriteLn('Erreur listen: ', GetLastErrorMessage);
    fpClose(FServerSocket);
    FServerSocket := -1;
    DeleteFile(FSocketPath);
    Exit;
  end;

  FConnected := True;
  Result := True;
end;

function TUnixSocketServer.WaitForClient: Integer;  
var
  ClientAddr: TSockAddr;
  AddrLen: TSockLen;
begin
  Result := -1;

  if FServerSocket = -1 then
  begin
    WriteLn('Le serveur n''est pas d√©marr√©');
    Exit;
  end;

  AddrLen := SizeOf(ClientAddr);
  Result := fpAccept(FServerSocket, @ClientAddr, @AddrLen);

  if Result = -1 then
    WriteLn('Erreur accept: ', GetLastErrorMessage);
end;

procedure TUnixSocketServer.Stop;  
begin
  if FServerSocket <> -1 then
  begin
    fpClose(FServerSocket);
    FServerSocket := -1;
    FConnected := False;

    if FileExists(FSocketPath) then
      DeleteFile(FSocketPath);
  end;
end;

{ TUnixSocketClient }

constructor TUnixSocketClient.Create(const ASocketPath: string);  
begin
  FSocketPath := ASocketPath;
  FClientSocket := -1;
  FConnected := False;
end;

destructor TUnixSocketClient.Destroy;  
begin
  Disconnect;
  inherited;
end;

function TUnixSocketClient.GetLastErrorMessage: string;  
var
  ErrNo: Integer;
begin
  ErrNo := fpGetErrno;
  Result := Format('Erreur %d: %s', [ErrNo, StrError(ErrNo)]);
end;

function TUnixSocketClient.Connect(TimeoutSec: Integer): Boolean;  
var
  Addr: TSockAddr;
  TimeVal: TTimeVal;
begin
  Result := False;

  if FClientSocket <> -1 then
  begin
    WriteLn('D√©j√† connect√©');
    Exit(True);
  end;

  // V√©rifier que le socket existe
  if not FileExists(FSocketPath) then
  begin
    WriteLn('Le socket n''existe pas: ', FSocketPath);
    Exit;
  end;

  // Cr√©ation du socket
  FClientSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);
  if FClientSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket: ', GetLastErrorMessage);
    Exit;
  end;

  // Configuration du timeout
  if TimeoutSec > 0 then
  begin
    TimeVal.tv_sec := TimeoutSec;
    TimeVal.tv_usec := 0;
    fpSetSockOpt(FClientSocket, SOL_SOCKET, SO_RCVTIMEO, @TimeVal, SizeOf(TimeVal));
    fpSetSockOpt(FClientSocket, SOL_SOCKET, SO_SNDTIMEO, @TimeVal, SizeOf(TimeVal));
  end;

  // Connexion
  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(FSocketPath[1], Addr.sa_data[0], Length(FSocketPath));

  if fpConnect(FClientSocket, @Addr, SizeOf(Addr)) = -1 then
  begin
    WriteLn('Erreur connexion: ', GetLastErrorMessage);
    fpClose(FClientSocket);
    FClientSocket := -1;
    Exit;
  end;

  FConnected := True;
  Result := True;
end;

function TUnixSocketClient.Send(const Data: string): Boolean;  
var
  BytesSent: ssize_t;
begin
  Result := False;

  if not FConnected then
  begin
    WriteLn('Non connect√©');
    Exit;
  end;

  BytesSent := fpSend(FClientSocket, PChar(Data), Length(Data), 0);

  if BytesSent = -1 then
    WriteLn('Erreur envoi: ', GetLastErrorMessage)
  else
    Result := True;
end;

function TUnixSocketClient.Receive(out Data: string; MaxSize: Integer): Boolean;  
var
  Buffer: PChar;
  BytesRead: ssize_t;
begin
  Result := False;
  Data := '';

  if not FConnected then
  begin
    WriteLn('Non connect√©');
    Exit;
  end;

  GetMem(Buffer, MaxSize);
  try
    FillChar(Buffer^, MaxSize, 0);
    BytesRead := fpRecv(FClientSocket, Buffer, MaxSize, 0);

    if BytesRead = -1 then
    begin
      if fpGetErrno = ESysEAGAIN then
        WriteLn('Timeout de r√©ception')
      else
        WriteLn('Erreur r√©ception: ', GetLastErrorMessage);
    end
    else if BytesRead = 0 then
      WriteLn('Connexion ferm√©e par le serveur')
    else
    begin
      SetLength(Data, BytesRead);
      Move(Buffer^, Data[1], BytesRead);
      Result := True;
    end;

  finally
    FreeMem(Buffer);
  end;
end;

procedure TUnixSocketClient.Disconnect;  
begin
  if FClientSocket <> -1 then
  begin
    fpClose(FClientSocket);
    FClientSocket := -1;
    FConnected := False;
  end;
end;

end.
```

### Utilisation de la classe wrapper

```pascal
program TestUnixSocketWrapper;

{$mode objfpc}{$H+}

uses
  SysUtils, UnixDomainSocket;

procedure TestServer;  
var
  Server: TUnixSocketServer;
  ClientSock: Integer;
  Buffer: array[0..4095] of Char;
  BytesRead: ssize_t;
begin
  WriteLn('=== Test Serveur ===');

  Server := TUnixSocketServer.Create('/tmp/testwrapper.sock');
  try
    if Server.Start then
    begin
      WriteLn('Serveur d√©marr√©');
      WriteLn('En attente de client...');

      ClientSock := Server.WaitForClient;
      if ClientSock >= 0 then
      begin
        WriteLn('Client connect√©');

        // Lecture
        FillChar(Buffer, SizeOf(Buffer), 0);
        BytesRead := fpRecv(ClientSock, @Buffer, SizeOf(Buffer), 0);

        if BytesRead > 0 then
        begin
          WriteLn('Message: ', Buffer);

          // R√©ponse
          fpSend(ClientSock, PChar('Bonjour du serveur !'),
                 Length('Bonjour du serveur !'), 0);
        end;

        fpClose(ClientSock);
      end;
    end;

  finally
    Server.Free;
  end;
end;

procedure TestClient;  
var
  Client: TUnixSocketClient;
  Response: string;
begin
  WriteLn('=== Test Client ===');

  Client := TUnixSocketClient.Create('/tmp/testwrapper.sock');
  try
    if Client.Connect(5) then
    begin
      WriteLn('Connect√©');

      // Envoi
      Client.Send('Bonjour du client !');

      // R√©ception
      if Client.Receive(Response) then
        WriteLn('R√©ponse: ', Response);

      Client.Disconnect;
    end;

  finally
    Client.Free;
  end;
end;

var
  Choice: string;

begin
  WriteLn('1. Serveur');
  WriteLn('2. Client');
  Write('Choix: ');
  ReadLn(Choice);
  WriteLn;

  if Choice = '1' then
    TestServer
  else if Choice = '2' then
    TestClient;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

## Cas d'usage avanc√©s

### 1. Service de base de donn√©es locale

```pascal
program LocalDBService;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes, fpjson, jsonparser, UnixDomainSocket;

type
  TCommand = (cmdGet, cmdSet, cmdDelete, cmdList);

  TLocalDB = class
  private
    FData: TStringList;
  public
    constructor Create;
    destructor Destroy; override;
    function Get(const Key: string): string;
    procedure SetValue(const Key, Value: string);
    function Delete(const Key: string): Boolean;
    function List: TStringList;
  end;

constructor TLocalDB.Create;  
begin
  FData := TStringList.Create;
  FData.NameValueSeparator := '=';
end;

destructor TLocalDB.Destroy;  
begin
  FData.Free;
  inherited;
end;

function TLocalDB.Get(const Key: string): string;  
begin
  Result := FData.Values[Key];
end;

procedure TLocalDB.SetValue(const Key, Value: string);  
begin
  FData.Values[Key] := Value;
end;

function TLocalDB.Delete(const Key: string): Boolean;  
var
  Index: Integer;
begin
  Index := FData.IndexOfName(Key);
  Result := Index >= 0;
  if Result then
    FData.Delete(Index);
end;

function TLocalDB.List: TStringList;  
begin
  Result := TStringList.Create;
  Result.Assign(FData);
end;

procedure HandleClient(ClientSocket: Integer; DB: TLocalDB);  
var
  Buffer: array[0..4095] of Char;
  BytesRead: ssize_t;
  Request, Response: TJSONObject;
  JSONData: TJSONData;
  Cmd, Key, Value: string;
begin
  // Lecture de la requ√™te JSON
  FillChar(Buffer, SizeOf(Buffer), 0);
  BytesRead := fpRecv(ClientSocket, @Buffer, SizeOf(Buffer), 0);

  if BytesRead > 0 then
  begin
    try
      JSONData := GetJSON(Buffer);
      if JSONData is TJSONObject then
      begin
        Request := TJSONObject(JSONData);
        Response := TJSONObject.Create;

        try
          Cmd := Request.Get('command', '');
          Key := Request.Get('key', '');

          if Cmd = 'GET' then
          begin
            Value := DB.Get(Key);
            Response.Add('success', True);
            Response.Add('value', Value);
          end
          else if Cmd = 'SET' then
          begin
            Value := Request.Get('value', '');
            DB.SetValue(Key, Value);
            Response.Add('success', True);
          end
          else if Cmd = 'DELETE' then
          begin
            Response.Add('success', DB.Delete(Key));
          end
          else if Cmd = 'LIST' then
          begin
            var List := DB.List;
            try
              Response.Add('success', True);
              Response.Add('count', List.Count);
              Response.Add('keys', List.Text);
            finally
              List.Free;
            end;
          end
          else
          begin
            Response.Add('success', False);
            Response.Add('error', 'Unknown command');
          end;

          // Envoi de la r√©ponse
          var ResponseStr := Response.AsJSON;
          fpSend(ClientSocket, PChar(ResponseStr), Length(ResponseStr), 0);

        finally
          Response.Free;
        end;
      end;

    except
      on E: Exception do
        WriteLn('Erreur traitement: ', E.Message);
    end;
  end;
end;

var
  Server: TUnixSocketServer;
  DB: TLocalDB;
  ClientSocket: Integer;

begin
  WriteLn('=== Service de base de donn√©es locale ===');

  DB := TLocalDB.Create;
  Server := TUnixSocketServer.Create('/tmp/localdb.sock');

  try
    if Server.Start then
    begin
      WriteLn('Service d√©marr√© sur /tmp/localdb.sock');
      WriteLn('En attente de connexions...');
      WriteLn;

      while True do
      begin
        ClientSocket := Server.WaitForClient;
        if ClientSocket >= 0 then
        begin
          HandleClient(ClientSocket, DB);
          fpClose(ClientSocket);
        end;
      end;
    end;

  finally
    Server.Free;
    DB.Free;
  end;
end.
```

### 2. Syst√®me de logs centralis√©

```pascal
program CentralizedLogger;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes, UnixDomainSocket;

type
  TLogLevel = (llDebug, llInfo, llWarning, llError);

procedure LogToFile(const AppName, Level, Message: string);  
var
  F: TextFile;
  LogFile: string;
begin
  LogFile := '/var/log/myapp.log';

  AssignFile(F, LogFile);
  try
    if FileExists(LogFile) then
      Append(F)
    else
      Rewrite(F);

    WriteLn(F, Format('[%s] [%s] [%s] %s',
      [FormatDateTime('yyyy-mm-dd hh:nn:ss', Now),
       AppName,
       Level,
       Message]));

  finally
    CloseFile(F);
  end;
end;

procedure HandleLogClient(ClientSocket: Integer);  
var
  Buffer: array[0..4095] of Char;
  BytesRead: ssize_t;
  Parts: TStringList;
begin
  FillChar(Buffer, SizeOf(Buffer), 0);
  BytesRead := fpRecv(ClientSocket, @Buffer, SizeOf(Buffer), 0);

  if BytesRead > 0 then
  begin
    Parts := TStringList.Create;
    try
      Parts.Delimiter := '|';
      Parts.DelimitedText := Buffer;

      if Parts.Count >= 3 then
      begin
        LogToFile(Parts[0], Parts[1], Parts[2]);
        fpSend(ClientSocket, PChar('OK'), 2, 0);
      end;

    finally
      Parts.Free;
    end;
  end;
end;

var
  Server: TUnixSocketServer;
  ClientSocket: Integer;

begin
  WriteLn('=== Logger centralis√© ===');

  Server := TUnixSocketServer.Create('/tmp/logger.sock');
  try
    if Server.Start then
    begin
      WriteLn('Logger d√©marr√©');
      fpChmod('/tmp/logger.sock', &666); // Accessible √† tous

      while True do
      begin
        ClientSocket := Server.WaitForClient;
        if ClientSocket >= 0 then
        begin
          HandleLogClient(ClientSocket);
          fpClose(ClientSocket);
        end;
      end;
    end;

  finally
    Server.Free;
  end;
end.
```

### Client pour le logger

```pascal
procedure LogMessage(const AppName, Level, Message: string);  
var
  Client: TUnixSocketClient;
  LogData: string;
begin
  Client := TUnixSocketClient.Create('/tmp/logger.sock');
  try
    if Client.Connect(1) then
    begin
      LogData := Format('%s|%s|%s', [AppName, Level, Message]);
      Client.Send(LogData);
      Client.Disconnect;
    end;
  finally
    Client.Free;
  end;
end;

// Utilisation
LogMessage('MyApp', 'INFO', 'Application d√©marr√©e');  
LogMessage('MyApp', 'ERROR', 'Erreur de connexion');
```

## Performance et benchmarks

### Test de performance

```pascal
program UnixSocketBenchmark;

{$mode objfpc}{$H+}

uses
  SysUtils, DateUtils, BaseUnix, Unix, Sockets, cthreads;

const
  SOCKET_PATH = '/tmp/benchmark.sock';
  MESSAGE_COUNT = 100000;
  MESSAGE_SIZE = 1024;

type
  TServerThread = class(TThread)
  private
    FServerSocket: Integer;
  protected
    procedure Execute; override;
  public
    constructor Create;
  end;

constructor TServerThread.Create;  
begin
  inherited Create(False);
  FreeOnTerminate := True;

  // Cr√©ation du serveur
  if FileExists(SOCKET_PATH) then
    DeleteFile(SOCKET_PATH);

  FServerSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);

  var Addr: TSockAddr;
  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(SOCKET_PATH[1], Addr.sa_data[0], Length(SOCKET_PATH));

  fpBind(FServerSocket, @Addr, SizeOf(Addr));
  fpListen(FServerSocket, 1);
end;

procedure TServerThread.Execute;  
var
  ClientSocket: Integer;
  Buffer: array[0..MESSAGE_SIZE-1] of Char;
  BytesRead: ssize_t;
  Count: Integer;
begin
  var Addr: TSockAddr;
  var AddrLen: TSockLen := SizeOf(Addr);

  ClientSocket := fpAccept(FServerSocket, @Addr, @AddrLen);

  Count := 0;
  while Count < MESSAGE_COUNT do
  begin
    BytesRead := fpRecv(ClientSocket, @Buffer, SizeOf(Buffer), 0);
    if BytesRead > 0 then
      Inc(Count);
  end;

  fpClose(ClientSocket);
  fpClose(FServerSocket);
  DeleteFile(SOCKET_PATH);
end;

procedure RunBenchmark;  
var
  ServerThread: TServerThread;
  ClientSocket: Integer;
  Addr: TSockAddr;
  Message: string;
  i: Integer;
  StartTime, EndTime: TDateTime;
  Duration: Double;
  Throughput: Double;
begin
  WriteLn('=== Benchmark Unix Domain Socket ===');
  WriteLn('Messages: ', MESSAGE_COUNT);
  WriteLn('Taille: ', MESSAGE_SIZE, ' octets');
  WriteLn;

  // Pr√©paration du message
  SetLength(Message, MESSAGE_SIZE);
  FillChar(Message[1], MESSAGE_SIZE, 'A');

  // D√©marrage du serveur
  ServerThread := TServerThread.Create;
  Sleep(100); // Attendre que le serveur soit pr√™t

  // Client
  ClientSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);

  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(SOCKET_PATH[1], Addr.sa_data[0], Length(SOCKET_PATH));

  if fpConnect(ClientSocket, @Addr, SizeOf(Addr)) = 0 then
  begin
    WriteLn('D√©marrage du test...');
    StartTime := Now;

    for i := 1 to MESSAGE_COUNT do
    begin
      fpSend(ClientSocket, PChar(Message), Length(Message), 0);

      if (i mod 10000) = 0 then
        Write('.');
    end;

    EndTime := Now;
    Duration := MilliSecondsBetween(EndTime, StartTime) / 1000;

    WriteLn;
    WriteLn('Dur√©e: ', Duration:0:3, ' secondes');
    WriteLn('Messages/sec: ', (MESSAGE_COUNT / Duration):0:0);

    Throughput := (MESSAGE_COUNT * MESSAGE_SIZE) / (Duration * 1024 * 1024);
    WriteLn('D√©bit: ', Throughput:0:2, ' MB/s');

    fpClose(ClientSocket);
  end;

  ServerThread.WaitFor;
end;

begin
  RunBenchmark;
  WriteLn;
  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

### R√©sultats typiques

Sur un syst√®me Linux moderne :

```
Messages/sec: 200,000 - 500,000  
D√©bit: 200 - 1000 MB/s (selon CPU et taille des messages)  
Latence: < 0.5 ms

Comparaison :
- Unix Domain Sockets: ‚ö°‚ö°‚ö°‚ö°‚ö° (tr√®s rapide)
- TCP localhost (127.0.0.1): ‚ö°‚ö°‚ö°‚ö° (rapide)
- Named Pipes Windows: ‚ö°‚ö°‚ö°‚ö° (rapide)
- TCP r√©seau: ‚ö°‚ö° (d√©pend du r√©seau)
```

## Outils de d√©bogage

### Lister les sockets Unix

```bash
# Lister tous les sockets Unix
netstat -lx

# Ou avec ss (plus moderne)
ss -xl

# Lister les fichiers socket dans /tmp
find /tmp -type s

# Voir les processus utilisant un socket
lsof /tmp/myapp.sock

# Permissions d'un socket
ls -l /tmp/myapp.sock
```

### Outil de monitoring

```pascal
program SocketMonitor;

{$mode objfpc}{$H+}

uses
  SysUtils, Unix, BaseUnix;

procedure MonitorSocket(const SocketPath: string);  
var
  StatBuf: TStat;
  Permissions: string;
begin
  WriteLn('=== Monitoring: ', SocketPath, ' ===');

  if not FileExists(SocketPath) then
  begin
    WriteLn('Le socket n''existe pas');
    Exit;
  end;

  if fpStat(SocketPath, StatBuf) = 0 then
  begin
    // V√©rifier le type
    if S_ISSOCK(StatBuf.st_mode) then
      WriteLn('Type: Socket Unix Domain')
    else
    begin
      WriteLn('Ce n''est pas un socket !');
      Exit;
    end;

    // Permissions
    Permissions := '';

    // User
    if (StatBuf.st_mode and S_IRUSR) <> 0 then Permissions := Permissions + 'r' else Permissions := Permissions + '-';
    if (StatBuf.st_mode and S_IWUSR) <> 0 then Permissions := Permissions + 'w' else Permissions := Permissions + '-';
    if (StatBuf.st_mode and S_IXUSR) <> 0 then Permissions := Permissions + 'x' else Permissions := Permissions + '-';

    // Group
    if (StatBuf.st_mode and S_IRGRP) <> 0 then Permissions := Permissions + 'r' else Permissions := Permissions + '-';
    if (StatBuf.st_mode and S_IWGRP) <> 0 then Permissions := Permissions + 'w' else Permissions := Permissions + '-';
    if (StatBuf.st_mode and S_IXGRP) <> 0 then Permissions := Permissions + 'x' else Permissions := Permissions + '-';

    // Others
    if (StatBuf.st_mode and S_IROTH) <> 0 then Permissions := Permissions + 'r' else Permissions := Permissions + '-';
    if (StatBuf.st_mode and S_IWOTH) <> 0 then Permissions := Permissions + 'w' else Permissions := Permissions + '-';
    if (StatBuf.st_mode and S_IXOTH) <> 0 then Permissions := Permissions + 'x' else Permissions := Permissions + '-';

    WriteLn('Permissions: ', Permissions);
    WriteLn('Propri√©taire UID: ', StatBuf.st_uid);
    WriteLn('Groupe GID: ', StatBuf.st_gid);
    WriteLn('Derni√®re modification: ',
            FormatDateTime('yyyy-mm-dd hh:nn:ss', FileDateToDateTime(StatBuf.st_mtime)));
  end
  else
    WriteLn('Impossible de lire les informations du socket');
end;

procedure ListUnixSockets(const Directory: string);  
var
  SearchRec: TSearchRec;
  FullPath: string;
begin
  WriteLn('=== Sockets dans ', Directory, ' ===');
  WriteLn;

  if FindFirst(Directory + '/*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      FullPath := Directory + '/' + SearchRec.Name;

      var StatBuf: TStat;
      if (fpStat(FullPath, StatBuf) = 0) and S_ISSOCK(StatBuf.st_mode) then
      begin
        WriteLn('Socket trouv√©: ', SearchRec.Name);
        MonitorSocket(FullPath);
        WriteLn;
      end;

    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end;
end;

begin
  if ParamCount > 0 then
    MonitorSocket(ParamStr(1))
  else
  begin
    WriteLn('Recherche de sockets Unix...');
    WriteLn;
    ListUnixSockets('/tmp');
    ListUnixSockets('/var/run');
  end;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

### Test de connectivit√©

```pascal
program SocketTester;

{$mode objfpc}{$H+}

uses
  SysUtils, BaseUnix, Unix, Sockets;

function TestSocketConnection(const SocketPath: string): Boolean;  
var
  Sock: Integer;
  Addr: TSockAddr;
begin
  Result := False;

  WriteLn('Test de connexion √†: ', SocketPath);

  // V√©rifier l'existence
  if not FileExists(SocketPath) then
  begin
    WriteLn('  ‚ùå Le socket n''existe pas');
    Exit;
  end;

  WriteLn('  ‚úì Le fichier socket existe');

  // V√©rifier les permissions
  if fpAccess(SocketPath, R_OK or W_OK) <> 0 then
  begin
    WriteLn('  ‚ùå Permissions insuffisantes');
    Exit;
  end;

  WriteLn('  ‚úì Permissions OK');

  // Tentative de connexion
  Sock := fpSocket(AF_UNIX, SOCK_STREAM, 0);
  if Sock = -1 then
  begin
    WriteLn('  ‚ùå Impossible de cr√©er le socket');
    Exit;
  end;

  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(SocketPath[1], Addr.sa_data[0], Length(SocketPath));

  if fpConnect(Sock, @Addr, SizeOf(Addr)) = 0 then
  begin
    WriteLn('  ‚úì Connexion r√©ussie');
    fpClose(Sock);
    Result := True;
  end
  else
  begin
    WriteLn('  ‚ùå Connexion √©chou√©e: ', StrError(fpGetErrno));
    fpClose(Sock);
  end;
end;

begin
  if ParamCount = 0 then
  begin
    WriteLn('Usage: SocketTester <chemin_socket>');
    WriteLn('Exemple: SocketTester /tmp/myapp.sock');
  end
  else
    TestSocketConnection(ParamStr(1));

  WriteLn;
  WriteLn('Appuyez sur Entr√©e...');
  ReadLn;
end.
```

## Bonnes pratiques

### Checklist pour Unix Domain Sockets

‚úÖ **Cr√©ation**
- Supprimer le fichier socket avant de cr√©er le serveur
- D√©finir des permissions appropri√©es avec `fpChmod`
- Utiliser un chemin dans `/tmp` pour les tests, `/var/run` pour les services
- Choisir SOCK_STREAM (TCP-like) ou SOCK_DGRAM (UDP-like) selon les besoins

‚úÖ **S√©curit√©**
- Configurer les permissions (600, 660, 666) selon le niveau de s√©curit√©
- V√©rifier l'existence et les permissions avant la connexion
- Utiliser `SO_PEERCRED` pour authentifier le client
- Ne pas utiliser `/tmp` en production (risques de s√©curit√©)

‚úÖ **Communication**
- Toujours v√©rifier les valeurs de retour
- Impl√©menter des timeouts
- G√©rer les d√©connexions brutales (`EPIPE`, `ECONNRESET`)
- Utiliser des buffers de taille appropri√©e

‚úÖ **Nettoyage**
- Toujours fermer les sockets avec `fpClose`
- Supprimer le fichier socket √† l'arr√™t du serveur
- G√©rer proprement les signaux (SIGTERM, SIGINT)

‚úÖ **Performance**
- Utiliser des threads pour les serveurs multi-clients
- Augmenter les tailles de buffer si n√©cessaire
- Consid√©rer les abstract sockets pour √©viter les I/O fichiers

### Exemple de code production-ready

```pascal
unit ProductionUnixSocket;

{$mode objfpc}{$H+}

interface

uses
  BaseUnix, Unix, Sockets, SysUtils, Classes;

type
  TUnixSocketServer = class
  private
    FSocketPath: string;
    FServerSocket: Integer;
    FRunning: Boolean;
    FOnClientConnect: TNotifyEvent;
    procedure SignalHandler(Sig: Integer);
    procedure Cleanup;
  public
    constructor Create(const ASocketPath: string);
    destructor Destroy; override;
    function Start: Boolean;
    procedure Stop;
    procedure Run;
    property Running: Boolean read FRunning;
    property OnClientConnect: TNotifyEvent read FOnClientConnect write FOnClientConnect;
  end;

implementation

var
  GlobalServer: TUnixSocketServer = nil;

procedure SignalHandlerProc(Sig: Integer); cdecl;  
begin
  if Assigned(GlobalServer) then
    GlobalServer.SignalHandler(Sig);
end;

constructor TUnixSocketServer.Create(const ASocketPath: string);  
begin
  FSocketPath := ASocketPath;
  FServerSocket := -1;
  FRunning := False;
  GlobalServer := Self;

  // Installation des handlers de signaux
  fpSignal(SIGTERM, @SignalHandlerProc);
  fpSignal(SIGINT, @SignalHandlerProc);
end;

destructor TUnixSocketServer.Destroy;  
begin
  Stop;
  GlobalServer := nil;
  inherited;
end;

procedure TUnixSocketServer.SignalHandler(Sig: Integer);  
begin
  WriteLn;
  WriteLn('Signal re√ßu (', Sig, '), arr√™t gracieux...');
  FRunning := False;
end;

procedure TUnixSocketServer.Cleanup;  
begin
  if FServerSocket <> -1 then
  begin
    fpClose(FServerSocket);
    FServerSocket := -1;
  end;

  if FileExists(FSocketPath) then
    DeleteFile(FSocketPath);
end;

function TUnixSocketServer.Start: Boolean;  
var
  Addr: TSockAddr;
  OptVal: Integer;
begin
  Result := False;

  // Nettoyage pr√©alable
  if FileExists(FSocketPath) then
  begin
    WriteLn('Suppression de l''ancien socket...');
    DeleteFile(FSocketPath);
  end;

  // Cr√©ation
  FServerSocket := fpSocket(AF_UNIX, SOCK_STREAM, 0);
  if FServerSocket = -1 then
  begin
    WriteLn('Erreur cr√©ation socket: ', StrError(fpGetErrno));
    Exit;
  end;

  // Option SO_REUSEADDR
  OptVal := 1;
  fpSetSockOpt(FServerSocket, SOL_SOCKET, SO_REUSEADDR, @OptVal, SizeOf(OptVal));

  // Bind
  FillChar(Addr, SizeOf(Addr), 0);
  Addr.sa_family := AF_UNIX;
  Move(FSocketPath[1], Addr.sa_data[0], Length(FSocketPath));

  if fpBind(FServerSocket, @Addr, SizeOf(Addr)) = -1 then
  begin
    WriteLn('Erreur bind: ', StrError(fpGetErrno));
    Cleanup;
    Exit;
  end;

  // Permissions
  fpChmod(FSocketPath, &660); // rw-rw----

  // Listen
  if fpListen(FServerSocket, 10) = -1 then
  begin
    WriteLn('Erreur listen: ', StrError(fpGetErrno));
    Cleanup;
    Exit;
  end;

  FRunning := True;
  Result := True;

  WriteLn('Serveur d√©marr√© sur: ', FSocketPath);
end;

procedure TUnixSocketServer.Stop;  
begin
  FRunning := False;
  Cleanup;
  WriteLn('Serveur arr√™t√©');
end;

procedure TUnixSocketServer.Run;  
var
  ClientSocket: Integer;
  ClientAddr: TSockAddr;
  AddrLen: TSockLen;
begin
  if not FRunning then
  begin
    WriteLn('Le serveur n''est pas d√©marr√©');
    Exit;
  end;

  WriteLn('En attente de connexions...');

  while FRunning do
  begin
    AddrLen := SizeOf(ClientAddr);
    ClientSocket := fpAccept(FServerSocket, @ClientAddr, @AddrLen);

    if ClientSocket >= 0 then
    begin
      if Assigned(FOnClientConnect) then
        FOnClientConnect(Self);

      // Traiter le client ici ou dans un thread
      fpClose(ClientSocket);
    end
    else if FRunning then
    begin
      WriteLn('Erreur accept: ', StrError(fpGetErrno));
    end;
  end;
end;

end.
```

## Comparaison finale

### Unix Domain Sockets vs autres IPC

| Crit√®re | UDS | Named Pipes | TCP Sockets | Shared Memory |
|---------|-----|-------------|-------------|---------------|
| **Performance** | ‚ö°‚ö°‚ö°‚ö°‚ö° | ‚ö°‚ö°‚ö°‚ö° | ‚ö°‚ö°‚ö° | ‚ö°‚ö°‚ö°‚ö°‚ö° |
| **Portabilit√©** | Unix/Linux | Windows | Universel | Limit√© |
| **Complexit√©** | ‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **S√©curit√©** | Permissions Unix | ACL Windows | Firewall | Complexe |
| **API** | Sockets standard | Sp√©cifique Windows | Sockets standard | Sp√©cifique |
| **R√©seau** | ‚ùå Local | ‚ö†Ô∏è Possible | ‚úÖ Oui | ‚ùå Local |

### Quand utiliser Unix Domain Sockets ?

**‚úÖ Utilisez UDS pour :**
- Communication locale sur Linux/Unix
- Services syst√®me (daemons)
- Architecture microservices locale
- Remplacement de TCP localhost (plus rapide)
- Applications n√©cessitant les permissions Unix
- Base de donn√©es locales (PostgreSQL, MySQL)

**‚ùå Pr√©f√©rez d'autres solutions pour :**
- Communication r√©seau (utilisez TCP/UDP)
- Windows uniquement (utilisez Named Pipes)
- Cross-platform (utilisez TCP localhost)
- Performance extr√™me (utilisez Shared Memory)
- Communication simple (utilisez des fichiers ou pipes)

## Exemples r√©els d'utilisation

De nombreux logiciels Linux utilisent les Unix Domain Sockets :

```bash
# Docker
/var/run/docker.sock

# PostgreSQL
/var/run/postgresql/.s.PGSQL.5432

# MySQL
/var/run/mysqld/mysqld.sock

# X11
/tmp/.X11-unix/X0

# systemd
/run/systemd/notify

# D-Bus
/var/run/dbus/system_bus_socket
```

Vous pouvez les voir avec :
```bash
find /var/run -type s  
find /tmp -type s
```

## R√©sum√©

### Points cl√©s √† retenir

‚úÖ **Unix Domain Sockets** sont excellents pour l'IPC locale sur Linux  
‚úÖ **API standard** compatible avec les sockets TCP/IP  
‚úÖ **Tr√®s performant** : 2-3x plus rapide que TCP localhost  
‚úÖ **S√©curit√©** via permissions Unix (chmod/chown)  
‚úÖ **Deux types** : SOCK_STREAM (TCP-like) et SOCK_DGRAM (UDP-like)  
‚úÖ **Credentials** : R√©cup√©ration automatique du PID/UID/GID  
‚úÖ **Abstract sockets** : Linux uniquement, pas de fichier

### Checklist rapide

```
‚ñ° Supprimer l'ancien socket avant de cr√©er le serveur
‚ñ° Configurer les permissions appropri√©es
‚ñ° G√©rer les erreurs (errno)
‚ñ° Impl√©menter des timeouts
‚ñ° Nettoyer √† l'arr√™t (supprimer le fichier)
‚ñ° G√©rer les signaux (SIGTERM, SIGINT)
‚ñ° Utiliser des threads pour multi-clients
‚ñ° Tester avec les outils syst√®me (netstat, ss, lsof)
```

## Ressources compl√©mentaires

### Documentation

- **man pages Linux** :
  ```bash
  man 7 unix        # Unix domain sockets
  man 2 socket      # Cr√©ation de socket
  man 2 bind        # Liaison
  man 2 listen      # √âcoute
  man 2 accept      # Acceptation
  man 2 connect     # Connexion
  ```

- **Livres** :
  - *Unix Network Programming* - W. Richard Stevens
  - *The Linux Programming Interface* - Michael Kerrisk

### Outils syst√®me utiles

```bash
# Voir les connexions Unix sockets
netstat -lx  
ss -lx

# Processus utilisant un socket
lsof /tmp/app.sock  
fuser /tmp/app.sock

# Test de connexion
nc -U /tmp/app.sock  
socat - UNIX-CONNECT:/tmp/app.sock

# Monitoring
watch -n 1 'netstat -lx | grep myapp'
```

### D√©bogage avanc√©

```bash
# Tracer les appels syst√®me
strace -e trace=socket,bind,listen,accept,connect ./myserver

# Capturer le trafic (ne fonctionne pas pour UDS)
# Utilisez plut√¥t strace

# Voir les sockets ouverts par processus
ls -l /proc/$(pidof myserver)/fd/
```

## Conclusion

Les Unix Domain Sockets sont un m√©canisme IPC puissant et performant pour Linux. Leur API famili√®re (identique aux sockets TCP/IP) les rend faciles √† utiliser, tout en offrant des performances bien sup√©rieures pour la communication locale.

**Avantages principaux :**
- üöÄ **Performance** : Le plus rapide apr√®s Shared Memory
- üîí **S√©curit√©** : Permissions Unix natives
- üí° **Simplicit√©** : API socket standard
- üõ†Ô∏è **Flexibilit√©** : STREAM ou DGRAM selon les besoins
- üîç **Debugging** : Outils syst√®me standards

**Cas d'usage id√©aux :**
- Services syst√®me et daemons
- Communication entre microservices locaux
- Bases de donn√©es locales
- Serveurs d'applications
- Communication inter-processus haute performance

Avec FreePascal, vous avez tout ce qu'il faut pour cr√©er des applications IPC robustes et performantes sur Linux en utilisant les Unix Domain Sockets. L'API bas niveau offre un contr√¥le total, tandis que des wrappers orient√©s objet simplifient le d√©veloppement pour des cas d'usage courants.

---

**Prochaine section** : 10.8.3 Shared Memory - Pour des performances encore plus √©lev√©es !

‚è≠Ô∏è [mORMot pour services REST/SOA](/10-programmation-reseau-avancee/09-mormot-services-rest-soa.md)
