üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.6.2 /dev/tty* Linux

## Introduction

Sur Linux et les syst√®mes Unix en g√©n√©ral, les ports s√©rie sont repr√©sent√©s comme des **fichiers sp√©ciaux** dans le r√©pertoire `/dev`. Cette approche "tout est fichier" est une philosophie fondamentale d'Unix qui simplifie grandement la programmation : on manipule un port s√©rie exactement comme un fichier texte, avec les fonctions `open()`, `read()`, `write()` et `close()`.

Cette section vous apprendra √† manipuler ces ports s√©rie depuis FreePascal sur Linux/Ubuntu, en utilisant l'API POSIX et la biblioth√®que `termios`.

## Architecture des ports s√©rie sous Linux

### Nomenclature des fichiers de p√©riph√©riques

Contrairement √† Windows avec ses `COMx`, Linux utilise des noms descriptifs dans `/dev` :

**Ports s√©rie natifs (anciens PC) :**
```
/dev/ttyS0    ‚Üí Premier port s√©rie (√©quivalent COM1)
/dev/ttyS1    ‚Üí Deuxi√®me port s√©rie (√©quivalent COM2)
/dev/ttyS2    ‚Üí Troisi√®me port s√©rie (√©quivalent COM3)
...
```

**Adaptateurs USB-Serial (les plus courants) :**
```
/dev/ttyUSB0  ‚Üí Premier adaptateur USB-Serial (FTDI, Prolific, CH340)
/dev/ttyUSB1  ‚Üí Deuxi√®me adaptateur USB-Serial
/dev/ttyUSB2  ‚Üí Troisi√®me adaptateur
...
```

**Ports CDC ACM (Arduino, STM32 avec USB natif) :**
```
/dev/ttyACM0  ‚Üí Premier port CDC (Communication Device Class)
/dev/ttyACM1  ‚Üí Deuxi√®me port CDC
...
```

**Autres types moins courants :**
```
/dev/ttyAMA0  ‚Üí UART Raspberry Pi (GPIO)
/dev/rfcomm0  ‚Üí Bluetooth Serial Port Profile
/dev/pts/0    ‚Üí Pseudo-terminal (√©mulation s√©rie)
```

### Lister les ports s√©rie disponibles

**M√©thode 1 : Commande ls**
```bash
# Tous les p√©riph√©riques tty
ls /dev/tty*

# Uniquement USB-Serial
ls /dev/ttyUSB*

# Uniquement CDC
ls /dev/ttyACM*
```

**M√©thode 2 : Commande dmesg (messages kernel)**
```bash
# Voir derniers p√©riph√©riques d√©tect√©s
dmesg | grep tty

# Exemple de sortie :
# [12345.678] usb 1-1.2: FTDI USB Serial Device converter now attached to ttyUSB0
# [12346.123] cdc_acm 1-1.3:1.0: ttyACM0: USB ACM device
```

**M√©thode 3 : Fichier /proc**
```bash
# Voir ports s√©rie enregistr√©s
cat /proc/tty/driver/serial

# Sortie exemple :
# serinfo:1.0 driver revision:
# 0: uart:16550A port:000003F8 irq:4 tx:0 rx:0
# 1: uart:unknown port:000002F8 irq:3
```

**M√©thode 4 : Commande udevadm**
```bash
# Informations d√©taill√©es sur un p√©riph√©rique
udevadm info --name=/dev/ttyUSB0

# Lister tous les p√©riph√©riques s√©rie
udevadm info --export-db | grep -A 10 ttyUSB
```

### Permissions et groupes

**Probl√®me fr√©quent :** L'utilisateur n'a pas les droits d'acc√®s au port s√©rie.

**V√©rifier les permissions :**
```bash
ls -l /dev/ttyUSB0

# Sortie typique :
# crw-rw---- 1 root dialout 188, 0 Oct  4 14:30 /dev/ttyUSB0
#            ‚îÇ     ‚îÇ
#            ‚îÇ     ‚îî‚îÄ Groupe : dialout
#            ‚îî‚îÄ Propri√©taire : root
```

**Signification :**
- `c` : character device (p√©riph√©rique caract√®re)
- `rw-rw----` : lecture/√©criture pour owner et group, rien pour others
- Groupe `dialout` : groupe par d√©faut pour ports s√©rie sur Ubuntu/Debian
- Groupe `uucp` : sur certaines distributions (Arch, Fedora)

**Solutions pour acc√©der au port :**

**Solution 1 : Ajouter utilisateur au groupe dialout (RECOMMAND√â)**
```bash
# Ajouter votre utilisateur au groupe
sudo usermod -a -G dialout $USER

# V√©rifier l'appartenance
groups

# IMPORTANT : Se d√©connecter/reconnecter pour que √ßa prenne effet
# Ou utiliser : newgrp dialout (temporaire pour session actuelle)
```

**Solution 2 : Changer permissions temporairement (non recommand√©)**
```bash
# Donner acc√®s √† tous (temporaire, perdu au reboot)
sudo chmod 666 /dev/ttyUSB0

# Donner acc√®s √† votre utilisateur seulement
sudo chown $USER /dev/ttyUSB0
```

**Solution 3 : Ex√©cuter en root (D√âCONSEILL√â pour d√©veloppement)**
```bash
sudo ./mon_programme
```

### udev : gestion automatique des p√©riph√©riques

udev est le gestionnaire de p√©riph√©riques dynamiques de Linux. Il d√©tecte automatiquement les branchements/d√©branchements.

**Cr√©er une r√®gle udev personnalis√©e :**

```bash
# Cr√©er fichier de r√®gle
sudo nano /etc/udev/rules.d/99-usb-serial.rules
```

**Contenu du fichier :**
```
# Donner acc√®s √† tous les USB-Serial pour le groupe plugdev
KERNEL=="ttyUSB[0-9]*", MODE="0666", GROUP="plugdev"
KERNEL=="ttyACM[0-9]*", MODE="0666", GROUP="plugdev"

# R√®gle sp√©cifique pour un p√©riph√©rique FTDI particulier
SUBSYSTEM=="tty", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001", SYMLINK+="arduino_uno"

# Arduino Uno (CH340)
SUBSYSTEM=="tty", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", SYMLINK+="arduino_ch340"
```

**Recharger les r√®gles :**
```bash
sudo udevadm control --reload-rules
sudo udevadm trigger
```

**Avantage :** Cr√©er des liens symboliques stables (`/dev/arduino_uno` au lieu de `/dev/ttyUSB0` qui peut changer).

## API POSIX pour ports s√©rie

### Philosophie "tout est fichier"

Sur Linux, un port s√©rie est manipul√© comme un fichier :

```pascal
var
  fd: Integer;  // File descriptor

begin
  // Ouvrir
  fd := fpOpen('/dev/ttyUSB0', O_RDWR or O_NOCTTY);

  // Lire
  fpRead(fd, buffer, size);

  // √âcrire
  fpWrite(fd, data, size);

  // Fermer
  fpClose(fd);
end.
```

### Fonctions principales

| Fonction | Usage |
|----------|-------|
| `fpOpen()` | Ouvrir le port |
| `fpClose()` | Fermer le port |
| `fpRead()` | Lire des donn√©es |
| `fpWrite()` | √âcrire des donn√©es |
| `tcgetattr()` | Lire configuration |
| `tcsetattr()` | Appliquer configuration |
| `tcflush()` | Vider les buffers |
| `tcdrain()` | Attendre fin d'√©mission |
| `cfsetispeed()` | D√©finir vitesse entr√©e |
| `cfsetospeed()` | D√©finir vitesse sortie |
| `fcntl()` | Contr√¥le fichier (flags) |
| `select()` | Attendre donn√©es (polling) |
| `ioctl()` | Contr√¥le signaux (DTR, RTS) |

### Structure termios

La configuration du port s√©rie se fait via la structure `termios` :

```pascal
type
  termios = record
    c_iflag: tcflag_t;   // Input flags
    c_oflag: tcflag_t;   // Output flags
    c_cflag: tcflag_t;   // Control flags
    c_lflag: tcflag_t;   // Local flags
    c_line: cc_t;        // Line discipline
    c_cc: array[0..NCCS-1] of cc_t;  // Control characters
    c_ispeed: speed_t;   // Input speed
    c_ospeed: speed_t;   // Output speed
  end;
```

**Principaux flags :**

**c_cflag (Control flags)** - Configuration mat√©rielle :
- `CBAUD` : Masque baud rate
- `B9600`, `B115200`, etc. : Vitesses
- `CS5`, `CS6`, `CS7`, `CS8` : Bits de donn√©es (5-8)
- `CSTOPB` : 2 bits de stop (sinon 1)
- `PARENB` : Activer parit√©
- `PARODD` : Parit√© impaire (sinon paire)
- `CREAD` : Activer r√©ception
- `CLOCAL` : Ignorer signaux modem (pas de hang-up)
- `CRTSCTS` : Flow control mat√©riel (RTS/CTS)

**c_iflag (Input flags)** - Traitement entr√©e :
- `IGNBRK` : Ignorer break
- `BRKINT` : Break g√©n√®re SIGINT
- `IGNPAR` : Ignorer erreurs parit√©
- `PARMRK` : Marquer erreurs parit√©
- `INPCK` : V√©rifier parit√©
- `ISTRIP` : Retirer 8√®me bit
- `IXON` : XON/XOFF en sortie
- `IXOFF` : XON/XOFF en entr√©e

**c_oflag (Output flags)** - Traitement sortie :
- `OPOST` : Post-traitement sortie
- `ONLCR` : Mapper NL ‚Üí CR-NL
- `OCRNL` : Mapper CR ‚Üí NL

**c_lflag (Local flags)** - Mode ligne :
- `ICANON` : Mode canonique (ligne par ligne)
- `ECHO` : Echo des caract√®res
- `ECHOE` : Echo erase
- `ISIG` : G√©n√©rer signaux (SIGINT, etc.)

## Ouverture d'un port s√©rie

### Fonction fpOpen

```pascal
uses
  BaseUnix, Unix, termio;

var
  fd: Integer;

begin
  // Ouvrir en lecture/√©criture, sans controlling terminal
  fd := fpOpen('/dev/ttyUSB0', O_RDWR or O_NOCTTY or O_NDELAY);

  if fd = -1 then
  begin
    WriteLn('Erreur ouverture: ', fpgeterrno);
    // Codes erreur courants :
    // EACCES (13) : Permission denied
    // ENOENT (2)  : No such file or directory
    // EBUSY (16)  : Device or resource busy
  end
  else
    WriteLn('Port ouvert, fd = ', fd);
end.
```

**Flags importants :**

- `O_RDWR` : Lecture et √©criture
- `O_RDONLY` : Lecture seule
- `O_WRONLY` : √âcriture seule
- `O_NOCTTY` : Ne pas devenir controlling terminal (important !)
- `O_NDELAY` / `O_NONBLOCK` : Mode non-bloquant (retour imm√©diat)
- `O_SYNC` : √âcriture synchrone (attend fin physique)

**Apr√®s ouverture, d√©sactiver mode non-bloquant si n√©cessaire :**

```pascal
// Passer en mode bloquant
fcntl(fd, F_SETFL, 0);

// Ou garder non-bloquant
// (rien √† faire)
```

### Gestion des erreurs

```pascal
procedure OuvrirPortSerie(const DeviceName: string; var fd: Integer);
var
  ErrNo: Integer;
begin
  fd := fpOpen(DeviceName, O_RDWR or O_NOCTTY);

  if fd = -1 then
  begin
    ErrNo := fpgeterrno;

    case ErrNo of
      ESysEACCES:
        WriteLn('ERREUR: Permission refus√©e');
        WriteLn('Solution: sudo usermod -a -G dialout $USER');

      ESysENOENT:
        WriteLn('ERREUR: P√©riph√©rique ', DeviceName, ' inexistant');
        WriteLn('V√©rifier: ls /dev/tty*');

      ESysEBUSY:
        WriteLn('ERREUR: Port occup√© par une autre application');
        WriteLn('Fermer: minicom, screen, Arduino IDE, etc.');

      else
        WriteLn('ERREUR: Code ', ErrNo);
    end;
  end;
end;
```

## Configuration du port s√©rie

### Configuration de base (mode raw)

Pour communication s√©rie "raw" (binaire, sans traitement) :

```pascal
uses
  BaseUnix, termio;

procedure ConfigurerPortRaw(fd: Integer; BaudRate: speed_t);
var
  options: termios;
begin
  // R√©cup√©rer config actuelle
  tcgetattr(fd, @options);

  // === Mode RAW (pas de traitement) ===

  // D√©sactiver tous les flags de traitement
  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;

  // Control flags : 8N1, enable receiver, local mode
  options.c_cflag := CS8 or CREAD or CLOCAL;

  // D√©finir vitesse
  cfsetispeed(@options, BaudRate);
  cfsetospeed(@options, BaudRate);

  // Param√®tres de lecture : retour imm√©diat
  options.c_cc[VMIN] := 0;   // Minimum 0 caract√®re
  options.c_cc[VTIME] := 0;  // Timeout 0 (retour imm√©diat)

  // Appliquer imm√©diatement
  tcsetattr(fd, TCSANOW, @options);

  // Vider les buffers
  tcflush(fd, TCIOFLUSH);
end;
```

**Constantes de vitesse :**

```pascal
const
  B0      = 0;
  B50     = 1;
  B75     = 2;
  B110    = 3;
  B134    = 4;
  B150    = 5;
  B200    = 6;
  B300    = 7;
  B600    = 8;
  B1200   = 9;
  B1800   = 10;
  B2400   = 11;
  B4800   = 12;
  B9600   = 13;      // ‚Üê Le plus courant
  B19200  = 14;
  B38400  = 15;
  B57600  = 4097;
  B115200 = 4098;    // ‚Üê Tr√®s courant aussi
  B230400 = 4099;
  B460800 = 4100;
  B500000 = 4101;
  B576000 = 4102;
  B921600 = 4103;
  B1000000 = 4104;
  B1152000 = 4105;
  B1500000 = 4106;
  B2000000 = 4107;
  B2500000 = 4108;
  B3000000 = 4109;
  B3500000 = 4110;
  B4000000 = 4111;
```

### Configuration avec parit√©

```pascal
procedure ConfigurerPort8E1(fd: Integer);
var
  options: termios;
begin
  tcgetattr(fd, @options);

  // 8 bits, Even parity, 1 stop bit
  options.c_cflag := options.c_cflag and (not CSIZE);  // Effacer taille
  options.c_cflag := options.c_cflag or CS8;           // 8 bits
  options.c_cflag := options.c_cflag or PARENB;        // Activer parit√©
  options.c_cflag := options.c_cflag and (not PARODD); // Parit√© paire
  options.c_cflag := options.c_cflag and (not CSTOPB); // 1 stop bit

  tcsetattr(fd, TCSANOW, @options);
end;

procedure ConfigurerPort7O2(fd: Integer);
var
  options: termios;
begin
  tcgetattr(fd, @options);

  // 7 bits, Odd parity, 2 stop bits
  options.c_cflag := options.c_cflag and (not CSIZE);
  options.c_cflag := options.c_cflag or CS7;           // 7 bits
  options.c_cflag := options.c_cflag or PARENB;        // Activer parit√©
  options.c_cflag := options.c_cflag or PARODD;        // Parit√© impaire
  options.c_cflag := options.c_cflag or CSTOPB;        // 2 stop bits

  tcsetattr(fd, TCSANOW, @options);
end;
```

### Configuration VMIN et VTIME (timeouts)

Ces deux param√®tres contr√¥lent le comportement de `read()` :

**VMIN** : Nombre minimum de caract√®res √† lire
**VTIME** : Timeout en dixi√®mes de seconde

**Cas 1 : Lecture non-bloquante (retour imm√©diat)**
```pascal
options.c_cc[VMIN] := 0;
options.c_cc[VTIME] := 0;
// read() retourne imm√©diatement avec donn√©es disponibles ou 0
```

**Cas 2 : Lecture avec timeout**
```pascal
options.c_cc[VMIN] := 0;
options.c_cc[VTIME] := 10;  // 1 seconde
// read() attend max 1 seconde, retourne ce qui est disponible
```

**Cas 3 : Lecture bloquante (attente infinie)**
```pascal
options.c_cc[VMIN] := 1;
options.c_cc[VTIME] := 0;
// read() attend au moins 1 caract√®re, bloque ind√©finiment
```

**Cas 4 : Lecture avec timeout inter-caract√®res**
```pascal
options.c_cc[VMIN] := 0;
options.c_cc[VTIME] := 5;  // 0.5 seconde
// Timeout red√©marre apr√®s chaque caract√®re re√ßu
```

## Lecture de donn√©es

### Fonction fpRead

```pascal
uses
  BaseUnix;

var
  fd: Integer;
  Buffer: array[0..255] of Byte;
  BytesRead: TSsize;
  i: Integer;

begin
  // ... ouvrir et configurer le port ...

  // Lire jusqu'√† 256 octets
  BytesRead := fpRead(fd, Buffer, SizeOf(Buffer));

  if BytesRead > 0 then
  begin
    WriteLn('Re√ßu ', BytesRead, ' octets:');

    // Afficher en hexad√©cimal
    for i := 0 to BytesRead - 1 do
      Write(IntToHex(Buffer[i], 2), ' ');
    WriteLn;
  end
  else if BytesRead = 0 then
    WriteLn('Aucune donn√©e (timeout ou EOF)')
  else
    WriteLn('Erreur lecture: ', fpgeterrno);
end.
```

### Lecture ligne par ligne

```pascal
function LireLigne(fd: Integer): string;
var
  c: Char;
  BytesRead: TSsize;
  ligne: string;
begin
  Result := '';
  ligne := '';

  repeat
    BytesRead := fpRead(fd, c, 1);

    if BytesRead <= 0 then
      Break;

    if c = #10 then  // LF
      Break;

    if c <> #13 then  // Ignorer CR
      ligne := ligne + c;

  until False;

  Result := ligne;
end;

// Utilisation
var
  ligne: string;
begin
  ligne := LireLigne(fd);
  if ligne <> '' then
    WriteLn('Ligne re√ßue: ', ligne);
end.
```

### Lecture avec timeout via select()

Pour attendre avec timeout sans bloquer :

```pascal
uses
  BaseUnix, Unix;

function AttendreDonnees(fd: Integer; TimeoutMs: Integer): Boolean;
var
  rfds: TFDSet;
  tv: TTimeVal;
  retval: Integer;
begin
  Result := False;

  // Initialiser ensemble de descripteurs
  fpFD_ZERO(rfds);
  fpFD_SET(fd, rfds);

  // D√©finir timeout
  tv.tv_sec := TimeoutMs div 1000;
  tv.tv_usec := (TimeoutMs mod 1000) * 1000;

  // Attendre
  retval := fpSelect(fd + 1, @rfds, nil, nil, @tv);

  if retval > 0 then
    Result := True  // Donn√©es disponibles
  else if retval = 0 then
    Result := False // Timeout
  else
    WriteLn('Erreur select: ', fpgeterrno);
end;

// Utilisation
begin
  if AttendreDonnees(fd, 5000) then
  begin
    BytesRead := fpRead(fd, Buffer, SizeOf(Buffer));
    // ... traiter donn√©es ...
  end
  else
    WriteLn('Timeout: aucune donn√©e re√ßue en 5 secondes');
end.
```

## √âcriture de donn√©es

### Fonction fpWrite

```pascal
procedure EnvoyerTexte(fd: Integer; const texte: string);
var
  BytesWritten: TSsize;
  AnsiTexte: AnsiString;
begin
  AnsiTexte := AnsiString(texte);

  BytesWritten := fpWrite(fd, AnsiTexte[1], Length(AnsiTexte));

  if BytesWritten = Length(AnsiTexte) then
    WriteLn('Envoy√©: ', texte)
  else if BytesWritten > 0 then
    WriteLn('√âcriture partielle: ', BytesWritten, '/', Length(AnsiTexte))
  else
    WriteLn('Erreur √©criture: ', fpgeterrno);
end;

// Utilisation
EnvoyerTexte(fd, 'Hello Arduino'#10);
```

### Envoi de donn√©es binaires

```pascal
procedure EnvoyerDonnees(fd: Integer; const data: array of Byte; len: Integer);
var
  BytesWritten, total: TSsize;
  p: PByte;
begin
  total := 0;
  p := @data[0];

  // Boucle pour g√©rer √©criture partielle
  while total < len do
  begin
    BytesWritten := fpWrite(fd, p^, len - total);

    if BytesWritten <= 0 then
    begin
      WriteLn('Erreur √©criture');
      Break;
    end;

    Inc(total, BytesWritten);
    Inc(p, BytesWritten);
  end;

  if total = len then
    WriteLn('Envoy√© ', total, ' octets');
end;

// Utilisation
var
  commande: array[0..4] of Byte = ($AA, $55, $01, $02, $03);
begin
  EnvoyerDonnees(fd, commande, 5);
end.
```

### Attendre fin d'√©mission

```pascal
// Attendre que toutes les donn√©es soient physiquement envoy√©es
tcdrain(fd);
```

### Vider les buffers

```pascal
// Vider buffer r√©ception
tcflush(fd, TCIFLUSH);

// Vider buffer √©mission
tcflush(fd, TCOFLUSH);

// Vider les deux buffers
tcflush(fd, TCIOFLUSH);
```

## Contr√¥le des signaux (DTR, RTS)

### Fonctions ioctl

```pascal
uses
  BaseUnix, termio;

// Activer DTR
procedure ActiverDTR(fd: Integer);
var
  status: Integer;
begin
  fpioctl(fd, TIOCMGET, @status);
  status := status or TIOCM_DTR;
  fpioctl(fd, TIOCMSET, @status);
end;

// D√©sactiver DTR
procedure DesactiverDTR(fd: Integer);
var
  status: Integer;
begin
  fpioctl(fd, TIOCMGET, @status);
  status := status and (not TIOCM_DTR);
  fpioctl(fd, TIOCMSET, @status);
end;

// Activer RTS
procedure ActiverRTS(fd: Integer);
var
  status: Integer;
begin
  fpioctl(fd, TIOCMGET, @status);
  status := status or TIOCM_RTS;
  fpioctl(fd, TIOCMSET, @status);
end;

// D√©sactiver RTS
procedure DesactiverRTS(fd: Integer);
var
  status: Integer;
begin
  fpioctl(fd, TIOCMGET, @status);
  status := status and (not TIOCM_RTS);
  fpioctl(fd, TIOCMSET, @status);
end;

// Lire √©tat CTS
function CTSActif(fd: Integer): Boolean;
var
  status: Integer;
begin
  fpioctl(fd, TIOCMGET, @status);
  Result := (status and TIOCM_CTS) <> 0;
end;

// Lire √©tat DSR
function DSRActif(fd: Integer): Boolean;
var
  status: Integer;
begin
  fpioctl(fd, TIOCMGET, @status);
  Result := (status and TIOCM_DSR) <> 0;
end;
```

**Constantes de signaux :**
```pascal
const
  TIOCM_LE  = $001;  // Line Enable
  TIOCM_DTR = $002;  // Data Terminal Ready
  TIOCM_RTS = $004;  // Request To Send
  TIOCM_ST  = $008;  // Secondary TXD
  TIOCM_SR  = $010;  // Secondary RXD
  TIOCM_CTS = $020;  // Clear To Send
  TIOCM_CAR = $040;  // Carrier Detect
  TIOCM_RNG = $080;  // Ring
  TIOCM_DSR = $100;  // Data Set Ready
  TIOCM_CD  = TIOCM_CAR;
  TIOCM_RI  = TIOCM_RNG;
```

### Reset Arduino via DTR

```pascal
procedure ResetArduino(fd: Integer);
begin
  WriteLn('Reset Arduino...');

  // DTR haut
  ActiverDTR(fd);
  Sleep(100);

  // DTR bas ‚Üí reset
  DesactiverDTR(fd);
  Sleep(100);

  // DTR haut
  ActiverDTR(fd);

  WriteLn('Arduino red√©marr√©');
  Sleep(2000);  // Attendre boot Arduino
end;
```

## Cr√©ation d'une classe SerialPort

```pascal
unit UnitSerialPortLinux;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, BaseUnix, Unix, termio;

type
  TSerialPort = class
  private
    FFD: Integer;
    FDeviceName: string;
    FBaudRate: speed_t;
    FConnected: Boolean;
  public
    constructor Create(const DeviceName: string; BaudRate: speed_t = B9600);
    destructor Destroy; override;

    function Open: Boolean;
    procedure Close;

    function ReadData(var Buffer; Size: Integer): Integer;
    function WriteData(const Buffer; Size: Integer): Integer;

    function ReadString: string;
    procedure WriteString(const Data: string);

    function Available: Integer;
    procedure Flush;

    property Connected: Boolean read FConnected;
    property DeviceName: string read FDeviceName;
    property BaudRate: speed_t read FBaudRate;
  end;

implementation

constructor TSerialPort.Create(const DeviceName: string; BaudRate: speed_t);
begin
  inherited Create;

  FDeviceName := DeviceName;
  FBaudRate := BaudRate;
  FConnected := False;
  FFD := -1;
end;

destructor TSerialPort.Destroy;
begin
  Close;
  inherited Destroy;
end;

function TSerialPort.Open: Boolean;
var
  options: termios;
begin
  Result := False;

  if FConnected then
    Exit;

  // Ouvrir p√©riph√©rique
  FFD := fpOpen(FDeviceName, O_RDWR or O_NOCTTY);

  if FFD = -1 then
    Exit;

  // Configuration termios
  tcgetattr(FFD, @options);

  // Mode RAW
  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;

  // Vitesse
  cfsetispeed(@options, FBaudRate);
  cfsetospeed(@options, FBaudRate);

  // Lecture non-bloquante
  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 0;

  // Appliquer
  tcsetattr(FFD, TCSANOW, @options);

  // Vider buffers
  tcflush(FFD, TCIOFLUSH);

  FConnected := True;
  Result := True;
end;

procedure TSerialPort.Close;
begin
  if FConnected then
  begin
    fpClose(FFD);
    FFD := -1;
    FConnected := False;
  end;
end;

function TSerialPort.ReadData(var Buffer; Size: Integer): Integer;
begin
  Result := 0;

  if not FConnected then
    Exit;

  Result := fpRead(FFD, Buffer, Size);

  if Result < 0 then
    Result := 0;
end;

function TSerialPort.WriteData(const Buffer; Size: Integer): Integer;
begin
  Result := 0;

  if not FConnected then
    Exit;

  Result := fpWrite(FFD, Buffer, Size);

  if Result < 0 then
    Result := 0;
end;

function TSerialPort.ReadString: string;
var
  Buffer: array[0..255] of AnsiChar;
  BytesRead: Integer;
begin
  Result := '';

  BytesRead := ReadData(Buffer, SizeOf(Buffer) - 1);

  if BytesRead > 0 then
  begin
    Buffer[BytesRead] := #0;
    Result := string(Buffer);
  end;
end;

procedure TSerialPort.WriteString(const Data: string);
var
  AnsiData: AnsiString;
begin
  AnsiData := AnsiString(Data);
  WriteData(AnsiData[1], Length(AnsiData));
end;

function TSerialPort.Available: Integer;
var
  BytesAvail: Integer;
begin
  Result := 0;

  if not FConnected then
    Exit;

  if fpioctl(FFD, FIONREAD, @BytesAvail) = 0 then
    Result := BytesAvail;
end;

procedure TSerialPort.Flush;
begin
  if FConnected then
    tcflush(FFD, TCIOFLUSH);
end;

end.
```

## √ânum√©ration des ports s√©rie

### M√©thode 1 : Scanner /dev

```pascal
uses
  BaseUnix, Unix, SysUtils;

procedure ListerPortsSerie;
var
  SearchRec: TSearchRec;
  path: string;
begin
  WriteLn('Ports s√©rie disponibles:');
  WriteLn;

  // Chercher /dev/ttyUSB*
  WriteLn('Adaptateurs USB-Serial:');
  if FindFirst('/dev/ttyUSB*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      WriteLn('  ', SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end
  else
    WriteLn('  Aucun');

  WriteLn;

  // Chercher /dev/ttyACM*
  WriteLn('Ports CDC (Arduino, STM32):');
  if FindFirst('/dev/ttyACM*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      WriteLn('  ', SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end
  else
    WriteLn('  Aucun');

  WriteLn;

  // Chercher /dev/ttyS*
  WriteLn('Ports s√©rie natifs:');
  if FindFirst('/dev/ttyS*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      WriteLn('  ', SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end
  else
    WriteLn('  Aucun');
end;
```

### M√©thode 2 : Via /sys (plus d'informations)

```pascal
uses
  Process, Classes, SysUtils;

function ExecuterCommande(const cmd: string): TStringList;
var
  Process: TProcess;
  Output: TStringList;
  Buffer: string;
  BytesRead: Integer;
begin
  Result := TStringList.Create;
  Process := TProcess.Create(nil);

  try
    Process.Executable := '/bin/sh';
    Process.Parameters.Add('-c');
    Process.Parameters.Add(cmd);
    Process.Options := Process.Options + [poUsePipes, poWaitOnExit];
    Process.Execute;

    Output := TStringList.Create;
    try
      SetLength(Buffer, 1024);
      repeat
        BytesRead := Process.Output.Read(Buffer[1], Length(Buffer));
        if BytesRead > 0 then
          Output.Add(Copy(Buffer, 1, BytesRead));
      until BytesRead = 0;

      Result.Text := Output.Text;
    finally
      Output.Free;
    end;
  finally
    Process.Free;
  end;
end;

procedure ListerPortsAvecInfo;
var
  Lines: TStringList;
  i: Integer;
begin
  WriteLn('=== Ports s√©rie avec informations d√©taill√©es ===');
  WriteLn;

  // Utiliser commande syst√®me
  Lines := ExecuterCommande('ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null');

  try
    for i := 0 to Lines.Count - 1 do
      WriteLn(Lines[i]);
  finally
    Lines.Free;
  end;

  WriteLn;
  WriteLn('=== Informations udev ===');
  WriteLn;

  // Informations via udevadm
  Lines := ExecuterCommande('for port in /dev/ttyUSB* /dev/ttyACM*; do ' +
    '[ -e "$port" ] && echo "=== $port ===" && udevadm info --query=property "$port" | grep -E "ID_VENDOR|ID_MODEL|ID_SERIAL"; ' +
    'done');

  try
    for i := 0 to Lines.Count - 1 do
      WriteLn(Lines[i]);
  finally
    Lines.Free;
  end;
end;
```

### M√©thode 3 : Fonction de d√©tection intelligente

```pascal
type
  TPortInfo = record
    DeviceName: string;
    Description: string;
    VendorID: string;
    ProductID: string;
    Available: Boolean;
  end;
  TPortList = array of TPortInfo;

function DetecterPorts: TPortList;
var
  SearchRec: TSearchRec;
  Liste: TPortList;
  Count: Integer;
  fd: Integer;

  procedure AjouterPort(const DevName: string);
  begin
    SetLength(Liste, Count + 1);
    Liste[Count].DeviceName := DevName;
    Liste[Count].Description := 'Port s√©rie';

    // Tester si on peut ouvrir
    fd := fpOpen(DevName, O_RDWR or O_NOCTTY or O_NONBLOCK);
    Liste[Count].Available := (fd <> -1);

    if fd <> -1 then
      fpClose(fd);

    Inc(Count);
  end;

begin
  Count := 0;
  SetLength(Liste, 0);

  // Scanner ttyUSB
  if FindFirst('/dev/ttyUSB*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      AjouterPort('/dev/' + SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end;

  // Scanner ttyACM
  if FindFirst('/dev/ttyACM*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      AjouterPort('/dev/' + SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end;

  // Scanner ttyS
  if FindFirst('/dev/ttyS[0-9]', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      AjouterPort('/dev/' + SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end;

  Result := Liste;
end;

// Utilisation
var
  Ports: TPortList;
  i: Integer;
begin
  Ports := DetecterPorts;

  WriteLn('Ports d√©tect√©s:');
  for i := 0 to High(Ports) do
  begin
    Write('  ', Ports[i].DeviceName);
    if Ports[i].Available then
      WriteLn(' - Disponible')
    else
      WriteLn(' - Occup√© ou inaccessible');
  end;
end.
```

## Exemples d'applications compl√®tes

### Exemple 1 : Terminal s√©rie simple

```pascal
program TerminalSerie;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, termio, SysUtils, Keyboard;

var
  fd: Integer;
  Buffer: array[0..255] of AnsiChar;
  BytesRead: TSsize;
  c: Char;
  texte: AnsiString;
  terminating: Boolean;

function OuvrirPort(const PortName: string; BaudRate: speed_t): Integer;
var
  options: termios;
begin
  Result := fpOpen(PortName, O_RDWR or O_NOCTTY);

  if Result = -1 then
    Exit;

  tcgetattr(Result, @options);

  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;

  cfsetispeed(@options, BaudRate);
  cfsetospeed(@options, BaudRate);

  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 0;

  tcsetattr(Result, TCSANOW, @options);
  tcflush(Result, TCIOFLUSH);
end;

begin
  WriteLn('=== Terminal S√©rie FreePascal ===');
  WriteLn('√âchap pour quitter');
  WriteLn;

  // Ouvrir /dev/ttyUSB0 √† 115200 bauds
  fd := OuvrirPort('/dev/ttyUSB0', B115200);

  if fd = -1 then
  begin
    WriteLn('ERREUR: Impossible d''ouvrir /dev/ttyUSB0');
    WriteLn('Errno: ', fpgeterrno);

    case fpgeterrno of
      ESysEACCES:
        begin
          WriteLn;
          WriteLn('Permission refus√©e !');
          WriteLn('Solution: sudo usermod -a -G dialout $USER');
          WriteLn('Puis se d√©connecter/reconnecter');
        end;
      ESysENOENT:
        WriteLn('Le p√©riph√©rique n''existe pas');
      ESysEBUSY:
        WriteLn('Le p√©riph√©rique est occup√©');
    end;

    ReadLn;
    Exit;
  end;

  WriteLn('Connect√© √† /dev/ttyUSB0 (115200-8-N-1)');
  WriteLn('--------------------------------------');
  WriteLn;

  InitKeyboard;
  terminating := False;

  try
    repeat
      // Lire du port s√©rie
      BytesRead := fpRead(fd, Buffer, SizeOf(Buffer));
      if BytesRead > 0 then
      begin
        Buffer[BytesRead] := #0;
        Write(string(Buffer));
      end;

      // Lire du clavier
      if KeyPressed then
      begin
        c := GetKeyEvent;
        c := TranslateKeyEvent(c);

        if c = #27 then  // √âchap
        begin
          terminating := True;
          Break;
        end;

        // Envoyer au port s√©rie
        texte := AnsiString(c);
        fpWrite(fd, texte[1], 1);
      end;

      Sleep(10);

    until terminating;
  finally
    DoneKeyboard;
  end;

  fpClose(fd);
  WriteLn;
  WriteLn('D√©connect√©');
end.
```

### Exemple 2 : Lecteur GPS NMEA

```pascal
program LecteurGPS;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, termio, SysUtils, DateUtils;

type
  TDonneesGPS = record
    Latitude: Double;
    Longitude: Double;
    Altitude: Double;
    NbSatellites: Integer;
    Heure: TDateTime;
    Valide: Boolean;
  end;

var
  fd: Integer;
  GPS: TDonneesGPS;

function OuvrirPortGPS(const PortName: string): Integer;
var
  options: termios;
begin
  Result := fpOpen(PortName, O_RDWR or O_NOCTTY);

  if Result = -1 then
    Exit;

  tcgetattr(Result, @options);

  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;

  cfsetispeed(@options, B9600);  // GPS = 9600 bauds typiquement
  cfsetospeed(@options, B9600);

  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 1;  // Timeout 100ms

  tcsetattr(Result, TCSANOW, @options);
  tcflush(Result, TCIOFLUSH);
end;

function LireLigne(fd: Integer): string;
var
  c: AnsiChar;
  BytesRead: TSsize;
  ligne: string;
begin
  Result := '';
  ligne := '';

  repeat
    BytesRead := fpRead(fd, c, 1);

    if BytesRead <= 0 then
      Break;

    if c = #10 then
      Break;

    if c <> #13 then
      ligne := ligne + Char(c);
  until False;

  Result := ligne;
end;

function ParseGPGGA(const trame: string; var GPS: TDonneesGPS): Boolean;
var
  parties: TStringArray;
  lat, lon: string;
  latDeg, lonDeg: Integer;
  latMin, lonMin: Double;
begin
  Result := False;

  // V√©rifier si c'est une trame GPGGA
  if Copy(trame, 1, 6) <> '$GPGGA' then
    Exit;

  // D√©couper par virgules
  parties := trame.Split(',');

  if Length(parties) < 15 then
    Exit;

  // V√©rifier validit√© (parties[6] = qualit√© fix)
  if (parties[6] = '0') or (parties[6] = '') then
    Exit;

  GPS.Valide := True;

  // Parser latitude (parties[2] = DDMM.MMMM, parties[3] = N/S)
  if (Length(parties[2]) > 0) and (Length(parties[3]) > 0) then
  begin
    lat := parties[2];
    latDeg := StrToIntDef(Copy(lat, 1, 2), 0);
    latMin := StrToFloatDef(Copy(lat, 3, Length(lat) - 2), 0.0);
    GPS.Latitude := latDeg + (latMin / 60.0);

    if parties[3] = 'S' then
      GPS.Latitude := -GPS.Latitude;
  end;

  // Parser longitude (parties[4] = DDDMM.MMMM, parties[5] = E/W)
  if (Length(parties[4]) > 0) and (Length(parties[5]) > 0) then
  begin
    lon := parties[4];
    lonDeg := StrToIntDef(Copy(lon, 1, 3), 0);
    lonMin := StrToFloatDef(Copy(lon, 4, Length(lon) - 3), 0.0);
    GPS.Longitude := lonDeg + (lonMin / 60.0);

    if parties[5] = 'W' then
      GPS.Longitude := -GPS.Longitude;
  end;

  // Nombre de satellites (parties[7])
  GPS.NbSatellites := StrToIntDef(parties[7], 0);

  // Altitude (parties[9])
  GPS.Altitude := StrToFloatDef(parties[9], 0.0);

  Result := True;
end;

var
  ligne: string;

begin
  WriteLn('=== Lecteur GPS NMEA ===');
  WriteLn;

  fd := OuvrirPortGPS('/dev/ttyUSB0');

  if fd = -1 then
  begin
    WriteLn('ERREUR: Impossible d''ouvrir /dev/ttyUSB0');
    WriteLn('Errno: ', fpgeterrno);
    ReadLn;
    Exit;
  end;

  WriteLn('GPS connect√© sur /dev/ttyUSB0');
  WriteLn('Attente de trames NMEA...');
  WriteLn('(Ctrl+C pour quitter)');
  WriteLn;

  FillChar(GPS, SizeOf(GPS), 0);

  repeat
    ligne := LireLigne(fd);

    if ligne <> '' then
    begin
      // Afficher toutes les trames (debug)
      // WriteLn('Trame: ', ligne);

      if ParseGPGGA(ligne, GPS) then
      begin
        WriteLn('=== Position GPS ===');
        WriteLn('Latitude  : ', GPS.Latitude:0:6, '¬∞');
        WriteLn('Longitude : ', GPS.Longitude:0:6, '¬∞');
        WriteLn('Altitude  : ', GPS.Altitude:0:1, ' m');
        WriteLn('Satellites: ', GPS.NbSatellites);
        WriteLn;
      end;
    end;

    Sleep(100);

  until False;

  fpClose(fd);
end.
```

### Exemple 3 : Contr√¥le Arduino avec protocole

```pascal
program ControleArduino;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, termio, SysUtils, Keyboard;

type
  TArduinoCmd = (cmdLedOn, cmdLedOff, cmdGetTemp, cmdGetStatus);

var
  fd: Integer;

function OuvrirArduino(const PortName: string): Integer;
var
  options: termios;
begin
  Result := fpOpen(PortName, O_RDWR or O_NOCTTY);

  if Result = -1 then
    Exit;

  tcgetattr(Result, @options);

  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;

  cfsetispeed(@options, B9600);
  cfsetospeed(@options, B9600);

  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 10;  // Timeout 1 seconde

  tcsetattr(Result, TCSANOW, @options);
  tcflush(Result, TCIOFLUSH);

  // Attendre boot Arduino (reset auto via DTR)
  Sleep(2000);
end;

procedure EnvoyerCommande(fd: Integer; const cmd: string);
var
  data: AnsiString;
begin
  data := AnsiString(cmd + #10);
  fpWrite(fd, data[1], Length(data));
end;

function LireReponse(fd: Integer; TimeoutMs: Integer): string;
var
  Buffer: array[0..255] of AnsiChar;
  BytesRead: TSsize;
  StartTime: QWord;
  Elapsed: QWord;
begin
  Result := '';
  StartTime := GetTickCount64;

  repeat
    BytesRead := fpRead(fd, Buffer, SizeOf(Buffer) - 1);

    if BytesRead > 0 then
    begin
      Buffer[BytesRead] := #0;
      Result := Result + string(Buffer);

      // Si on a une ligne compl√®te
      if Pos(#10, Result) > 0 then
      begin
        Result := Trim(Result);
        Break;
      end;
    end;

    Elapsed := GetTickCount64 - StartTime;
    Sleep(10);

  until Elapsed > TimeoutMs;

  Result := Trim(Result);
end;

procedure AfficherMenu;
begin
  WriteLn;
  WriteLn('Commandes:');
  WriteLn('  1 - Allumer LED');
  WriteLn('  0 - √âteindre LED');
  WriteLn('  T - Lire temp√©rature');
  WriteLn('  S - √âtat syst√®me');
  WriteLn('  Q - Quitter');
  WriteLn;
end;

var
  choix: Char;
  reponse: string;

begin
  WriteLn('=== Contr√¥le Arduino ===');
  WriteLn;

  fd := OuvrirArduino('/dev/ttyUSB0');

  if fd = -1 then
  begin
    WriteLn('ERREUR: Impossible d''ouvrir /dev/ttyUSB0');
    WriteLn('Errno: ', fpgeterrno);

    if fpgeterrno = ESysEACCES then
    begin
      WriteLn;
      WriteLn('Solution: sudo usermod -a -G dialout $USER');
    end;

    ReadLn;
    Exit;
  end;

  WriteLn('Arduino connect√© sur /dev/ttyUSB0');
  AfficherMenu;

  InitKeyboard;

  try
    repeat
      Write('Commande: ');

      choix := GetKeyEvent;
      choix := UpCase(TranslateKeyEvent(choix));
      WriteLn(choix);

      case choix of
        '1':
          begin
            EnvoyerCommande(fd, 'LED_ON');
            reponse := LireReponse(fd, 1000);
            if reponse <> '' then
              WriteLn('  Arduino: ', reponse);
          end;

        '0':
          begin
            EnvoyerCommande(fd, 'LED_OFF');
            reponse := LireReponse(fd, 1000);
            if reponse <> '' then
              WriteLn('  Arduino: ', reponse);
          end;

        'T':
          begin
            EnvoyerCommande(fd, 'GET_TEMP');
            reponse := LireReponse(fd, 1000);
            if reponse <> '' then
              WriteLn('  Temp√©rature: ', reponse, ' ¬∞C');
          end;

        'S':
          begin
            EnvoyerCommande(fd, 'STATUS');
            reponse := LireReponse(fd, 1000);
            if reponse <> '' then
              WriteLn('  √âtat: ', reponse);
          end;

        'Q':
          Break;
      end;

      WriteLn;

    until False;
  finally
    DoneKeyboard;
  end;

  fpClose(fd);
  WriteLn('D√©connect√©');
end.
```

## Probl√®mes courants et solutions

### Probl√®me 1 : Permission denied (EACCES)

**Sympt√¥me :**
```
fpOpen retourne -1
fpgeterrno = 13 (ESysEACCES)
```

**Solution permanente :**
```bash
# Ajouter utilisateur au groupe dialout
sudo usermod -a -G dialout $USER

# V√©rifier
groups

# SE D√âCONNECTER/RECONNECTER pour que √ßa prenne effet !
```

**Solution temporaire (pour tester) :**
```bash
# Changer permissions (perdu au reboot)
sudo chmod 666 /dev/ttyUSB0
```

**V√©rifier les permissions :**
```bash
ls -l /dev/ttyUSB0
# Doit afficher : crw-rw---- 1 root dialout ...
```

### Probl√®me 2 : Device or resource busy (EBUSY)

**Sympt√¥me :**
```
fpOpen retourne -1
fpgeterrno = 16 (ESysEBUSY)
```

**Causes :**
- Port d√©j√† ouvert par autre application (minicom, screen, Arduino IDE)
- Verrou de fichier (lock file) non lib√©r√©
- Processus zombie tenant le port

**Solutions :**

**1. Identifier qui utilise le port**
```bash
# M√©thode 1 : lsof
sudo lsof /dev/ttyUSB0

# Sortie exemple :
# COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
# minicom  1234 user    3u   CHR  188,0      0t0  123 /dev/ttyUSB0

# M√©thode 2 : fuser
sudo fuser /dev/ttyUSB0

# Sortie : 1234
# Tuer le processus :
sudo kill 1234
```

**2. V√©rifier les lock files**
```bash
# Lock files typiques
ls -la /var/lock/*ttyUSB*
ls -la /tmp/*ttyUSB*

# Supprimer si bloqu√©
sudo rm /var/lock/LCK..ttyUSB0
```

**3. D√©brancher/rebrancher l'adaptateur USB**

Le plus simple si les m√©thodes ci-dessus √©chouent.

### Probl√®me 3 : No such file or directory (ENOENT)

**Sympt√¥me :**
```
fpOpen retourne -1
fpgeterrno = 2 (ESysENOENT)
```

**Causes :**
- P√©riph√©rique non connect√©
- Mauvais nom de p√©riph√©rique
- Driver non charg√©

**Solutions :**

```bash
# V√©rifier p√©riph√©riques disponibles
ls -l /dev/tty{USB,ACM}*

# V√©rifier dmesg pour d√©tection
dmesg | tail -20
dmesg | grep tty

# V√©rifier modules kernel charg√©s
lsmod | grep usb
lsmod | grep ftdi
lsmod | grep ch341

# Charger module si n√©cessaire
sudo modprobe ftdi_sio
sudo modprobe ch341
sudo modprobe pl2303
```

**Identifier le p√©riph√©rique USB :**
```bash
# Avant branchement
ls /dev/ttyUSB* > avant.txt

# Apr√®s branchement
ls /dev/ttyUSB* > apres.txt

# Comparer
diff avant.txt apres.txt
```

### Probl√®me 4 : Donn√©es corrompues

**Sympt√¥me :**
Caract√®res bizarres, garbage.

**Causes :**
1. Baud rate incorrect
2. Configuration diff√©rente (bits/parit√©/stop)
3. Probl√®me de c√¢blage
4. Interf√©rences

**Diagnostic automatique :**

```pascal
procedure TesterVitesses(const DeviceName: string);
const
  Vitesses: array[0..7] of speed_t = (
    B2400, B4800, B9600, B19200, B38400, B57600, B115200, B230400
  );
  VitessesNom: array[0..7] of string = (
    '2400', '4800', '9600', '19200', '38400', '57600', '115200', '230400'
  );
var
  i: Integer;
  fd: Integer;
  options: termios;
  Buffer: array[0..63] of AnsiChar;
  BytesRead: TSsize;
begin
  WriteLn('Test automatique des vitesses sur ', DeviceName);
  WriteLn;

  for i := 0 to High(Vitesses) do
  begin
    Write('Test ', VitessesNom[i], ' bauds... ');

    fd := fpOpen(DeviceName, O_RDWR or O_NOCTTY);

    if fd <> -1 then
    begin
      tcgetattr(fd, @options);

      options.c_iflag := 0;
      options.c_oflag := 0;
      options.c_lflag := 0;
      options.c_cflag := CS8 or CREAD or CLOCAL;

      cfsetispeed(@options, Vitesses[i]);
      cfsetospeed(@options, Vitesses[i]);

      options.c_cc[VMIN] := 0;
      options.c_cc[VTIME] := 5;  // 500ms timeout

      tcsetattr(fd, TCSANOW, @options);
      tcflush(fd, TCIOFLUSH);

      Sleep(100);

      BytesRead := fpRead(fd, Buffer, SizeOf(Buffer) - 1);

      if BytesRead > 0 then
      begin
        Buffer[BytesRead] := #0;
        WriteLn('Donn√©es re√ßues: "', string(Buffer), '"');
      end
      else
        WriteLn('Aucune donn√©e');

      fpClose(fd);
    end
    else
      WriteLn('Impossible d''ouvrir');
  end;
end;
```

### Probl√®me 5 : Timeout lors de la lecture

**Sympt√¥me :**
`fpRead` ne retourne jamais ou trop lentement.

**Solution : Ajuster VMIN et VTIME**

```pascal
procedure ConfigurerTimeout(fd: Integer; TimeoutDeciSec: Byte);
var
  options: termios;
begin
  tcgetattr(fd, @options);

  // Lecture avec timeout
  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := TimeoutDeciSec;  // En 1/10 de seconde

  tcsetattr(fd, TCSANOW, @options);
end;

// Exemples d'utilisation
ConfigurerTimeout(fd, 10);  // 1 seconde
ConfigurerTimeout(fd, 5);   // 500 ms
ConfigurerTimeout(fd, 0);   // Retour imm√©diat (non-bloquant)
```

### Probl√®me 6 : Perte de donn√©es

**Causes :**
- Buffer kernel trop petit
- Programme ne lit pas assez vite
- Pas de flow control

**Solutions :**

**1. Augmenter buffer kernel :**
```bash
# V√©rifier taille actuelle
cat /proc/sys/kernel/tty/ldisc_autoload

# Augmenter (temporaire)
echo 16384 | sudo tee /sys/class/tty/ttyUSB0/rx_buffer_size
```

**2. Utiliser un thread de lecture d√©di√© :**

```pascal
type
  TThreadLecture = class(TThread)
  private
    FFD: Integer;
    FBuffer: TThreadList;
  protected
    procedure Execute; override;
  public
    constructor Create(FD: Integer);
    destructor Destroy; override;
    function GetData: TBytes;
  end;

constructor TThreadLecture.Create(FD: Integer);
begin
  inherited Create(False);
  FFD := FD;
  FBuffer := TThreadList.Create;
  FreeOnTerminate := False;
end;

destructor TThreadLecture.Destroy;
begin
  FBuffer.Free;
  inherited Destroy;
end;

procedure TThreadLecture.Execute;
var
  TempBuffer: array[0..1023] of Byte;
  BytesRead: TSsize;
  Liste: TList;
  Copie: PByte;
begin
  while not Terminated do
  begin
    BytesRead := fpRead(FFD, TempBuffer, SizeOf(TempBuffer));

    if BytesRead > 0 then
    begin
      GetMem(Copie, BytesRead);
      Move(TempBuffer, Copie^, BytesRead);

      Liste := FBuffer.LockList;
      try
        Liste.Add(Copie);
      finally
        FBuffer.UnlockList;
      end;
    end;

    Sleep(1);
  end;
end;

function TThreadLecture.GetData: TBytes;
var
  Liste: TList;
  i, TotalSize, Offset: Integer;
  p: PByte;
begin
  SetLength(Result, 0);

  Liste := FBuffer.LockList;
  try
    if Liste.Count = 0 then
      Exit;

    // Calculer taille totale
    TotalSize := 0;
    for i := 0 to Liste.Count - 1 do
      Inc(TotalSize, PtrUInt(Liste[i]));

    SetLength(Result, TotalSize);

    // Copier toutes les donn√©es
    Offset := 0;
    for i := 0 to Liste.Count - 1 do
    begin
      p := Liste[i];
      Move(p^, Result[Offset], PtrUInt(p));
      Inc(Offset, PtrUInt(p));
      FreeMem(p);
    end;

    Liste.Clear;
  finally
    FBuffer.UnlockList;
  end;
end;
```

**3. Activer flow control mat√©riel :**

```pascal
procedure ActiverFlowControl(fd: Integer);
var
  options: termios;
begin
  tcgetattr(fd, @options);

  // Activer RTS/CTS
  options.c_cflag := options.c_cflag or CRTSCTS;

  tcsetattr(fd, TCSANOW, @options);
end;
```

### Probl√®me 7 : Port USB dispara√Æt apr√®s d√©branchement

**Solution : D√©tection automatique avec inotify**

```pascal
uses
  BaseUnix, Unix, inotify;

type
  TPortMonitor = class(TThread)
  private
    FFD: Integer;
    FInotifyFD: Integer;
    FWatchDescriptor: Integer;
    FOnDisconnected: TNotifyEvent;
    FOnReconnected: TNotifyEvent;
  protected
    procedure Execute; override;
  public
    constructor Create(const DeviceName: string);
    destructor Destroy; override;
    property OnDisconnected: TNotifyEvent read FOnDisconnected write FOnDisconnected;
    property OnReconnected: TNotifyEvent read FOnReconnected write FOnReconnected;
  end;

constructor TPortMonitor.Create(const DeviceName: string);
begin
  inherited Create(True);

  FInotifyFD := inotify_init;
  if FInotifyFD = -1 then
    raise Exception.Create('Impossible d''initialiser inotify');

  FWatchDescriptor := inotify_add_watch(FInotifyFD, '/dev', IN_CREATE or IN_DELETE);

  Start;
end;

destructor TPortMonitor.Destroy;
begin
  if FWatchDescriptor <> -1 then
    inotify_rm_watch(FInotifyFD, FWatchDescriptor);

  if FInotifyFD <> -1 then
    fpClose(FInotifyFD);

  inherited Destroy;
end;

procedure TPortMonitor.Execute;
var
  Buffer: array[0..1023] of Byte;
  BytesRead: TSsize;
  Event: Pinotify_event;
  p: PByte;
begin
  while not Terminated do
  begin
    BytesRead := fpRead(FInotifyFD, Buffer, SizeOf(Buffer));

    if BytesRead > 0 then
    begin
      p := @Buffer[0];

      while PtrUInt(p) < PtrUInt(@Buffer[0]) + BytesRead do
      begin
        Event := Pinotify_event(p);

        // Analyser l'√©v√©nement
        if (Event^.mask and IN_DELETE) <> 0 then
        begin
          if Assigned(FOnDisconnected) then
            Synchronize(@FOnDisconnected);
        end
        else if (Event^.mask and IN_CREATE) <> 0 then
        begin
          if Assigned(FOnReconnected) then
            Synchronize(@FOnReconnected);
        end;

        Inc(p, SizeOf(inotify_event) + Event^.len);
      end;
    end;

    Sleep(100);
  end;
end;
```

## Optimisation des performances

### Mesure de d√©bit

```pascal
procedure MesurerDebitReception(fd: Integer; DureeSecondes: Integer);
var
  Buffer: array[0..1023] of Byte;
  BytesRead: TSsize;
  TotalBytes: Int64;
  StartTime: QWord;
  Elapsed: Double;
begin
  WriteLn('Mesure du d√©bit pendant ', DureeSecondes, ' secondes...');

  TotalBytes := 0;
  StartTime := GetTickCount64;

  repeat
    BytesRead := fpRead(fd, Buffer, SizeOf(Buffer));

    if BytesRead > 0 then
      Inc(TotalBytes, BytesRead);

    Elapsed := (GetTickCount64 - StartTime) / 1000.0;
  until Elapsed >= DureeSecondes;

  WriteLn('Octets re√ßus: ', TotalBytes);
  WriteLn('D√©bit moyen: ', (TotalBytes / Elapsed):0:2, ' octets/s');
  WriteLn('            ', (TotalBytes * 8 / Elapsed):0:2, ' bits/s');
  WriteLn('            ', (TotalBytes / Elapsed / 1024):0:2, ' Ko/s');
end;
```

### Buffer circulaire pour haute performance

```pascal
type
  TBufferCirculaire = class
  private
    FBuffer: array of Byte;
    FTaille: Integer;
    FTete: Integer;
    FQueue: Integer;
    FCount: Integer;
    FLock: TRTLCriticalSection;
  public
    constructor Create(Taille: Integer);
    destructor Destroy; override;

    procedure Ecrire(const Data; Len: Integer);
    function Lire(var Data; MaxLen: Integer): Integer;
    function Disponible: Integer;
    procedure Vider;
  end;

constructor TBufferCirculaire.Create(Taille: Integer);
begin
  inherited Create;
  FTaille := Taille;
  SetLength(FBuffer, Taille);
  FTete := 0;
  FQueue := 0;
  FCount := 0;
  InitCriticalSection(FLock);
end;

destructor TBufferCirculaire.Destroy;
begin
  DoneCriticalSection(FLock);
  inherited Destroy;
end;

procedure TBufferCirculaire.Ecrire(const Data; Len: Integer);
var
  i: Integer;
  p: PByte;
begin
  EnterCriticalSection(FLock);
  try
    p := @Data;

    for i := 0 to Len - 1 do
    begin
      if FCount < FTaille then
      begin
        FBuffer[FQueue] := p^;
        FQueue := (FQueue + 1) mod FTaille;
        Inc(FCount);
        Inc(p);
      end
      else
      begin
        // Buffer plein, donn√©es perdues
        WriteLn('AVERTISSEMENT: Buffer circulaire plein !');
        Break;
      end;
    end;
  finally
    LeaveCriticalSection(FLock);
  end;
end;

function TBufferCirculaire.Lire(var Data; MaxLen: Integer): Integer;
var
  i: Integer;
  p: PByte;
begin
  Result := 0;

  EnterCriticalSection(FLock);
  try
    p := @Data;

    for i := 0 to MaxLen - 1 do
    begin
      if FCount > 0 then
      begin
        p^ := FBuffer[FTete];
        FTete := (FTete + 1) mod FTaille;
        Dec(FCount);
        Inc(p);
        Inc(Result);
      end
      else
        Break;
    end;
  finally
    LeaveCriticalSection(FLock);
  end;
end;

function TBufferCirculaire.Disponible: Integer;
begin
  EnterCriticalSection(FLock);
  try
    Result := FCount;
  finally
    LeaveCriticalSection(FLock);
  end;
end;

procedure TBufferCirculaire.Vider;
begin
  EnterCriticalSection(FLock);
  try
    FTete := 0;
    FQueue := 0;
    FCount := 0;
  finally
    LeaveCriticalSection(FLock);
  end;
end;
```

### Lecture asynchrone avec epoll

Pour tr√®s haute performance (milliers d'√©v√©nements/seconde) :

```pascal
uses
  Linux;  // Pour epoll

type
  TSerialPortAsync = class
  private
    FFD: Integer;
    FEpollFD: Integer;
    FThread: TThread;
    FOnDataReceived: TNotifyEvent;
  public
    constructor Create(const DeviceName: string; BaudRate: speed_t);
    destructor Destroy; override;
    property OnDataReceived: TNotifyEvent read FOnDataReceived write FOnDataReceived;
  end;

constructor TSerialPortAsync.Create(const DeviceName: string; BaudRate: speed_t);
var
  options: termios;
  event: epoll_event;
begin
  inherited Create;

  // Ouvrir port
  FFD := fpOpen(DeviceName, O_RDWR or O_NOCTTY or O_NONBLOCK);
  if FFD = -1 then
    raise Exception.Create('Impossible d''ouvrir ' + DeviceName);

  // Configurer
  tcgetattr(FFD, @options);
  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;
  cfsetispeed(@options, BaudRate);
  cfsetospeed(@options, BaudRate);
  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 0;
  tcsetattr(FFD, TCSANOW, @options);

  // Cr√©er epoll
  FEpollFD := epoll_create1(0);
  if FEpollFD = -1 then
  begin
    fpClose(FFD);
    raise Exception.Create('Impossible de cr√©er epoll');
  end;

  // Ajouter fd au epoll
  event.events := EPOLLIN;
  event.data.fd := FFD;

  if epoll_ctl(FEpollFD, EPOLL_CTL_ADD, FFD, @event) = -1 then
  begin
    fpClose(FFD);
    fpClose(FEpollFD);
    raise Exception.Create('Impossible d''ajouter fd √† epoll');
  end;

  // Cr√©er thread de surveillance
  // ... (impl√©mentation du thread)
end;

destructor TSerialPortAsync.Destroy;
begin
  if FEpollFD <> -1 then
    fpClose(FEpollFD);

  if FFD <> -1 then
    fpClose(FFD);

  inherited Destroy;
end;
```

## Int√©gration avec Lazarus (GUI)

### Composant TSerialPort pour Lazarus

```pascal
unit UnitSerialPortLazarus;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, BaseUnix, Unix, termio;

type
  TDataReceivedEvent = procedure(Sender: TObject; const Data: array of Byte; Count: Integer) of object;
  TErrorEvent = procedure(Sender: TObject; const ErrorMsg: string) of object;

  TSerialPort = class(TComponent)
  private
    FFD: Integer;
    FDeviceName: string;
    FBaudRate: speed_t;
    FConnected: Boolean;
    FThread: TThread;
    FOnDataReceived: TDataReceivedEvent;
    FOnError: TErrorEvent;

    procedure SetConnected(Value: Boolean);
    function GetBaudRateAsInteger: Integer;
    procedure SetBaudRateAsInteger(Value: Integer);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure Open;
    procedure Close;
    procedure WriteData(const Data: array of Byte; Count: Integer); overload;
    procedure WriteString(const S: string);
    function Available: Integer;

  published
    property DeviceName: string read FDeviceName write FDeviceName;
    property BaudRate: Integer read GetBaudRateAsInteger write SetBaudRateAsInteger default 9600;
    property Connected: Boolean read FConnected write SetConnected;
    property OnDataReceived: TDataReceivedEvent read FOnDataReceived write FOnDataReceived;
    property OnError: TErrorEvent read FOnError write FOnError;
  end;

procedure Register;

implementation

type
  TSerialThread = class(TThread)
  private
    FFD: Integer;
    FOwner: TSerialPort;
  protected
    procedure Execute; override;
  public
    constructor Create(FD: Integer; Owner: TSerialPort);
  end;

constructor TSerialThread.Create(FD: Integer; Owner: TSerialPort);
begin
  inherited Create(False);
  FreeOnTerminate := False;
  FFD := FD;
  FOwner := Owner;
end;

procedure TSerialThread.Execute;
var
  Buffer: array[0..255] of Byte;
  BytesRead: TSsize;
begin
  while not Terminated do
  begin
    BytesRead := fpRead(FFD, Buffer, SizeOf(Buffer));

    if BytesRead > 0 then
    begin
      if Assigned(FOwner.FOnDataReceived) then
      begin
        Synchronize(
          procedure
          begin
            FOwner.FOnDataReceived(FOwner, Buffer, BytesRead);
          end
        );
      end;
    end;

    Sleep(10);
  end;
end;

constructor TSerialPort.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FFD := -1;
  FDeviceName := '/dev/ttyUSB0';
  FBaudRate := B9600;
  FConnected := False;
  FThread := nil;
end;

destructor TSerialPort.Destroy;
begin
  Close;
  inherited Destroy;
end;

procedure TSerialPort.SetConnected(Value: Boolean);
begin
  if Value then
    Open
  else
    Close;
end;

function TSerialPort.GetBaudRateAsInteger: Integer;
begin
  case FBaudRate of
    B9600: Result := 9600;
    B19200: Result := 19200;
    B38400: Result := 38400;
    B57600: Result := 57600;
    B115200: Result := 115200;
    else Result := 9600;
  end;
end;

procedure TSerialPort.SetBaudRateAsInteger(Value: Integer);
begin
  case Value of
    2400: FBaudRate := B2400;
    4800: FBaudRate := B4800;
    9600: FBaudRate := B9600;
    19200: FBaudRate := B19200;
    38400: FBaudRate := B38400;
    57600: FBaudRate := B57600;
    115200: FBaudRate := B115200;
    230400: FBaudRate := B230400;
    else FBaudRate := B9600;
  end;
end;

procedure TSerialPort.Open;
var
  options: termios;
  ErrMsg: string;
begin
  if FConnected then
    Exit;

  FFD := fpOpen(FDeviceName, O_RDWR or O_NOCTTY);

  if FFD = -1 then
  begin
    case fpgeterrno of
      ESysEACCES:
        ErrMsg := 'Permission refus√©e. Solution: sudo usermod -a -G dialout $USER';
      ESysENOENT:
        ErrMsg := 'P√©riph√©rique ' + FDeviceName + ' inexistant';
      ESysEBUSY:
        ErrMsg := 'Port occup√© par une autre application';
      else
        ErrMsg := 'Erreur ' + IntToStr(fpgeterrno);
    end;

    if Assigned(FOnError) then
      FOnError(Self, ErrMsg);

    raise Exception.Create('Impossible d''ouvrir ' + FDeviceName + ': ' + ErrMsg);
  end;

  tcgetattr(FFD, @options);

  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;

  cfsetispeed(@options, FBaudRate);
  cfsetospeed(@options, FBaudRate);

  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 0;

  tcsetattr(FFD, TCSANOW, @options);
  tcflush(FFD, TCIOFLUSH);

  FThread := TSerialThread.Create(FFD, Self);

  FConnected := True;
end;

procedure TSerialPort.Close;
begin
  if not FConnected then
    Exit;

  if Assigned(FThread) then
  begin
    FThread.Terminate;
    FThread.WaitFor;
    FThread.Free;
    FThread := nil;
  end;

  fpClose(FFD);
  FFD := -1;

  FConnected := False;
end;

procedure TSerialPort.WriteData(const Data: array of Byte; Count: Integer);
begin
  if not FConnected then
    Exit;

  fpWrite(FFD, Data[0], Count);
end;

procedure TSerialPort.WriteString(const S: string);
var
  AnsiS: AnsiString;
begin
  AnsiS := AnsiString(S);
  if Length(AnsiS) > 0 then
    WriteData(PByte(AnsiS)^, Length(AnsiS));
end;

function TSerialPort.Available: Integer;
var
  BytesAvail: Integer;
begin
  Result := 0;

  if not FConnected then
    Exit;

  if fpioctl(FFD, FIONREAD, @BytesAvail) = 0 then
    Result := BytesAvail;
end;

procedure Register;
begin
  RegisterComponents('Communication', [TSerialPort]);
end;

end.
```

### Utilisation dans une form Lazarus

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  ComCtrls, UnitSerialPortLazarus;

type
  TForm1 = class(TForm)
    ButtonConnect: TButton;
    ButtonSend: TButton;
    ComboBoxPort: TComboBox;
    ComboBoxBaud: TComboBox;
    EditSend: TEdit;
    MemoReceived: TMemo;
    StatusBar1: TStatusBar;

    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure ButtonConnectClick(Sender: TObject);
    procedure ButtonSendClick(Sender: TObject);
  private
    FSerialPort: TSerialPort;
    procedure OnDataReceived(Sender: TObject; const Data: array of Byte; Count: Integer);
    procedure OnError(Sender: TObject; const ErrorMsg: string);
    procedure ScannerPorts;
  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

procedure TForm1.FormCreate(Sender: TObject);
begin
  FSerialPort := TSerialPort.Create(Self);
  FSerialPort.OnDataReceived := @OnDataReceived;
  FSerialPort.OnError := @OnError;

  // Remplir combo vitesses
  ComboBoxBaud.Items.Add('9600');
  ComboBoxBaud.Items.Add('19200');
  ComboBoxBaud.Items.Add('38400');
  ComboBoxBaud.Items.Add('57600');
  ComboBoxBaud.Items.Add('115200');
  ComboBoxBaud.ItemIndex := 0;

  // Scanner ports
  ScannerPorts;

  StatusBar1.SimpleText := 'D√©connect√©';
end;

procedure TForm1.FormDestroy(Sender: TObject);
begin
  FSerialPort.Free;
end;

procedure TForm1.ScannerPorts;
var
  SearchRec: TSearchRec;
begin
  ComboBoxPort.Items.Clear;

  // Scanner ttyUSB
  if FindFirst('/dev/ttyUSB*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      ComboBoxPort.Items.Add('/dev/' + SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end;

  // Scanner ttyACM
  if FindFirst('/dev/ttyACM*', faAnyFile, SearchRec) = 0 then
  begin
    repeat
      ComboBoxPort.Items.Add('/dev/' + SearchRec.Name);
    until FindNext(SearchRec) <> 0;
    FindClose(SearchRec);
  end;

  if ComboBoxPort.Items.Count > 0 then
    ComboBoxPort.ItemIndex := 0;
end;

procedure TForm1.ButtonConnectClick(Sender: TObject);
begin
  if not FSerialPort.Connected then
  begin
    try
      FSerialPort.DeviceName := ComboBoxPort.Text;
      FSerialPort.BaudRate := StrToInt(ComboBoxBaud.Text);
      FSerialPort.Open;

      ButtonConnect.Caption := 'D√©connecter';
      ComboBoxPort.Enabled := False;
      ComboBoxBaud.Enabled := False;
      StatusBar1.SimpleText := 'Connect√© √† ' + ComboBoxPort.Text + ' @ ' + ComboBoxBaud.Text;

    except
      on E: Exception do
      begin
        ShowMessage('Erreur de connexion: ' + E.Message);
        StatusBar1.SimpleText := 'Erreur';
      end;
    end;
  end
  else
  begin
    FSerialPort.Close;
    ButtonConnect.Caption := 'Connecter';
    ComboBoxPort.Enabled := True;
    ComboBoxBaud.Enabled := True;
    StatusBar1.SimpleText := 'D√©connect√©';
  end;
end;

procedure TForm1.ButtonSendClick(Sender: TObject);
begin
  if FSerialPort.Connected and (EditSend.Text <> '') then
  begin
    FSerialPort.WriteString(EditSend.Text + #10);
    MemoReceived.Lines.Add('TX: ' + EditSend.Text);
    EditSend.Clear;
  end;
end;

procedure TForm1.OnDataReceived(Sender: TObject; const Data: array of Byte; Count: Integer);
var
  S: AnsiString;
  i: Integer;
begin
  SetLength(S, Count);
  for i := 0 to Count - 1 do
    S[i + 1] := AnsiChar(Data[i]);

  MemoReceived.Lines.Add('RX: ' + string(S));
end;

procedure TForm1.OnError(Sender: TObject; const ErrorMsg: string);
begin
  ShowMessage('Erreur: ' + ErrorMsg);
end;

end.
```

## Comparaison Windows vs Linux

### Tableau r√©capitulatif

| Aspect | Windows | Linux |
|--------|---------|-------|
| **Nomenclature** | COM1, COM2, COM3... | /dev/ttyS0, /dev/ttyUSB0, /dev/ttyACM0 |
| **API** | Win32 (CreateFile, ReadFile) | POSIX (open, read, write) |
| **Configuration** | Structure DCB | Structure termios |
| **Permissions** | Automatique | Groupe dialout/uucp requis |
| **Timeouts** | COMMTIMEOUTS | VMIN/VTIME |
| **√ânum√©ration** | QueryDosDevice, registre | Scanner /dev, udevadm |
| **Hot-plug** | Notifications syst√®me | inotify, udev |
| **Flow control** | Flags DCB | CRTSCTS flag |
| **Signaux** | EscapeCommFunction | ioctl TIOCMGET/TIOCMSET |

### Diff√©rences de code

**Ouverture :**

```pascal
// Windows
hPort := CreateFile('\\.\COM3', GENERIC_READ or GENERIC_WRITE, ...);

// Linux
fd := fpOpen('/dev/ttyUSB0', O_RDWR or O_NOCTTY);
```

**Configuration vitesse :**

```pascal
// Windows
DCB.BaudRate := CBR_115200;

// Linux
cfsetispeed(@options, B115200);
cfsetospeed(@options, B115200);
```

**Lecture :**

```pascal
// Windows
ReadFile(hPort, Buffer, Size, BytesRead, nil);

// Linux
BytesRead := fpRead(fd, Buffer, Size);
```

**√âcriture :**

```pascal
// Windows
WriteFile(hPort, Data, Size, BytesWritten, nil);

// Linux
BytesWritten := fpWrite(fd, Data, Size);
```

## Outils en ligne de commande

### minicom - Terminal s√©rie interactif

```bash
# Installer
sudo apt install minicom

# Configuration initiale
sudo minicom -s

# Dans le menu :
# - Serial port setup
# - A : /dev/ttyUSB0
# - E : 115200 8N1
# - F : No (hardware flow control)
# - Save setup as dfl (default)
# - Exit

# Lancer
minicom

# Quitter : Ctrl+A puis X
```

### screen - Simple et rapide

```bash
# Installer (souvent pr√©install√©)
sudo apt install screen

# Se connecter
screen /dev/ttyUSB0 115200

# Quitter : Ctrl+A puis K puis Y
```

### picocom - L√©ger et efficace

```bash
# Installer
sudo apt install picocom

# Se connecter
picocom -b 115200 /dev/ttyUSB0

# Quitter : Ctrl+A puis Ctrl+X
```

### cu - Classique Unix

```bash
# Installer
sudo apt install cu

# Se connecter
cu -l /dev/ttyUSB0 -s 115200

# Quitter : ~.
```

### stty - Configuration en ligne de commande

```bash
# Configurer le port
stty -F /dev/ttyUSB0 115200 cs8 -cstopb -parenb

# Afficher configuration
stty -F /dev/ttyUSB0 -a

# Envoyer des donn√©es
echo "Hello" > /dev/ttyUSB0

# Lire des donn√©es
cat /dev/ttyUSB0
```

## Scripts shell utiles

### Script de connexion automatique

**connect_serial.sh :**

```bash
#!/bin/bash

PORT="/dev/ttyUSB0"
BAUD="115200"

# V√©rifier si le port existe
if [ ! -e "$PORT" ]; then
    echo "Erreur: $PORT n'existe pas"
    echo "Ports disponibles:"
    ls /dev/tty{USB,ACM}* 2>/dev/null
    exit 1
fi

# V√©rifier permissions
if [ ! -r "$PORT" ] || [ ! -w "$PORT" ]; then
    echo "Erreur: Permissions insuffisantes pour $PORT"
    echo "Solution: sudo usermod -a -G dialout $USER"
    echo "Puis se d√©connecter/reconnecter"
    exit 1
fi

# Configurer le port
stty -F "$PORT" "$BAUD" cs8 -cstopb -parenb raw -echo

# Lancer screen
screen "$PORT" "$BAUD"
```

### Script de monitoring continu

**monitor_serial.sh :**

```bash
#!/bin/bash

PORT="${1:-/dev/ttyUSB0}"
BAUD="${2:-115200}"
LOGFILE="serial_$(date +%Y%m%d_%H%M%S).log"

echo "Monitoring $PORT @ $BAUD bauds"
echo "Log: $LOGFILE"
echo "Ctrl+C pour arr√™ter"
echo ""

# Configurer port
stty -F "$PORT" "$BAUD" cs8 -cstopb -parenb raw -echo

# Lire et logger
while true; do
    cat "$PORT" | while IFS= read -r ligne; do
        timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo "[$timestamp] $ligne" | tee -a "$LOGFILE"
    done
done
```

### Script de test de vitesse

**test_baudrate.sh :**

```bash
#!/bin/bash

PORT="${1:-/dev/ttyUSB0}"

if [ ! -e "$PORT" ]; then
    echo "Port $PORT inexistant"
    exit 1
fi

echo "Test automatique des vitesses sur $PORT"
echo ""

for BAUD in 2400 4800 9600 19200 38400 57600 115200 230400; do
    echo -n "Test $BAUD bauds... "

    # Configurer
    stty -F "$PORT" "$BAUD" cs8 -cstopb -parenb raw -echo 2>/dev/null

    if [ $? -eq 0 ]; then
        # Tenter de lire (timeout 1 seconde)
        timeout 1 cat "$PORT" > /tmp/serial_test 2>/dev/null

        if [ -s /tmp/serial_test ]; then
            echo "Donn√©es re√ßues !"
            head -c 50 /tmp/serial_test
            echo ""
        else
            echo "Aucune donn√©e"
        fi
    else
        echo "Erreur configuration"
    fi

    rm -f /tmp/serial_test
done
```

## Ressources et documentation

### Documentation officielle

**Pages man Linux :**
```bash
man termios    # Structure termios et configuration
man tcsetattr  # Configuration port s√©rie
man select     # Multiplexage I/O
man fcntl      # Contr√¥le fichier
man ioctl      # Contr√¥le p√©riph√©rique
man ioctl_tty  # Contr√¥le sp√©cifique TTY
```

**Kernel Documentation :**
- `/usr/src/linux/Documentation/serial/`
- Serial HOWTO : https://tldp.org/HOWTO/Serial-HOWTO.html

### Biblioth√®ques tierces

**Synapse (Ararat Synapse)**
- Multi-plateforme (Windows/Linux)
- Support s√©rie inclus
- URL: http://synapse.ararat.cz

**libserialport**
- Biblioth√®que C multi-plateforme
- Bindings disponibles pour plusieurs langages
- URL: https://sigrok.org/wiki/Libserialport

### Outils de diagnostic

**1. setserial - Configuration avanc√©e**
```bash
# Installer
sudo apt install setserial

# Voir configuration
setserial -a /dev/ttyS0

# Changer IRQ (ports natifs)
sudo setserial /dev/ttyS0 irq 4
```

**2. lsusb - Lister p√©riph√©riques USB**
```bash
# Lister tous les USB
lsusb

# D√©tails d'un p√©riph√©rique
lsusb -v -d 1a86:7523  # Exemple: CH340

# Arbre USB
lsusb -t
```

**3. usb-devices - Infos d√©taill√©es**
```bash
usb-devices | grep -A 10 "Serial"
```

**4. dmesg - Messages kernel**
```bash
# Voir derniers messages
dmesg | tail -20

# Filtrer s√©rie
dmesg | grep -i tty
dmesg | grep -i serial
dmesg | grep -i usb

# Suivre en temps r√©el
dmesg -w
```

## Annexes

### Annexe A : R√©f√©rence rapide termios

**Flags c_cflag (Control) :**

| Flag | Description |
|------|-------------|
| `CBAUD` | Masque baud rate |
| `B9600`, `B115200`, etc. | Vitesses |
| `CSIZE` | Masque taille caract√®re |
| `CS5`, `CS6`, `CS7`, `CS8` | Taille (5-8 bits) |
| `CSTOPB` | 2 bits stop (sinon 1) |
| `PARENB` | Activer parit√© |
| `PARODD` | Parit√© impaire |
| `CREAD` | Activer r√©ception |
| `CLOCAL` | Mode local (pas de modem) |
| `CRTSCTS` | Flow control mat√©riel |

**Flags c_iflag (Input) :**

| Flag | Description |
|------|-------------|
| `IGNBRK` | Ignorer break |
| `BRKINT` | Break ‚Üí SIGINT |
| `IGNPAR` | Ignorer erreurs parit√© |
| `PARMRK` | Marquer erreurs parit√© |
| `INPCK` | V√©rifier parit√© |
| `ISTRIP` | Retirer 8√®me bit |
| `IXON` | XON/XOFF sortie |
| `IXOFF` | XON/XOFF entr√©e |

**Flags c_lflag (Local) :**

| Flag | Description |
|------|-------------|
| `ICANON` | Mode canonique (ligne) |
| `ECHO` | Echo caract√®res |
| `ISIG` | G√©n√©rer signaux |

### Annexe B : Codes d'erreur courants

| Errno | Valeur | Description | Solution |
|-------|--------|-------------|----------|
| `EACCES` | 13 | Permission denied | usermod -a -G dialout |
| `ENOENT` | 2 | No such file | V√©rifier p√©riph√©rique |
| `EBUSY` | 16 | Device busy | Fermer autres apps |
| `EIO` | 5 | I/O error | Probl√®me mat√©riel |
| `ENXIO` | 6 | No such device | Driver non charg√© |
| `ENOTTY` | 25 | Not a tty | Pas un port s√©rie |

### Annexe C : Configuration udev avanc√©e

**Cr√©er lien symbolique stable :**

**/etc/udev/rules.d/99-ftdi-stable.rules :**

```
# R√®gle pour FTDI sp√©cifique (par num√©ro de s√©rie)
SUBSYSTEM=="tty", ATTRS{idVendor}=="0403", ATTRS{idProduct}=="6001", \
  ATTRS{serial}=="A12345", SYMLINK+="ftdi_module1"

# R√®gle pour Arduino Uno (CH340)
SUBSYSTEM=="tty", ATTRS{idVendor}=="1a86", ATTRS{idProduct}=="7523", \
  SYMLINK+="arduino_uno", MODE="0666", GROUP="dialout"

# R√®gle pour GPS g√©n√©rique
SUBSYSTEM=="tty", ATTRS{idVendor}=="067b", ATTRS{idProduct}=="2303", \
  SYMLINK+="gps", MODE="0666"
```

**Recharger :**
```bash
sudo udevadm control --reload-rules
sudo udevadm trigger
```

**Utilisation :**
```bash
# Au lieu de /dev/ttyUSB0 (qui peut changer)
# Utiliser /dev/ftdi_module1 (stable)
./mon_programme /dev/ftdi_module1
```

### Annexe D : Snippets r√©utilisables

**D√©terminer si un fichier est un port s√©rie :**

```pascal
uses
  BaseUnix, Unix;

function EstPortSerie(const DevName: string): Boolean;
var
  StatBuf: TStat;
begin
  Result := False;

  if fpStat(DevName, StatBuf) = 0 then
  begin
    // V√©rifier si c'est un character device
    if fpS_ISCHR(StatBuf.st_mode) then
      Result := True;
  end;
end;
```

**Attendre avec timeout via select :**

```pascal
function AttendreDonneesTimeout(fd: Integer; TimeoutMs: Integer): Boolean;
var
  rfds: TFDSet;
  tv: TTimeVal;
begin
  fpFD_ZERO(rfds);
  fpFD_SET(fd, rfds);

  tv.tv_sec := TimeoutMs div 1000;
  tv.tv_usec := (TimeoutMs mod 1000) * 1000;

  Result := fpSelect(fd + 1, @rfds, nil, nil, @tv) > 0;
end;
```

**V√©rifier nombre d'octets disponibles :**

```pascal
function OctetsDisponibles(fd: Integer): Integer;
var
  BytesAvail: Integer;
begin
  Result := 0;

  if fpioctl(fd, FIONREAD, @BytesAvail) = 0 then
    Result := BytesAvail;
end;
```

**Hexdump pour debug :**

```pascal
procedure HexDump(const Data: array of Byte; Count: Integer);
var
  i: Integer;
begin
  Write('HexDump (', Count, ' octets): ');

  for i := 0 to Count - 1 do
  begin
    Write(IntToHex(Data[i], 2), ' ');

    if (i + 1) mod 16 = 0 then
    begin
      WriteLn;
      Write('  ');
    end;
  end;

  WriteLn;
end;
```

### Annexe E : Checklist de d√©pannage

**‚òê 1. Le p√©riph√©rique existe-t-il ?**
```bash
ls -l /dev/ttyUSB* /dev/ttyACM*
dmesg | grep tty
```

**‚òê 2. Ai-je les permissions ?**
```bash
groups | grep dialout
ls -l /dev/ttyUSB0
```

**‚òê 3. Le port est-il libre ?**
```bash
sudo lsof /dev/ttyUSB0
sudo fuser /dev/ttyUSB0
```

**‚òê 4. La configuration est-elle correcte ?**
```bash
stty -F /dev/ttyUSB0 -a
```

**‚òê 5. Le c√¢blage est-il bon ?**
- TX ‚Üí RX crois√©
- GND commun
- Niveaux tension (3.3V vs 5V)

**‚òê 6. Les drivers sont-ils charg√©s ?**
```bash
lsmod | grep -E "ftdi|ch341|pl2303"
dmesg | tail
```

**‚òê 7. Puis-je communiquer avec autre outil ?**
```bash
screen /dev/ttyUSB0 115200
minicom
```

### Annexe F : Template complet production-ready

Voici un template final optimis√© et robuste :

```pascal
unit UnitSerialPortPro;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, BaseUnix, Unix, termio;

type
  TSerialPortPro = class
  private
    FFD: Integer;
    FDeviceName: string;
    FBaudRate: speed_t;
    FConnected: Boolean;
    FLastError: string;

    function InternalOpen: Boolean;
    procedure InternalClose;
    procedure SetLastError(const Msg: string);
  public
    constructor Create;
    destructor Destroy; override;

    // Connexion
    function Open(const DeviceName: string; BaudRate: speed_t): Boolean;
    procedure Close;

    // Configuration
    procedure SetParams(ByteSize, Parity, StopBits: Byte);
    procedure SetTimeouts(MinChars: Byte; TimeoutDeciSec: Byte);
    procedure SetFlowControl(Hardware, Software: Boolean);

    // I/O
    function Read(var Buffer; Size: Integer): Integer;
    function Write(const Buffer; Size: Integer): Integer;
    function ReadString(MaxLen: Integer = 256): string;
    procedure WriteString(const S: string);
    function ReadLine: string;

    // Utilitaires
    function Available: Integer;
    procedure Flush;
    function WaitForData(TimeoutMs: Integer): Boolean;

    // Contr√¥le signaux
    procedure SetDTR(State: Boolean);
    procedure SetRTS(State: Boolean);
    function GetCTS: Boolean;
    function GetDSR: Boolean;

    // Propri√©t√©s
    property Connected: Boolean read FConnected;
    property DeviceName: string read FDeviceName;
    property BaudRate: speed_t read FBaudRate;
    property LastError: string read FLastError;
  end;

implementation

constructor TSerialPortPro.Create;
begin
  inherited Create;
  FFD := -1;
  FConnected := False;
  FLastError := '';
end;

destructor TSerialPortPro.Destroy;
begin
  Close;
  inherited Destroy;
end;

procedure TSerialPortPro.SetLastError(const Msg: string);
begin
  FLastError := Msg;
end;

function TSerialPortPro.InternalOpen: Boolean;
var
  options: termios;
begin
  Result := False;

  if FConnected then
  begin
    SetLastError('D√©j√† connect√©');
    Exit;
  end;

  FFD := fpOpen(FDeviceName, O_RDWR or O_NOCTTY);

  if FFD = -1 then
  begin
    case fpgeterrno of
      ESysEACCES:
        SetLastError('Permission refus√©e. Solution: sudo usermod -a -G dialout $USER');
      ESysENOENT:
        SetLastError('P√©riph√©rique inexistant: ' + FDeviceName);
      ESysEBUSY:
        SetLastError('Port occup√©');
      else
        SetLastError('Erreur ' + IntToStr(fpgeterrno));
    end;
    Exit;
  end;

  // Configuration par d√©faut (8N1, mode raw)
  if tcgetattr(FFD, @options) <> 0 then
  begin
    SetLastError('Erreur tcgetattr');
    fpClose(FFD);
    FFD := -1;
    Exit;
  end;

  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;

  cfsetispeed(@options, FBaudRate);
  cfsetospeed(@options, FBaudRate);

  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 0;

  if tcsetattr(FFD, TCSANOW, @options) <> 0 then
  begin
    SetLastError('Erreur tcsetattr');
    fpClose(FFD);
    FFD := -1;
    Exit;
  end;

  tcflush(FFD, TCIOFLUSH);

  FConnected := True;
  FLastError := '';
  Result := True;
end;

procedure TSerialPortPro.InternalClose;
begin
  if FConnected then
  begin
    fpClose(FFD);
    FFD := -1;
    FConnected := False;
  end;
end;

function TSerialPortPro.Open(const DeviceName: string; BaudRate: speed_t): Boolean;
begin
  FDeviceName := DeviceName;
  FBaudRate := BaudRate;
  Result := InternalOpen;
end;

procedure TSerialPortPro.Close;
begin
  InternalClose;
end;

function TSerialPortPro.Read(var Buffer; Size: Integer): Integer;
begin
  Result := 0;

  if not FConnected then
  begin
    SetLastError('Non connect√©');
    Exit;
  end;

  Result := fpRead(FFD, Buffer, Size);

  if Result < 0 then
  begin
    SetLastError('Erreur lecture: ' + IntToStr(fpgeterrno));
    Result := 0;
  end;
end;

function TSerialPortPro.Write(const Buffer; Size: Integer): Integer;
begin
  Result := 0;

  if not FConnected then
  begin
    SetLastError('Non connect√©');
    Exit;
  end;

  Result := fpWrite(FFD, Buffer, Size);

  if Result < 0 then
  begin
    SetLastError('Erreur √©criture: ' + IntToStr(fpgeterrno));
    Result := 0;
  end;
end;

function TSerialPortPro.ReadString(MaxLen: Integer): string;
var
  Buffer: array[0..255] of AnsiChar;
  BytesRead: Integer;
  Len: Integer;
begin
  Result := '';

  if MaxLen > 256 then
    MaxLen := 256;

  BytesRead := Read(Buffer, MaxLen - 1);

  if BytesRead > 0 then
  begin
    Buffer[BytesRead] := #0;
    Result := string(Buffer);
  end;
end;

procedure TSerialPortPro.WriteString(const S: string);
var
  AnsiS: AnsiString;
begin
  AnsiS := AnsiString(S);
  if Length(AnsiS) > 0 then
    Write(AnsiS[1], Length(AnsiS));
end;

function TSerialPortPro.ReadLine: string;
var
  c: AnsiChar;
  BytesRead: Integer;
begin
  Result := '';

  repeat
    BytesRead := Read(c, 1);

    if BytesRead <= 0 then
      Break;

    if c = #10 then
      Break;

    if c <> #13 then
      Result := Result + Char(c);
  until False;
end;

function TSerialPortPro.Available: Integer;
var
  BytesAvail: Integer;
begin
  Result := 0;

  if not FConnected then
    Exit;

  if fpioctl(FFD, FIONREAD, @BytesAvail) = 0 then
    Result := BytesAvail;
end;

procedure TSerialPortPro.Flush;
begin
  if FConnected then
    tcflush(FFD, TCIOFLUSH);
end;

function TSerialPortPro.WaitForData(TimeoutMs: Integer): Boolean;
var
  rfds: TFDSet;
  tv: TTimeVal;
begin
  Result := False;

  if not FConnected then
    Exit;

  fpFD_ZERO(rfds);
  fpFD_SET(FFD, rfds);

  tv.tv_sec := TimeoutMs div 1000;
  tv.tv_usec := (TimeoutMs mod 1000) * 1000;

  Result := fpSelect(FFD + 1, @rfds, nil, nil, @tv) > 0;
end;

procedure TSerialPortPro.SetDTR(State: Boolean);
var
  status: Integer;
begin
  if not FConnected then
    Exit;

  fpioctl(FFD, TIOCMGET, @status);

  if State then
    status := status or TIOCM_DTR
  else
    status := status and (not TIOCM_DTR);

  fpioctl(FFD, TIOCMSET, @status);
end;

procedure TSerialPortPro.SetRTS(State: Boolean);
var
  status: Integer;
begin
  if not FConnected then
    Exit;

  fpioctl(FFD, TIOCMGET, @status);

  if State then
    status := status or TIOCM_RTS
  else
    status := status and (not TIOCM_RTS);

  fpioctl(FFD, TIOCMSET, @status);
end;

function TSerialPortPro.GetCTS: Boolean;
var
  status: Integer;
begin
  Result := False;

  if not FConnected then
    Exit;

  if fpioctl(FFD, TIOCMGET, @status) = 0 then
    Result := (status and TIOCM_CTS) <> 0;
end;

function TSerialPortPro.GetDSR: Boolean;
var
  status: Integer;
begin
  Result := False;

  if not FConnected then
    Exit;

  if fpioctl(FFD, TIOCMGET, @status) = 0 then
    Result := (status and TIOCM_DSR) <> 0;
end;

// M√©thodes de configuration suppl√©mentaires...
procedure TSerialPortPro.SetParams(ByteSize, Parity, StopBits: Byte);
var
  options: termios;
begin
  if not FConnected then
    Exit;

  tcgetattr(FFD, @options);

  // Appliquer param√®tres...
  // (impl√©mentation similaire aux exemples pr√©c√©dents)

  tcsetattr(FFD, TCSANOW, @options);
end;

procedure TSerialPortPro.SetTimeouts(MinChars: Byte; TimeoutDeciSec: Byte);
var
  options: termios;
begin
  if not FConnected then
    Exit;

  tcgetattr(FFD, @options);

  options.c_cc[VMIN] := MinChars;
  options.c_cc[VTIME] := TimeoutDeciSec;

  tcsetattr(FFD, TCSANOW, @options);
end;

procedure TSerialPortPro.SetFlowControl(Hardware, Software: Boolean);
var
  options: termios;
begin
  if not FConnected then
    Exit;

  tcgetattr(FFD, @options);

  if Hardware then
    options.c_cflag := options.c_cflag or CRTSCTS
  else
    options.c_cflag := options.c_cflag and (not CRTSCTS);

  if Software then
  begin
    options.c_iflag := options.c_iflag or (IXON or IXOFF);
  end
  else
  begin
    options.c_iflag := options.c_iflag and (not (IXON or IXOFF));
  end;

  tcsetattr(FFD, TCSANOW, @options);
end;

end.
```

## Conclusion

La communication s√©rie sous Linux avec FreePascal repose sur l'API POSIX et la structure `termios`, offrant un contr√¥le complet et performant des ports s√©rie.

**Points cl√©s √† retenir :**

‚úÖ **Nomenclature** : /dev/ttyUSB*, /dev/ttyACM*, /dev/ttyS*

‚úÖ **Permissions** : Groupe dialout n√©cessaire (`sudo usermod -a -G dialout $USER`)

‚úÖ **API POSIX** : fpOpen, fpRead, fpWrite, fpClose

‚úÖ **Configuration** : Structure termios avec tcsetattr

‚úÖ **Timeouts** : VMIN et VTIME pour contr√¥le lecture

‚úÖ **Signaux** : ioctl pour DTR/RTS/CTS/DSR

‚úÖ **√ânum√©ration** : Scanner /dev, udevadm, r√®gles udev

‚úÖ **Debugging** : minicom, screen, picocom, dmesg

Avec ces connaissances, vous pouvez cr√©er des applications robustes communiquant avec Arduino, GPS, capteurs industriels, ou tout appareil s√©rie sous Linux/Ubuntu.

**Avantages de l'approche Linux :**
- Philosophie "tout est fichier" : simplicit√© conceptuelle
- API standard POSIX : portabilit√© entre Unix (Linux, BSD, macOS)
- Outils en ligne de commande puissants
- udev pour gestion dynamique des p√©riph√©riques
- Pas de limitations artificielles (COM1-COM256)

**D√©fis sp√©cifiques :**
- Gestion des permissions (groupe dialout)
- Nomenclature variable selon type de p√©riph√©rique
- Hot-plug n√©cessite surveillance active (inotify)
- Documentation parfois dispers√©e

---

## Comparaison finale Windows vs Linux

### Code √©quivalent c√¥te √† c√¥te

**Programme complet : Echo s√©rie simple**

**Windows (Win32 API) :**

```pascal
program EchoSerieWin;

uses
  Windows, SysUtils;

var
  hPort: THandle;
  Buffer: array[0..255] of Byte;
  BytesRead, BytesWritten: DWORD;
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;

begin
  // Ouvrir
  hPort := CreateFile('\\.\COM3', GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0);

  if hPort = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur ouverture: ', GetLastError);
    Exit;
  end;

  // Configurer
  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(hPort, DCB);
  DCB.BaudRate := CBR_115200;
  DCB.ByteSize := 8;
  DCB.Parity := NOPARITY;
  DCB.StopBits := ONESTOPBIT;
  DCB.fBinary := 1;
  SetCommState(hPort, DCB);

  // Timeouts
  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;
  SetCommTimeouts(hPort, Timeouts);

  WriteLn('Port COM3 ouvert √† 115200 bauds');

  // Boucle echo
  while True do
  begin
    if ReadFile(hPort, Buffer, SizeOf(Buffer), BytesRead, nil) and (BytesRead > 0) then
    begin
      WriteFile(hPort, Buffer, BytesRead, BytesWritten, nil);
      WriteLn('Echo: ', BytesRead, ' octets');
    end;

    Sleep(10);
  end;

  CloseHandle(hPort);
end.
```

**Linux (POSIX API) :**

```pascal
program EchoSerieLinux;

{$mode objfpc}{$H+}

uses
  BaseUnix, Unix, termio, SysUtils;

var
  fd: Integer;
  Buffer: array[0..255] of Byte;
  BytesRead, BytesWritten: TSsize;
  options: termios;

begin
  // Ouvrir
  fd := fpOpen('/dev/ttyUSB0', O_RDWR or O_NOCTTY);

  if fd = -1 then
  begin
    WriteLn('Erreur ouverture: ', fpgeterrno);

    if fpgeterrno = ESysEACCES then
      WriteLn('Solution: sudo usermod -a -G dialout $USER');

    Exit;
  end;

  // Configurer
  tcgetattr(fd, @options);
  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;
  cfsetispeed(@options, B115200);
  cfsetospeed(@options, B115200);
  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 0;
  tcsetattr(fd, TCSANOW, @options);
  tcflush(fd, TCIOFLUSH);

  WriteLn('Port /dev/ttyUSB0 ouvert √† 115200 bauds');

  // Boucle echo
  while True do
  begin
    BytesRead := fpRead(fd, Buffer, SizeOf(Buffer));

    if BytesRead > 0 then
    begin
      BytesWritten := fpWrite(fd, Buffer, BytesRead);
      WriteLn('Echo: ', BytesRead, ' octets');
    end;

    Sleep(10);
  end;

  fpClose(fd);
end.
```

### Tableau comparatif des diff√©rences

| Aspect | Windows | Linux |
|--------|---------|-------|
| **Ouverture** | `CreateFile('\\.\COM3', ...)` | `fpOpen('/dev/ttyUSB0', ...)` |
| **Configuration** | Structure `DCB` | Structure `termios` |
| **Vitesse** | `DCB.BaudRate := CBR_115200` | `cfsetispeed(@opt, B115200)` |
| **Bits donn√©es** | `DCB.ByteSize := 8` | `opt.c_cflag := CS8` |
| **Parit√©** | `DCB.Parity := NOPARITY` | Pas de flag parit√© |
| **Stop bits** | `DCB.StopBits := ONESTOPBIT` | Pas de flag CSTOPB |
| **Timeouts** | Structure `COMMTIMEOUTS` | `VMIN` et `VTIME` |
| **Lecture** | `ReadFile(h, buf, size, read, nil)` | `fpRead(fd, buf, size)` |
| **√âcriture** | `WriteFile(h, buf, size, written, nil)` | `fpWrite(fd, buf, size)` |
| **Vider buffers** | `PurgeComm(h, flags)` | `tcflush(fd, flags)` |
| **Fermeture** | `CloseHandle(h)` | `fpClose(fd)` |
| **Type handle** | `THandle` (pointeur) | `Integer` (file descriptor) |
| **Valeur invalide** | `INVALID_HANDLE_VALUE` | `-1` |
| **Code erreur** | `GetLastError` | `fpgeterrno` |

### Portabilit√© entre Windows et Linux

**Approche 1 : Directives conditionnelles**

```pascal
unit UnitSerialPortMulti;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils
  {$IFDEF WINDOWS}
  , Windows
  {$ENDIF}
  {$IFDEF UNIX}
  , BaseUnix, Unix, termio
  {$ENDIF};

type
  TSerialPort = class
  private
    {$IFDEF WINDOWS}
    FHandle: THandle;
    {$ENDIF}
    {$IFDEF UNIX}
    FFD: Integer;
    {$ENDIF}
    FDeviceName: string;
    FBaudRate: Integer;
    FConnected: Boolean;
  public
    function Open(const DeviceName: string; BaudRate: Integer): Boolean;
    procedure Close;
    function Read(var Buffer; Size: Integer): Integer;
    function Write(const Buffer; Size: Integer): Integer;
    property Connected: Boolean read FConnected;
  end;

implementation

function TSerialPort.Open(const DeviceName: string; BaudRate: Integer): Boolean;
{$IFDEF WINDOWS}
var
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;
{$ENDIF}
{$IFDEF UNIX}
var
  options: termios;
  speed: speed_t;
{$ENDIF}
begin
  Result := False;
  FDeviceName := DeviceName;
  FBaudRate := BaudRate;

  {$IFDEF WINDOWS}
  FHandle := CreateFile(PChar('\\.\' + DeviceName),
    GENERIC_READ or GENERIC_WRITE, 0, nil, OPEN_EXISTING, 0, 0);

  if FHandle = INVALID_HANDLE_VALUE then
    Exit;

  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(FHandle, DCB);
  DCB.BaudRate := BaudRate;
  DCB.ByteSize := 8;
  DCB.Parity := NOPARITY;
  DCB.StopBits := ONESTOPBIT;
  DCB.fBinary := 1;
  SetCommState(FHandle, DCB);

  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;
  SetCommTimeouts(FHandle, Timeouts);
  {$ENDIF}

  {$IFDEF UNIX}
  FFD := fpOpen(DeviceName, O_RDWR or O_NOCTTY);

  if FFD = -1 then
    Exit;

  // Convertir baud rate
  case BaudRate of
    9600: speed := B9600;
    19200: speed := B19200;
    38400: speed := B38400;
    57600: speed := B57600;
    115200: speed := B115200;
    else speed := B9600;
  end;

  tcgetattr(FFD, @options);
  options.c_iflag := 0;
  options.c_oflag := 0;
  options.c_lflag := 0;
  options.c_cflag := CS8 or CREAD or CLOCAL;
  cfsetispeed(@options, speed);
  cfsetospeed(@options, speed);
  options.c_cc[VMIN] := 0;
  options.c_cc[VTIME] := 0;
  tcsetattr(FFD, TCSANOW, @options);
  tcflush(FFD, TCIOFLUSH);
  {$ENDIF}

  FConnected := True;
  Result := True;
end;

procedure TSerialPort.Close;
begin
  if not FConnected then
    Exit;

  {$IFDEF WINDOWS}
  CloseHandle(FHandle);
  {$ENDIF}

  {$IFDEF UNIX}
  fpClose(FFD);
  {$ENDIF}

  FConnected := False;
end;

function TSerialPort.Read(var Buffer; Size: Integer): Integer;
begin
  Result := 0;

  if not FConnected then
    Exit;

  {$IFDEF WINDOWS}
  var BytesRead: DWORD;
  if ReadFile(FHandle, Buffer, Size, BytesRead, nil) then
    Result := BytesRead;
  {$ENDIF}

  {$IFDEF UNIX}
  Result := fpRead(FFD, Buffer, Size);
  if Result < 0 then
    Result := 0;
  {$ENDIF}
end;

function TSerialPort.Write(const Buffer; Size: Integer): Integer;
begin
  Result := 0;

  if not FConnected then
    Exit;

  {$IFDEF WINDOWS}
  var BytesWritten: DWORD;
  if WriteFile(FHandle, Buffer, Size, BytesWritten, nil) then
    Result := BytesWritten;
  {$ENDIF}

  {$IFDEF UNIX}
  Result := fpWrite(FFD, Buffer, Size);
  if Result < 0 then
    Result := 0;
  {$ENDIF}
end;

end.
```

**Utilisation (m√™me code sur Windows et Linux) :**

```pascal
program TestMultiPlatform;

uses
  SysUtils, UnitSerialPortMulti;

var
  Serial: TSerialPort;
  Buffer: array[0..255] of Byte;
  BytesRead: Integer;

begin
  Serial := TSerialPort.Create;

  try
    {$IFDEF WINDOWS}
    if Serial.Open('COM3', 115200) then
    {$ENDIF}
    {$IFDEF UNIX}
    if Serial.Open('/dev/ttyUSB0', 115200) then
    {$ENDIF}
    begin
      WriteLn('Port ouvert');

      Serial.Write('Hello'#10, 6);

      Sleep(100);

      BytesRead := Serial.Read(Buffer, SizeOf(Buffer));
      if BytesRead > 0 then
        WriteLn('Re√ßu: ', BytesRead, ' octets');

      Serial.Close;
    end
    else
      WriteLn('Erreur ouverture');
  finally
    Serial.Free;
  end;
end.
```

## Recommandations finales

### Pour d√©buter

**1. Commencez simple :**
```bash
# Test avec outil en ligne de commande
screen /dev/ttyUSB0 115200

# Puis √©crivez un programme minimal
```

**2. V√©rifiez toujours les permissions :**
```bash
sudo usermod -a -G dialout $USER
# PUIS SE D√âCONNECTER/RECONNECTER
```

**3. Utilisez les outils de debug :**
```bash
dmesg | grep tty    # Voir d√©tection
lsusb               # Voir p√©riph√©riques USB
stty -F /dev/ttyUSB0 -a  # Voir configuration
```

### Pour production

**1. G√©rer les erreurs proprement :**
```pascal
if fd = -1 then
begin
  case fpgeterrno of
    ESysEACCES: ShowMessage('Permission refus√©e');
    ESysENOENT: ShowMessage('P√©riph√©rique inexistant');
    ESysEBUSY: ShowMessage('Port occup√©');
  end;
  Exit;
end;
```

**2. Utiliser des threads pour lecture :**
```pascal
// Thread d√©di√© √©vite blocage interface
TThreadLecture = class(TThread)
  // ... lecture en arri√®re-plan
end;
```

**3. Impl√©menter reconnexion automatique :**
```pascal
procedure TentativeReconnexion;
begin
  while not Connected do
  begin
    try
      Open(...);
      Break;
    except
      Sleep(1000);
    end;
  end;
end;
```

**4. Logger les communications :**
```pascal
procedure LogData(const Direction: string; const Data; Size: Integer);
begin
  WriteLn(FormatDateTime('hh:nn:ss', Now), ' ', Direction, ': ',
    BytesToHex(Data, Size));
end;
```

### Biblioth√®ques recommand√©es

**Synapse (Multi-plateforme) :**
- Abstraction Windows/Linux transparente
- Support TCP/IP + s√©rie
- Stable et √©prouv√©e
- URL: http://synapse.ararat.cz

**Utilisation Synapse :**
```pascal
uses
  synaser;

var
  ser: TBlockSerial;

begin
  ser := TBlockSerial.Create;
  try
    ser.Connect('/dev/ttyUSB0');
    ser.Config(115200, 8, 'N', SB1, False, False);

    if ser.LastError = 0 then
    begin
      ser.SendString('Hello'#10);
      WriteLn(ser.RecvString(1000));  // Timeout 1s
    end;
  finally
    ser.Free;
  end;
end.
```

## Ressources compl√©mentaires

### Documentation essentielle

**Pages man Linux :**
```bash
man termios     # Configuration port s√©rie
man tcsetattr   # Fonctions configuration
man select      # Multiplexage I/O
man ioctl_tty   # Contr√¥le terminal
```

**Kernel Documentation :**
- Serial HOWTO: https://tldp.org/HOWTO/Serial-HOWTO.html
- Linux Serial Programming: https://en.wikibooks.org/wiki/Serial_Programming

**FreePascal Documentation :**
- FreePascal Wiki: https://wiki.freepascal.org
- Section "Serial Port Programming"

### Communaut√© et support

**Forums :**
- Forum Lazarus: https://forum.lazarus.freepascal.org
- Stack Overflow: Tag `freepascal` + `serial-port`
- Reddit: r/freepascal

**GitHub :**
- Chercher: "freepascal serial" ou "lazarus serial"
- Exemples de code r√©els et test√©s

### Projets open source utilisant s√©rie

**Exemples √† √©tudier :**
- PascalSCADA: Framework industriel avec communication s√©rie
- mORMot: Framework avec support s√©rie
- Divers projets Arduino + FreePascal

## Exercice final : Projet complet

Pour valider votre apprentissage, cr√©ez un **moniteur de temp√©rature multi-capteurs** :

**Sp√©cifications :**
- Lire 3 capteurs DS18B20 via Arduino
- Interface Lazarus avec graphique temps r√©el
- Logging dans fichier CSV
- Alarmes configurables
- Support Windows ET Linux

**Architecture sugg√©r√©e :**
```
[Arduino] ‚Üês√©rie‚Üí [Application FreePascal]
                       ‚Üì
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ         ‚îÇ
            [GUI Lazarus] [Thread]
                  ‚îÇ         ‚îÇ
              [Graphique] [Logger]
```

## Conclusion g√©n√©rale

Vous ma√Ætrisez maintenant la **communication s√©rie multi-plateforme** avec FreePascal :

**Comp√©tences acquises :**
- ‚úÖ Comprendre architecture ports s√©rie Windows et Linux
- ‚úÖ Configurer et ouvrir ports s√©rie
- ‚úÖ Lire et √©crire donn√©es (texte et binaire)
- ‚úÖ G√©rer timeouts et flow control
- ‚úÖ Contr√¥ler signaux mat√©riels (DTR, RTS)
- ‚úÖ √ânum√©rer ports disponibles
- ‚úÖ D√©boguer probl√®mes courants
- ‚úÖ Optimiser performances
- ‚úÖ Cr√©er applications GUI avec Lazarus
- ‚úÖ √âcrire code portable Windows/Linux

**Applications possibles :**
- ü§ñ Communication avec Arduino/STM32
- üì° Lecture GPS et t√©l√©m√©trie
- üè≠ Protocoles industriels (ModBus RTU)
- üî¨ Instrumentation scientifique
- üìä Acquisition de donn√©es multi-capteurs
- üéÆ Interfaces de contr√¥le personnalis√©es

**Prochaines √©tapes sugg√©r√©es :**
1. Impl√©menter un protocole binaire personnalis√©
2. Cr√©er un analyseur de protocole (type Wireshark pour s√©rie)
3. Int√©grer avec base de donn√©es pour logging long terme
4. D√©velopper interface web (serveur s√©rie ‚Üí WebSocket)
5. Explorer RS-485 pour r√©seaux multi-points

**N'oubliez pas :**
- Toujours v√©rifier permissions sur Linux
- G√©rer proprement les erreurs et reconnexions
- Documenter votre protocole de communication
- Tester sur vraie mat√©riel, pas seulement en simulation
- Contribuer √† la communaut√© (partager vos biblioth√®ques)

**Bon d√©veloppement s√©rie avec FreePascal ! üöÄ**

---

*Ce tutoriel fait partie du module 14.6 "Communication s√©rie" de la formation "FreePascal/Lazarus - Niveau D√©veloppeur Avanc√© - Edition Multi-plateforme Windows/Ubuntu"*

*Section pr√©c√©dente : 14.6.1 Ports COM Windows*

*Prochaine section : 14.7 GPIO et interfaces mat√©rielles*

‚è≠Ô∏è [GPIO et interfaces mat√©rielles](/14-systemes-embarques-iot/07-gpio-interfaces-materielles.md)
