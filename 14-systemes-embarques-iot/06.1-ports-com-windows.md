üîù Retour au [Sommaire](/SOMMAIRE.md)

# 14.6.1 Ports COM Windows

## Introduction

Sur Windows, les ports s√©rie sont appel√©s **ports COM** (pour "Communication"). Chaque port s√©rie physique ou √©mul√© (USB-Serial) se voit attribuer un nom unique : COM1, COM2, COM3, etc.

Cette section vous apprendra √† manipuler ces ports COM depuis FreePascal sur Windows, en utilisant l'API Win32 native pour obtenir des performances optimales et un contr√¥le complet.

## Architecture des ports COM sous Windows

### Nomenclature et num√©rotation

**Format** : `COM` suivi d'un num√©ro de 1 √† 256

**Exemples :**
- `COM1`, `COM2` : ports s√©rie natifs (carte m√®re, anciens PC)
- `COM3`, `COM4` : souvent utilis√©s par adaptateurs USB-Serial
- `COM10`, `COM15`, etc. : num√©ros automatiquement attribu√©s

**Particularit√© Windows :** Pour les num√©ros ‚â• 10, il faut utiliser la syntaxe `\\.\COMxx`

```pascal
// Correct pour tous les num√©ros
'\\.\COM1'
'\\.\COM3'
'\\.\COM15'
'\\.\COM256'
```

### Gestionnaire de p√©riph√©riques

Pour voir les ports COM disponibles sur votre syst√®me :

1. **Windows + X** ‚Üí Gestionnaire de p√©riph√©riques
2. D√©velopper **Ports (COM et LPT)**
3. Voir la liste des ports avec leur num√©ro

**Exemple d'affichage :**
```
Ports (COM et LPT)
‚îú‚îÄ Port de communications (COM1)
‚îú‚îÄ USB Serial Port (COM3)
‚îî‚îÄ Prolific USB-to-Serial Comm Port (COM4)
```

### Types de ports COM

**1. Ports s√©rie physiques (rares aujourd'hui)**
- Connecteur DB9 sur la carte m√®re
- G√©n√©ralement COM1 ou COM2
- Vitesse limit√©e (115200 bauds max)

**2. Adaptateurs USB-Serial (les plus courants)**
- Puces FTDI (FT232, FT234X)
- Prolific (PL2303)
- CH340/CH341 (tr√®s r√©pandus sur Arduino clones)
- CP210x (Silicon Labs)

**3. Ports virtuels**
- Bluetooth Serial Port
- Null-modem virtuel (com0com)
- √âmulateurs de terminal

## API Win32 pour les ports s√©rie

Windows fournit une API compl√®te pour manipuler les ports s√©rie, bas√©e sur le concept de **fichiers** (comme sous Unix).

### Fonctions principales

| Fonction | Usage |
|----------|-------|
| `CreateFile()` | Ouvrir un port COM |
| `CloseHandle()` | Fermer un port COM |
| `ReadFile()` | Lire des donn√©es |
| `WriteFile()` | √âcrire des donn√©es |
| `SetCommState()` | Configurer param√®tres (vitesse, bits, etc.) |
| `SetCommTimeouts()` | D√©finir timeouts lecture/√©criture |
| `GetCommState()` | Lire configuration actuelle |
| `PurgeComm()` | Vider les buffers |
| `SetCommMask()` | D√©finir √©v√©nements √† surveiller |
| `WaitCommEvent()` | Attendre un √©v√©nement |

### Structures importantes

**DCB (Device Control Block)** : configuration du port

```pascal
type
  TDCB = record
    DCBlength: DWORD;
    BaudRate: DWORD;           // Vitesse (9600, 115200, etc.)
    fBinary: DWORD;            // Flags (1 bit chacun)
    // fParity, fOutxCtsFlow, fOutxDsrFlow, etc.
    wReserved: WORD;
    XonLim: WORD;
    XoffLim: WORD;
    ByteSize: Byte;            // Bits de donn√©es (7, 8)
    Parity: Byte;              // Parit√© (NOPARITY, EVENPARITY, etc.)
    StopBits: Byte;            // Bits de stop (ONESTOPBIT, etc.)
    XonChar: AnsiChar;
    XoffChar: AnsiChar;
    ErrorChar: AnsiChar;
    EofChar: AnsiChar;
    EvtChar: AnsiChar;
    wReserved1: WORD;
  end;
```

**COMMTIMEOUTS** : d√©lais d'attente

```pascal
type
  TCOMMTIMEOUTS = record
    ReadIntervalTimeout: DWORD;
    ReadTotalTimeoutMultiplier: DWORD;
    ReadTotalTimeoutConstant: DWORD;
    WriteTotalTimeoutMultiplier: DWORD;
    WriteTotalTimeoutConstant: DWORD;
  end;
```

## Ouverture d'un port COM

### Fonction CreateFile

```pascal
function CreateFile(
  lpFileName: PChar;              // Nom du port '\\.\COM3'
  dwDesiredAccess: DWORD;         // GENERIC_READ or GENERIC_WRITE
  dwShareMode: DWORD;             // 0 (exclusif)
  lpSecurityAttributes: Pointer;  // nil
  dwCreationDisposition: DWORD;   // OPEN_EXISTING
  dwFlagsAndAttributes: DWORD;    // 0 ou FILE_FLAG_OVERLAPPED
  hTemplateFile: THandle          // 0
): THandle;
```

### Exemple simple

```pascal
uses
  Windows;

var
  hPort: THandle;

begin
  // Ouvrir COM3 en lecture/√©criture
  hPort := CreateFile(
    '\\.\COM3',                        // Nom du port
    GENERIC_READ or GENERIC_WRITE,     // Acc√®s lecture + √©criture
    0,                                 // Mode exclusif
    nil,                               // Pas de s√©curit√© sp√©ciale
    OPEN_EXISTING,                     // Le port doit exister
    0,                                 // Mode synchrone
    0                                  // Pas de template
  );

  if hPort = INVALID_HANDLE_VALUE then
  begin
    WriteLn('Erreur: impossible d''ouvrir COM3');
    WriteLn('Code erreur: ', GetLastError);
    Exit;
  end;

  WriteLn('Port COM3 ouvert avec succ√®s');

  // ... utiliser le port ...

  // Fermer le port
  CloseHandle(hPort);
end.
```

### Gestion des erreurs

**Codes d'erreur courants :**

| Code | Constante | Signification |
|------|-----------|---------------|
| 2 | ERROR_FILE_NOT_FOUND | Port inexistant |
| 5 | ERROR_ACCESS_DENIED | Port d√©j√† utilis√© |
| 31 | ERROR_GEN_FAILURE | Erreur mat√©rielle |

```pascal
var
  LastError: DWORD;

begin
  hPort := CreateFile('\\.\COM3', ...);

  if hPort = INVALID_HANDLE_VALUE then
  begin
    LastError := GetLastError;

    case LastError of
      ERROR_FILE_NOT_FOUND:
        WriteLn('Le port COM3 n''existe pas');
      ERROR_ACCESS_DENIED:
        WriteLn('Le port COM3 est d√©j√† utilis√© par une autre application');
      else
        WriteLn('Erreur inconnue: ', LastError);
    end;

    Exit;
  end;
end.
```

## Configuration du port COM

### Structure DCB et param√®tres

Une fois le port ouvert, il faut le configurer avec les bons param√®tres.

```pascal
uses
  Windows;

procedure ConfigurerPort(hPort: THandle);  
var
  DCB: TDCB;
begin
  // Initialiser la structure
  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);

  // R√©cup√©rer config actuelle
  if not GetCommState(hPort, DCB) then
  begin
    WriteLn('Erreur GetCommState');
    Exit;
  end;

  // Modifier les param√®tres
  DCB.BaudRate := CBR_115200;    // 115200 bauds
  DCB.ByteSize := 8;             // 8 bits de donn√©es
  DCB.Parity := NOPARITY;        // Pas de parit√©
  DCB.StopBits := ONESTOPBIT;    // 1 bit de stop

  // Flags importants
  DCB.fBinary := 1;              // Mode binaire (obligatoire)
  DCB.fParity := 0;              // Pas de v√©rification parit√©
  DCB.fOutxCtsFlow := 0;         // Pas de flow control CTS
  DCB.fOutxDsrFlow := 0;         // Pas de flow control DSR
  DCB.fDtrControl := DTR_CONTROL_ENABLE;   // DTR activ√©
  DCB.fRtsControl := RTS_CONTROL_ENABLE;   // RTS activ√©
  DCB.fOutX := 0;                // Pas de XON/XOFF en sortie
  DCB.fInX := 0;                 // Pas de XON/XOFF en entr√©e

  // Appliquer la configuration
  if not SetCommState(hPort, DCB) then
  begin
    WriteLn('Erreur SetCommState');
    Exit;
  end;

  WriteLn('Port configur√© : 115200-8-N-1');
end;
```

### Constantes de vitesse (Baud Rate)

Windows d√©finit des constantes pr√©d√©finies :

```pascal
const
  CBR_110    = 110;
  CBR_300    = 300;
  CBR_600    = 600;
  CBR_1200   = 1200;
  CBR_2400   = 2400;
  CBR_4800   = 4800;
  CBR_9600   = 9600;
  CBR_14400  = 14400;
  CBR_19200  = 19200;
  CBR_38400  = 38400;
  CBR_56000  = 56000;
  CBR_57600  = 57600;
  CBR_115200 = 115200;
  CBR_128000 = 128000;
  CBR_256000 = 256000;
```

**Note :** On peut aussi utiliser des valeurs personnalis√©es :

```pascal
DCB.BaudRate := 230400;  // 230400 bauds (non standard mais fonctionne)
```

### Constantes de parit√©

```pascal
const
  NOPARITY    = 0;  // Pas de parit√© (le plus courant)
  ODDPARITY   = 1;  // Parit√© impaire
  EVENPARITY  = 2;  // Parit√© paire
  MARKPARITY  = 3;  // Toujours 1
  SPACEPARITY = 4;  // Toujours 0
```

### Constantes de bits de stop

```pascal
const
  ONESTOPBIT   = 0;  // 1 bit de stop (standard)
  ONE5STOPBITS = 1;  // 1.5 bits de stop
  TWOSTOPBITS  = 2;  // 2 bits de stop
```

## Configuration des timeouts

Les timeouts contr√¥lent combien de temps Windows attendra lors d'une lecture ou √©criture.

### Structure COMMTIMEOUTS

```pascal
procedure ConfigurerTimeouts(hPort: THandle);  
var
  Timeouts: TCOMMTIMEOUTS;
begin
  // Configuration pour lecture imm√©diate (non-bloquante)
  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;

  // Pas de timeout en √©criture
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  if not SetCommTimeouts(hPort, Timeouts) then
    WriteLn('Erreur SetCommTimeouts');
end;
```

### Configurations courantes

**1. Lecture non-bloquante (retour imm√©diat)**

```pascal
// Retourne imm√©diatement, m√™me si aucune donn√©e
Timeouts.ReadIntervalTimeout := MAXDWORD;  
Timeouts.ReadTotalTimeoutMultiplier := 0;  
Timeouts.ReadTotalTimeoutConstant := 0;
```

**2. Lecture avec timeout fixe (ex: 1 seconde)**

```pascal
// Attend max 1000 ms
Timeouts.ReadIntervalTimeout := 0;  
Timeouts.ReadTotalTimeoutMultiplier := 0;  
Timeouts.ReadTotalTimeoutConstant := 1000;  // 1000 ms
```

**3. Lecture bloquante (attente infinie)**

```pascal
// Attend ind√©finiment
Timeouts.ReadIntervalTimeout := 0;  
Timeouts.ReadTotalTimeoutMultiplier := 0;  
Timeouts.ReadTotalTimeoutConstant := 0;
```

## Lecture de donn√©es

### Fonction ReadFile

```pascal
function ReadFile(
  hFile: THandle;              // Handle du port
  var Buffer;                  // Buffer de r√©ception
  nNumberOfBytesToRead: DWORD; // Nombre d'octets √† lire
  var lpNumberOfBytesRead: DWORD; // Nombre effectivement lus
  lpOverlapped: POverlapped    // nil en mode synchrone
): BOOL;
```

### Exemple de lecture simple

```pascal
var
  hPort: THandle;
  Buffer: array[0..255] of Byte;
  BytesRead: DWORD;
  i: Integer;

begin
  // ... ouvrir et configurer le port ...

  // Lire jusqu'√† 256 octets
  if ReadFile(hPort, Buffer, SizeOf(Buffer), BytesRead, nil) then
  begin
    WriteLn('Re√ßu ', BytesRead, ' octets:');

    // Afficher en hexad√©cimal
    for i := 0 to BytesRead - 1 do
      Write(IntToHex(Buffer[i], 2), ' ');
    WriteLn;
  end
  else
    WriteLn('Erreur ReadFile: ', GetLastError);
end.
```

### Lecture de texte ligne par ligne

```pascal
function LireLigne(hPort: THandle): string;  
var
  c: AnsiChar;
  BytesRead: DWORD;
  ligne: string;
begin
  Result := '';
  ligne := '';

  repeat
    // Lire 1 caract√®re
    if not ReadFile(hPort, c, 1, BytesRead, nil) then
      Break;

    if BytesRead = 0 then
      Break;  // Timeout ou fin de donn√©es

    if c = #13 then  // CR (retour chariot)
      Continue;      // Ignorer

    if c = #10 then  // LF (nouvelle ligne)
      Break;         // Fin de ligne

    ligne := ligne + c;
  until False;

  Result := ligne;
end;

// Utilisation
var
  ligne: string;
begin
  ligne := LireLigne(hPort);
  if ligne <> '' then
    WriteLn('Ligne re√ßue: ', ligne);
end.
```

### V√©rifier si des donn√©es sont disponibles

```pascal
function DonneesDisponibles(hPort: THandle): Boolean;  
var
  Errors: DWORD;
  ComStat: TCOMSTAT;
begin
  ClearCommError(hPort, Errors, @ComStat);
  Result := ComStat.cbInQue > 0;
end;

// Utilisation
if DonneesDisponibles(hPort) then
  WriteLn('Il y a des donn√©es √† lire');
```

## √âcriture de donn√©es

### Fonction WriteFile

```pascal
function WriteFile(
  hFile: THandle;                 // Handle du port
  const Buffer;                   // Donn√©es √† envoyer
  nNumberOfBytesToWrite: DWORD;   // Nombre d'octets
  var lpNumberOfBytesWritten: DWORD; // Nombre effectivement √©crits
  lpOverlapped: POverlapped       // nil en mode synchrone
): BOOL;
```

### Exemple d'√©criture simple

```pascal
procedure EnvoyerTexte(hPort: THandle; const texte: string);  
var
  BytesWritten: DWORD;
begin
  if not WriteFile(hPort, texte[1], Length(texte), BytesWritten, nil) then
  begin
    WriteLn('Erreur WriteFile: ', GetLastError);
    Exit;
  end;

  WriteLn('Envoy√© ', BytesWritten, ' octets');
end;

// Utilisation
EnvoyerTexte(hPort, 'Hello Arduino'#13#10);
```

### Envoi de donn√©es binaires

```pascal
procedure EnvoyerDonnees(hPort: THandle; const data: array of Byte; len: Integer);  
var
  BytesWritten: DWORD;
begin
  if not WriteFile(hPort, data[0], len, BytesWritten, nil) then
    WriteLn('Erreur √©criture')
  else if BytesWritten <> len then
    WriteLn('√âcriture incompl√®te: ', BytesWritten, '/', len);
end;

// Utilisation
var
  commande: array[0..4] of Byte = ($AA, $55, $01, $02, $03);
begin
  EnvoyerDonnees(hPort, commande, 5);
end.
```

### Vider les buffers

Avant d'envoyer des donn√©es importantes, il est parfois utile de vider les buffers :

```pascal
procedure ViderBuffers(hPort: THandle);  
begin
  // PURGE_TXABORT : annuler √©criture en cours
  // PURGE_RXABORT : annuler lecture en cours
  // PURGE_TXCLEAR : vider buffer √©mission
  // PURGE_RXCLEAR : vider buffer r√©ception

  PurgeComm(hPort, PURGE_TXCLEAR or PURGE_RXCLEAR);
end;
```

## Cr√©ation d'une classe SerialPort

Pour simplifier l'utilisation, cr√©ons une classe r√©utilisable :

```pascal
unit UnitSerialPort;

{$mode objfpc}{$H+}

interface

uses
  Windows, SysUtils;

type
  TSerialPort = class
  private
    FHandle: THandle;
    FPortName: string;
    FBaudRate: DWORD;
    FConnected: Boolean;
  public
    constructor Create(const PortName: string; BaudRate: DWORD = CBR_115200);
    destructor Destroy; override;

    function Open: Boolean;
    procedure Close;

    function ReadData(var Buffer; Size: DWORD): DWORD;
    function WriteData(const Buffer; Size: DWORD): DWORD;

    function ReadString: string;
    procedure WriteString(const Data: string);

    function Available: Integer;
    procedure Flush;

    property Connected: Boolean read FConnected;
    property PortName: string read FPortName;
    property BaudRate: DWORD read FBaudRate;
  end;

implementation

constructor TSerialPort.Create(const PortName: string; BaudRate: DWORD);  
begin
  inherited Create;

  FPortName := PortName;
  FBaudRate := BaudRate;
  FConnected := False;
  FHandle := INVALID_HANDLE_VALUE;
end;

destructor TSerialPort.Destroy;  
begin
  Close;
  inherited Destroy;
end;

function TSerialPort.Open: Boolean;  
var
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;
  FullPortName: string;
begin
  Result := False;

  if FConnected then
    Exit;

  // Format: \\.\COMx
  if Pos('\\.\', FPortName) = 0 then
    FullPortName := '\\.\' + FPortName
  else
    FullPortName := FPortName;

  // Ouvrir le port
  FHandle := CreateFile(
    PChar(FullPortName),
    GENERIC_READ or GENERIC_WRITE,
    0,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  if FHandle = INVALID_HANDLE_VALUE then
    Exit;

  // Configuration DCB
  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);

  if not GetCommState(FHandle, DCB) then
  begin
    CloseHandle(FHandle);
    FHandle := INVALID_HANDLE_VALUE;
    Exit;
  end;

  DCB.BaudRate := FBaudRate;
  DCB.ByteSize := 8;
  DCB.Parity := NOPARITY;
  DCB.StopBits := ONESTOPBIT;
  DCB.fBinary := 1;
  DCB.fDtrControl := DTR_CONTROL_ENABLE;
  DCB.fRtsControl := RTS_CONTROL_ENABLE;

  if not SetCommState(FHandle, DCB) then
  begin
    CloseHandle(FHandle);
    FHandle := INVALID_HANDLE_VALUE;
    Exit;
  end;

  // Configuration timeouts (lecture non-bloquante)
  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  if not SetCommTimeouts(FHandle, Timeouts) then
  begin
    CloseHandle(FHandle);
    FHandle := INVALID_HANDLE_VALUE;
    Exit;
  end;

  FConnected := True;
  Result := True;
end;

procedure TSerialPort.Close;  
begin
  if FConnected then
  begin
    CloseHandle(FHandle);
    FHandle := INVALID_HANDLE_VALUE;
    FConnected := False;
  end;
end;

function TSerialPort.ReadData(var Buffer; Size: DWORD): DWORD;  
begin
  Result := 0;

  if not FConnected then
    Exit;

  if not ReadFile(FHandle, Buffer, Size, Result, nil) then
    Result := 0;
end;

function TSerialPort.WriteData(const Buffer; Size: DWORD): DWORD;  
begin
  Result := 0;

  if not FConnected then
    Exit;

  if not WriteFile(FHandle, Buffer, Size, Result, nil) then
    Result := 0;
end;

function TSerialPort.ReadString: string;  
var
  Buffer: array[0..255] of AnsiChar;
  BytesRead: DWORD;
begin
  Result := '';

  BytesRead := ReadData(Buffer, SizeOf(Buffer) - 1);

  if BytesRead > 0 then
  begin
    Buffer[BytesRead] := #0;
    Result := string(Buffer);
  end;
end;

procedure TSerialPort.WriteString(const Data: string);  
var
  AnsiData: AnsiString;
begin
  AnsiData := AnsiString(Data);
  WriteData(AnsiData[1], Length(AnsiData));
end;

function TSerialPort.Available: Integer;  
var
  Errors: DWORD;
  ComStat: TCOMSTAT;
begin
  Result := 0;

  if not FConnected then
    Exit;

  if ClearCommError(FHandle, Errors, @ComStat) then
    Result := ComStat.cbInQue;
end;

procedure TSerialPort.Flush;  
begin
  if FConnected then
    PurgeComm(FHandle, PURGE_TXCLEAR or PURGE_RXCLEAR);
end;

end.
```

### Utilisation de la classe

```pascal
program TestSerialPort;

uses
  UnitSerialPort, SysUtils;

var
  Serial: TSerialPort;
  data: string;

begin
  // Cr√©er instance
  Serial := TSerialPort.Create('COM3', CBR_115200);

  try
    // Ouvrir le port
    if not Serial.Open then
    begin
      WriteLn('Erreur: impossible d''ouvrir COM3');
      Exit;
    end;

    WriteLn('Port COM3 ouvert');

    // Envoyer un message
    Serial.WriteString('Hello from FreePascal'#13#10);

    // Lire la r√©ponse
    Sleep(100);  // Attendre un peu

    if Serial.Available > 0 then
    begin
      data := Serial.ReadString;
      WriteLn('Re√ßu: ', data);
    end;

    // Fermer
    Serial.Close;
    WriteLn('Port ferm√©');

  finally
    Serial.Free;
  end;

  ReadLn;
end.
```

## √ânum√©ration des ports COM

Pour lister les ports COM disponibles sur le syst√®me :

### M√©thode 1 : Via le registre Windows

```pascal
uses
  Windows, Registry;

procedure ListerPortsCOM;  
var
  Reg: TRegistry;
  Ports: TStringList;
  i: Integer;
begin
  Reg := TRegistry.Create;
  Ports := TStringList.Create;

  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;

    if Reg.OpenKeyReadOnly('\HARDWARE\DEVICEMAP\SERIALCOMM') then
    begin
      Reg.GetValueNames(Ports);

      WriteLn('Ports COM disponibles:');
      for i := 0 to Ports.Count - 1 do
        WriteLn('  ', Reg.ReadString(Ports[i]));

      Reg.CloseKey;
    end
    else
      WriteLn('Aucun port COM trouv√©');
  finally
    Ports.Free;
    Reg.Free;
  end;
end;
```

### M√©thode 2 : Tentative d'ouverture

```pascal
function PortCOMExiste(NumPort: Integer): Boolean;  
var
  hPort: THandle;
  PortName: string;
begin
  PortName := '\\.\COM' + IntToStr(NumPort);

  hPort := CreateFile(
    PChar(PortName),
    GENERIC_READ or GENERIC_WRITE,
    0,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  Result := (hPort <> INVALID_HANDLE_VALUE);

  if Result then
    CloseHandle(hPort);
end;

procedure ScannerPortsCOM;  
var
  i: Integer;
begin
  WriteLn('Scan des ports COM (1-20):');

  for i := 1 to 20 do
  begin
    if PortCOMExiste(i) then
      WriteLn('  COM', i, ' : disponible')
    else
      WriteLn('  COM', i, ' : inexistant ou utilis√©');
  end;
end;

// Utilisation
begin
  ScannerPortsCOM;
end.
```

**Note :** Cette m√©thode peut √™tre lente car elle tente d'ouvrir chaque port. Elle d√©tecte aussi les ports d√©j√† utilis√©s (qui apparaissent comme "inexistant ou utilis√©").

### M√©thode 3 : Via QueryDosDevice (recommand√©e)

Cette m√©thode est la plus rapide et la plus fiable :

```pascal
uses
  Windows, SysUtils;

procedure ListerPortsCOMAvecQueryDosDevice;  
var
  Buffer: array[0..65535] of Char;
  p: PChar;
  DeviceName: string;
begin
  // R√©cup√©rer tous les devices DOS
  if QueryDosDevice(nil, @Buffer[0], SizeOf(Buffer)) = 0 then
  begin
    WriteLn('Erreur QueryDosDevice');
    Exit;
  end;

  WriteLn('Ports COM d√©tect√©s:');

  p := @Buffer[0];
  while p^ <> #0 do
  begin
    DeviceName := string(p);

    // Filtrer uniquement les COMx
    if (Length(DeviceName) >= 3) and
       (Copy(DeviceName, 1, 3) = 'COM') then
    begin
      WriteLn('  ', DeviceName);
    end;

    // Passer au device suivant (cha√Ænes termin√©es par #0#0)
    Inc(p, Length(DeviceName) + 1);
  end;
end;
```

### Fonction compl√®te d'√©num√©ration

```pascal
type
  TPortCOMInfo = record
    Nom: string;
    Numero: Integer;
    Disponible: Boolean;
  end;
  TListePortsCOM = array of TPortCOMInfo;

function ObtenirListePortsCOM: TListePortsCOM;  
var
  Buffer: array[0..65535] of Char;
  p: PChar;
  DeviceName: string;
  Liste: TListePortsCOM;
  Count: Integer;
  NumPort: Integer;
  Code: Integer;
begin
  SetLength(Liste, 0);
  Count := 0;

  if QueryDosDevice(nil, @Buffer[0], SizeOf(Buffer)) = 0 then
  begin
    Result := Liste;
    Exit;
  end;

  p := @Buffer[0];
  while p^ <> #0 do
  begin
    DeviceName := string(p);

    if (Length(DeviceName) >= 3) and (Copy(DeviceName, 1, 3) = 'COM') then
    begin
      // Extraire le num√©ro
      Val(Copy(DeviceName, 4, Length(DeviceName) - 3), NumPort, Code);

      if Code = 0 then
      begin
        SetLength(Liste, Count + 1);
        Liste[Count].Nom := DeviceName;
        Liste[Count].Numero := NumPort;
        Liste[Count].Disponible := PortCOMExiste(NumPort);
        Inc(Count);
      end;
    end;

    Inc(p, Length(DeviceName) + 1);
  end;

  Result := Liste;
end;

// Utilisation
var
  Ports: TListePortsCOM;
  i: Integer;
begin
  Ports := ObtenirListePortsCOM;

  WriteLn('Liste des ports COM:');
  for i := 0 to High(Ports) do
  begin
    Write('  ', Ports[i].Nom);
    if Ports[i].Disponible then
      WriteLn(' - Disponible')
    else
      WriteLn(' - Occup√©');
  end;
end.
```

## Communication asynchrone (Overlapped I/O)

Les exemples pr√©c√©dents utilisaient le mode **synchrone** : le programme attend que l'op√©ration se termine. En mode **asynchrone**, le programme peut continuer pendant l'op√©ration.

### Ouverture en mode asynchrone

```pascal
var
  hPort: THandle;
begin
  hPort := CreateFile(
    '\\.\COM3',
    GENERIC_READ or GENERIC_WRITE,
    0,
    nil,
    OPEN_EXISTING,
    FILE_FLAG_OVERLAPPED,  // Mode asynchrone !
    0
  );
end.
```

### Structure OVERLAPPED

```pascal
type
  TOVERLAPPED = record
    Internal: ULONG_PTR;
    InternalHigh: ULONG_PTR;
    case Integer of
      0: (
        Offset: DWORD;
        OffsetHigh: DWORD;
      );
      1: (
        Pointer: Pointer;
      );
    hEvent: THandle;  // Handle d'√©v√©nement
  end;
```

### Lecture asynchrone

```pascal
function LireAsynchrone(hPort: THandle; var Buffer; Size: DWORD): Boolean;  
var
  Overlapped: TOVERLAPPED;
  BytesRead: DWORD;
  LastError: DWORD;
begin
  Result := False;

  // Initialiser structure overlapped
  FillChar(Overlapped, SizeOf(Overlapped), 0);
  Overlapped.hEvent := CreateEvent(nil, True, False, nil);

  if Overlapped.hEvent = 0 then
    Exit;

  try
    // Lancer lecture asynchrone
    if not ReadFile(hPort, Buffer, Size, BytesRead, @Overlapped) then
    begin
      LastError := GetLastError;

      if LastError = ERROR_IO_PENDING then
      begin
        // Op√©ration en cours, attendre
        WriteLn('Lecture en cours...');

        if WaitForSingleObject(Overlapped.hEvent, 5000) = WAIT_OBJECT_0 then
        begin
          // R√©cup√©rer r√©sultat
          if GetOverlappedResult(hPort, Overlapped, BytesRead, False) then
          begin
            WriteLn('Lu ', BytesRead, ' octets');
            Result := True;
          end;
        end
        else
          WriteLn('Timeout !');
      end;
    end
    else
    begin
      // Lecture termin√©e imm√©diatement
      WriteLn('Lu ', BytesRead, ' octets (imm√©diat)');
      Result := True;
    end;
  finally
    CloseHandle(Overlapped.hEvent);
  end;
end;
```

### √âcriture asynchrone

```pascal
function EcrireAsynchrone(hPort: THandle; const Buffer; Size: DWORD): Boolean;  
var
  Overlapped: TOVERLAPPED;
  BytesWritten: DWORD;
begin
  Result := False;

  FillChar(Overlapped, SizeOf(Overlapped), 0);
  Overlapped.hEvent := CreateEvent(nil, True, False, nil);

  if Overlapped.hEvent = 0 then
    Exit;

  try
    if not WriteFile(hPort, Buffer, Size, BytesWritten, @Overlapped) then
    begin
      if GetLastError = ERROR_IO_PENDING then
      begin
        if WaitForSingleObject(Overlapped.hEvent, 5000) = WAIT_OBJECT_0 then
        begin
          if GetOverlappedResult(hPort, Overlapped, BytesWritten, False) then
          begin
            WriteLn('√âcrit ', BytesWritten, ' octets');
            Result := True;
          end;
        end;
      end;
    end
    else
    begin
      WriteLn('√âcrit ', BytesWritten, ' octets (imm√©diat)');
      Result := True;
    end;
  finally
    CloseHandle(Overlapped.hEvent);
  end;
end;
```

## Gestion des √©v√©nements (WaitCommEvent)

Windows peut notifier votre programme quand certains √©v√©nements se produisent sur le port s√©rie.

### Types d'√©v√©nements

```pascal
const
  EV_RXCHAR   = $0001;  // Caract√®re re√ßu
  EV_RXFLAG   = $0002;  // Caract√®re sp√©cial re√ßu
  EV_TXEMPTY  = $0004;  // Buffer √©mission vide
  EV_CTS      = $0008;  // Changement CTS
  EV_DSR      = $0010;  // Changement DSR
  EV_RLSD     = $0020;  // Changement RLSD (DCD)
  EV_BREAK    = $0040;  // Break d√©tect√©
  EV_ERR      = $0080;  // Erreur ligne
  EV_RING     = $0100;  // Ring (sonnerie)
  EV_PERR     = $0200;  // Erreur d'imprimante
  EV_RX80FULL = $0400;  // Buffer r√©ception 80% plein
  EV_EVENT1   = $0800;  // Provider specific event 1
  EV_EVENT2   = $1000;  // Provider specific event 2
```

### Attendre un √©v√©nement

```pascal
procedure AttendreDonnees(hPort: THandle);  
var
  EventMask: DWORD;
  Overlapped: TOVERLAPPED;
begin
  // D√©finir les √©v√©nements √† surveiller
  SetCommMask(hPort, EV_RXCHAR);

  FillChar(Overlapped, SizeOf(Overlapped), 0);
  Overlapped.hEvent := CreateEvent(nil, True, False, nil);

  try
    WriteLn('Attente de donn√©es...');

    if not WaitCommEvent(hPort, EventMask, @Overlapped) then
    begin
      if GetLastError = ERROR_IO_PENDING then
      begin
        // Attendre √©v√©nement
        WaitForSingleObject(Overlapped.hEvent, INFINITE);

        if EventMask and EV_RXCHAR <> 0 then
          WriteLn('Donn√©es re√ßues !');
      end;
    end
    else
    begin
      if EventMask and EV_RXCHAR <> 0 then
        WriteLn('Donn√©es disponibles imm√©diatement !');
    end;
  finally
    CloseHandle(Overlapped.hEvent);
  end;
end;
```

### Thread de surveillance

Pour ne pas bloquer le programme principal, cr√©er un thread :

```pascal
type
  TThreadSurveillanceCOM = class(TThread)
  private
    FHandle: THandle;
    FOnDataReceived: TNotifyEvent;
  protected
    procedure Execute; override;
  public
    constructor Create(Handle: THandle);
    property OnDataReceived: TNotifyEvent read FOnDataReceived write FOnDataReceived;
  end;

constructor TThreadSurveillanceCOM.Create(Handle: THandle);  
begin
  inherited Create(False);  // D√©marrer imm√©diatement
  FreeOnTerminate := True;
  FHandle := Handle;
end;

procedure TThreadSurveillanceCOM.Execute;  
var
  EventMask: DWORD;
  Overlapped: TOVERLAPPED;
begin
  SetCommMask(FHandle, EV_RXCHAR);

  FillChar(Overlapped, SizeOf(Overlapped), 0);
  Overlapped.hEvent := CreateEvent(nil, True, False, nil);

  try
    while not Terminated do
    begin
      if WaitCommEvent(FHandle, EventMask, @Overlapped) then
      begin
        if EventMask and EV_RXCHAR <> 0 then
        begin
          if Assigned(FOnDataReceived) then
            Synchronize(
              procedure
              begin
                FOnDataReceived(Self);
              end
            );
        end;
      end
      else
      begin
        if GetLastError = ERROR_IO_PENDING then
        begin
          WaitForSingleObject(Overlapped.hEvent, 100);

          if EventMask and EV_RXCHAR <> 0 then
          begin
            if Assigned(FOnDataReceived) then
              Synchronize(
                procedure
                begin
                  FOnDataReceived(Self);
                end
              );
          end;
        end;
      end;
    end;
  finally
    CloseHandle(Overlapped.hEvent);
  end;
end;
```

## Gestion des erreurs de communication

### Types d'erreurs

```pascal
const
  CE_RXOVER   = $0001;  // Buffer r√©ception d√©bord√©
  CE_OVERRUN  = $0002;  // Character-buffer overrun
  CE_RXPARITY = $0004;  // Erreur de parit√©
  CE_FRAME    = $0008;  // Erreur de trame (framing)
  CE_BREAK    = $0010;  // Break d√©tect√©
  CE_TXFULL   = $0100;  // Buffer √©mission plein
  CE_PTO      = $0200;  // Printer timeout
  CE_IOE      = $0400;  // I/O error
  CE_DNS      = $0800;  // Device not selected
  CE_OOP      = $1000;  // Out of paper
  CE_MODE     = $8000;  // Mode non support√©
```

### Fonction ClearCommError

```pascal
procedure VerifierErreurs(hPort: THandle);  
var
  Errors: DWORD;
  ComStat: TCOMSTAT;
begin
  if ClearCommError(hPort, Errors, @ComStat) then
  begin
    if Errors <> 0 then
    begin
      WriteLn('Erreurs d√©tect√©es:');

      if Errors and CE_RXOVER <> 0 then
        WriteLn('  - Buffer r√©ception d√©bord√©');

      if Errors and CE_OVERRUN <> 0 then
        WriteLn('  - Character overrun');

      if Errors and CE_RXPARITY <> 0 then
        WriteLn('  - Erreur de parit√©');

      if Errors and CE_FRAME <> 0 then
        WriteLn('  - Erreur de trame');

      if Errors and CE_BREAK <> 0 then
        WriteLn('  - Break d√©tect√©');
    end;

    WriteLn('√âtat des buffers:');
    WriteLn('  R√©ception: ', ComStat.cbInQue, ' octets en attente');
    WriteLn('  √âmission: ', ComStat.cbOutQue, ' octets en attente');
  end;
end;
```

### Strat√©gie de r√©cup√©ration

```pascal
procedure RecupererErreur(hPort: THandle);  
var
  Errors: DWORD;
  ComStat: TCOMSTAT;
begin
  // Effacer les erreurs
  ClearCommError(hPort, Errors, @ComStat);

  // Vider les buffers si n√©cessaire
  if (Errors and CE_RXOVER) <> 0 then
  begin
    WriteLn('Buffer d√©bord√©, vidage...');
    PurgeComm(hPort, PURGE_RXCLEAR);
  end;

  // R√©initialiser timeouts si probl√®me de timing
  if (Errors and CE_FRAME) <> 0 then
  begin
    WriteLn('Erreur de trame, v√©rifier baud rate');
  end;
end;
```

## Contr√¥le des signaux (DTR, RTS, etc.)

### Signaux s√©rie classiques

| Signal | Direction | Description |
|--------|-----------|-------------|
| **DTR** | PC ‚Üí Device | Data Terminal Ready |
| **DSR** | Device ‚Üí PC | Data Set Ready |
| **RTS** | PC ‚Üí Device | Request To Send |
| **CTS** | Device ‚Üí PC | Clear To Send |
| **DCD** | Device ‚Üí PC | Data Carrier Detect |
| **RI** | Device ‚Üí PC | Ring Indicator |

### Fonctions de contr√¥le

```pascal
// Activer DTR
procedure ActiverDTR(hPort: THandle);  
begin
  EscapeCommFunction(hPort, SETDTR);
end;

// D√©sactiver DTR
procedure DesactiverDTR(hPort: THandle);  
begin
  EscapeCommFunction(hPort, CLRDTR);
end;

// Activer RTS
procedure ActiverRTS(hPort: THandle);  
begin
  EscapeCommFunction(hPort, SETRTS);
end;

// D√©sactiver RTS
procedure DesactiverRTS(hPort: THandle);  
begin
  EscapeCommFunction(hPort, CLRRTS);
end;

// Lire l'√©tat des signaux
function LireSignaux(hPort: THandle): DWORD;  
var
  ModemStat: DWORD;
begin
  GetCommModemStatus(hPort, @ModemStat);
  Result := ModemStat;
end;

// V√©rifier CTS
function CTSActif(hPort: THandle): Boolean;  
var
  ModemStat: DWORD;
begin
  GetCommModemStatus(hPort, @ModemStat);
  Result := (ModemStat and MS_CTS_ON) <> 0;
end;

// V√©rifier DSR
function DSRActif(hPort: THandle): Boolean;  
var
  ModemStat: DWORD;
begin
  GetCommModemStatus(hPort, @ModemStat);
  Result := (ModemStat and MS_DSR_ON) <> 0;
end;
```

### Utilisation pratique : Reset Arduino

Arduino se r√©initialise quand DTR passe de HIGH √† LOW :

```pascal
procedure ResetArduino(hPort: THandle);  
begin
  WriteLn('Reset Arduino...');

  // DTR HIGH
  EscapeCommFunction(hPort, SETDTR);
  Sleep(100);

  // DTR LOW ‚Üí reset
  EscapeCommFunction(hPort, CLRDTR);
  Sleep(100);

  // DTR HIGH √† nouveau
  EscapeCommFunction(hPort, SETDTR);

  WriteLn('Arduino red√©marr√©');
end;
```

## Exemples d'applications compl√®tes

### Exemple 1 : Terminal s√©rie simple

```pascal
program TerminalSerie;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils, Crt;

var
  hPort: THandle;
  Buffer: array[0..255] of AnsiChar;
  BytesRead, BytesWritten: DWORD;
  c: Char;
  texte: AnsiString;

function OuvrirPort(const PortName: string; BaudRate: DWORD): THandle;  
var
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;
begin
  Result := CreateFile(
    PChar('\\.\' + PortName),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if Result = INVALID_HANDLE_VALUE then
    Exit;

  // Configuration
  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(Result, DCB);

  DCB.BaudRate := BaudRate;
  DCB.ByteSize := 8;
  DCB.Parity := NOPARITY;
  DCB.StopBits := ONESTOPBIT;
  DCB.fBinary := 1;

  SetCommState(Result, DCB);

  // Timeouts non-bloquants
  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  SetCommTimeouts(Result, Timeouts);
end;

begin
  ClrScr;
  WriteLn('=== Terminal S√©rie FreePascal ===');
  WriteLn('√âchap pour quitter');
  WriteLn;

  // Ouvrir COM3 √† 115200 bauds
  hPort := OuvrirPort('COM3', CBR_115200);

  if hPort = INVALID_HANDLE_VALUE then
  begin
    WriteLn('ERREUR: Impossible d''ouvrir COM3');
    WriteLn('Appuyez sur Entr√©e pour quitter');
    ReadLn;
    Exit;
  end;

  WriteLn('Connect√© √† COM3 (115200-8-N-1)');
  WriteLn('-------------------------------');
  WriteLn;

  texte := '';

  repeat
    // Lire du port s√©rie
    if ReadFile(hPort, Buffer, SizeOf(Buffer), BytesRead, nil) and (BytesRead > 0) then
    begin
      Buffer[BytesRead] := #0;
      Write(string(Buffer));
    end;

    // Lire du clavier
    if KeyPressed then
    begin
      c := ReadKey;

      if c = #27 then  // √âchap
        Break;

      // Envoyer au port s√©rie
      texte := AnsiString(c);
      WriteFile(hPort, texte[1], 1, BytesWritten, nil);

      // Echo local (optionnel)
      // Write(c);
    end;

    Sleep(10);  // Petite pause pour ne pas surcharger CPU

  until False;

  CloseHandle(hPort);
  WriteLn;
  WriteLn('D√©connect√©');
end.
```

### Exemple 2 : Lecture d'un capteur GPS

```pascal
program LecteurGPS;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils, DateUtils;

type
  TDonneesGPS = record
    Latitude: Double;
    Longitude: Double;
    Altitude: Double;
    Vitesse: Double;
    DateHeure: TDateTime;
    NbSatellites: Integer;
    Valide: Boolean;
  end;

var
  hPort: THandle;
  GPS: TDonneesGPS;

function OuvrirPortGPS(const PortName: string): THandle;  
var
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;
begin
  Result := CreateFile(
    PChar('\\.\' + PortName),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if Result = INVALID_HANDLE_VALUE then
    Exit;

  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(Result, DCB);

  // GPS = 9600 bauds typiquement
  DCB.BaudRate := CBR_9600;
  DCB.ByteSize := 8;
  DCB.Parity := NOPARITY;
  DCB.StopBits := ONESTOPBIT;
  DCB.fBinary := 1;

  SetCommState(Result, DCB);

  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 100;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  SetCommTimeouts(Result, Timeouts);
end;

function LireLigne(hPort: THandle): string;  
var
  c: AnsiChar;
  BytesRead: DWORD;
  ligne: string;
begin
  Result := '';
  ligne := '';

  repeat
    if not ReadFile(hPort, c, 1, BytesRead, nil) or (BytesRead = 0) then
      Break;

    if c = #10 then
      Break;

    if c <> #13 then
      ligne := ligne + Char(c);
  until False;

  Result := ligne;
end;

function ParseGPGGA(const trame: string; var GPS: TDonneesGPS): Boolean;  
var
  parties: array of string;
  i, count: Integer;
  s: string;
  sep: Char;
begin
  Result := False;

  // V√©rifier si c'est une trame GPGGA
  if Copy(trame, 1, 6) <> '$GPGGA' then
    Exit;

  // D√©couper par virgules
  SetLength(parties, 15);
  count := 0;
  s := '';

  for i := 1 to Length(trame) do
  begin
    if trame[i] = ',' then
    begin
      if count < 15 then
        parties[count] := s;
      Inc(count);
      s := '';
    end
    else
      s := s + trame[i];
  end;

  // V√©rifier validit√©
  if (count < 6) or (parties[6] = '0') then
    Exit;

  GPS.Valide := True;

  // Parser latitude (parties[2] et [3])
  // Parser longitude (parties[4] et [5])
  // Parser altitude (parties[9])
  // etc.

  // (Code de parsing d√©taill√© omis pour bri√®vet√©)

  Result := True;
end;

var
  ligne: string;

begin
  WriteLn('=== Lecteur GPS ===');

  hPort := OuvrirPortGPS('COM5');

  if hPort = INVALID_HANDLE_VALUE then
  begin
    WriteLn('ERREUR: Impossible d''ouvrir COM5');
    ReadLn;
    Exit;
  end;

  WriteLn('GPS connect√© sur COM5');
  WriteLn('Attente de trames NMEA...');
  WriteLn;

  FillChar(GPS, SizeOf(GPS), 0);

  repeat
    ligne := LireLigne(hPort);

    if ligne <> '' then
    begin
      WriteLn('Trame: ', ligne);

      if ParseGPGGA(ligne, GPS) then
      begin
        WriteLn('Position valide:');
        WriteLn('  Lat: ', GPS.Latitude:0:6);
        WriteLn('  Lon: ', GPS.Longitude:0:6);
        WriteLn('  Alt: ', GPS.Altitude:0:1, ' m');
        WriteLn('  Sat: ', GPS.NbSatellites);
        WriteLn;
      end;
    end;

    Sleep(100);

  until KeyPressed;

  CloseHandle(hPort);
end.
```

### Exemple 3 : Contr√¥le d'un Arduino

```pascal
program ControleArduino;

{$mode objfpc}{$H+}

uses
  Windows, SysUtils, Crt;

var
  hPort: THandle;

function OuvrirArduino(const PortName: string): THandle;  
var
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;
begin
  Result := CreateFile(
    PChar('\\.\' + PortName),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if Result = INVALID_HANDLE_VALUE then
    Exit;

  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(Result, DCB);

  DCB.BaudRate := CBR_9600;
  DCB.ByteSize := 8;
  DCB.Parity := NOPARITY;
  DCB.StopBits := ONESTOPBIT;
  DCB.fBinary := 1;
  DCB.fDtrControl := DTR_CONTROL_ENABLE;

  SetCommState(Result, DCB);

  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 100;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 1000;

  SetCommTimeouts(Result, Timeouts);

  // Attendre que Arduino boot (reset automatique √† l'ouverture)
  Sleep(2000);
end;

procedure EnvoyerCommande(hPort: THandle; const cmd: string);  
var
  data: AnsiString;
  BytesWritten: DWORD;
begin
  data := AnsiString(cmd + #13#10);
  WriteFile(hPort, data[1], Length(data), BytesWritten, nil);
end;

function LireReponse(hPort: THandle): string;  
var
  Buffer: array[0..255] of AnsiChar;
  BytesRead: DWORD;
begin
  Result := '';

  if ReadFile(hPort, Buffer, SizeOf(Buffer) - 1, BytesRead, nil) and (BytesRead > 0) then
  begin
    Buffer[BytesRead] := #0;
    Result := Trim(string(Buffer));
  end;
end;

var
  choix: Char;
  reponse: string;

begin
  ClrScr;
  WriteLn('=== Contr√¥le Arduino ===');
  WriteLn;

  hPort := OuvrirArduino('COM3');

  if hPort = INVALID_HANDLE_VALUE then
  begin
    WriteLn('ERREUR: Impossible d''ouvrir COM3');
    ReadLn;
    Exit;
  end;

  WriteLn('Arduino connect√© sur COM3');
  WriteLn;
  WriteLn('Commandes:');
  WriteLn('  1 - Allumer LED');
  WriteLn('  0 - √âteindre LED');
  WriteLn('  T - Lire temp√©rature');
  WriteLn('  S - √âtat syst√®me');
  WriteLn('  Q - Quitter');
  WriteLn;

  repeat
    Write('Commande: ');
    choix := UpCase(ReadKey);
    WriteLn(choix);

    case choix of
      '1':
        begin
          EnvoyerCommande(hPort, 'LED_ON');
          Sleep(100);
          reponse := LireReponse(hPort);
          if reponse <> '' then
            WriteLn('  Arduino: ', reponse);
        end;

      '0':
        begin
          EnvoyerCommande(hPort, 'LED_OFF');
          Sleep(100);
          reponse := LireReponse(hPort);
          if reponse <> '' then
            WriteLn('  Arduino: ', reponse);
        end;

      'T':
        begin
          EnvoyerCommande(hPort, 'GET_TEMP');
          Sleep(100);
          reponse := LireReponse(hPort);
          if reponse <> '' then
            WriteLn('  Temp√©rature: ', reponse, ' ¬∞C');
        end;

      'S':
        begin
          EnvoyerCommande(hPort, 'STATUS');
          Sleep(100);
          reponse := LireReponse(hPort);
          if reponse <> '' then
            WriteLn('  √âtat: ', reponse);
        end;

      'Q':
        Break;
    end;

    WriteLn;

  until False;

  CloseHandle(hPort);
  WriteLn('D√©connect√©');
end.
```

**Code Arduino correspondant :**

```cpp
// Sketch Arduino pour test
void setup() {
  Serial.begin(9600);
  pinMode(LED_BUILTIN, OUTPUT);
  Serial.println("Arduino Ready");
}

void loop() {
  if (Serial.available() > 0) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();

    if (cmd == "LED_ON") {
      digitalWrite(LED_BUILTIN, HIGH);
      Serial.println("OK: LED ON");
    }
    else if (cmd == "LED_OFF") {
      digitalWrite(LED_BUILTIN, LOW);
      Serial.println("OK: LED OFF");
    }
    else if (cmd == "GET_TEMP") {
      // Exemple avec capteur temp√©rature
      float temp = 23.5; // Remplacer par lecture r√©elle
      Serial.println(temp);
    }
    else if (cmd == "STATUS") {
      Serial.println("System OK");
    }
    else {
      Serial.println("ERROR: Unknown command");
    }
  }
}
```

## Probl√®mes courants et solutions

### Probl√®me 1 : "Access Denied" √† l'ouverture

**Sympt√¥me :**
```
CreateFile retourne INVALID_HANDLE_VALUE  
GetLastError = 5 (ERROR_ACCESS_DENIED)
```

**Causes possibles :**
1. Port d√©j√† utilis√© par une autre application
2. Permissions insuffisantes (rare sur Windows)
3. Port verrouill√© par driver d√©fectueux

**Solutions :**

```pascal
procedure DiagnostiquerAccesDenie(const PortName: string);  
var
  hPort: THandle;
begin
  WriteLn('Diagnostic pour ', PortName);

  // V√©rifier si le port existe
  hPort := CreateFile(
    PChar('\\.\' + PortName),
    0,  // Pas d'acc√®s demand√©
    0,
    nil,
    OPEN_EXISTING,
    0,
    0
  );

  if hPort = INVALID_HANDLE_VALUE then
  begin
    if GetLastError = ERROR_FILE_NOT_FOUND then
      WriteLn('  ‚Üí Le port n''existe pas')
    else
      WriteLn('  ‚Üí Erreur: ', GetLastError);
  end
  else
  begin
    CloseHandle(hPort);
    WriteLn('  ‚Üí Port existe mais est occup√©');
    WriteLn('  ‚Üí V√©rifier: Gestionnaire de t√¢ches, Device Manager');
    WriteLn('  ‚Üí Applications potentielles: Arduino IDE, PuTTY, autres terminaux');
  end;
end;
```

**Astuce :** Utiliser **Process Explorer** (Sysinternals) pour voir quel processus utilise le port.

### Probl√®me 2 : Donn√©es corrompues ou caract√®res bizarres

**Sympt√¥me :**
```
Re√ßu: ‚ï´‚ï™‚ñì‚îò‚îú‚ï¨‚ïó
```

**Causes :**
1. **Baud rate incorrect** (le plus fr√©quent)
2. Configuration bits/parit√©/stop diff√©rente
3. Probl√®me de c√¢blage (TX/RX invers√©s)
4. Interf√©rences √©lectromagn√©tiques

**Solution diagnostic :**

```pascal
procedure TesterVitesses(const PortName: string);  
const
  Vitesses: array[0..7] of DWORD = (
    CBR_2400, CBR_4800, CBR_9600, CBR_19200,
    CBR_38400, CBR_57600, CBR_115200, CBR_256000
  );
var
  i: Integer;
  hPort: THandle;
  DCB: TDCB;
  Buffer: array[0..63] of AnsiChar;
  BytesRead: DWORD;
begin
  WriteLn('Test automatique des vitesses sur ', PortName);
  WriteLn;

  for i := 0 to High(Vitesses) do
  begin
    Write('Test ', Vitesses[i], ' bauds... ');

    hPort := CreateFile(
      PChar('\\.\' + PortName),
      GENERIC_READ or GENERIC_WRITE,
      0, nil, OPEN_EXISTING, 0, 0
    );

    if hPort <> INVALID_HANDLE_VALUE then
    begin
      FillChar(DCB, SizeOf(DCB), 0);
      DCB.DCBlength := SizeOf(DCB);
      GetCommState(hPort, DCB);

      DCB.BaudRate := Vitesses[i];
      DCB.ByteSize := 8;
      DCB.Parity := NOPARITY;
      DCB.StopBits := ONESTOPBIT;
      DCB.fBinary := 1;

      SetCommState(hPort, DCB);

      // Vider buffer
      PurgeComm(hPort, PURGE_RXCLEAR);

      // Attendre donn√©es
      Sleep(500);

      if ReadFile(hPort, Buffer, SizeOf(Buffer), BytesRead, nil) and (BytesRead > 0) then
      begin
        Buffer[BytesRead] := #0;
        WriteLn('Donn√©es re√ßues: ', string(Buffer));
      end
      else
        WriteLn('Aucune donn√©e');

      CloseHandle(hPort);
    end
    else
      WriteLn('Impossible d''ouvrir');
  end;
end;
```

### Probl√®me 3 : Timeout lors de la lecture

**Sympt√¥me :**
```
ReadFile retourne False  
GetLastError = ERROR_TIMEOUT
```

**Solution :** Ajuster les timeouts

```pascal
procedure ConfigurerTimeoutsLecture(hPort: THandle; TimeoutMs: DWORD);  
var
  Timeouts: TCOMMTIMEOUTS;
begin
  // Timeout total = TimeoutMs
  Timeouts.ReadIntervalTimeout := 0;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := TimeoutMs;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  SetCommTimeouts(hPort, Timeouts);
end;

// Pour lecture non-bloquante (retour imm√©diat)
procedure ConfigurerLectureNonBloquante(hPort: THandle);  
var
  Timeouts: TCOMMTIMEOUTS;
begin
  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  SetCommTimeouts(hPort, Timeouts);
end;
```

### Probl√®me 4 : Perte de donn√©es

**Sympt√¥me :**
Des octets manquent dans la r√©ception.

**Causes :**
1. Buffer Windows trop petit
2. Programme ne lit pas assez vite
3. Flow control d√©sactiv√© alors que n√©cessaire

**Solution 1 : Augmenter taille du buffer**

```pascal
procedure AugmenterBuffers(hPort: THandle);  
begin
  // Buffers de 4096 octets (par d√©faut souvent 1024)
  SetupComm(hPort, 4096, 4096);
end;
```

**Solution 2 : Activer flow control mat√©riel**

```pascal
procedure ActiverFlowControl(hPort: THandle);  
var
  DCB: TDCB;
begin
  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(hPort, DCB);

  // Activer RTS/CTS flow control
  DCB.fOutxCtsFlow := 1;     // Respecter CTS en √©mission
  DCB.fRtsControl := RTS_CONTROL_HANDSHAKE;  // RTS automatique

  SetCommState(hPort, DCB);
end;
```

**Solution 3 : Lire plus fr√©quemment**

```pascal
// Utiliser un thread d√©di√© √† la lecture
type
  TThreadLecture = class(TThread)
  private
    FHandle: THandle;
    FBuffer: TThreadList;
  protected
    procedure Execute; override;
  public
    constructor Create(Handle: THandle);
    function LireDonnees: TBytes;
  end;

procedure TThreadLecture.Execute;  
var
  Buffer: array[0..255] of Byte;
  BytesRead: DWORD;
  Liste: TList;
  Copie: PByte;
begin
  while not Terminated do
  begin
    if ReadFile(FHandle, Buffer, SizeOf(Buffer), BytesRead, nil) and (BytesRead > 0) then
    begin
      // Copier dans buffer thread-safe
      GetMem(Copie, BytesRead);
      Move(Buffer, Copie^, BytesRead);

      Liste := FBuffer.LockList;
      try
        Liste.Add(Copie);
      finally
        FBuffer.UnlockList;
      end;
    end;

    Sleep(10);
  end;
end;
```

### Probl√®me 5 : Port COM inexistant apr√®s d√©branchement USB

**Sympt√¥me :**
Le port COM3 existe, puis dispara√Æt apr√®s d√©branchement de l'adaptateur USB.

**Solution : D√©tecter d√©connexion**

```pascal
function PortToujoursConnecte(hPort: THandle): Boolean;  
var
  Errors: DWORD;
  ComStat: TCOMSTAT;
begin
  Result := ClearCommError(hPort, Errors, @ComStat);

  if not Result then
  begin
    // Port d√©connect√©
    WriteLn('ERREUR: Port d√©connect√© (GetLastError = ', GetLastError, ')');
  end;
end;

// Dans boucle principale
while True do  
begin
  if not PortToujoursConnecte(hPort) then
  begin
    WriteLn('Tentative de reconnexion...');
    CloseHandle(hPort);

    // Attendre que le port r√©apparaisse
    repeat
      Sleep(1000);
      hPort := CreateFile(...);
    until hPort <> INVALID_HANDLE_VALUE;

    WriteLn('Reconnect√© !');
  end;

  // ... reste du code ...
end;
```

## Optimisation des performances

### Buffer circulaire pour r√©ception continue

```pascal
type
  TBufferCirculaire = class
  private
    FBuffer: array of Byte;
    FTaille: Integer;
    FTete: Integer;
    FQueue: Integer;
    FCount: Integer;
    FLock: TRTLCriticalSection;
  public
    constructor Create(Taille: Integer);
    destructor Destroy; override;

    procedure Ecrire(const Data; Len: Integer);
    function Lire(var Data; MaxLen: Integer): Integer;
    function Disponible: Integer;
    procedure Vider;
  end;

constructor TBufferCirculaire.Create(Taille: Integer);  
begin
  inherited Create;
  FTaille := Taille;
  SetLength(FBuffer, Taille);
  FTete := 0;
  FQueue := 0;
  FCount := 0;
  InitializeCriticalSection(FLock);
end;

destructor TBufferCirculaire.Destroy;  
begin
  DeleteCriticalSection(FLock);
  inherited Destroy;
end;

procedure TBufferCirculaire.Ecrire(const Data; Len: Integer);  
var
  i: Integer;
  p: PByte;
begin
  EnterCriticalSection(FLock);
  try
    p := @Data;

    for i := 0 to Len - 1 do
    begin
      if FCount < FTaille then
      begin
        FBuffer[FQueue] := p^;
        FQueue := (FQueue + 1) mod FTaille;
        Inc(FCount);
        Inc(p);
      end
      else
        Break;  // Buffer plein
    end;
  finally
    LeaveCriticalSection(FLock);
  end;
end;

function TBufferCirculaire.Lire(var Data; MaxLen: Integer): Integer;  
var
  i: Integer;
  p: PByte;
begin
  Result := 0;

  EnterCriticalSection(FLock);
  try
    p := @Data;

    for i := 0 to MaxLen - 1 do
    begin
      if FCount > 0 then
      begin
        p^ := FBuffer[FTete];
        FTete := (FTete + 1) mod FTaille;
        Dec(FCount);
        Inc(p);
        Inc(Result);
      end
      else
        Break;
    end;
  finally
    LeaveCriticalSection(FLock);
  end;
end;

function TBufferCirculaire.Disponible: Integer;  
begin
  EnterCriticalSection(FLock);
  try
    Result := FCount;
  finally
    LeaveCriticalSection(FLock);
  end;
end;

procedure TBufferCirculaire.Vider;  
begin
  EnterCriticalSection(FLock);
  try
    FTete := 0;
    FQueue := 0;
    FCount := 0;
  finally
    LeaveCriticalSection(FLock);
  end;
end;
```

### Utilisation avec thread de lecture

```pascal
type
  TSerialPortOptimise = class
  private
    FHandle: THandle;
    FThread: TThread;
    FBuffer: TBufferCirculaire;
    FConnected: Boolean;
  public
    constructor Create(const PortName: string; BaudRate: DWORD);
    destructor Destroy; override;

    function Available: Integer;
    function ReadData(var Buffer; Size: Integer): Integer;
    procedure WriteData(const Buffer; Size: Integer);
  end;

// Thread de lecture optimis√©
type
  TThreadLectureOptimise = class(TThread)
  private
    FHandle: THandle;
    FBuffer: TBufferCirculaire;
  protected
    procedure Execute; override;
  public
    constructor Create(Handle: THandle; Buffer: TBufferCirculaire);
  end;

constructor TThreadLectureOptimise.Create(Handle: THandle; Buffer: TBufferCirculaire);  
begin
  inherited Create(False);
  FreeOnTerminate := False;
  FHandle := Handle;
  FBuffer := Buffer;
end;

procedure TThreadLectureOptimise.Execute;  
var
  TempBuffer: array[0..1023] of Byte;
  BytesRead: DWORD;
begin
  while not Terminated do
  begin
    if ReadFile(FHandle, TempBuffer, SizeOf(TempBuffer), BytesRead, nil) and (BytesRead > 0) then
    begin
      // √âcrire dans buffer circulaire thread-safe
      FBuffer.Ecrire(TempBuffer, BytesRead);
    end;

    Sleep(1);  // Petite pause
  end;
end;
```

### Mesure de performances

```pascal
procedure MesurerDebit(hPort: THandle; DureeSecondes: Integer);  
var
  Buffer: array[0..1023] of Byte;
  BytesRead, TotalBytes: DWORD;
  StartTime: TDateTime;
  Elapsed: Double;
begin
  WriteLn('Mesure du d√©bit pendant ', DureeSecondes, ' secondes...');

  TotalBytes := 0;
  StartTime := Now;

  repeat
    if ReadFile(hPort, Buffer, SizeOf(Buffer), BytesRead, nil) then
      Inc(TotalBytes, BytesRead);

    Elapsed := (Now - StartTime) * 86400;  // Convertir en secondes
  until Elapsed >= DureeSecondes;

  WriteLn('Octets re√ßus: ', TotalBytes);
  WriteLn('D√©bit moyen: ', (TotalBytes / Elapsed):0:2, ' octets/s');
  WriteLn('            ', (TotalBytes * 8 / Elapsed):0:2, ' bits/s');
end;
```

## Int√©gration avec Lazarus (GUI)

### Composant TComPort personnalis√©

```pascal
unit UnitComPort;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Windows;

type
  TDataReceivedEvent = procedure(Sender: TObject; const Data: array of Byte; Count: Integer) of object;

  TComPort = class(TComponent)
  private
    FHandle: THandle;
    FPortName: string;
    FBaudRate: DWORD;
    FConnected: Boolean;
    FThread: TThread;
    FOnDataReceived: TDataReceivedEvent;

    procedure SetConnected(Value: Boolean);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;

    procedure Open;
    procedure Close;
    procedure WriteData(const Data: array of Byte; Count: Integer); overload;
    procedure WriteString(const S: string);

  published
    property PortName: string read FPortName write FPortName;
    property BaudRate: DWORD read FBaudRate write FBaudRate default CBR_9600;
    property Connected: Boolean read FConnected write SetConnected;
    property OnDataReceived: TDataReceivedEvent read FOnDataReceived write FOnDataReceived;
  end;

procedure Register;

implementation

type
  TComPortThread = class(TThread)
  private
    FHandle: THandle;
    FOwner: TComPort;
  protected
    procedure Execute; override;
  public
    constructor Create(Handle: THandle; Owner: TComPort);
  end;

constructor TComPortThread.Create(Handle: THandle; Owner: TComPort);  
begin
  inherited Create(False);
  FreeOnTerminate := False;
  FHandle := Handle;
  FOwner := Owner;
end;

procedure TComPortThread.Execute;  
var
  Buffer: array[0..255] of Byte;
  BytesRead: DWORD;
begin
  while not Terminated do
  begin
    if ReadFile(FHandle, Buffer, SizeOf(Buffer), BytesRead, nil) and (BytesRead > 0) then
    begin
      if Assigned(FOwner.FOnDataReceived) then
      begin
        Synchronize(
          procedure
          begin
            FOwner.FOnDataReceived(FOwner, Buffer, BytesRead);
          end
        );
      end;
    end;

    Sleep(10);
  end;
end;

constructor TComPort.Create(AOwner: TComponent);  
begin
  inherited Create(AOwner);
  FHandle := INVALID_HANDLE_VALUE;
  FPortName := 'COM1';
  FBaudRate := CBR_9600;
  FConnected := False;
  FThread := nil;
end;

destructor TComPort.Destroy;  
begin
  Close;
  inherited Destroy;
end;

procedure TComPort.SetConnected(Value: Boolean);  
begin
  if Value then
    Open
  else
    Close;
end;

procedure TComPort.Open;  
var
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;
begin
  if FConnected then
    Exit;

  FHandle := CreateFile(
    PChar('\\.\' + FPortName),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if FHandle = INVALID_HANDLE_VALUE then
    raise Exception.Create('Impossible d''ouvrir ' + FPortName);

  // Configuration DCB
  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(FHandle, DCB);

  DCB.BaudRate := FBaudRate;
  DCB.ByteSize := 8;
  DCB.Parity := NOPARITY;
  DCB.StopBits := ONESTOPBIT;
  DCB.fBinary := 1;

  SetCommState(FHandle, DCB);

  // Timeouts
  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  SetCommTimeouts(FHandle, Timeouts);

  // D√©marrer thread
  FThread := TComPortThread.Create(FHandle, Self);

  FConnected := True;
end;

procedure TComPort.Close;  
begin
  if not FConnected then
    Exit;

  // Arr√™ter thread
  if Assigned(FThread) then
  begin
    FThread.Terminate;
    FThread.WaitFor;
    FThread.Free;
    FThread := nil;
  end;

  // Fermer port
  CloseHandle(FHandle);
  FHandle := INVALID_HANDLE_VALUE;

  FConnected := False;
end;

procedure TComPort.WriteData(const Data: array of Byte; Count: Integer);  
var
  BytesWritten: DWORD;
begin
  if not FConnected then
    raise Exception.Create('Port non connect√©');

  WriteFile(FHandle, Data[0], Count, BytesWritten, nil);
end;

procedure TComPort.WriteString(const S: string);  
var
  AnsiS: AnsiString;
begin
  AnsiS := AnsiString(S);
  WriteData(BytesArray(AnsiS), Length(AnsiS));
end;

procedure Register;  
begin
  RegisterComponents('Communication', [TComPort]);
end;

end.
```

### Utilisation dans une form Lazarus

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls,
  ComCtrls, UnitComPort;

type
  TForm1 = class(TForm)
    ButtonConnect: TButton;
    ButtonSend: TButton;
    EditPort: TEdit;
    EditSend: TEdit;
    MemoReceived: TMemo;
    StatusBar1: TStatusBar;

    procedure ButtonConnectClick(Sender: TObject);
    procedure ButtonSendClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
  private
    FComPort: TComPort;
    procedure OnDataReceived(Sender: TObject; const Data: array of Byte; Count: Integer);
  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

procedure TForm1.FormCreate(Sender: TObject);  
begin
  FComPort := TComPort.Create(Self);
  FComPort.OnDataReceived := @OnDataReceived;
  FComPort.PortName := 'COM3';
  FComPort.BaudRate := CBR_115200;

  EditPort.Text := 'COM3';
  StatusBar1.SimpleText := 'D√©connect√©';
end;

procedure TForm1.FormDestroy(Sender: TObject);  
begin
  FComPort.Free;
end;

procedure TForm1.ButtonConnectClick(Sender: TObject);  
begin
  if not FComPort.Connected then
  begin
    try
      FComPort.PortName := EditPort.Text;
      FComPort.Open;

      ButtonConnect.Caption := 'D√©connecter';
      StatusBar1.SimpleText := 'Connect√© √† ' + EditPort.Text;
    except
      on E: Exception do
        ShowMessage('Erreur: ' + E.Message);
    end;
  end
  else
  begin
    FComPort.Close;
    ButtonConnect.Caption := 'Connecter';
    StatusBar1.SimpleText := 'D√©connect√©';
  end;
end;

procedure TForm1.ButtonSendClick(Sender: TObject);  
begin
  if FComPort.Connected then
  begin
    FComPort.WriteString(EditSend.Text + #13#10);
    EditSend.Clear;
  end;
end;

procedure TForm1.OnDataReceived(Sender: TObject; const Data: array of Byte; Count: Integer);  
var
  S: AnsiString;
  i: Integer;
begin
  SetLength(S, Count);
  for i := 0 to Count - 1 do
    S[i + 1] := AnsiChar(Data[i]);

  MemoReceived.Lines.Add(string(S));
end;

end.
```

## Ressources et outils utiles

### Outils de diagnostic

**1. Device Manager (Gestionnaire de p√©riph√©riques)**
- `devmgmt.msc` dans Ex√©cuter
- Voir ports COM et leurs drivers
- D√©sactiver/activer ports
- Mettre √† jour drivers

**2. Mode (commande DOS)**
```batch
REM Afficher config d'un port  
mode COM3

REM Configurer un port  
mode COM3 BAUD=115200 PARITY=N DATA=8 STOP=1
```

**3. PowerShell**
```powershell
# Lister ports COM
Get-WMIObject Win32_SerialPort | Select Name, DeviceID

# D√©tails
Get-WMIObject Win32_SerialPort | Format-List *
```

### Biblioth√®ques tierces

**Synapse (Ararat Synapse)**
- Biblioth√®que r√©seau incluant support s√©rie
- Multi-plateforme (Windows/Linux)
- Gratuite et open source
- URL: http://synapse.ararat.cz

**ComPort Library**
- Composants Delphi/Lazarus pour ports s√©rie
- Interface visuelle
- Nombreux exemples

### Documentation officielle

**Microsoft Docs**
- "Communications Resources" (Win32 API)
- "Serial Communications"
- Exemples C++ adaptables en Pascal

**FreePascal Wiki**
- "Serial Programming"
- Exemples multi-plateformes

## Conclusion

La communication s√©rie sur Windows via FreePascal est rendue accessible gr√¢ce √† l'API Win32 bien document√©e. Les points cl√©s √† retenir :

‚úÖ **Ouverture** : CreateFile avec syntaxe `\\.\COMx`

‚úÖ **Configuration** : Structure DCB pour param√®tres (vitesse, bits, parit√©)

‚úÖ **Timeouts** : COMMTIMEOUTS pour contr√¥le lecture/√©criture

‚úÖ **Lecture/√âcriture** : ReadFile et WriteFile

‚úÖ **Mode asynchrone** : OVERLAPPED pour non-blocage

‚úÖ **√âv√©nements** : WaitCommEvent pour notification

‚úÖ **Gestion erreurs** : ClearCommError et r√©cup√©ration

‚úÖ **Optimisation** : Threads et buffers circulaires

Avec ces connaissances, vous pouvez cr√©er des applications robustes communiquant avec Arduino, GPS, capteurs industriels, ou tout appareil s√©rie sous Windows.

**Prochaine section : 14.6.2 /dev/tty* Linux** - d√©couvrez comment g√©rer les ports s√©rie sous Linux avec une approche similaire mais adapt√©e aux sp√©cificit√©s Unix.

---

## Annexes

### Annexe A : R√©f√©rence rapide des fonctions Win32

| Fonction | Description | Param√®tres cl√©s |
|----------|-------------|-----------------|
| `CreateFile()` | Ouvrir port | PortName, GENERIC_READ/WRITE |
| `CloseHandle()` | Fermer port | Handle |
| `ReadFile()` | Lire donn√©es | Buffer, Size, BytesRead |
| `WriteFile()` | √âcrire donn√©es | Buffer, Size, BytesWritten |
| `GetCommState()` | Lire config | DCB |
| `SetCommState()` | Appliquer config | DCB |
| `GetCommTimeouts()` | Lire timeouts | COMMTIMEOUTS |
| `SetCommTimeouts()` | D√©finir timeouts | COMMTIMEOUTS |
| `PurgeComm()` | Vider buffers | Flags (TX/RX) |
| `ClearCommError()` | Effacer erreurs | Errors, COMSTAT |
| `SetCommMask()` | D√©finir √©v√©nements | Mask (EV_xxx) |
| `WaitCommEvent()` | Attendre √©v√©nement | EventMask |
| `GetCommModemStatus()` | √âtat signaux | ModemStat |
| `EscapeCommFunction()` | Contr√¥le signaux | Function (SETDTR, etc.) |
| `SetupComm()` | Taille buffers | InQueue, OutQueue |
| `GetOverlappedResult()` | R√©sultat async | OVERLAPPED |

### Annexe B : Codes d'erreur courants

| Code | Constante | Signification | Solution |
|------|-----------|---------------|----------|
| 2 | ERROR_FILE_NOT_FOUND | Port inexistant | V√©rifier nom du port |
| 5 | ERROR_ACCESS_DENIED | Port occup√© | Fermer autres applications |
| 31 | ERROR_GEN_FAILURE | Erreur mat√©rielle | V√©rifier c√¢bles/driver |
| 87 | ERROR_INVALID_PARAMETER | Param√®tre invalide | V√©rifier DCB/timeouts |
| 995 | ERROR_OPERATION_ABORTED | Op√©ration annul√©e | Normal en mode async |
| 997 | ERROR_IO_PENDING | I/O en cours | Attendre avec WaitForSingleObject |
| 1167 | ERROR_DEVICE_NOT_CONNECTED | Appareil d√©connect√© | D√©branch√© physiquement |

### Annexe C : Valeurs DCB importantes

**fBinary** : Toujours mettre √† 1 (mode binaire obligatoire sur Win32)

**fParity** :
- 0 = Pas de v√©rification parit√©
- 1 = V√©rifier et remplacer par ErrorChar si erreur

**fOutxCtsFlow** :
- 0 = Ignorer CTS
- 1 = Respecter CTS (flow control mat√©riel)

**fOutxDsrFlow** :
- 0 = Ignorer DSR
- 1 = Respecter DSR

**fDtrControl** :
- DTR_CONTROL_DISABLE (0) = DTR toujours bas
- DTR_CONTROL_ENABLE (1) = DTR toujours haut
- DTR_CONTROL_HANDSHAKE (2) = DTR automatique

**fRtsControl** :
- RTS_CONTROL_DISABLE (0) = RTS toujours bas
- RTS_CONTROL_ENABLE (1) = RTS toujours haut
- RTS_CONTROL_HANDSHAKE (2) = RTS automatique (flow control)
- RTS_CONTROL_TOGGLE (3) = RTS toggle automatique

**fOutX / fInX** :
- 0 = Pas de XON/XOFF
- 1 = XON/XOFF software flow control

### Annexe D : Snippets r√©utilisables

#### Convertir string en bytes

```pascal
function StringToBytes(const S: string): TBytes;  
var
  AnsiS: AnsiString;
  i: Integer;
begin
  AnsiS := AnsiString(S);
  SetLength(Result, Length(AnsiS));
  for i := 0 to Length(AnsiS) - 1 do
    Result[i] := Ord(AnsiS[i + 1]);
end;
```

#### Convertir bytes en string

```pascal
function BytesToString(const Bytes: array of Byte; Count: Integer): string;  
var
  AnsiS: AnsiString;
  i: Integer;
begin
  SetLength(AnsiS, Count);
  for i := 0 to Count - 1 do
    AnsiS[i + 1] := AnsiChar(Bytes[i]);
  Result := string(AnsiS);
end;
```

#### Afficher donn√©es en hexad√©cimal

```pascal
function BytesToHex(const Bytes: array of Byte; Count: Integer): string;  
var
  i: Integer;
begin
  Result := '';
  for i := 0 to Count - 1 do
    Result := Result + IntToHex(Bytes[i], 2) + ' ';
end;
```

#### Calculer checksum simple

```pascal
function CalculerChecksum(const Data: array of Byte; Count: Integer): Byte;  
var
  i: Integer;
  Sum: Word;
begin
  Sum := 0;
  for i := 0 to Count - 1 do
    Sum := Sum + Data[i];
  Result := Byte(Sum and $FF);
end;
```

#### V√©rifier si string est ASCII imprimable

```pascal
function EstASCIIImprimable(const S: string): Boolean;  
var
  i: Integer;
begin
  Result := True;
  for i := 1 to Length(S) do
  begin
    if (Ord(S[i]) < 32) or (Ord(S[i]) > 126) then
    begin
      Result := False;
      Break;
    end;
  end;
end;
```

### Annexe E : Template de classe compl√®te

Voici un template pr√™t √† l'emploi pour vos projets :

```pascal
unit UnitSerialPort;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Windows;

type
  TSerialPort = class
  private
    FHandle: THandle;
    FPortName: string;
    FBaudRate: DWORD;
    FByteSize: Byte;
    FParity: Byte;
    FStopBits: Byte;
    FConnected: Boolean;

    function InternalOpen: Boolean;
    procedure InternalClose;
  public
    constructor Create;
    destructor Destroy; override;

    // Connexion
    function Open(const PortName: string; BaudRate: DWORD): Boolean;
    procedure Close;

    // Configuration
    procedure SetParams(ByteSize, Parity, StopBits: Byte);
    procedure SetTimeouts(ReadTimeout, WriteTimeout: DWORD);
    procedure SetFlowControl(Hardware, Software: Boolean);

    // I/O
    function Read(var Buffer; Size: DWORD): DWORD;
    function Write(const Buffer; Size: DWORD): DWORD;
    function ReadString(MaxLen: Integer = 256): string;
    procedure WriteString(const S: string);

    // Utilitaires
    function Available: Integer;
    procedure Flush;
    function GetStatus: string;

    // Contr√¥le signaux
    procedure SetDTR(State: Boolean);
    procedure SetRTS(State: Boolean);
    function GetCTS: Boolean;
    function GetDSR: Boolean;

    // Propri√©t√©s
    property Connected: Boolean read FConnected;
    property PortName: string read FPortName;
    property BaudRate: DWORD read FBaudRate;
  end;

implementation

constructor TSerialPort.Create;  
begin
  inherited Create;
  FHandle := INVALID_HANDLE_VALUE;
  FConnected := False;
  FByteSize := 8;
  FParity := NOPARITY;
  FStopBits := ONESTOPBIT;
end;

destructor TSerialPort.Destroy;  
begin
  Close;
  inherited Destroy;
end;

function TSerialPort.InternalOpen: Boolean;  
var
  DCB: TDCB;
  Timeouts: TCOMMTIMEOUTS;
  FullName: string;
begin
  Result := False;

  if FConnected then
    Exit;

  // Format: \\.\COMx
  if Pos('\\.\', FPortName) = 0 then
    FullName := '\\.\' + FPortName
  else
    FullName := FPortName;

  // Ouvrir
  FHandle := CreateFile(
    PChar(FullName),
    GENERIC_READ or GENERIC_WRITE,
    0, nil, OPEN_EXISTING, 0, 0
  );

  if FHandle = INVALID_HANDLE_VALUE then
    Exit;

  // Configuration DCB
  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);

  if not GetCommState(FHandle, DCB) then
  begin
    CloseHandle(FHandle);
    FHandle := INVALID_HANDLE_VALUE;
    Exit;
  end;

  DCB.BaudRate := FBaudRate;
  DCB.ByteSize := FByteSize;
  DCB.Parity := FParity;
  DCB.StopBits := FStopBits;
  DCB.fBinary := 1;
  DCB.fDtrControl := DTR_CONTROL_ENABLE;
  DCB.fRtsControl := RTS_CONTROL_ENABLE;

  if not SetCommState(FHandle, DCB) then
  begin
    CloseHandle(FHandle);
    FHandle := INVALID_HANDLE_VALUE;
    Exit;
  end;

  // Timeouts par d√©faut (non-bloquants)
  Timeouts.ReadIntervalTimeout := MAXDWORD;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := 0;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := 0;

  SetCommTimeouts(FHandle, Timeouts);

  FConnected := True;
  Result := True;
end;

procedure TSerialPort.InternalClose;  
begin
  if FConnected then
  begin
    CloseHandle(FHandle);
    FHandle := INVALID_HANDLE_VALUE;
    FConnected := False;
  end;
end;

function TSerialPort.Open(const PortName: string; BaudRate: DWORD): Boolean;  
begin
  FPortName := PortName;
  FBaudRate := BaudRate;
  Result := InternalOpen;
end;

procedure TSerialPort.Close;  
begin
  InternalClose;
end;

procedure TSerialPort.SetParams(ByteSize, Parity, StopBits: Byte);  
begin
  FByteSize := ByteSize;
  FParity := Parity;
  FStopBits := StopBits;

  if FConnected then
  begin
    InternalClose;
    InternalOpen;
  end;
end;

procedure TSerialPort.SetTimeouts(ReadTimeout, WriteTimeout: DWORD);  
var
  Timeouts: TCOMMTIMEOUTS;
begin
  if not FConnected then
    Exit;

  Timeouts.ReadIntervalTimeout := 0;
  Timeouts.ReadTotalTimeoutMultiplier := 0;
  Timeouts.ReadTotalTimeoutConstant := ReadTimeout;
  Timeouts.WriteTotalTimeoutMultiplier := 0;
  Timeouts.WriteTotalTimeoutConstant := WriteTimeout;

  SetCommTimeouts(FHandle, Timeouts);
end;

procedure TSerialPort.SetFlowControl(Hardware, Software: Boolean);  
var
  DCB: TDCB;
begin
  if not FConnected then
    Exit;

  FillChar(DCB, SizeOf(DCB), 0);
  DCB.DCBlength := SizeOf(DCB);
  GetCommState(FHandle, DCB);

  if Hardware then
  begin
    DCB.fOutxCtsFlow := 1;
    DCB.fRtsControl := RTS_CONTROL_HANDSHAKE;
  end
  else
  begin
    DCB.fOutxCtsFlow := 0;
    DCB.fRtsControl := RTS_CONTROL_ENABLE;
  end;

  if Software then
  begin
    DCB.fOutX := 1;
    DCB.fInX := 1;
  end
  else
  begin
    DCB.fOutX := 0;
    DCB.fInX := 0;
  end;

  SetCommState(FHandle, DCB);
end;

function TSerialPort.Read(var Buffer; Size: DWORD): DWORD;  
begin
  Result := 0;
  if not FConnected then
    Exit;

  if not ReadFile(FHandle, Buffer, Size, Result, nil) then
    Result := 0;
end;

function TSerialPort.Write(const Buffer; Size: DWORD): DWORD;  
begin
  Result := 0;
  if not FConnected then
    Exit;

  if not WriteFile(FHandle, Buffer, Size, Result, nil) then
    Result := 0;
end;

function TSerialPort.ReadString(MaxLen: Integer): string;  
var
  Buffer: array[0..255] of AnsiChar;
  BytesRead: DWORD;
  Len: Integer;
begin
  Result := '';

  if MaxLen > 256 then
    MaxLen := 256;

  BytesRead := Read(Buffer, MaxLen - 1);

  if BytesRead > 0 then
  begin
    Buffer[BytesRead] := #0;
    Result := string(Buffer);
  end;
end;

procedure TSerialPort.WriteString(const S: string);  
var
  AnsiS: AnsiString;
begin
  AnsiS := AnsiString(S);
  Write(AnsiS[1], Length(AnsiS));
end;

function TSerialPort.Available: Integer;  
var
  Errors: DWORD;
  ComStat: TCOMSTAT;
begin
  Result := 0;

  if not FConnected then
    Exit;

  if ClearCommError(FHandle, Errors, @ComStat) then
    Result := ComStat.cbInQue;
end;

procedure TSerialPort.Flush;  
begin
  if FConnected then
    PurgeComm(FHandle, PURGE_TXCLEAR or PURGE_RXCLEAR);
end;

function TSerialPort.GetStatus: string;  
var
  Errors: DWORD;
  ComStat: TCOMSTAT;
begin
  if not FConnected then
  begin
    Result := 'D√©connect√©';
    Exit;
  end;

  if ClearCommError(FHandle, Errors, @ComStat) then
    Result := Format('RX: %d octets, TX: %d octets', [ComStat.cbInQue, ComStat.cbOutQue])
  else
    Result := 'Erreur';
end;

procedure TSerialPort.SetDTR(State: Boolean);  
begin
  if not FConnected then
    Exit;

  if State then
    EscapeCommFunction(FHandle, SETDTR)
  else
    EscapeCommFunction(FHandle, CLRDTR);
end;

procedure TSerialPort.SetRTS(State: Boolean);  
begin
  if not FConnected then
    Exit;

  if State then
    EscapeCommFunction(FHandle, SETRTS)
  else
    EscapeCommFunction(FHandle, CLRRTS);
end;

function TSerialPort.GetCTS: Boolean;  
var
  ModemStat: DWORD;
begin
  Result := False;

  if not FConnected then
    Exit;

  if GetCommModemStatus(FHandle, @ModemStat) then
    Result := (ModemStat and MS_CTS_ON) <> 0;
end;

function TSerialPort.GetDSR: Boolean;  
var
  ModemStat: DWORD;
begin
  Result := False;

  if not FConnected then
    Exit;

  if GetCommModemStatus(FHandle, @ModemStat) then
    Result := (ModemStat and MS_DSR_ON) <> 0;
end;

end.
```

### Annexe F : Checklist de d√©pannage

Utilisez cette checklist quand votre communication s√©rie ne fonctionne pas :

**‚òê 1. Le port existe-t-il ?**
- V√©rifier dans Gestionnaire de p√©riph√©riques
- Tester avec `QueryDosDevice`

**‚òê 2. Le port est-il accessible ?**
- Fermer Arduino IDE, PuTTY, etc.
- V√©rifier droits d'acc√®s (normalement OK sur Windows)

**‚òê 3. Les param√®tres sont-ils corrects ?**
- M√™me baud rate des deux c√¥t√©s
- 8-N-1 (le plus courant)
- Timeouts appropri√©s

**‚òê 4. Le c√¢blage est-il bon ?**
- TX ‚Üí RX et RX ‚Üí TX (crois√©)
- GND commun connect√©
- Niveaux de tension compatibles (3.3V vs 5V)

**‚òê 5. Les drivers sont-ils install√©s ?**
- CH340/CH341 : driver sp√©cifique
- FTDI : normalement reconnu automatiquement
- Prolific : peut n√©cessiter driver ancien

**‚òê 6. L'appareil distant fonctionne-t-il ?**
- Tester avec autre logiciel (PuTTY, Tera Term)
- V√©rifier LED TX/RX (si pr√©sentes)

**‚òê 7. Y a-t-il des erreurs dans le code ?**
- V√©rifier codes retour des fonctions
- Utiliser `GetLastError` pour diagnostic
- Activer logging d√©taill√©

---

*Ce document fait partie du module 14.6 "Communication s√©rie" de la formation "FreePascal/Lazarus - Niveau D√©veloppeur Avanc√© - Edition Multi-plateforme Windows/Ubuntu"*

*Prochaine section : 14.6.2 /dev/tty* Linux*

‚è≠Ô∏è [/dev/tty* Linux](/14-systemes-embarques-iot/06.2-dev-tty-linux.md)
