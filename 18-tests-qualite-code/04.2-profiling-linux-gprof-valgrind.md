üîù Retour au [Sommaire](/SOMMAIRE.md)

# 18.4.2 Profiling Linux (gprof, Valgrind)

## Introduction au Profiling sous Linux

Le profiling sous Linux dispose d'un √©cosyst√®me d'outils puissants et gratuits qui permettent d'analyser en profondeur les performances de vos applications FreePascal. Contrairement √† Windows, Linux offre nativement plusieurs outils compl√©mentaires.

### Pourquoi profiler sous Linux ?

- **Outils gratuits et open source** : gprof, Valgrind, perf sont libres et tr√®s performants
- **Int√©gration syst√®me** : acc√®s direct aux m√©triques du noyau Linux
- **Pr√©cision** : mesures tr√®s d√©taill√©es des performances CPU et m√©moire
- **D√©bogage avanc√©** : d√©tection de fuites m√©moire, erreurs d'acc√®s, probl√®mes de cache

## Vue d'Ensemble des Outils

Linux propose principalement deux outils compl√©mentaires :

| Outil | Usage Principal | Ce qu'il mesure |
|-------|----------------|-----------------|
| **gprof** | Profiling CPU | Temps d'ex√©cution des fonctions |
| **Valgrind** | Profiling m√©moire et CPU | Utilisation m√©moire, fuites, acc√®s invalides, cache |

Ces outils sont **compl√©mentaires** : gprof pour le temps CPU, Valgrind pour la m√©moire et les probl√®mes subtils.

---

## Partie 1 : gprof - Profiling Temps CPU

### Qu'est-ce que gprof ?

`gprof` (GNU Profiler) est l'outil standard GNU pour le profiling de temps d'ex√©cution. Il fonctionne exactement de la m√™me mani√®re sous Linux que sous Windows, mais avec une meilleure int√©gration syst√®me.

### Installation de gprof

Sur Ubuntu/Debian :
```bash
sudo apt update
sudo apt install binutils gcc gdb
```

Sur Fedora/RedHat :
```bash
sudo dnf install binutils gcc gdb
```

gprof est g√©n√©ralement d√©j√† install√© avec le compilateur GCC.

### Configuration du Projet

#### Compilation avec Options de Profiling

Pour utiliser gprof, compilez votre programme avec l'option `-pg` :

```bash
fpc -pg -gl MonProgramme.pas
```

**Options importantes :**
- `-pg` : Active l'instrumentation pour gprof
- `-gl` : Inclut les informations de d√©bogage avec num√©ros de ligne
- `-O2` : (Optionnel) Active les optimisations pour profiler du code r√©aliste

#### Exemple Complet

```bash
# Compilation
fpc -pg -gl -O2 MonProgramme.pas

# V√©rification
ls -lh MonProgramme
# Le fichier doit √™tre l√©g√®rement plus gros (code d'instrumentation)
```

### Utilisation de gprof

#### √âtape 1 : Ex√©cuter le Programme

```bash
./MonProgramme
```

Le programme g√©n√®re automatiquement un fichier `gmon.out` dans le r√©pertoire courant.

**Note :** Le fichier `gmon.out` est √©cras√© √† chaque ex√©cution.

#### √âtape 2 : G√©n√©rer le Rapport

```bash
gprof MonProgramme gmon.out > rapport.txt
```

Ou pour visualiser directement :

```bash
gprof MonProgramme gmon.out | less
```

#### √âtape 3 : Analyser les R√©sultats

Ouvrez `rapport.txt` avec votre √©diteur pr√©f√©r√© :

```bash
nano rapport.txt
# ou
gedit rapport.txt
# ou
kate rapport.txt
```

### Structure du Rapport gprof

Le rapport contient deux sections principales :

#### 1. Flat Profile (Profil Plat)

```
Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 33.34      0.35     0.35   500000     0.00     0.00  CalculerDistance
 28.57      0.65     0.30   100000     0.00     0.01  TrierDonnees
 19.05      0.85     0.20  1000000     0.00     0.00  ValiderEntree
 14.29      1.00     0.15        1   150.00   1000.00  FonctionPrincipale
```

**Lecture du tableau :**

- **% time** : Pourcentage du temps total dans cette fonction (33.34% pour CalculerDistance)
- **cumulative seconds** : Temps cumul√© (0.35s pour la premi√®re fonction)
- **self seconds** : Temps pass√© uniquement dans cette fonction
- **calls** : Nombre d'appels (500 000 fois pour CalculerDistance)
- **self ms/call** : Temps moyen par appel
- **name** : Nom de la fonction

**Interpr√©tation :** `CalculerDistance` est la fonction la plus co√ªteuse (33% du temps) et est appel√©e tr√®s souvent (500 000 fois). C'est la priorit√© pour l'optimisation.

#### 2. Call Graph (Graphe d'Appels)

```
index % time    self  children    called     name
                                                 <spontaneous>
[1]    100.0    0.15     0.85                 FonctionPrincipale [1]
                0.35     0.00  500000/500000     CalculerDistance [2]
                0.30     0.00  100000/100000     TrierDonnees [3]
                0.20     0.00 1000000/1000000    ValiderEntree [4]
-----------------------------------------------
                0.35     0.00  500000/500000     FonctionPrincipale [1]
[2]     33.3    0.35     0.00  500000         CalculerDistance [2]
-----------------------------------------------
```

**Ce que √ßa montre :**
- `FonctionPrincipale` [1] est le point d'entr√©e (100% du temps)
- Elle appelle `CalculerDistance` 500 000 fois
- Chaque fonction est li√©e √† ses appelants et appel√©s

### Options Avanc√©es de gprof

#### Afficher seulement les N fonctions les plus co√ªteuses

```bash
gprof -b MonProgramme gmon.out | head -n 50 > top50.txt
```

#### Exclure certaines fonctions

```bash
gprof -e FonctionAIgnorer MonProgramme gmon.out
```

#### Format de sortie annot√©

```bash
gprof -A MonProgramme gmon.out > rapport_annote.txt
```

### Conseils pour gprof sous Linux

#### 1. D√©sactiver ASLR pour des R√©sultats Coh√©rents

ASLR (Address Space Layout Randomization) peut perturber le profiling :

```bash
# D√©sactiver temporairement
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Ex√©cuter le profiling
./MonProgramme
gprof MonProgramme gmon.out > rapport.txt

# R√©activer (important pour la s√©curit√©)
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

#### 2. Profiler sur un Seul CPU

Pour des r√©sultats plus stables :

```bash
taskset -c 0 ./MonProgramme
```

Cela force l'ex√©cution sur le CPU 0 uniquement.

#### 3. Script de Profiling Automatis√©

Cr√©ez un script `profile.sh` :

```bash
#!/bin/bash
# Script de profiling automatique

PROGRAM=$1

if [ -z "$PROGRAM" ]; then
    echo "Usage: ./profile.sh MonProgramme"
    exit 1
fi

# Compilation
echo "Compilation avec profiling..."
fpc -pg -gl -O2 $PROGRAM.pas

# Ex√©cution
echo "Ex√©cution du programme..."
./$PROGRAM

# G√©n√©ration du rapport
echo "G√©n√©ration du rapport..."
gprof $PROGRAM gmon.out > profiling_$(date +%Y%m%d_%H%M%S).txt

echo "Rapport g√©n√©r√© : profiling_$(date +%Y%m%d_%H%M%S).txt"
```

Utilisation :

```bash
chmod +x profile.sh
./profile.sh MonProgramme
```

---

## Partie 2 : Valgrind - Profiling M√©moire et Performance

### Qu'est-ce que Valgrind ?

Valgrind est une suite d'outils de d√©bogage et de profiling extr√™mement puissante. Elle fonctionne en ex√©cutant votre programme dans une machine virtuelle qui surveille chaque acc√®s m√©moire et instruction CPU.

### Outils de Valgrind

Valgrind contient plusieurs outils :

| Outil | Fonction |
|-------|----------|
| **Memcheck** | D√©tection de fuites m√©moire et erreurs d'acc√®s |
| **Cachegrind** | Profiling du cache CPU (L1, L2, L3) |
| **Callgrind** | Profiling d√©taill√© des appels de fonction |
| **Massif** | Profiling de l'utilisation du heap (tas) |
| **Helgrind** | D√©tection de probl√®mes de threads |

### Installation de Valgrind

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install valgrind

# Fedora/RedHat
sudo dnf install valgrind

# V√©rification
valgrind --version
```

### Outil 1 : Memcheck - D√©tection de Probl√®mes M√©moire

#### Qu'est-ce que Memcheck d√©tecte ?

- **Fuites m√©moire** : m√©moire allou√©e mais jamais lib√©r√©e
- **Acc√®s invalides** : lecture/√©criture hors des limites
- **Utilisation de m√©moire non initialis√©e**
- **Double lib√©ration** : lib√©rer deux fois la m√™me m√©moire
- **D√©bordements de pile** (stack overflow)

#### Compilation pour Memcheck

Pas besoin de `-pg`, mais ajoutez des informations de d√©bogage :

```bash
fpc -gl -gh MonProgramme.pas
```

**Options :**
- `-gl` : Informations de d√©bogage avec num√©ros de ligne
- `-gh` : Active le heap manager pour tracer les allocations

#### Utilisation de Memcheck

Commande de base :

```bash
valgrind --leak-check=full ./MonProgramme
```

Commande d√©taill√©e avec toutes les options utiles :

```bash
valgrind \
  --leak-check=full \
  --show-leak-kinds=all \
  --track-origins=yes \
  --verbose \
  --log-file=memcheck_rapport.txt \
  ./MonProgramme
```

**Options expliqu√©es :**
- `--leak-check=full` : Recherche exhaustive des fuites
- `--show-leak-kinds=all` : Affiche tous les types de fuites
- `--track-origins=yes` : Trace l'origine des valeurs non initialis√©es
- `--verbose` : Mode verbeux pour plus de d√©tails
- `--log-file=...` : Sauvegarde le rapport dans un fichier

#### Lecture du Rapport Memcheck

Exemple de sortie :

```
==12345== Memcheck, a memory error detector
==12345== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
==12345== Using Valgrind-3.19.0 and LibVEX; rerun with -h for copyright info
==12345== Command: ./MonProgramme
==12345==

==12345== Invalid write of size 4
==12345==    at 0x401234: EcrireDansTableau (MonProgramme.pas:42)
==12345==    by 0x401156: FonctionPrincipale (MonProgramme.pas:28)
==12345==    by 0x401089: main (MonProgramme.pas:15)
==12345==  Address 0x5204050 is 0 bytes after a block of size 40 alloc'd
==12345==    at 0x4C2DB8F: malloc (vg_replace_malloc.c:299)
==12345==    by 0x401123: AllouerTableau (MonProgramme.pas:25)

==12345== LEAK SUMMARY:
==12345==    definitely lost: 120 bytes in 3 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 40 bytes in 1 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

**Interpr√©tation :**

1. **Invalid write** : √âcriture en dehors des limites √† la ligne 42
2. **definitely lost: 120 bytes** : Fuite m√©moire confirm√©e (3 allocations jamais lib√©r√©es)
3. **possibly lost: 40 bytes** : Fuite possible (√† v√©rifier)
4. Les num√©ros de ligne permettent de localiser exactement le probl√®me

#### Types de Fuites M√©moire

```
definitely lost     ‚Üí Fuite confirm√©e, plus aucune r√©f√©rence
indirectly lost     ‚Üí Fuite indirecte (contenue dans une fuite principale)
possibly lost       ‚Üí Peut-√™tre une fuite (pointeur vers le milieu du bloc)
still reachable     ‚Üí M√©moire non lib√©r√©e mais toujours accessible (pas grave)
suppressed          ‚Üí Fuites ignor√©es (biblioth√®ques syst√®me)
```

### Outil 2 : Cachegrind - Profiling du Cache

#### Qu'est-ce que Cachegrind analyse ?

Cachegrind simule le fonctionnement des caches CPU (L1, L2, L3) et compte :
- Les instructions ex√©cut√©es
- Les acc√®s m√©moire
- Les d√©fauts de cache (cache miss) qui ralentissent l'ex√©cution

#### Utilisation de Cachegrind

```bash
valgrind --tool=cachegrind ./MonProgramme
```

Cela g√©n√®re un fichier `cachegrind.out.<pid>`.

#### Visualiser les R√©sultats

Utilisez `cg_annotate` pour lire le rapport :

```bash
cg_annotate cachegrind.out.12345
```

Exemple de sortie :

```
--------------------------------------------------------------------------------
Ir                    I1mr  ILmr          Dr          D1mr       DLmr          Dw         D1mw  DLmw file:function
--------------------------------------------------------------------------------
1,234,567,890          456    123  345,678,901     12,345      2,345  123,456,789       3,456   890  MonProgramme.pas:CalculerDistance
  987,654,321          234     89  234,567,890     10,234      1,890  100,000,000       2,100   567  MonProgramme.pas:TrierDonnees
```

**Colonnes expliqu√©es :**

- **Ir** : Instructions Read (nombre d'instructions ex√©cut√©es)
- **I1mr** : Instruction cache L1 miss rate (d√©fauts L1)
- **Dr** : Data Read (lectures de donn√©es)
- **D1mr** : Data cache L1 miss rate (d√©fauts lecture L1)
- **Dw** : Data Write (√©critures de donn√©es)
- **D1mw** : Data cache L1 write miss (d√©fauts √©criture L1)

**Plus le nombre de "miss" est √©lev√©, plus le code est lent** car les donn√©es ne sont pas dans le cache rapide.

#### Annoter le Code Source

Pour voir ligne par ligne les statistiques :

```bash
cg_annotate --auto=yes cachegrind.out.12345 MonProgramme.pas > rapport_annote.txt
```

### Outil 3 : Callgrind - Profiling d'Appels D√©taill√©

#### Avantages de Callgrind vs gprof

- **Plus pr√©cis** : compte exact des instructions
- **Pas besoin de `-pg`** : pas d'instrumentation du code
- **Visualisation graphique** : avec KCachegrind

#### Utilisation de Callgrind

```bash
valgrind --tool=callgrind ./MonProgramme
```

G√©n√®re un fichier `callgrind.out.<pid>`.

#### Analyser avec KCachegrind (Interface Graphique)

Installation :

```bash
sudo apt install kcachegrind
```

Utilisation :

```bash
kcachegrind callgrind.out.12345
```

**KCachegrind affiche :**
- Un graphique visuel des appels de fonction
- Le temps pass√© dans chaque fonction (avec couleurs)
- Le graphe d'appels interactif
- Les statistiques de cache
- Le code source annot√©

C'est l'outil le plus visuel et intuitif pour le profiling !

#### Callgrind en Ligne de Commande

```bash
callgrind_annotate callgrind.out.12345
```

Affiche un rapport similaire √† gprof mais plus d√©taill√©.

### Outil 4 : Massif - Profiling du Heap

#### Qu'est-ce que Massif mesure ?

Massif trace l'utilisation du heap (tas) dans le temps :
- Combien de m√©moire est allou√©e
- Quand les allocations ont lieu
- Quelles fonctions allouent le plus de m√©moire

#### Utilisation de Massif

```bash
valgrind --tool=massif ./MonProgramme
```

G√©n√®re un fichier `massif.out.<pid>`.

#### Visualiser avec ms_print

```bash
ms_print massif.out.12345
```

Exemple de sortie (graphique ASCII) :

```
    MB
120 |                                                       :#
    |                                                    @@@:#
    |                                                 @@@@@@:#
100 |                                              @@@@@@@@@:#
    |                                           @@@@@@@@@@@@:#
    |                                        @@@@@@@@@@@@@@@:#
 80 |                                     @@@@@@@@@@@@@@@@@@:#
    |                                  @@@@@@@@@@@@@@@@@@@@@:#
    |                               @@@@@@@@@@@@@@@@@@@@@@@@:#
 60 |                            @@@@@@@@@@@@@@@@@@@@@@@@@@@:#
    |                         @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
    |                      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
 40 |                   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
    |                @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
    |             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
 20 |          @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
    |       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
    |    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:#
  0 +----------------------------------------------------------------------->s
    0                                                                   10.00
```

Chaque `@` ou `:` repr√©sente une allocation. On voit clairement :
- Le pic de m√©moire √† 120 MB
- La croissance progressive de l'utilisation
- Les moments d'allocation intense

#### Interface Graphique avec Massif-Visualizer

Installation :

```bash
sudo apt install massif-visualizer
```

Utilisation :

```bash
massif-visualizer massif.out.12345
```

Affiche un graphique moderne avec :
- Courbe de l'utilisation m√©moire dans le temps
- Liste des fonctions qui allouent le plus
- D√©tails de chaque snapshot

---

## Comparaison gprof vs Valgrind

| Crit√®re | gprof | Valgrind |
|---------|-------|----------|
| **Vitesse** | Rapide (10-20% overhead) | Lent (10-50x plus lent) |
| **Pr√©cision** | Sampling (√©chantillonnage) | Exacte (instruction par instruction) |
| **M√©moire** | Non | Oui (Memcheck, Massif) |
| **Cache** | Non | Oui (Cachegrind) |
| **Setup** | Compilation avec `-pg` | Aucune compilation sp√©ciale |
| **Threads** | Limit√© | Excellent (Helgrind) |
| **Usage** | Profiling rapide temps CPU | Analyse approfondie et d√©bogage |

**R√®gle g√©n√©rale :**
- **gprof** pour identifier rapidement les fonctions lentes
- **Valgrind** pour comprendre en d√©tail les probl√®mes de m√©moire et performance

---

## Workflows Pratiques

### Workflow 1 : Optimisation de Performance

```bash
# 1. Profiling rapide avec gprof
fpc -pg -O2 MonProgramme.pas
./MonProgramme
gprof MonProgramme gmon.out > gprof_rapport.txt

# 2. Identifier les fonctions lentes dans gprof_rapport.txt

# 3. Analyse d√©taill√©e avec Callgrind
fpc -gl -O2 MonProgramme.pas
valgrind --tool=callgrind ./MonProgramme
kcachegrind callgrind.out.*

# 4. Optimiser le code

# 5. Recommencer pour v√©rifier l'am√©lioration
```

### Workflow 2 : Chasse aux Fuites M√©moire

```bash
# 1. Compilation avec d√©bogage
fpc -gl -gh MonProgramme.pas

# 2. D√©tection de fuites avec Memcheck
valgrind --leak-check=full \
         --show-leak-kinds=all \
         --track-origins=yes \
         --log-file=memcheck.txt \
         ./MonProgramme

# 3. Analyser memcheck.txt pour trouver les fuites

# 4. Corriger le code

# 5. Profiler l'utilisation heap avec Massif
valgrind --tool=massif ./MonProgramme
massif-visualizer massif.out.*

# 6. V√©rifier que l'utilisation m√©moire est normale
```

### Workflow 3 : Optimisation Cache

```bash
# 1. Profiler le cache
valgrind --tool=cachegrind ./MonProgramme

# 2. Analyser les d√©fauts de cache
cg_annotate --auto=yes cachegrind.out.* MonProgramme.pas

# 3. Identifier les structures de donn√©es avec beaucoup de cache miss

# 4. R√©organiser les donn√©es pour am√©liorer la localit√©
#    (ex: structure of arrays au lieu de array of structures)

# 5. Re-profiler pour confirmer l'am√©lioration
```

---

## Conseils et Astuces Avanc√©s

### 1. Profiler Uniquement une Partie du Code

Avec Callgrind, vous pouvez activer/d√©sactiver le profiling dynamiquement :

```bash
valgrind --tool=callgrind --instr-atstart=no ./MonProgramme
```

Dans votre code Pascal, utilisez les fonctions de contr√¥le :

```pascal
{$IFDEF UNIX}
uses
  BaseUnix;

procedure DemarrerProfiling;
begin
  // D√©marre l'instrumentation Callgrind
  FpSystem('callgrind_control -i on');
end;

procedure ArreterProfiling;
begin
  // Arr√™te l'instrumentation
  FpSystem('callgrind_control -i off');
end;
{$ENDIF}

// Utilisation
DemarrerProfiling;
  CodeACritiqueAProfler;
ArreterProfiling;
```

### 2. Comparer Deux Profilages

Utilisez `cg_diff` pour comparer deux sessions Callgrind :

```bash
# Profiling avant optimisation
valgrind --tool=callgrind -o callgrind.avant ./MonProgramme

# Optimisation du code...

# Profiling apr√®s optimisation
valgrind --tool=callgrind -o callgrind.apres ./MonProgramme

# Comparaison
cg_diff callgrind.avant callgrind.apres
```

### 3. Profiling Multi-Thread

Pour profiler les applications multi-thread√©es :

```bash
# V√©rifier les race conditions
valgrind --tool=helgrind ./MonProgramme

# Profiler avec support threads
valgrind --tool=callgrind --separate-threads=yes ./MonProgramme
```

### 4. Suppressions Valgrind

Cr√©ez un fichier `suppressions.txt` pour ignorer les fausses alertes :

```
{
   <nom_suppression>
   Memcheck:Leak
   fun:malloc
   fun:InitializeRTL
}
```

Utilisez-le :

```bash
valgrind --suppressions=suppressions.txt ./MonProgramme
```

### 5. Script de Profiling Complet

Cr√©ez `profile_complet.sh` :

```bash
#!/bin/bash
PROGRAM=$1

echo "=== Compilation ==="
fpc -gl -gh -O2 $PROGRAM.pas

echo "=== Memcheck - Fuites m√©moire ==="
valgrind --leak-check=full \
         --log-file=memcheck.log \
         ./$PROGRAM

echo "=== Callgrind - Performance ==="
valgrind --tool=callgrind \
         --callgrind-out-file=callgrind.out \
         ./$PROGRAM

echo "=== Massif - Heap ==="
valgrind --tool=massif \
         --massif-out-file=massif.out \
         ./$PROGRAM

echo "=== G√©n√©ration des rapports ==="
callgrind_annotate callgrind.out > callgrind_rapport.txt
ms_print massif.out > massif_rapport.txt

echo "=== Termin√© ==="
echo "Rapports disponibles:"
echo "  - memcheck.log"
echo "  - callgrind_rapport.txt"
echo "  - massif_rapport.txt"
```

---

## Exemple Complet Comment√©

### Code avec Probl√®mes

```pascal
program ExempleProfilageBuggy;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes;

type
  TPersonne = class
    Nom: string;
    Age: Integer;
  end;

var
  Liste: TList;
  i: Integer;
  p: TPersonne;

begin
  Liste := TList.Create;

  // PROBL√àME 1: Fuite m√©moire - objets jamais lib√©r√©s
  for i := 1 to 10000 do
  begin
    p := TPersonne.Create;
    p.Nom := 'Personne' + IntToStr(i);
    p.Age := Random(100);
    Liste.Add(p);
  end;

  // PROBL√àME 2: Acc√®s hors limites
  WriteLn('Acc√®s √† l''√©l√©ment 10001:', TPersonne(Liste[10001]).Nom);

  // PROBL√àME 3: Liste lib√©r√©e mais pas son contenu
  Liste.Free;
end.
```

### Profiling avec Valgrind

```bash
# Compilation
fpc -gl -gh ExempleProfilageBuggy.pas

# D√©tection des probl√®mes
valgrind --leak-check=full ./ExempleProfilageBuggy
```

### Rapport Valgrind

```
==12345== Invalid read of size 8
==12345==    at 0x401234: main (ExempleProfilageBuggy.pas:28)
==12345==  Address 0x5204050 is not stack'd, malloc'd or (recently) free'd

==12345== LEAK SUMMARY:
==12345==    definitely lost: 480,000 bytes in 10,000 blocks
```

**Diagnostic :**
1. Acc√®s invalide ligne 28 (hors limites)
2. Fuite de 480 Ko (10 000 objets TPersonne jamais lib√©r√©s)

### Code Corrig√©

```pascal
program ExempleProfilageCorrige;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes;

type
  TPersonne = class
    Nom: string;
    Age: Integer;
  end;

var
  Liste: TList;
  i: Integer;
  p: TPersonne;

begin
  Liste := TList.Create;
  try
    // Cr√©ation des objets
    for i := 1 to 10000 do
    begin
      p := TPersonne.Create;
      p.Nom := 'Personne' + IntToStr(i);
      p.Age := Random(100);
      Liste.Add(p);
    end;

    // Acc√®s VALIDE (dans les limites)
    if Liste.Count > 0 then
      WriteLn('Premi√®re personne: ', TPersonne(Liste[0]).Nom);

  finally
    // Lib√©ration correcte de tous les objets
    for i := 0 to Liste.Count - 1 do
      TPersonne(Liste[i]).Free;
    Liste.Free;
  end;
end.
```

### V√©rification

```bash
valgrind --leak-check=full ./ExempleProfilageCorrige
```

R√©sultat :

```
==12346== HEAP SUMMARY:
==12346==     in use at exit: 0 bytes in 0 blocks
==12346==   total heap usage: 10,001 allocs, 10,001 frees
==12346==
==12346== All heap blocks were freed -- no leaks are possible
```

‚úÖ Aucune fuite, tous les objets lib√©r√©s correctement !

---

## Conclusion

Le profiling sous Linux offre des outils exceptionnels :

### gprof
‚úÖ Rapide et simple pour identifier les fonctions lentes  
‚úÖ Int√©gr√© nativement  
‚úÖ Parfait pour une premi√®re analyse

### Valgrind
‚úÖ D√©tection exhaustive des probl√®mes m√©moire  
‚úÖ Profiling tr√®s pr√©cis du CPU et du cache  
‚úÖ Visualisation graphique avec KCachegrind  
‚úÖ Indispensable pour du code robuste

**Recommandation :** Utilisez les deux ! gprof pour la vitesse, Valgrind pour la qualit√© et la rigueur.

**R√®gle d'or du profiling :**
> Mesurez, optimisez, mesurez √† nouveau. Jamais dans l'autre sens !

‚è≠Ô∏è [Analyse statique du code](/18-tests-qualite-code/05-analyse-statique-code.md)
