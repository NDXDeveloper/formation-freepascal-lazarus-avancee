üîù Retour au [Sommaire](/SOMMAIRE.md)

# 26.7.2 Adaptation pour Linux

## Introduction

Une fois votre projet Delphi port√© vers FreePascal/Lazarus (section 26.7.1), l'√©tape suivante consiste √† l'adapter pour une v√©ritable compatibilit√© Linux. La simple compilation sous Linux ne suffit pas : une application v√©ritablement multi-plateforme doit respecter les conventions Linux, s'int√©grer harmonieusement dans l'environnement desktop, et offrir une exp√©rience utilisateur native.

Cette section vous guide √† travers toutes les adaptations n√©cessaires pour transformer votre application Windows en une application Linux de qualit√© professionnelle.

### Philosophie : Penser multi-plateforme

**Mauvaise approche :**
```pascal
// Application qui "fonctionne" sur Linux mais reste Windows-centr√©e
if FileExists('C:\Config\app.ini') then
  LoadConfig('C:\Config\app.ini');
```

**Bonne approche :**
```pascal
// Application v√©ritablement multi-plateforme
function GetConfigFile: String;  
begin
  {$IFDEF WINDOWS}
  Result := GetEnvironmentVariable('APPDATA') + '\MyApp\config.ini';
  {$ENDIF}
  {$IFDEF UNIX}
  Result := GetEnvironmentVariable('HOME') + '/.config/myapp/config.ini';
  {$ENDIF}
end;
```

---

## Diff√©rences fondamentales Windows ‚Üî Linux

### Tableau comparatif

| Aspect | Windows | Linux | Impact |
|--------|---------|-------|--------|
| **Syst√®me de fichiers** | Insensible √† la casse | Sensible √† la casse | ‚ö†Ô∏è √âlev√© |
| **S√©parateur de chemin** | `\` backslash | `/` slash | ‚ö†Ô∏è √âlev√© |
| **Fin de ligne** | CRLF (`\r\n`) | LF (`\n`) | ‚ö†Ô∏è Moyen |
| **Lecteurs** | C:, D:, etc. | Point de montage unique `/` | ‚ö†Ô∏è √âlev√© |
| **Ex√©cutables** | .exe, .dll | Sans extension, .so | ‚ö†Ô∏è Moyen |
| **Registry** | Centralis√©e | Fichiers texte distribu√©s | ‚ö†Ô∏è √âlev√© |
| **Permissions** | ACL complexes | Mod√®le Unix (rwx) | ‚ö†Ô∏è Moyen |
| **Services** | Service Manager | systemd/init | ‚ö†Ô∏è √âlev√© |
| **Encodage** | ANSI/UTF-16 historique | UTF-8 natif | ‚ö†Ô∏è Moyen |
| **Interface** | Win32 API | GTK/Qt/X11 | ‚ö†Ô∏è Faible (LCL abstrait) |
| **Utilisateurs** | Admin/User | root/user | ‚ö†Ô∏è Moyen |
| **Raccourcis** | .lnk | .desktop | ‚ö†Ô∏è Faible |

### Concepts cl√©s √† comprendre

**1. Syst√®me de fichiers hi√©rarchique unique**

```
Windows:                    Linux:  
C:\                         /
‚îú‚îÄ‚îÄ Program Files\          ‚îú‚îÄ‚îÄ usr/
‚îú‚îÄ‚îÄ Users\                  ‚îÇ   ‚îú‚îÄ‚îÄ bin/         (ex√©cutables)
‚îî‚îÄ‚îÄ Windows\                ‚îÇ   ‚îú‚îÄ‚îÄ lib/         (biblioth√®ques)
                            ‚îÇ   ‚îî‚îÄ‚îÄ share/       (donn√©es partag√©es)
D:\                         ‚îú‚îÄ‚îÄ home/
‚îî‚îÄ‚îÄ Data\                   ‚îÇ   ‚îî‚îÄ‚îÄ username/    (donn√©es utilisateur)
                            ‚îú‚îÄ‚îÄ etc/             (configuration syst√®me)
                            ‚îú‚îÄ‚îÄ var/             (donn√©es variables)
                            ‚îî‚îÄ‚îÄ tmp/             (temporaire)
```

**2. Sensibilit√© √† la casse**

```pascal
// Windows : tous √©quivalents
'MyFile.txt'
'myfile.txt'
'MYFILE.TXT'

// Linux : tous diff√©rents !
'MyFile.txt'  ‚â† 'myfile.txt' ‚â† 'MYFILE.TXT'
```

**3. Permissions Unix**

```bash
-rwxr-xr-x  1 user group  12345 Jan 15 10:30 myapp
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îî‚îÄ Autres : ex√©cution (x)
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ Autres : lecture (r)
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ Groupe : ex√©cution (x)
‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Groupe : lecture (r)
‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Propri√©taire : ex√©cution (x)
‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Propri√©taire : √©criture (w)
‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Propri√©taire : lecture (r)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Type : - (fichier normal), d (r√©pertoire)
```

---

## Adaptation des chemins de fichiers

### Utiliser les fonctions portables

FreePascal fournit des fonctions qui s'adaptent automatiquement √† la plateforme.

**Fonctions recommand√©es :**

```pascal
uses
  SysUtils, FileUtil, LazFileUtils;

// Chemin du r√©pertoire de l'application
function GetAppPath: String;  
begin
  Result := ExtractFilePath(ParamStr(0));
  // Windows: C:\Program Files\MyApp\
  // Linux:   /opt/myapp/
end;

// R√©pertoire temporaire
function GetTempDir: String;  
begin
  Result := GetTempDir(True);  // LazFileUtils
  // Windows: C:\Users\xxx\AppData\Local\Temp\
  // Linux:   /tmp/
end;

// R√©pertoire utilisateur
function GetUserDir: String;  
begin
  Result := GetUserDir;  // SysUtils
  // Windows: C:\Users\username\
  // Linux:   /home/username/
end;

// R√©pertoire de configuration utilisateur
function GetAppConfigDir: String;  
begin
  Result := GetAppConfigDir(False);  // LazFileUtils
  // Windows: C:\Users\xxx\AppData\Roaming\
  // Linux:   /home/username/.config/
end;

// Construire un chemin multi-plateforme
function BuildPath(const Parts: array of String): String;  
var
  Part: String;
begin
  Result := '';
  for Part in Parts do
    Result := IncludeTrailingPathDelimiter(Result) + Part;
  // Utilise automatiquement \ ou / selon l'OS
end;

// Utilisation
var
  ConfigFile: String;
begin
  ConfigFile := BuildPath([GetAppConfigDir, 'myapp', 'config.ini']);
  // Windows: C:\Users\xxx\AppData\Roaming\myapp\config.ini
  // Linux:   /home/username/.config/myapp/config.ini
end;
```

### Abstraction compl√®te des chemins

Cr√©ez une unit√© centrale pour g√©rer tous les chemins :

```pascal
unit AppPaths;

{$mode objfpc}{$H+}

interface

uses
  SysUtils, FileUtil, LazFileUtils;

type
  TAppPaths = class
  private
    class var FAppName: String;
  public
    class constructor Create;

    // Propri√©t√©s de classe
    class property AppName: String read FAppName write FAppName;

    // M√©thodes
    class function GetAppDir: String;
    class function GetConfigDir: String;
    class function GetDataDir: String;
    class function GetCacheDir: String;
    class function GetLogDir: String;
    class function GetConfigFile: String;
    class function GetLogFile: String;

    // Utilitaires
    class procedure EnsureDirectoryExists(const Dir: String);
  end;

implementation

class constructor TAppPaths.Create;  
begin
  FAppName := 'MyApp';  // Nom par d√©faut
end;

class function TAppPaths.GetAppDir: String;  
begin
  Result := ExtractFilePath(ParamStr(0));
end;

class function TAppPaths.GetConfigDir: String;  
begin
  {$IFDEF WINDOWS}
  Result := GetAppConfigDir(False) + AppName + PathDelim;
  {$ENDIF}
  {$IFDEF UNIX}
  Result := GetUserDir + '.config' + PathDelim +
            LowerCase(AppName) + PathDelim;
  {$ENDIF}
  EnsureDirectoryExists(Result);
end;

class function TAppPaths.GetDataDir: String;  
begin
  {$IFDEF WINDOWS}
  Result := GetAppConfigDir(False) + AppName + PathDelim + 'Data' + PathDelim;
  {$ENDIF}
  {$IFDEF UNIX}
  Result := GetUserDir + '.local' + PathDelim + 'share' + PathDelim +
            LowerCase(AppName) + PathDelim;
  {$ENDIF}
  EnsureDirectoryExists(Result);
end;

class function TAppPaths.GetCacheDir: String;  
begin
  {$IFDEF WINDOWS}
  Result := GetAppConfigDir(False) + AppName + PathDelim + 'Cache' + PathDelim;
  {$ENDIF}
  {$IFDEF UNIX}
  Result := GetUserDir + '.cache' + PathDelim +
            LowerCase(AppName) + PathDelim;
  {$ENDIF}
  EnsureDirectoryExists(Result);
end;

class function TAppPaths.GetLogDir: String;  
begin
  {$IFDEF WINDOWS}
  Result := GetAppConfigDir(False) + AppName + PathDelim + 'Logs' + PathDelim;
  {$ENDIF}
  {$IFDEF UNIX}
  Result := GetUserDir + '.local' + PathDelim + 'share' + PathDelim +
            LowerCase(AppName) + PathDelim + 'logs' + PathDelim;
  {$ENDIF}
  EnsureDirectoryExists(Result);
end;

class function TAppPaths.GetConfigFile: String;  
begin
  Result := GetConfigDir + 'config.ini';
end;

class function TAppPaths.GetLogFile: String;  
begin
  Result := GetLogDir + 'app.log';
end;

class procedure TAppPaths.EnsureDirectoryExists(const Dir: String);  
begin
  if not DirectoryExists(Dir) then
    ForceDirectories(Dir);
end;

end.
```

**Utilisation :**

```pascal
uses
  AppPaths;

procedure SaveSettings;  
begin
  TAppPaths.AppName := 'MyApplication';
  SaveToFile(TAppPaths.GetConfigFile);
  WriteLn('Configuration saved to: ', TAppPaths.GetConfigFile);
  // Windows: C:\Users\xxx\AppData\Roaming\MyApplication\config.ini
  // Linux:   /home/username/.config/myapplication/config.ini
end;

procedure WriteLog(const Msg: String);  
var
  F: TextFile;
begin
  AssignFile(F, TAppPaths.GetLogFile);
  try
    if FileExists(TAppPaths.GetLogFile) then
      Append(F)
    else
      Rewrite(F);
    WriteLn(F, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', Msg);
  finally
    CloseFile(F);
  end;
end;
```

### Gestion de la casse des fichiers

**Probl√®me :**

```pascal
// Windows : fonctionne
if FileExists('MyFile.TXT') then
  LoadFile('myfile.txt');  // OK, m√™me fichier

// Linux : √©choue silencieusement
if FileExists('MyFile.TXT') then  // False
  LoadFile('myfile.txt');         // Pas ex√©cut√© si fichier = MyFile.TXT
```

**Solutions :**

```pascal
// Solution 1 : Toujours utiliser la m√™me casse
// Convention : minuscules pour Linux
const
  CONFIG_FILE = 'config.ini';  // Pas 'Config.INI' ou 'CONFIG.INI'

// Solution 2 : Recherche insensible √† la casse
function FindFileIgnoreCase(const FileName: String): String;  
var
  Dir, Name: String;
  SR: TSearchRec;
begin
  Result := '';
  Dir := ExtractFilePath(FileName);
  Name := ExtractFileName(FileName);

  if FindFirst(Dir + '*', faAnyFile, SR) = 0 then
  begin
    repeat
      if CompareText(SR.Name, Name) = 0 then  // Insensible √† la casse
      begin
        Result := Dir + SR.Name;
        Break;
      end;
    until FindNext(SR) <> 0;
    FindClose(SR);
  end;
end;

// Utilisation
var
  ActualFile: String;
begin
  ActualFile := FindFileIgnoreCase('/home/user/myfile.txt');
  if ActualFile <> '' then
    LoadFile(ActualFile);
end;

// Solution 3 : Normaliser les noms √† la cr√©ation
function NormalizeFileName(const FileName: String): String;  
begin
  {$IFDEF UNIX}
  Result := LowerCase(FileName);  // Tout en minuscules sur Linux
  {$ELSE}
  Result := FileName;
  {$ENDIF}
end;
```

---

## Configuration : Registry ‚Üí Fichiers texte

### Migrer depuis le Registry Windows

**Approche Windows (Registry) :**

```pascal
uses
  Registry;

procedure SaveSettingToRegistry(const Key, Value: String);  
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey('Software\MyApp\Settings', True);
    Reg.WriteString(Key, Value);
  finally
    Reg.Free;
  end;
end;
```

**Approche multi-plateforme (INI) :**

```pascal
uses
  IniFiles;

procedure SaveSetting(const Key, Value: String);  
var
  Ini: TIniFile;
begin
  Ini := TIniFile.Create(TAppPaths.GetConfigFile);
  try
    Ini.WriteString('Settings', Key, Value);
  finally
    Ini.Free;
  end;
end;
```

**Approche moderne (JSON) :**

```pascal
uses
  fpjson, jsonparser;

procedure SaveSettings(const Settings: TJSONObject);  
var
  F: TextFile;
begin
  AssignFile(F, TAppPaths.GetConfigDir + 'settings.json');
  try
    Rewrite(F);
    WriteLn(F, Settings.FormatJSON);
  finally
    CloseFile(F);
  end;
end;

procedure LoadSettings(out Settings: TJSONObject);  
var
  JSONString: String;
begin
  JSONString := ReadFileToString(TAppPaths.GetConfigDir + 'settings.json');
  Settings := TJSONObject(GetJSON(JSONString));
end;

// Utilisation
var
  Settings: TJSONObject;
begin
  Settings := TJSONObject.Create;
  try
    Settings.Add('language', 'fr');
    Settings.Add('theme', 'dark');
    Settings.Add('fontSize', 12);
    SaveSettings(Settings);
  finally
    Settings.Free;
  end;
end;
```

### Configuration syst√®me vs utilisateur

**Sous Linux, distinguer :**

```pascal
// Configuration GLOBALE (tous les utilisateurs)
// N√©cessite sudo pour √©crire
const
  SYSTEM_CONFIG = '/etc/myapp/config.ini';

// Configuration UTILISATEUR (utilisateur courant)
// Pas besoin de privil√®ges
function GetUserConfig: String;  
begin
  Result := GetUserDir + '.config/myapp/config.ini';
end;

// Ordre de priorit√© recommand√©
function LoadConfiguration: TIniFile;  
begin
  // 1. Config utilisateur (prioritaire)
  if FileExists(GetUserConfig) then
    Result := TIniFile.Create(GetUserConfig)
  // 2. Sinon config syst√®me
  else if FileExists(SYSTEM_CONFIG) then
    Result := TIniFile.Create(SYSTEM_CONFIG)
  // 3. Sinon cr√©er config utilisateur par d√©faut
  else
  begin
    Result := TIniFile.Create(GetUserConfig);
    // Initialiser avec valeurs par d√©faut
    Result.WriteString('General', 'Language', 'en');
  end;
end;
```

---

## Permissions et s√©curit√©

### Comprendre les permissions Linux

**Lecture des permissions :**

```pascal
uses
  BaseUnix;

function GetFilePermissions(const FileName: String): Integer;  
var
  Info: Stat;
begin
  if FpStat(FileName, Info) = 0 then
    Result := Info.st_mode and $1FF  // 9 derniers bits = permissions
  else
    Result := 0;
end;

function IsExecutable(const FileName: String): Boolean;  
var
  Perm: Integer;
begin
  Perm := GetFilePermissions(FileName);
  Result := (Perm and S_IXUSR) <> 0;  // Bit ex√©cution propri√©taire
end;

// V√©rifier si le fichier est lisible
function IsReadable(const FileName: String): Boolean;  
var
  Perm: Integer;
begin
  Perm := GetFilePermissions(FileName);
  Result := (Perm and S_IRUSR) <> 0;
end;
```

### D√©finir les permissions

```pascal
uses
  BaseUnix;

// Rendre un fichier ex√©cutable
procedure MakeExecutable(const FileName: String);  
begin
  FpChmod(FileName, S_IRWXU or S_IRGRP or S_IXGRP or S_IROTH or S_IXOTH);
  // rwxr-xr-x : 755
end;

// Permissions lecture seule
procedure MakeReadOnly(const FileName: String);  
begin
  FpChmod(FileName, S_IRUSR or S_IRGRP or S_IROTH);
  // r--r--r-- : 444
end;

// Permissions priv√©es (utilisateur seulement)
procedure MakePrivate(const FileName: String);  
begin
  FpChmod(FileName, S_IRUSR or S_IWUSR);
  // rw------- : 600
end;
```

### Gestion des erreurs de permissions

```pascal
procedure SafeWriteToFile(const FileName, Content: String);  
begin
  try
    WriteStringToFile(FileName, Content);
  except
    on E: EInOutError do
    begin
      // Erreur d'acc√®s, probablement permissions
      if E.ErrorCode = 13 then  // Permission denied
      begin
        ShowMessage('Permission refus√©e. ' +
          'Lancez l''application avec sudo ou changez les permissions.');
      end
      else
        raise;  // Autre erreur
    end;
  end;
end;
```

### √âl√©vation de privil√®ges

**D√©tecter si root :**

```pascal
uses
  BaseUnix;

function IsRunningAsRoot: Boolean;  
begin
  Result := FpGetUID = 0;
end;

// Avertir l'utilisateur
procedure CheckPrivileges;  
begin
  if IsRunningAsRoot then
    ShowMessage('Attention : Application ex√©cut√©e en tant que root. ' +
                'Ceci n''est pas recommand√© pour des raisons de s√©curit√©.');
end;
```

**Demander √©l√©vation (via pkexec) :**

```pascal
uses
  Process;

function RunWithElevatedPrivileges(const Command: String): Boolean;  
var
  Proc: TProcess;
begin
  Proc := TProcess.Create(nil);
  try
    Proc.Executable := 'pkexec';  // PolicyKit (remplace gksudo)
    Proc.Parameters.Add(Command);
    Proc.Options := [poWaitOnExit];
    Proc.Execute;
    Result := Proc.ExitStatus = 0;
  finally
    Proc.Free;
  end;
end;

// Utilisation
if not IsRunningAsRoot then  
begin
  if MessageDlg('Cette op√©ration n√©cessite des privil√®ges administrateur. Continuer ?',
                mtConfirmation, [mbYes, mbNo], 0) = mrYes then
  begin
    if RunWithElevatedPrivileges('/opt/myapp/myapp --install') then
      ShowMessage('Installation r√©ussie')
    else
      ShowMessage('Installation annul√©e ou √©chou√©e');
  end;
end;
```

---

## Services et d√©mons

### Migrer un service Windows vers systemd

**Service Windows (ancien) :**

```pascal
uses
  {$IFDEF WINDOWS}
  JwaTlHelp32, Windows;
  {$ENDIF}

type
  TMyService = class(TService)
    procedure ServiceExecute(Sender: TService);
  end;

procedure TMyService.ServiceExecute(Sender: TService);  
begin
  while not Terminated do
  begin
    // Logique du service
    Sleep(1000);
  end;
end;
```

**D√©mon Linux (systemd) :**

```pascal
program MyDaemon;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  BaseUnix, Unix,
  {$ENDIF}
  SysUtils, Classes;

var
  Terminated: Boolean = False;

procedure SignalHandler(Signal: LongInt); cdecl;  
begin
  case Signal of
    SIGTERM, SIGINT:
      begin
        WriteLn('Received termination signal');
        Terminated := True;
      end;
    SIGHUP:
      begin
        WriteLn('Received reload signal');
        // Recharger la configuration
      end;
  end;
end;

procedure DaemonLoop;  
begin
  WriteLn('Daemon started');

  while not Terminated do
  begin
    // Logique du d√©mon
    WriteLn(FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - Running');
    Sleep(5000);
  end;

  WriteLn('Daemon stopped');
end;

begin
  {$IFDEF UNIX}
  // Installer les gestionnaires de signaux
  FpSignal(SIGTERM, @SignalHandler);
  FpSignal(SIGINT, @SignalHandler);
  FpSignal(SIGHUP, @SignalHandler);

  // Se d√©tacher du terminal (daemonize)
  if FpFork > 0 then
    Halt(0);  // Le parent se termine

  // Le fils continue en arri√®re-plan
  FpUmask(0);
  FpSetsid;

  // Fermer stdin, stdout, stderr
  FpClose(0);
  FpClose(1);
  FpClose(2);

  // R√©ouvrir vers /dev/null ou fichier log
  // ...
  {$ENDIF}

  DaemonLoop;
end.
```

**Fichier systemd unit (/etc/systemd/system/myapp.service) :**

```ini
[Unit]
Description=My Application Daemon  
After=network.target

[Service]
Type=simple  
User=myappuser  
Group=myappuser  
WorkingDirectory=/opt/myapp  
ExecStart=/opt/myapp/myapp-daemon  
Restart=on-failure  
RestartSec=10

# S√©curit√©
PrivateTmp=yes  
NoNewPrivileges=yes  
ProtectSystem=strict  
ProtectHome=yes  
ReadWritePaths=/var/lib/myapp /var/log/myapp

[Install]
WantedBy=multi-user.target
```

**Installation et contr√¥le :**

```bash
# Copier le fichier unit
sudo cp myapp.service /etc/systemd/system/

# Recharger systemd
sudo systemctl daemon-reload

# Activer au d√©marrage
sudo systemctl enable myapp.service

# D√©marrer le service
sudo systemctl start myapp.service

# V√©rifier le statut
sudo systemctl status myapp.service

# Voir les logs
sudo journalctl -u myapp.service -f
```

### Approche simplifi√©e : daemon en mode "foreground"

Plus simple pour d√©buter :

```pascal
program SimpleDaemon;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes;

var
  Running: Boolean = True;

procedure MainLoop;  
var
  LogFile: TextFile;
begin
  AssignFile(LogFile, '/var/log/myapp/daemon.log');
  try
    if FileExists('/var/log/myapp/daemon.log') then
      Append(LogFile)
    else
      Rewrite(LogFile);

    WriteLn(LogFile, 'Daemon started at ', DateTimeToStr(Now));
    Flush(LogFile);

    while Running do
    begin
      // Votre logique
      WriteLn(LogFile, 'Running at ', DateTimeToStr(Now));
      Flush(LogFile);
      Sleep(5000);
    end;

    WriteLn(LogFile, 'Daemon stopped at ', DateTimeToStr(Now));
  finally
    CloseFile(LogFile);
  end;
end;

begin
  try
    MainLoop;
  except
    on E: Exception do
      WriteLn('Error: ', E.Message);
  end;
end.
```

**Systemd unit en mode simple :**

```ini
[Service]
Type=simple  
ExecStart=/opt/myapp/simpledaemon  
StandardOutput=journal  
StandardError=journal
```

---

## Interface graphique : Widgetsets

### Choisir le widgetset Linux

Lazarus supporte plusieurs widgetsets sur Linux :

| Widgetset | Description | Avantages | Inconv√©nients |
|-----------|-------------|-----------|---------------|
| **GTK2** | GNOME Toolkit 2 | Mature, stable | Ancien, abandonn√© GNOME |
| **GTK3** | GNOME Toolkit 3 | Moderne, GNOME natif | Quelques bugs LCL |
| **Qt5** | Qt 5 | Excellent, KDE natif | D√©pendances Qt lourdes |
| **Qt6** | Qt 6 | Moderne | Encore jeune en LCL |

**Configuration du widgetset :**

```bash
# Compilation avec GTK2 (d√©faut)
lazbuild --ws=gtk2 myproject.lpi

# Compilation avec Qt5
lazbuild --ws=qt5 myproject.lpi

# Compilation avec GTK3
lazbuild --ws=gtk3 myproject.lpi
```

**Dans l'IDE Lazarus :**

```
Project ‚Üí Project Options ‚Üí Compiler Options
‚Üí Config and Target
  ‚Üí Target OS: Linux
  ‚Üí Target CPU: x86_64
  ‚Üí LCL Widgetset: gtk2 / qt5 / gtk3
```

### Code sp√©cifique au widgetset

```pascal
{$IFDEF LCLGtk2}
uses
  Gtk2, Gdk2, Glib2;

procedure CustomGTK2Code;  
begin
  // Code sp√©cifique GTK2
end;
{$ENDIF}

{$IFDEF LCLQt5}
uses
  Qt5, QtWidgets;

procedure CustomQt5Code;  
begin
  // Code sp√©cifique Qt5
end;
{$ENDIF}

// Code portable (recommand√©)
procedure PortableCode;  
begin
  // Utiliser LCL, pas les API natives
  ShowMessage('Ceci fonctionne partout');
end;
```

### Th√®mes et apparence

**Respecter le th√®me syst√®me :**

```pascal
uses
  LCLIntf, LCLType;

procedure ApplySystemTheme;  
begin
  // LCL applique automatiquement le th√®me syst√®me
  // Pas besoin de code sp√©cial sur Linux

  {$IFDEF LINUX}
  // Le th√®me GTK/Qt du syst√®me est utilis√© automatiquement
  {$ENDIF}
end;

// Forcer un th√®me sp√©cifique (d√©conseill√©)
procedure ForceTheme(const ThemeName: String);  
begin
  {$IFDEF LCLGtk2}
  // gtk_settings_set_string_property(...)
  {$ENDIF}
  // Mieux : laisser l'utilisateur choisir son th√®me syst√®me
end;
```

**Dark mode :**

```pascal
uses
  Graphics, Forms;

function IsDarkTheme: Boolean;  
var
  BgColor: TColor;
begin
  BgColor := Application.MainForm.Color;
  // Si couleur sombre, probablement dark theme
  Result := (GetRValue(BgColor) + GetGValue(BgColor) + GetBValue(BgColor)) < 384;
end;

procedure AdaptToDarkMode;  
begin
  if IsDarkTheme then
  begin
    // Adapter les couleurs si n√©cessaire
    Panel1.Font.Color := clWhite;
  end
  else
  begin
    Panel1.Font.Color := clBlack;
  end;
end;
```

---

## Int√©gration desktop Linux

### Fichiers .desktop

Cr√©er un lanceur d'application :

```ini
# /usr/share/applications/myapp.desktop
[Desktop Entry]
Version=1.0  
Type=Application  
Name=My Application  
Name[fr]=Mon Application  
Comment=Description of my app  
Comment[fr]=Description de mon application  
Icon=/usr/share/icons/hicolor/256x256/apps/myapp.png  
Exec=/usr/bin/myapp %F  
Terminal=false  
Categories=Office;Utility;  
MimeType=application/x-myapp;  
StartupNotify=true  
StartupWMClass=myapp
```

**Installation :**

```bash
# Copier le fichier .desktop
sudo cp myapp.desktop /usr/share/applications/

# Mettre √† jour le cache
sudo update-desktop-database

# Ic√¥ne
sudo cp myapp.png /usr/share/icons/hicolor/256x256/apps/  
sudo gtk-update-icon-cache /usr/share/icons/hicolor/
```

**Cr√©er depuis l'application :**

```pascal
procedure CreateDesktopEntry;  
var
  DesktopFile: TextFile;
  DesktopPath: String;
begin
  DesktopPath := GetUserDir + '.local/share/applications/myapp.desktop';

  AssignFile(DesktopFile, DesktopPath);
  try
    Rewrite(DesktopFile);
    WriteLn(DesktopFile, '[Desktop Entry]');
    WriteLn(DesktopFile, 'Version=1.0');
    WriteLn(DesktopFile, 'Type=Application');
    WriteLn(DesktopFile, 'Name=My Application');
    WriteLn(DesktopFile, 'Exec=', ParamStr(0), ' %F');
    WriteLn(DesktopFile, 'Icon=myapp');
    WriteLn(DesktopFile, 'Terminal=false');
    WriteLn(DesktopFile, 'Categories=Utility;');
  finally
    CloseFile(DesktopFile);
  end;

  // Rendre ex√©cutable
  FpChmod(DesktopPath, S_IRWXU or S_IRGRP or S_IXGRP or S_IROTH or S_IXOTH);
end;
```

### Association de fichiers

**MIME type (/usr/share/mime/packages/myapp.xml) :**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<mime-info xmlns="http://www.freedesktop.org/standards/shared-mime-info">
  <mime-type type="application/x-myapp">
    <comment>MyApp Document</comment>
    <comment xml:lang="fr">Document MyApp</comment>
    <icon name="myapp"/>
    <glob pattern="*.myapp"/>
    <magic priority="50">
      <match type="string" offset="0" value="MYAPP"/>
    </magic>
  </mime-type>
</mime-info>
```

**Installation :**

```bash
sudo cp myapp.xml /usr/share/mime/packages/  
sudo update-mime-database /usr/share/mime
```

**G√©rer les fichiers pass√©s en param√®tre :**

```pascal
procedure TMainForm.FormCreate(Sender: TObject);  
var
  i: Integer;
begin
  // V√©rifier les param√®tres de ligne de commande
  for i := 1 to ParamCount do
  begin
    if FileExists(ParamStr(i)) then
      OpenFile(ParamStr(i));
  end;
end;
```

---

## Packaging et distribution

### Structure de d√©ploiement Linux

```
/opt/myapp/                    # Application
‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ myapp                  # Ex√©cutable principal
‚îú‚îÄ‚îÄ lib/                       # Biblioth√®ques priv√©es (.so)
‚îÇ   ‚îú‚îÄ‚îÄ libmylib.so
‚îÇ   ‚îî‚îÄ‚îÄ plugins/
‚îú‚îÄ‚îÄ share/                     # Donn√©es partag√©es
‚îÇ   ‚îú‚îÄ‚îÄ icons/
‚îÇ   ‚îú‚îÄ‚îÄ translations/
‚îÇ   ‚îî‚îÄ‚îÄ help/
‚îî‚îÄ‚îÄ doc/
    ‚îú‚îÄ‚îÄ README
    ‚îî‚îÄ‚îÄ LICENSE

/usr/share/applications/       # Lanceur
‚îî‚îÄ‚îÄ myapp.desktop

/usr/share/icons/hicolor/      # Ic√¥nes
‚îî‚îÄ‚îÄ 256x256/apps/
    ‚îî‚îÄ‚îÄ myapp.png

/etc/myapp/                    # Config syst√®me (optionnel)
‚îî‚îÄ‚îÄ config.ini

~/.config/myapp/               # Config utilisateur
‚îî‚îÄ‚îÄ config.ini

~/.local/share/myapp/          # Donn√©es utilisateur
‚îî‚îÄ‚îÄ data/
```

### Cr√©ation d'un paquet .deb (Debian/Ubuntu)

**Structure du paquet :**

```
myapp-1.0/
‚îú‚îÄ‚îÄ debian/
‚îÇ   ‚îú‚îÄ‚îÄ control              # M√©tadonn√©es
‚îÇ   ‚îú‚îÄ‚îÄ changelog            # Historique
‚îÇ   ‚îú‚îÄ‚îÄ copyright            # Licence
‚îÇ   ‚îú‚îÄ‚îÄ rules                # Build script
‚îÇ   ‚îú‚îÄ‚îÄ install              # Fichiers √† installer
‚îÇ   ‚îú‚îÄ‚îÄ postinst             # Script post-installation
‚îÇ   ‚îî‚îÄ‚îÄ prerm                # Script pr√©-suppression
‚îî‚îÄ‚îÄ [source files]
```

**debian/control :**

```
Source: myapp  
Section: utils  
Priority: optional  
Maintainer: Your Name <your.email@example.com>  
Build-Depends: debhelper (>= 10), lazarus, lcl, lcl-gtk2  
Standards-Version: 4.1.3

Package: myapp  
Architecture: amd64  
Depends: ${shlibs:Depends}, ${misc:Depends}, libgtk2.0-0  
Description: My Application
 Long description of my application
 spanning multiple lines.
```

**debian/rules :**

```makefile
#!/usr/bin/make -f

%:
	dh $@

override_dh_auto_build:
	lazbuild --build-mode=Release myapp.lpi

override_dh_auto_install:
	mkdir -p debian/myapp/opt/myapp/bin
	cp myapp debian/myapp/opt/myapp/bin/
	mkdir -p debian/myapp/usr/share/applications
	cp myapp.desktop debian/myapp/usr/share/applications/
```

**Compilation du paquet :**

```bash
# Se placer dans le r√©pertoire du projet
cd myapp-1.0/

# Construire le paquet
dpkg-buildpackage -us -uc

# Le .deb est cr√©√© dans le r√©pertoire parent
ls ../myapp_1.0_amd64.deb

# Installer
sudo dpkg -i ../myapp_1.0_amd64.deb

# Ou cr√©er un repository APT
```

### AppImage (portable)

AppImage = ex√©cutable autonome avec toutes les d√©pendances.

**Structure AppImage :**

```bash
# Installer linuxdeploy
wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage  
chmod +x linuxdeploy-x86_64.AppImage

# Pr√©parer l'AppDir
mkdir -p AppDir/usr/bin  
cp myapp AppDir/usr/bin/

mkdir -p AppDir/usr/share/applications  
cp myapp.desktop AppDir/usr/share/applications/

mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps  
cp myapp.png AppDir/usr/share/icons/hicolor/256x256/apps/

# Cr√©er l'AppImage
./linuxdeploy-x86_64.AppImage --appdir AppDir --output appimage

# R√©sultat : MyApp-x86_64.AppImage
chmod +x MyApp-x86_64.AppImage
./MyApp-x86_64.AppImage
```

**Script automatis√© :**

```bash
#!/bin/bash
# build-appimage.sh

APP_NAME="MyApp"  
VERSION="1.0"

# Compiler
lazbuild --build-mode=Release myapp.lpi

# Cr√©er AppDir
rm -rf AppDir  
mkdir -p AppDir/usr/bin  
cp myapp AppDir/usr/bin/

# Ic√¥ne et desktop
mkdir -p AppDir/usr/share/applications  
cp myapp.desktop AppDir/usr/share/applications/  
mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps  
cp myapp.png AppDir/usr/share/icons/hicolor/256x256/apps/

# G√©n√©rer AppImage
linuxdeploy-x86_64.AppImage \
  --appdir AppDir \
  --output appimage \
  --desktop-file=AppDir/usr/share/applications/myapp.desktop

# Renommer
mv MyApp-*.AppImage ${APP_NAME}-${VERSION}-x86_64.AppImage

echo "AppImage created: ${APP_NAME}-${VERSION}-x86_64.AppImage"
```

### Snap (Ubuntu moderne)

**snapcraft.yaml :**

```yaml
name: myapp  
version: '1.0'  
summary: My Application  
description: |
  Long description of my application

grade: stable  
confinement: strict

apps:
  myapp:
    command: bin/myapp
    desktop: share/applications/myapp.desktop
    plugs:
      - desktop
      - desktop-legacy
      - x11
      - home
      - network

parts:
  myapp:
    plugin: nil
    source: .
    override-build: |
      lazbuild --build-mode=Release myapp.lpi
      mkdir -p $SNAPCRAFT_PART_INSTALL/bin
      cp myapp $SNAPCRAFT_PART_INSTALL/bin/
    build-packages:
      - lazarus
      - lcl
      - lcl-gtk2
    stage-packages:
      - libgtk2.0-0
```

**Compilation :**

```bash
# Installer snapcraft
sudo snap install snapcraft --classic

# Builder le snap
snapcraft

# R√©sultat : myapp_1.0_amd64.snap

# Installer localement
sudo snap install --dangerous myapp_1.0_amd64.snap

# Ou publier sur Snap Store
snapcraft login  
snapcraft upload myapp_1.0_amd64.snap
```

---

## Tests sous Linux

### Tests de compatibilit√©

**Checklist de tests Linux :**

```markdown
## Interface utilisateur
- [ ] Application se lance correctement
- [ ] Toutes les fen√™tres s'affichent
- [ ] Menus fonctionnent
- [ ] Raccourcis clavier corrects
- [ ] Boutons r√©pondent aux clics
- [ ] Polices lisibles
- [ ] Ic√¥nes affich√©es
- [ ] Th√®me syst√®me respect√©

## Syst√®me de fichiers
- [ ] Ouverture de fichiers
- [ ] Sauvegarde de fichiers
- [ ] Chemins corrects (pas de C:\)
- [ ] Permissions respect√©es
- [ ] Casse des fichiers g√©r√©e
- [ ] Configuration sauvegard√©e dans ~/.config

## R√©seau
- [ ] Connexions HTTP/HTTPS
- [ ] Connexions base de donn√©es
- [ ] Sockets TCP/UDP

## Int√©gration syst√®me
- [ ] Lanceur .desktop fonctionne
- [ ] Ic√¥ne appara√Æt dans le menu
- [ ] Association fichiers OK
- [ ] Notifications syst√®me

## Performance
- [ ] Temps de d√©marrage acceptable
- [ ] Utilisation m√©moire normale
- [ ] Pas de fuite m√©moire
- [ ] CPU non satur√©
```

### Tests en machine virtuelle

```bash
# Installer VirtualBox
sudo apt install virtualbox

# Cr√©er une VM Ubuntu
# T√©l√©charger ISO Ubuntu depuis ubuntu.com
# Cr√©er VM, installer Ubuntu

# Tester votre application dans la VM
# Copier via dossier partag√© ou SSH

# Tests distribution
# - Ubuntu 20.04 LTS
# - Ubuntu 22.04 LTS
# - Debian 11
# - Fedora 38
```

### Tests avec Docker

```dockerfile
# Dockerfile.test
FROM ubuntu:22.04

# Installer d√©pendances
RUN apt-get update && apt-get install -y \
    libgtk2.0-0 \
    libx11-6 \
    && rm -rf /var/lib/apt/lists/*

# Copier application
COPY myapp /opt/myapp/

# Tests
CMD ["/opt/myapp/myapp", "--test"]
```

```bash
# Builder et tester
docker build -f Dockerfile.test -t myapp-test .  
docker run --rm myapp-test
```

---

## Bonnes pratiques multi-plateforme

### 1. Abstraire les diff√©rences

```pascal
unit PlatformAbstraction;

interface

type
  TPlatform = class
    class function GetOSName: String;
    class function GetUserName: String;
    class function GetComputerName: String;
    class function OpenURL(const URL: String): Boolean;
    class function GetDefaultBrowser: String;
  end;

implementation

uses
  SysUtils, Process, LCLIntf
  {$IFDEF UNIX}, BaseUnix{$ENDIF}
  {$IFDEF WINDOWS}, Windows{$ENDIF};

class function TPlatform.GetOSName: String;  
begin
  {$IFDEF WINDOWS}
  Result := 'Windows';
  {$ENDIF}
  {$IFDEF LINUX}
  Result := 'Linux';
  {$ENDIF}
  {$IFDEF DARWIN}
  Result := 'macOS';
  {$ENDIF}
end;

class function TPlatform.GetUserName: String;  
begin
  Result := GetEnvironmentVariable('USER');
  if Result = '' then
    Result := GetEnvironmentVariable('USERNAME');  // Windows
end;

class function TPlatform.OpenURL(const URL: String): Boolean;  
begin
  Result := OpenURL(URL);  // LCLIntf
end;

end.
```

### 2. Tester sur toutes les plateformes

```pascal
// Tests unitaires multi-plateforme
unit TestPlatform;

interface

uses
  fpcunit, testregistry;

type
  TPlatformTest = class(TTestCase)
  published
    procedure TestPaths;
    procedure TestPermissions;
    procedure TestFileOperations;
  end;

implementation

procedure TPlatformTest.TestPaths;  
var
  Path: String;
begin
  Path := GetAppConfigDir(False);
  AssertTrue('Config dir should exist', DirectoryExists(Path));

  {$IFDEF WINDOWS}
  AssertTrue('Should contain AppData', Pos('AppData', Path) > 0);
  {$ENDIF}
  {$IFDEF UNIX}
  AssertTrue('Should contain .config', Pos('.config', Path) > 0);
  {$ENDIF}
end;

initialization
  RegisterTest(TPlatformTest);
end.
```

### 3. Documentation multi-plateforme


# Installation

## Windows
1. T√©l√©charger myapp-setup.exe
2. Double-cliquer et suivre l'assistant

## Linux (Debian/Ubuntu)
```bash
sudo dpkg -i myapp_1.0_amd64.deb
```

## Linux (autres distributions)
T√©l√©charger MyApp-x86_64.AppImage et le rendre ex√©cutable :
```bash
chmod +x MyApp-x86_64.AppImage
./MyApp-x86_64.AppImage
```


---

## Conclusion

L'adaptation d'une application pour Linux va au-del√† de la simple compilation. Une application v√©ritablement multi-plateforme doit :

‚úÖ **Respecter les conventions Linux** (chemins, permissions, configuration)  
‚úÖ **S'int√©grer au desktop** (.desktop, th√®mes, ic√¥nes)  
‚úÖ **√ätre distribuable facilement** (.deb, AppImage, Snap)  
‚úÖ **Fonctionner comme une application native**

**Checklist finale d'adaptation Linux :**

- [ ] Tous les chemins sont portables (pas de C:\)
- [ ] Configuration via fichiers texte (pas Registry)
- [ ] Permissions g√©r√©es correctement
- [ ] Service converti en systemd unit (si applicable)
- [ ] Fichier .desktop cr√©√©
- [ ] MIME type d√©fini (si association fichiers)
- [ ] Paquet .deb ou AppImage cr√©√©
- [ ] Tests sur Ubuntu/Debian r√©alis√©s
- [ ] Documentation mise √† jour

Votre application est maintenant pr√™te pour Linux ! Dans les sections suivantes, nous verrons comment maintenir et faire √©voluer une base de code multi-plateforme, et comment contribuer √† l'√©cosyst√®me FreePascal/Lazarus.

‚è≠Ô∏è [Opportunit√©s professionnelles](/26-communaute-ecosysteme/08-opportunites-professionnelles.md)
