üîù Retour au [Sommaire](/SOMMAIRE.md)

# 24.8.2 Cross-compilation Linux ‚Üí Windows

## Introduction

La cross-compilation de Linux vers Windows permet de d√©velopper sur un environnement Linux (Ubuntu par exemple) tout en produisant des ex√©cutables Windows (.exe). Cette approche est particuli√®rement avantageuse pour :

- Les d√©veloppeurs qui pr√©f√®rent travailler sous Linux
- Les serveurs de build automatis√©s (CI/CD) sous Linux
- La cr√©ation de pipelines de compilation unifi√©s
- Le d√©veloppement open source multi-plateforme

FreePascal offre un excellent support pour ce type de cross-compilation gr√¢ce √† son architecture modulaire et ses outils MinGW int√©gr√©s.

## Pr√©requis

Avant de commencer, vous aurez besoin de :

1. **Ubuntu** (ou toute autre distribution Linux) avec les droits sudo
2. **FreePascal** install√© sur votre syst√®me Linux
3. **Lazarus IDE** (optionnel mais recommand√©)
4. **Un cross-compilateur Windows** (nous allons l'installer)
5. **Les biblioth√®ques Windows** n√©cessaires
6. **Environ 1 GB d'espace disque** pour les outils et biblioth√®ques

## Comprendre l'environnement MinGW

**MinGW** (Minimalist GNU for Windows) est un environnement de d√©veloppement qui permet de compiler des applications Windows depuis Linux. Il fournit :

- Un compilateur GCC adapt√© pour Windows
- L'√©diteur de liens pour Windows
- Les biblioth√®ques runtime Windows (DLL)
- Les en-t√™tes de l'API Windows

FreePascal utilise les outils MinGW pour la cross-compilation vers Windows.

## Architectures cibles Windows

Windows moderne fonctionne sur deux architectures principales :

- **i386** (32 bits) : Compatible avec Windows XP et sup√©rieur, fonctionne sur tous les syst√®mes
- **x86_64** (64 bits) : Pour Windows Vista 64 bits et sup√©rieur, plus performant

Nous nous concentrerons sur **x86_64** qui est aujourd'hui le standard, mais la proc√©dure est similaire pour i386.

## Installation du cross-compilateur

### M√©thode 1 : Via fpcupdeluxe (Recommand√©)

**fpcupdeluxe** est disponible pour Linux et simplifie grandement l'installation.

1. **T√©l√©charger fpcupdeluxe** :
   ```bash
   cd ~/Downloads
   wget https://github.com/LongDirtyAnimAlf/fpcupdeluxe/releases/download/release_2.2.4/fpcupdeluxe-x86_64-linux
   chmod +x fpcupdeluxe-x86_64-linux
   ```

2. **Lancer fpcupdeluxe** :
   ```bash
   ./fpcupdeluxe-x86_64-linux
   ```

3. **Installer le cross-compilateur Windows** :
   - Allez dans l'onglet **"Cross"**
   - S√©lectionnez **"x86_64-win64"** dans la liste
   - Cliquez sur **"Install compiler"**
   - Attendez la fin de l'installation (plusieurs minutes)

4. **Installer les biblioth√®ques Windows** :
   - Toujours dans l'onglet "Cross"
   - Cliquez sur **"Install libraries"**
   - Cela t√©l√©charge les DLL et fichiers .a n√©cessaires

### M√©thode 2 : Installation manuelle via APT

Sur Ubuntu/Debian, certains paquets facilitent l'installation :

```bash
# Mettre √† jour les paquets
sudo apt update

# Installer FreePascal si pas d√©j√† fait
sudo apt install fpc fpc-source

# Installer les outils MinGW pour Windows 64 bits
sudo apt install mingw-w64 binutils-mingw-w64-x86-64

# Installer les biblioth√®ques de d√©veloppement Windows
sudo apt install wine64-dev wine64-tools
```

### M√©thode 3 : Installation depuis les sources FPC

Pour les utilisateurs avanc√©s qui veulent la derni√®re version :

```bash
# Cloner le d√©p√¥t FPC
git clone https://gitlab.com/freepascal.org/fpc/source.git fpc-source
cd fpc-source

# Construire le compilateur cross pour Windows
make clean
make all OS_TARGET=win64 CPU_TARGET=x86_64

# Installer
sudo make install OS_TARGET=win64 CPU_TARGET=x86_64
```

## V√©rifier l'installation

Apr√®s l'installation, v√©rifiez que le cross-compilateur est disponible :

```bash
# Lister les compilateurs disponibles
fpc -i

# Chercher sp√©cifiquement les targets Windows
fpc -i | grep -i win
```

Vous devriez voir quelque chose comme :
```
Supported targets:
  ...
  x86_64-win64
  i386-win32
  ...
```

## Configuration de Lazarus pour la cross-compilation

### √âtape 1 : Ouvrir les options de build

1. Lancez **Lazarus**
2. Ouvrez votre projet ou cr√©ez-en un nouveau
3. Allez dans **Projet ‚Üí Options du projet**

### √âtape 2 : Configurer la cible Windows

1. Dans **Options de compilation ‚Üí Config et Target** :
   - **OS cible (-T)** : `win64` (ou `win32` pour 32 bits)
   - **CPU cible (-P)** : `x86_64` (ou `i386` pour 32 bits)
   - **LCL Widget Set** : `win32` (l'interface Windows)

2. Dans **Options de compilation ‚Üí Chemins de recherche** :
   - V√©rifiez que les chemins sont corrects
   - Utilisez des chemins relatifs quand possible pour la portabilit√©

### √âtape 3 : Configurer les biblioth√®ques

1. Dans **Options de compilation ‚Üí Chemins de recherche** :
   - **Chemin des biblioth√®ques (-Fl)** : Ajoutez le chemin vers les biblioth√®ques Windows
   - Typiquement : `/usr/x86_64-w64-mingw32/lib` ou similaire

### √âtape 4 : Options de l'√©diteur de liens

1. Dans **Options de compilation ‚Üí √âdition de liens** :
   - Pour une application console : laissez les options par d√©faut
   - Pour une application GUI : assurez-vous que **"Type d'application"** est sur **"GUI"**

## Compilation en ligne de commande

### Compilation simple d'une application console

```bash
fpc -Twin64 -Px86_64 monprogramme.pas
```

**Explication des param√®tres** :
- `-Twin64` : Syst√®me d'exploitation cible (Windows 64 bits)
- `-Px86_64` : Architecture processeur cible
- `monprogramme.pas` : Votre fichier source

R√©sultat : Un fichier `monprogramme.exe` sera cr√©√©.

### Compilation d'une application Windows 32 bits

```bash
fpc -Twin32 -Pi386 monprogramme.pas
```

### Compilation avec Lazarus (LCL)

Pour une application graphique utilisant la LCL :

```bash
lazbuild --os=win64 --cpu=x86_64 --ws=win32 monprojet.lpi
```

**Explication** :
- `--os=win64` : Syst√®me cible
- `--cpu=x86_64` : Architecture cible
- `--ws=win32` : Widget set (interface Windows native)
- `monprojet.lpi` : Fichier projet Lazarus

### Options avanc√©es

```bash
fpc -Twin64 -Px86_64 \
    -O3 \
    -XX \
    -CX \
    -WG \
    -Fl/usr/x86_64-w64-mingw32/lib \
    monprogramme.pas
```

**Explication des options** :
- `-O3` : Optimisation maximale
- `-XX` : Smart linking (ex√©cutable plus petit)
- `-CX` : Smart linking
- `-WG` : Application GUI (pas de console Windows)
- `-Fl` : Chemin des biblioth√®ques Windows

## Gestion des d√©pendances

### Biblioth√®ques runtime n√©cessaires

Votre application Windows compil√©e depuis Linux aura besoin de certaines DLL :

**Pour une application console basique** :
- Aucune DLL externe si compil√©e statiquement (par d√©faut avec FPC)

**Pour une application GUI Win32** :
- Les DLL Windows natives sont d√©j√† pr√©sentes sur tous les Windows
- Aucune DLL suppl√©mentaire n√©cessaire

**Pour une application utilisant des biblioth√®ques externes** :
- Vous devrez inclure les DLL correspondantes
- Exemple : SQLite3.dll, OpenSSL DLL, etc.

### Localiser les biblioth√®ques Windows sur Linux

Les biblioth√®ques Windows install√©es se trouvent g√©n√©ralement dans :

```bash
# Pour x86_64 (64 bits)
/usr/x86_64-w64-mingw32/lib/

# Pour i386 (32 bits)
/usr/i686-w64-mingw32/lib/

# Lister le contenu
ls -la /usr/x86_64-w64-mingw32/lib/
```

### Inclure des ressources Windows

Pour ajouter une ic√¥ne, un manifeste ou d'autres ressources :

1. **Cr√©er un fichier de ressources (.rc)** :
   ```
   // monapp.rc
   1 ICON "monapp.ico"
   1 24 "monapp.manifest"
   ```

2. **Compiler le fichier de ressources** :
   ```bash
   x86_64-w64-mingw32-windres monapp.rc -o monapp.res
   ```

3. **Lier les ressources lors de la compilation** :
   ```bash
   fpc -Twin64 -Px86_64 monapp.pas monapp.res
   ```

## R√©solution des probl√®mes courants

### Erreur : "Can't find unit System"

**Cause** : Le compilateur ne trouve pas les unit√©s Windows.

**Solution** :
```bash
# V√©rifier o√π sont les unit√©s Windows
find /usr/lib/fpc -name "system.ppu" | grep win64

# Ajouter le chemin dans la compilation
fpc -Twin64 -Px86_64 -Fu/usr/lib/fpc/3.2.2/units/x86_64-win64/rtl monprogramme.pas
```

### Erreur : "Can't find linker ld"

**Cause** : L'√©diteur de liens Windows n'est pas trouv√©.

**Solution** :
```bash
# V√©rifier que MinGW est install√©
which x86_64-w64-mingw32-ld

# Si absent, installer
sudo apt install binutils-mingw-w64-x86-64

# Sp√©cifier explicitement le linker
fpc -Twin64 -Px86_64 -XP/usr/bin/x86_64-w64-mingw32- monprogramme.pas
```

### Erreur : "Undefined reference to WinMain"

**Cause** : Probl√®me de point d'entr√©e pour une application GUI.

**Solution** :
```bash
# Ajouter l'option -WG pour une application GUI
fpc -Twin64 -Px86_64 -WG monprogramme.pas

# Ou -WC pour une application console explicite
fpc -Twin64 -Px86_64 -WC monprogramme.pas
```

### L'exe ne s'ex√©cute pas sur Windows

**Causes possibles** :
1. **Architecture incorrecte** (32 vs 64 bits)
2. **DLL manquantes**
3. **Antivirus qui bloque** l'ex√©cutable

**Solutions** :

1. **V√©rifier l'architecture** :
   ```bash
   file monprogramme.exe
   ```
   Devrait afficher : `PE32+ executable (console) x86-64` pour du 64 bits

2. **V√©rifier les d√©pendances DLL** :
   Sur Windows, utilisez **Dependency Walker** ou :
   ```bash
   # Sur Linux avec wine
   wine monprogramme.exe
   # Les erreurs de DLL s'afficheront
   ```

3. **Tester avec Wine** :
   ```bash
   # Installer Wine si n√©cessaire
   sudo apt install wine64

   # Ex√©cuter l'exe
   wine64 monprogramme.exe
   ```

### Probl√®mes de chemins Windows

**Cause** : Les chemins Linux (/) vs Windows (\).

**Solution** : Utilisez `PathDelim` et `PathSep` :
```pascal
uses
  SysUtils;

const
  // PathDelim = '\' sur Windows, '/' sur Linux
  CONFIG_FILE = 'config' + PathDelim + 'app.ini';
```

## Exemple pratique complet

Cr√©ons une application Windows depuis Linux.

### 1. Cr√©er le fichier source (hello_windows.pas)

```pascal
program HelloWindows;

{$mode objfpc}{$H+}
{$APPTYPE GUI}  // Important pour Windows GUI

uses
  {$IFDEF WINDOWS}
  Windows,  // API Windows
  {$ENDIF}
  SysUtils;

{$IFDEF WINDOWS}
procedure ShowMessageBox;
begin
  MessageBox(0,
    'Bonjour depuis Linux!' + #13#10 +
    'Cette application a √©t√© compil√©e sur Ubuntu pour Windows.',
    'Cross-Compilation R√©ussie',
    MB_OK or MB_ICONINFORMATION);
end;
{$ENDIF}

begin
  {$IFDEF WINDOWS}
  ShowMessageBox;
  {$ELSE}
  WriteLn('Cette application doit √™tre ex√©cut√©e sur Windows');
  {$ENDIF}
end.
```

### 2. Compiler depuis Linux

```bash
# Compiler pour Windows 64 bits
fpc -Twin64 -Px86_64 -WG hello_windows.pas

# V√©rifier que l'exe est cr√©√©
ls -lh hello_windows.exe

# Afficher les informations du fichier
file hello_windows.exe
```

### 3. Transf√©rer sur Windows

Plusieurs m√©thodes :

**Via r√©seau partag√©** :
```bash
# Copier vers un dossier partag√© Windows
cp hello_windows.exe /mnt/partage_windows/
```

**Via SCP** (si vous avez OpenSSH sur Windows) :
```bash
scp hello_windows.exe user@ip-windows:C:/Temp/
```

**Via cl√© USB** :
```bash
# Monter la cl√© USB
sudo mkdir /mnt/usb
sudo mount /dev/sdb1 /mnt/usb

# Copier
cp hello_windows.exe /mnt/usb/

# D√©monter
sudo umount /mnt/usb
```

### 4. Tester avec Wine (optionnel)

Avant de transf√©rer, testez localement :

```bash
# Installer Wine64
sudo apt install wine64

# Ex√©cuter
wine64 hello_windows.exe
```

Une fen√™tre Windows devrait s'afficher avec votre message !

## Cr√©er un script de build automatis√©

Pour simplifier la compilation, cr√©ez un script `build_windows.sh` :

```bash
#!/bin/bash

# Configuration
PROJECT="monprojet"
TARGET_OS="win64"
TARGET_CPU="x86_64"
BUILD_MODE="release"

# Couleurs pour l'affichage
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "========================================="
echo " Cross-compilation Linux ‚Üí Windows"
echo "========================================="
echo ""
echo "Projet     : ${PROJECT}"
echo "OS cible   : ${TARGET_OS}"
echo "CPU cible  : ${TARGET_CPU}"
echo "Mode       : ${BUILD_MODE}"
echo ""

# Nettoyer les anciens builds
echo -e "${YELLOW}Nettoyage...${NC}"
rm -f ${PROJECT}.exe
rm -f ${PROJECT}.o
rm -rf lib backup

# Compilation
echo -e "${YELLOW}Compilation en cours...${NC}"

if [ "$BUILD_MODE" = "release" ]; then
    # Build de production : optimis√©
    fpc -T${TARGET_OS} -P${TARGET_CPU} \
        -O3 -XX -CX \
        -WG \
        ${PROJECT}.pas
else
    # Build de d√©veloppement : avec debug
    fpc -T${TARGET_OS} -P${TARGET_CPU} \
        -g -gl \
        -WG \
        ${PROJECT}.pas
fi

# V√©rifier le r√©sultat
if [ $? -eq 0 ]; then
    echo ""
    echo -e "${GREEN}=========================================${NC}"
    echo -e "${GREEN} Compilation r√©ussie !${NC}"
    echo -e "${GREEN}=========================================${NC}"
    echo ""
    echo "Fichier cr√©√© : ${PROJECT}.exe"

    # Afficher la taille
    SIZE=$(du -h ${PROJECT}.exe | cut -f1)
    echo "Taille      : ${SIZE}"

    # Afficher le type
    echo "Type        : $(file ${PROJECT}.exe | cut -d: -f2)"
    echo ""

    # Option de test avec Wine
    echo "Pour tester avec Wine :"
    echo "  wine64 ${PROJECT}.exe"
    echo ""
    echo "Pour transf√©rer sur Windows :"
    echo "  scp ${PROJECT}.exe user@windows-pc:/destination/"

else
    echo ""
    echo -e "${RED}=========================================${NC}"
    echo -e "${RED} Erreur de compilation !${NC}"
    echo -e "${RED}=========================================${NC}"
    echo ""
    echo "V√©rifiez les messages d'erreur ci-dessus"
    exit 1
fi
```

Rendez-le ex√©cutable et utilisez-le :

```bash
chmod +x build_windows.sh
./build_windows.sh
```

## Application Lazarus compl√®te

Pour une application GUI plus √©labor√©e :

### 1. Cr√©er le projet dans Lazarus

```bash
lazarus-ide
```

1. **Fichier ‚Üí Nouveau ‚Üí Projet ‚Üí Application**
2. Cr√©ez une interface simple avec quelques boutons
3. Sauvegardez le projet

### 2. Configurer pour Windows

Dans **Projet ‚Üí Options du projet** :
- **Config et Target** : OS=win64, CPU=x86_64, Widgetset=win32
- **Chemins de recherche** : V√©rifier que tout est OK

### 3. Compiler

```bash
lazbuild --os=win64 --cpu=x86_64 --ws=win32 monprojet.lpi
```

### 4. Script complet pour projet Lazarus

```bash
#!/bin/bash

PROJECT="monprojet.lpi"
OUTPUT_DIR="build/windows"

# Cr√©er le dossier de sortie
mkdir -p ${OUTPUT_DIR}

# Compiler
lazbuild \
    --os=win64 \
    --cpu=x86_64 \
    --ws=win32 \
    --build-mode=Release \
    ${PROJECT}

# D√©placer l'exe dans le dossier de sortie
if [ -f *.exe ]; then
    mv *.exe ${OUTPUT_DIR}/
    echo "Ex√©cutable Windows cr√©√© dans ${OUTPUT_DIR}/"
fi
```

## Compilation conditionnelle avanc√©e

Code qui s'adapte automatiquement √† la plateforme de compilation et d'ex√©cution :

```pascal
program MultiPlatform;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  {$IFDEF WINDOWS}
  Windows,
  {$ENDIF}
  SysUtils;

procedure ShowInfo;
begin
  WriteLn('=================================');
  WriteLn(' Informations de compilation');
  WriteLn('=================================');

  // Plateforme de compilation
  {$IFDEF LINUX}
  WriteLn('Compil√© depuis : Linux');
  {$ENDIF}
  {$IFDEF DARWIN}
  WriteLn('Compil√© depuis : macOS');
  {$ENDIF}
  {$IFDEF WINDOWS}
  WriteLn('Compil√© depuis : Windows');
  {$ENDIF}

  // Plateforme cible
  WriteLn('OS cible       : {$I %FPCTARGETOS%}');
  WriteLn('CPU cible      : {$I %FPCTARGETCPU%}');
  WriteLn('Date de build  : {$I %DATE%}');
  WriteLn('Heure de build : {$I %TIME%}');
  WriteLn('Version FPC    : {$I %FPCVERSION%}');

  WriteLn('=================================');
end;

procedure PlatformSpecific;
begin
  {$IFDEF WINDOWS}
  WriteLn('Code sp√©cifique Windows en cours...');
  // Utilisez l'API Windows ici
  {$ENDIF}

  {$IFDEF LINUX}
  WriteLn('Code sp√©cifique Linux en cours...');
  // Utilisez les API POSIX ici
  {$ENDIF}
end;

begin
  ShowInfo;
  WriteLn;
  PlatformSpecific;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e pour quitter...');
  ReadLn;
end.
```

## Int√©gration CI/CD

### Exemple avec GitLab CI

Cr√©ez un fichier `.gitlab-ci.yml` :

```yaml
stages:
  - build

build:windows:
  stage: build
  image: ubuntu:22.04
  before_script:
    - apt-get update
    - apt-get install -y fpc mingw-w64 binutils-mingw-w64-x86-64
  script:
    - fpc -Twin64 -Px86_64 -O3 monprojet.pas
  artifacts:
    paths:
      - "*.exe"
    expire_in: 1 week
  only:
    - main
    - tags
```

### Exemple avec GitHub Actions

Cr√©ez `.github/workflows/build-windows.yml` :

```yaml
name: Build Windows

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Install FreePascal and MinGW
      run: |
        sudo apt-get update
        sudo apt-get install -y fpc fpc-source
        sudo apt-get install -y mingw-w64 binutils-mingw-w64-x86-64

    - name: Compile for Windows
      run: |
        fpc -Twin64 -Px86_64 -O3 monprojet.pas

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: windows-executable
        path: "*.exe"
```

## Bonnes pratiques

### 1. Chemins portables

```pascal
uses
  SysUtils;

var
  ConfigPath: string;
begin
  // Chemin adaptatif
  {$IFDEF WINDOWS}
  ConfigPath := GetEnvironmentVariable('APPDATA') + '\MonApp\';
  {$ELSE}
  ConfigPath := GetEnvironmentVariable('HOME') + '/.config/monapp/';
  {$ENDIF}

  // Ou utilisez les fonctions portables
  ConfigPath := GetAppConfigDir(False);
end.
```

### 2. Gestion des fins de ligne

```pascal
const
  {$IFDEF WINDOWS}
  NL = #13#10;  // CRLF pour Windows
  {$ELSE}
  NL = #10;     // LF pour Unix/Linux
  {$ENDIF}

// Ou utilisez simplement la constante int√©gr√©e LineEnding (dans System) :
WriteLn('Fin de ligne = ', LineEnding);
```

### 3. Ex√©cutables optimis√©s

Pour des ex√©cutables Windows plus petits et rapides :

```bash
fpc -Twin64 -Px86_64 \
    -O4 \           # Optimisation maximale
    -XX \           # Smart linking
    -CX \           # Smart linking
    -Xs \           # Strip symbols
    -WG \           # GUI app (pas de console)
    monprojet.pas

# Compresser encore plus avec UPX
upx --best monprojet.exe
```

### 4. S√©parer le code plateforme

```pascal
// platform_windows.pas
unit PlatformWindows;

interface
  procedure DoSomethingSpecific;

implementation
  uses Windows;

  procedure DoSomethingSpecific;
  begin
    // Code Windows
  end;
end.

// platform_linux.pas
unit PlatformLinux;

interface
  procedure DoSomethingSpecific;

implementation
  uses BaseUnix;

  procedure DoSomethingSpecific;
  begin
    // Code Linux
  end;
end.

// Programme principal
program Main;
uses
  {$IFDEF WINDOWS}
  PlatformWindows;
  {$ELSE}
  PlatformLinux;
  {$ENDIF}

begin
  DoSomethingSpecific;
end.
```

### 5. Tests avec Wine

Int√©grez Wine dans votre workflow de test :

```bash
#!/bin/bash

# Compiler
fpc -Twin64 -Px86_64 monprojet.pas

# Tester automatiquement
if command -v wine64 &> /dev/null; then
    echo "Test avec Wine..."
    wine64 monprojet.exe

    if [ $? -eq 0 ]; then
        echo "‚úì Test r√©ussi"
    else
        echo "‚úó Test √©chou√©"
        exit 1
    fi
else
    echo "Wine non install√©, test ignor√©"
fi
```

## D√©pannage avanc√©

### Probl√®mes de ressources

Si vous incluez des ic√¥nes ou ressources :

```bash
# Cr√©er le fichier de ressources
echo '1 ICON "app.ico"' > app.rc

# Compiler avec windres de MinGW
x86_64-w64-mingw32-windres app.rc -o app.res

# Compiler avec les ressources
fpc -Twin64 -Px86_64 -WG monprojet.pas app.res
```

### Debugging cross-platform

Pour d√©boguer un exe Windows depuis Linux :

```bash
# Utiliser Wine avec winedbg
winedbg monprojet.exe

# Ou avec gdb via Wine
WINEDEBUG=+debugstr wine64 monprojet.exe
```

### Compatibilit√© Windows XP/7/10/11

Pour maximiser la compatibilit√© :

```pascal
{$APPTYPE GUI}
{$IFDEF WINDOWS}
  {$R manifest.rc}  // Inclure un manifeste pour Windows moderne
{$ENDIF}
```

Cr√©ez `manifest.rc` :
```xml
1 24 "manifest.xml"
```

Et `manifest.xml` :
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <assemblyIdentity type="win32" name="MonApp" version="1.0.0.0"/>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>  <!-- Vista -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>  <!-- 7 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>  <!-- 8 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>  <!-- 8.1 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>  <!-- 10/11 -->
    </application>
  </compatibility>
</assembly>
```

## Conclusion

La cross-compilation de Linux vers Windows avec FreePascal est une solution puissante et efficace qui offre :

‚úÖ **Environnement de d√©veloppement Linux** performant et gratuit  
‚úÖ **Build servers Linux** pour CI/CD  
‚úÖ **Ex√©cutables Windows natifs** sans compromis de performance  
‚úÖ **Automatisation facile** avec scripts shell  
‚úÖ **Tests avec Wine** avant d√©ploiement r√©el  
‚úÖ **Workflow unifi√©** pour projets open source

Cette approche est particuli√®rement appr√©ci√©e dans les environnements DevOps modernes o√π Linux domine les serveurs de build. Une fois configur√©e, la cross-compilation devient transparente et s'int√®gre naturellement dans votre workflow de d√©veloppement.

N'h√©sitez pas √† exp√©rimenter avec diff√©rentes configurations et √† consulter la documentation officielle de FreePascal pour d√©couvrir toutes les possibilit√©s offertes par le compilateur.

‚è≠Ô∏è [Toolchains crois√©s](/24-compilateur-outils-avances/08.3-toolchains-croises.md)
