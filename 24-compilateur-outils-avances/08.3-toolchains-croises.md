üîù Retour au [Sommaire](/SOMMAIRE.md)

# 24.8.3 Toolchains crois√©s

## Introduction

Une **toolchain** (cha√Æne d'outils) est un ensemble de programmes qui travaillent ensemble pour transformer votre code source en un ex√©cutable fonctionnel. Dans le contexte de la cross-compilation, une **toolchain crois√©e** permet de compiler du code sur une plateforme pour qu'il s'ex√©cute sur une autre plateforme diff√©rente.

Comprendre et ma√Ætriser les toolchains crois√©es est essentiel pour :
- Compiler pour plusieurs plateformes depuis un seul poste de d√©veloppement
- Automatiser les builds multi-plateformes
- Cibler des architectures embarqu√©es (ARM, MIPS, etc.)
- Optimiser les workflows de d√©veloppement

FreePascal offre un support exceptionnel des toolchains crois√©es gr√¢ce √† son architecture modulaire.

## Composants d'une toolchain

Une toolchain compl√®te comprend plusieurs √©l√©ments essentiels :

### 1. Le compilateur

Le **compilateur** (FPC dans notre cas) transforme le code source Pascal en code assembleur ou directement en code machine pour la plateforme cible.

```
Code Pascal (.pas) ‚Üí Compilateur FPC ‚Üí Code assembleur ou objet (.o/.obj)
```

### 2. L'assembleur

L'**assembleur** convertit le code assembleur en code machine (fichiers objets).

```
Code assembleur (.s) ‚Üí Assembleur ‚Üí Fichier objet (.o/.obj)
```

Pour Windows : utilise l'assembleur de MinGW (as.exe)
Pour Linux : utilise GNU as

### 3. L'√©diteur de liens (linker)

Le **linker** combine tous les fichiers objets et biblioth√®ques pour cr√©er l'ex√©cutable final.

```
Fichiers objets (.o) + Biblioth√®ques (.a/.lib) ‚Üí Linker ‚Üí Ex√©cutable (.exe/.elf)
```

Pour Windows : ld.exe de MinGW
Pour Linux : ld de GNU binutils

### 4. Les biblioth√®ques standard

Les **biblioth√®ques** fournissent les fonctions de base du syst√®me d'exploitation :
- Biblioth√®que C standard (libc sur Linux, msvcrt sur Windows)
- Biblioth√®ques syst√®me (Win32 API, POSIX, etc.)
- Biblioth√®ques runtime de FreePascal

### 5. Les en-t√™tes et interfaces

Les **fichiers d'en-t√™te** d√©finissent les interfaces des biblioth√®ques syst√®me :
- Fichiers .h pour le C
- Unit√©s .ppu pour FreePascal
- D√©finitions des API syst√®me

## Architecture des toolchains FreePascal

FreePascal organise ses toolchains de mani√®re tr√®s structur√©e :

```
/usr/lib/fpc/3.2.2/
‚îú‚îÄ‚îÄ units/
‚îÇ   ‚îú‚îÄ‚îÄ x86_64-linux/        # Unit√©s pour Linux 64 bits
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rtl/             # Runtime library
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fcl-base/        # Free Component Library
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ x86_64-win64/        # Unit√©s pour Windows 64 bits
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rtl/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ i386-linux/          # Unit√©s pour Linux 32 bits
‚îÇ   ‚îî‚îÄ‚îÄ arm-linux/           # Unit√©s pour ARM Linux
‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ x86_64-linux/        # Binaires du compilateur
‚îî‚îÄ‚îÄ ...
```

## Nomenclature des toolchains

Les toolchains suivent une convention de nommage standard :

```
<architecture>-<vendor>-<syst√®me>-<abi>
```

### Exemples courants :

**Pour Linux :**
- `x86_64-linux-gnu` : Linux 64 bits avec GNU libc
- `i686-linux-gnu` : Linux 32 bits avec GNU libc
- `arm-linux-gnueabihf` : ARM Linux avec support hardware float

**Pour Windows :**
- `x86_64-w64-mingw32` : Windows 64 bits avec MinGW-w64
- `i686-w64-mingw32` : Windows 32 bits avec MinGW-w64

**Pour syst√®mes embarqu√©s :**
- `arm-none-eabi` : ARM sans OS (bare metal)
- `avr-none-elf` : Microcontr√¥leurs AVR (Arduino)

### D√©cryptage de la nomenclature :

- **architecture** : Type de processeur (x86_64, i686, arm, etc.)
- **vendor** : Fournisseur ou caract√©ristique (w64, none, pc, etc.)
- **syst√®me** : Syst√®me d'exploitation (linux, mingw32, eabi, etc.)
- **abi** : Application Binary Interface (gnu, gnueabihf, etc.)

## Installation de toolchains multiples

### Sur Linux (Ubuntu)

#### Toolchain Windows 64 bits

```bash
# Installer MinGW pour Windows 64 bits
sudo apt install mingw-w64 binutils-mingw-w64-x86-64

# V√©rifier l'installation
x86_64-w64-mingw32-gcc --version
x86_64-w64-mingw32-ld --version
```

#### Toolchain Windows 32 bits

```bash
# Installer MinGW pour Windows 32 bits
sudo apt install binutils-mingw-w64-i686

# V√©rifier
i686-w64-mingw32-gcc --version
```

#### Toolchain ARM Linux

```bash
# Installer la toolchain ARM
sudo apt install gcc-arm-linux-gnueabihf binutils-arm-linux-gnueabihf

# Pour ARM 64 bits (aarch64)
sudo apt install gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu
```

#### Toolchain pour Raspberry Pi

```bash
# Toolchain ARM pour Raspberry Pi
sudo apt install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf

# V√©rifier
arm-linux-gnueabihf-gcc --version
```

### Sur Windows

#### Toolchain Linux via WSL2

La m√©thode la plus simple est d'utiliser WSL2 :

```powershell
# Installer WSL2
wsl --install

# Installer Ubuntu
wsl --install -d Ubuntu

# Dans WSL, installer les outils de compilation
sudo apt update
sudo apt install build-essential
```

#### Toolchain ARM pour embarqu√©

```powershell
# Via Chocolatey
choco install gcc-arm-embedded

# Ou t√©l√©charger depuis ARM
# https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain
```

## Configuration de FreePascal pour toolchains multiples

### Fichier de configuration fpc.cfg

FreePascal utilise un fichier de configuration pour g√©rer les toolchains. Voici comment le structurer :

```ini
# Fichier fpc.cfg principal
# Localisation typique : /etc/fpc.cfg ou ~/.fpc.cfg

# Configuration globale
-Mobjfpc
-Scghi
-O1
-g
-gl
-l
-vewnhibq

# Chemins de recherche g√©n√©raux
-Fu/usr/lib/fpc/$fpcversion/units/$fpctarget
-Fu/usr/lib/fpc/$fpcversion/units/$fpctarget/*
-Fu/usr/lib/fpc/$fpcversion/units/$fpctarget/rtl

#IFDEF CPUX86_64
  #IFDEF WIN64
    # Configuration pour Windows 64 bits
    -Fu/usr/lib/fpc/$fpcversion/units/x86_64-win64/*
    -Fl/usr/x86_64-w64-mingw32/lib
    -XP/usr/bin/x86_64-w64-mingw32-
  #ENDIF

  #IFDEF LINUX
    # Configuration pour Linux 64 bits
    -Fu/usr/lib/fpc/$fpcversion/units/x86_64-linux/*
  #ENDIF
#ENDIF

#IFDEF CPUARM
  #IFDEF LINUX
    # Configuration pour ARM Linux
    -Fu/usr/lib/fpc/$fpcversion/units/arm-linux/*
    -Fl/usr/arm-linux-gnueabihf/lib
    -XP/usr/bin/arm-linux-gnueabihf-
  #ENDIF
#ENDIF
```

### Cr√©er des fichiers de configuration sp√©cifiques

Pour chaque toolchain, cr√©ez un fichier de configuration d√©di√© :

**fpc-win64.cfg** (compilation vers Windows 64) :
```ini
# Configuration pour cross-compilation vers Windows 64
-Twin64
-Px86_64
-XP/usr/bin/x86_64-w64-mingw32-
-Fl/usr/x86_64-w64-mingw32/lib
-Fu/usr/lib/fpc/$fpcversion/units/x86_64-win64/rtl
```

**fpc-arm.cfg** (compilation vers ARM) :
```ini
# Configuration pour cross-compilation vers ARM Linux
-Tlinux
-Parm
-XP/usr/bin/arm-linux-gnueabihf-
-Fl/usr/arm-linux-gnueabihf/lib
-Fu/usr/lib/fpc/$fpcversion/units/arm-linux/rtl
```

Utilisation :
```bash
# Compiler avec une configuration sp√©cifique
fpc @fpc-win64.cfg monprogramme.pas
fpc @fpc-arm.cfg monprogramme.pas
```

## Gestion des biblioth√®ques pour chaque toolchain

### Structure des biblioth√®ques

Organisez vos biblioth√®ques de mani√®re claire :

```
/usr/local/cross/
‚îú‚îÄ‚îÄ x86_64-w64-mingw32/
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ libkernel32.a
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ libuser32.a
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ include/
‚îÇ       ‚îî‚îÄ‚îÄ windows.h
‚îú‚îÄ‚îÄ arm-linux-gnueabihf/
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ libc.so.6
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ libpthread.so.0
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ include/
‚îÇ       ‚îî‚îÄ‚îÄ stdio.h
‚îî‚îÄ‚îÄ i686-w64-mingw32/
    ‚îî‚îÄ‚îÄ ...
```

### Sp√©cifier les chemins de biblioth√®ques

Dans votre compilation :

```bash
# Pour Windows 64
fpc -Twin64 -Px86_64 \
    -Fl/usr/x86_64-w64-mingw32/lib \
    -Fl/usr/local/cross/x86_64-w64-mingw32/lib \
    monprogramme.pas

# Pour ARM Linux
fpc -Tlinux -Parm \
    -Fl/usr/arm-linux-gnueabihf/lib \
    -Fl/usr/local/cross/arm-linux-gnueabihf/lib \
    monprogramme.pas
```

## Script de compilation multi-toolchain

Cr√©ez un script pour compiler automatiquement pour toutes vos toolchains :

```bash
#!/bin/bash

# build_all_platforms.sh
# Compile pour toutes les plateformes configur√©es

PROJECT_NAME="monprojet"
SOURCE_FILE="${PROJECT_NAME}.pas"
OUTPUT_DIR="build"

# Couleurs pour l'affichage
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Cr√©er le dossier de sortie
mkdir -p ${OUTPUT_DIR}

echo -e "${BLUE}=========================================${NC}"
echo -e "${BLUE} Compilation multi-plateforme${NC}"
echo -e "${BLUE}=========================================${NC}"
echo ""

# Fonction de compilation
compile_for_target() {
    local target_name=$1
    local os_target=$2
    local cpu_target=$3
    local prefix=$4
    local extra_flags=$5

    echo -e "${YELLOW}Compilation pour ${target_name}...${NC}"

    fpc -T${os_target} -P${cpu_target} \
        ${extra_flags} \
        -FU${OUTPUT_DIR}/units/${target_name} \
        -o${OUTPUT_DIR}/${PROJECT_NAME}_${target_name} \
        ${SOURCE_FILE}

    if [ $? -eq 0 ]; then
        echo -e "${GREEN}‚úì ${target_name} : Succ√®s${NC}"

        # Afficher la taille du fichier
        local output_file="${OUTPUT_DIR}/${PROJECT_NAME}_${target_name}"
        if [ "${os_target}" = "win64" ] || [ "${os_target}" = "win32" ]; then
            output_file="${output_file}.exe"
        fi

        if [ -f "${output_file}" ]; then
            local size=$(du -h "${output_file}" | cut -f1)
            echo "  Taille : ${size}"
        fi
    else
        echo -e "${RED}‚úó ${target_name} : √âchec${NC}"
        return 1
    fi

    echo ""
}

# Compiler pour Linux x86_64 (natif si sur Linux)
compile_for_target "linux-x64" "linux" "x86_64" "" "-O3"

# Compiler pour Windows x86_64
compile_for_target "windows-x64" "win64" "x86_64" "x86_64-w64-mingw32-" "-O3 -WG"

# Compiler pour Windows i386
compile_for_target "windows-x86" "win32" "i386" "i686-w64-mingw32-" "-O3 -WG"

# Compiler pour ARM Linux (Raspberry Pi)
compile_for_target "linux-arm" "linux" "arm" "arm-linux-gnueabihf-" "-O2"

# Compiler pour ARM 64 bits (aarch64)
compile_for_target "linux-arm64" "linux" "aarch64" "aarch64-linux-gnu-" "-O2"

echo -e "${BLUE}=========================================${NC}"
echo -e "${BLUE} Compilation termin√©e${NC}"
echo -e "${BLUE}=========================================${NC}"
echo ""
echo "Les binaires sont disponibles dans : ${OUTPUT_DIR}/"
ls -lh ${OUTPUT_DIR}/${PROJECT_NAME}_*

echo ""
echo "Pour tester :"
echo "  Linux x64    : ${OUTPUT_DIR}/${PROJECT_NAME}_linux-x64"
echo "  Windows x64  : wine64 ${OUTPUT_DIR}/${PROJECT_NAME}_windows-x64.exe"
echo "  ARM          : qemu-arm ${OUTPUT_DIR}/${PROJECT_NAME}_linux-arm"
```

Rendez-le ex√©cutable :
```bash
chmod +x build_all_platforms.sh
./build_all_platforms.sh
```

## Tests des binaires cross-compil√©s

### Test avec QEMU

**QEMU** permet d'√©muler diff√©rentes architectures :

```bash
# Installer QEMU pour ARM
sudo apt install qemu-user qemu-user-static

# Tester un binaire ARM
qemu-arm -L /usr/arm-linux-gnueabihf ./monprogramme_arm

# Tester un binaire ARM 64 bits
qemu-aarch64 -L /usr/aarch64-linux-gnu ./monprogramme_aarch64
```

### Test avec Wine

Pour les binaires Windows :

```bash
# Installer Wine
sudo apt install wine64 wine32

# Tester Windows 64 bits
wine64 monprogramme.exe

# Tester Windows 32 bits
wine monprogramme.exe
```

### Test avec Docker

Cr√©ez des conteneurs pour chaque plateforme :

**Dockerfile pour ARM :**
```dockerfile
FROM arm32v7/ubuntu:22.04

COPY ./monprogramme_arm /app/monprogramme
RUN chmod +x /app/monprogramme

CMD ["/app/monprogramme"]
```

**Dockerfile pour Windows avec Wine :**
```dockerfile
FROM ubuntu:22.04

RUN apt-get update && \
    apt-get install -y wine64 && \
    rm -rf /var/lib/apt/lists/*

COPY ./monprogramme.exe /app/monprogramme.exe

CMD ["wine64", "/app/monprogramme.exe"]
```

Construire et tester :
```bash
# Build ARM
docker build -f Dockerfile.arm -t monapp-arm .
docker run --rm monapp-arm

# Build Windows
docker build -f Dockerfile.wine -t monapp-win .
docker run --rm monapp-win
```

## Toolchains pour plateformes sp√©ciales

### Raspberry Pi (ARM)

Configuration sp√©cifique pour Raspberry Pi :

```bash
#!/bin/bash
# build_raspberry.sh

# Raspberry Pi OS est bas√© sur ARM
TARGET_OS="linux"
TARGET_CPU="arm"
TARGET_SUBARCH="armv6"  # Pi Zero, Pi 1
# TARGET_SUBARCH="armv7a"  # Pi 2, Pi 3
# TARGET_SUBARCH="armv8"   # Pi 4

fpc -T${TARGET_OS} -P${TARGET_CPU} -Cp${TARGET_SUBARCH} \
    -XParm-linux-gnueabihf- \
    -Fl/usr/arm-linux-gnueabihf/lib \
    -O2 \
    monprogramme.pas
```

### Android (ARM/ARM64)

Pour compiler vers Android :

```bash
# Installer le NDK Android
# https://developer.android.com/ndk/downloads

# D√©finir les variables d'environnement
export NDK_ROOT=/path/to/android-ndk
export ANDROID_PLATFORM=android-28

# Compiler pour ARM Android
fpc -Tlinux -Parm \
    -Cparmv7a \
    -CfVFPV3 \
    -XP${NDK_ROOT}/toolchains/llvm/prebuilt/linux-x86_64/bin/arm-linux-androideabi- \
    monprogramme.pas
```

### Microcontr√¥leurs (AVR/STM32)

Pour les syst√®mes embarqu√©s bare-metal :

**AVR (Arduino) :**
```bash
# Installer la toolchain AVR pour FPC
# Via fpcupdeluxe ou compilation manuelle

fpc -Pavr -Cpavr5 \
    -Tembedded \
    -Wpatmega328p \
    arduino_program.pas
```

**ARM Cortex-M (STM32) :**
```bash
fpc -Parm -Cparmv7em \
    -Tembedded \
    -Wpstm32f407 \
    stm32_program.pas
```

## Gestion avanc√©e avec fpcupdeluxe

**fpcupdeluxe** simplifie √©norm√©ment la gestion de toolchains multiples :

### Installation de plusieurs toolchains

1. Lancez fpcupdeluxe
2. Allez dans l'onglet **"Cross"**
3. Pour chaque plateforme cible :
   - S√©lectionnez la target (ex: x86_64-win64)
   - Cliquez sur "Install compiler"
   - Cliquez sur "Install libraries"
4. R√©p√©tez pour toutes vos plateformes

### Organisation par fpcupdeluxe

fpcupdeluxe organise automatiquement :

```
~/fpcupdeluxe/
‚îú‚îÄ‚îÄ fpc/                    # Compilateur source
‚îú‚îÄ‚îÄ lazarus/                # IDE Lazarus
‚îú‚îÄ‚îÄ cross/
‚îÇ   ‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ x86_64-win64/   # Outils Windows 64
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ i386-win32/     # Outils Windows 32
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ arm-linux/      # Outils ARM Linux
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îÇ       ‚îú‚îÄ‚îÄ x86_64-win64/   # Biblioth√®ques Windows 64
‚îÇ       ‚îú‚îÄ‚îÄ i386-win32/     # Biblioth√®ques Windows 32
‚îÇ       ‚îî‚îÄ‚îÄ arm-linux/      # Biblioth√®ques ARM Linux
‚îî‚îÄ‚îÄ config/                 # Fichiers de configuration
```

## Makefile pour compilation multi-toolchain

Un **Makefile** avanc√© pour g√©rer plusieurs toolchains :

```makefile
# Makefile multi-toolchain FreePascal

PROJECT := monprojet
SOURCE := $(PROJECT).pas
OUTPUT_DIR := build

# Compilateur et options de base
FPC := fpc
FPC_FLAGS := -O3 -XX -CX

# D√©finition des cibles
TARGETS := linux-x64 windows-x64 windows-x86 linux-arm

# D√©tails par cible
linux-x64_OS := linux
linux-x64_CPU := x86_64
linux-x64_EXT :=
linux-x64_FLAGS :=

windows-x64_OS := win64
windows-x64_CPU := x86_64
windows-x64_EXT := .exe
windows-x64_FLAGS := -WG
windows-x64_PREFIX := x86_64-w64-mingw32-

windows-x86_OS := win32
windows-x86_CPU := i386
windows-x86_EXT := .exe
windows-x86_FLAGS := -WG
windows-x86_PREFIX := i686-w64-mingw32-

linux-arm_OS := linux
linux-arm_CPU := arm
linux-arm_EXT :=
linux-arm_FLAGS :=
linux-arm_PREFIX := arm-linux-gnueabihf-

# R√®gle par d√©faut : compiler toutes les cibles
.PHONY: all
all: $(TARGETS)

# R√®gle g√©n√©rique pour chaque cible
.PHONY: $(TARGETS)
$(TARGETS):
	@echo "Compilation pour $@..."
	@mkdir -p $(OUTPUT_DIR)/units/$@
	$(FPC) $(FPC_FLAGS) \
		-T$($@_OS) \
		-P$($@_CPU) \
		$($@_FLAGS) \
		$(if $($@_PREFIX),-XP$($@_PREFIX),) \
		-FU$(OUTPUT_DIR)/units/$@ \
		-o$(OUTPUT_DIR)/$(PROJECT)_$@$($@_EXT) \
		$(SOURCE)
	@echo "‚úì $@ compil√© avec succ√®s"
	@echo ""

# Nettoyage
.PHONY: clean
clean:
	rm -rf $(OUTPUT_DIR)
	rm -f *.o *.ppu

# Test des binaires
.PHONY: test
test:
	@echo "Test Linux x64..."
	@$(OUTPUT_DIR)/$(PROJECT)_linux-x64 || true
	@echo ""
	@echo "Test Windows x64 avec Wine..."
	@wine64 $(OUTPUT_DIR)/$(PROJECT)_windows-x64.exe || true
	@echo ""
	@echo "Test ARM avec QEMU..."
	@qemu-arm -L /usr/arm-linux-gnueabihf $(OUTPUT_DIR)/$(PROJECT)_linux-arm || true

# Informations
.PHONY: info
info:
	@echo "Projet: $(PROJECT)"
	@echo "Source: $(SOURCE)"
	@echo "Cibles disponibles: $(TARGETS)"
	@echo ""
	@echo "Commandes:"
	@echo "  make          - Compiler toutes les cibles"
	@echo "  make linux-x64   - Compiler pour Linux 64 bits"
	@echo "  make windows-x64 - Compiler pour Windows 64 bits"
	@echo "  make clean    - Nettoyer les builds"
	@echo "  make test     - Tester tous les binaires"
```

Utilisation :
```bash
# Compiler toutes les cibles
make

# Compiler une cible sp√©cifique
make windows-x64

# Nettoyer
make clean

# Tester
make test

# Afficher les infos
make info
```

## Pipeline CI/CD multi-toolchain

### Configuration GitLab CI

```yaml
# .gitlab-ci.yml

stages:
  - build
  - test
  - package

variables:
  PROJECT_NAME: "monprojet"

# Template de build
.build_template: &build_template
  image: ubuntu:22.04
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq fpc
  script:
    - mkdir -p build
    - fpc -T${TARGET_OS} -P${TARGET_CPU} ${EXTRA_FLAGS} -o build/${PROJECT_NAME}_${TARGET_NAME} ${PROJECT_NAME}.pas
  artifacts:
    paths:
      - build/
    expire_in: 1 week

# Build Linux x64
build:linux-x64:
  <<: *build_template
  variables:
    TARGET_OS: "linux"
    TARGET_CPU: "x86_64"
    TARGET_NAME: "linux-x64"
    EXTRA_FLAGS: "-O3"

# Build Windows x64
build:windows-x64:
  <<: *build_template
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq fpc mingw-w64 binutils-mingw-w64-x86-64
  variables:
    TARGET_OS: "win64"
    TARGET_CPU: "x86_64"
    TARGET_NAME: "windows-x64"
    EXTRA_FLAGS: "-O3 -WG"

# Build ARM
build:linux-arm:
  <<: *build_template
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq fpc gcc-arm-linux-gnueabihf binutils-arm-linux-gnueabihf
  variables:
    TARGET_OS: "linux"
    TARGET_CPU: "arm"
    TARGET_NAME: "linux-arm"
    EXTRA_FLAGS: "-O2"

# Tests
test:linux:
  stage: test
  dependencies:
    - build:linux-x64
  script:
    - chmod +x build/${PROJECT_NAME}_linux-x64
    - ./build/${PROJECT_NAME}_linux-x64

test:windows:
  stage: test
  dependencies:
    - build:windows-x64
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq wine64
  script:
    - wine64 build/${PROJECT_NAME}_windows-x64.exe

test:arm:
  stage: test
  dependencies:
    - build:linux-arm
  before_script:
    - apt-get update -qq
    - apt-get install -y -qq qemu-user qemu-user-static
  script:
    - qemu-arm -L /usr/arm-linux-gnueabihf build/${PROJECT_NAME}_linux-arm

# Package
package:all:
  stage: package
  dependencies:
    - build:linux-x64
    - build:windows-x64
    - build:linux-arm
  script:
    - cd build
    - tar czf ${PROJECT_NAME}_linux-x64.tar.gz ${PROJECT_NAME}_linux-x64
    - tar czf ${PROJECT_NAME}_linux-arm.tar.gz ${PROJECT_NAME}_linux-arm
    - zip ${PROJECT_NAME}_windows-x64.zip ${PROJECT_NAME}_windows-x64.exe
  artifacts:
    paths:
      - build/*.tar.gz
      - build/*.zip
```

### Configuration GitHub Actions

```yaml
# .github/workflows/multi-platform-build.yml

name: Multi-Platform Build

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-matrix:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target_os: linux
            target_cpu: x86_64
            name: linux-x64

          - os: ubuntu-latest
            target_os: win64
            target_cpu: x86_64
            name: windows-x64
            setup: |
              sudo apt-get install -y mingw-w64 binutils-mingw-w64-x86-64

          - os: ubuntu-latest
            target_os: linux
            target_cpu: arm
            name: linux-arm
            setup: |
              sudo apt-get install -y gcc-arm-linux-gnueabihf binutils-arm-linux-gnueabihf

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v3

    - name: Install FreePascal
      run: |
        sudo apt-get update
        sudo apt-get install -y fpc fpc-source

    - name: Setup platform-specific tools
      if: matrix.setup
      run: ${{ matrix.setup }}

    - name: Compile
      run: |
        mkdir -p build
        fpc -T${{ matrix.target_os }} -P${{ matrix.target_cpu }} \
            -O3 -XX -CX \
            -o build/monprojet_${{ matrix.name }} \
            monprojet.pas

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: ${{ matrix.name }}
        path: build/
```

## R√©solution de probl√®mes courants

### Probl√®me : Linker non trouv√©

**Sympt√¥me :**
```
Error: Can't find linker "ld"
```

**Solution :**
```bash
# V√©rifier quel linker est n√©cessaire
fpc -i | grep linker

# Installer le paquet binutils pour la plateforme cible
sudo apt install binutils-mingw-w64-x86-64  # Pour Windows 64
sudo apt install binutils-arm-linux-gnueabihf  # Pour ARM
```

### Probl√®me : Unit√©s non trouv√©es

**Sympt√¥me :**
```
Fatal: Can't find unit System used by ...
```

**Solution :**
```bash
# V√©rifier o√π sont les unit√©s
find /usr/lib/fpc -name "system.ppu"

# Ajouter le chemin explicitement
fpc -Twin64 -Px86_64 -Fu/usr/lib/fpc/3.2.2/units/x86_64-win64/rtl monprogramme.pas
```

### Probl√®me : Biblioth√®ques manquantes

**Sympt√¥me :**
```
/usr/bin/ld: cannot find -lc
```

**Solution :**
```bash
# Installer les biblioth√®ques de d√©veloppement
sudo apt install libc6-dev-i386-cross  # Pour i386
sudo apt install libc6-dev-arm64-cross  # Pour ARM64

# Ou sp√©cifier le chemin
fpc -Tlinux -Parm -Fl/usr/arm-linux-gnueabihf/lib monprogramme.pas
```

## Bonnes pratiques

### 1. Versionner les configurations

Gardez vos configurations de toolchain sous contr√¥le de version :

```
projet/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ monprojet.pas
‚îú‚îÄ‚îÄ build_configs/
‚îÇ   ‚îú‚îÄ‚îÄ fpc-win64.cfg
‚îÇ   ‚îú‚îÄ‚îÄ fpc-win32.cfg
‚îÇ   ‚îú‚îÄ‚îÄ fpc-linux-x64.cfg
‚îÇ   ‚îú‚îÄ‚îÄ fpc-arm.cfg
‚îÇ   ‚îî‚îÄ‚îÄ fpc-android.cfg
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ build_all.sh
‚îÇ   ‚îú‚îÄ‚îÄ build_windows.sh
‚îÇ   ‚îú‚îÄ‚îÄ build_linux.sh
‚îÇ   ‚îî‚îÄ‚îÄ test_all.sh
‚îú‚îÄ‚îÄ .gitlab-ci.yml
‚îú‚îÄ‚îÄ Makefile
‚îî‚îÄ‚îÄ README.md
```

**Avantages :**
- Configuration reproductible sur diff√©rentes machines
- Historique des changements de configuration
- Facilite le travail en √©quipe
- Documentation implicite du projet

### 2. Isoler les d√©pendances par plateforme

Organisez vos d√©pendances externes de mani√®re claire :

```
projet/
‚îú‚îÄ‚îÄ libs/
‚îÇ   ‚îú‚îÄ‚îÄ windows/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ x64/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sqlite3.dll
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ openssl.dll
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ x86/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ sqlite3.dll
‚îÇ   ‚îú‚îÄ‚îÄ linux/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ x64/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ libsqlite3.so
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ libssl.so
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ arm/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ libsqlite3.so
‚îÇ   ‚îî‚îÄ‚îÄ android/
‚îÇ       ‚îî‚îÄ‚îÄ libsqlite3.so
‚îî‚îÄ‚îÄ src/
```

Dans votre code, chargez dynamiquement selon la plateforme :

```pascal
program MultiPlatformApp;

{$mode objfpc}{$H+}

uses
  SysUtils, DynLibs;

const
  {$IFDEF WINDOWS}
    {$IFDEF CPU64}
    LIB_PATH = 'libs\windows\x64\';
    {$ELSE}
    LIB_PATH = 'libs\windows\x86\';
    {$ENDIF}
    SQLITE_LIB = LIB_PATH + 'sqlite3.dll';
  {$ENDIF}

  {$IFDEF LINUX}
    {$IFDEF CPUX86_64}
    LIB_PATH = 'libs/linux/x64/';
    {$ELSE}
    LIB_PATH = 'libs/linux/arm/';
    {$ENDIF}
    SQLITE_LIB = LIB_PATH + 'libsqlite3.so';
  {$ENDIF}

  {$IFDEF ANDROID}
  SQLITE_LIB = 'libs/android/libsqlite3.so';
  {$ENDIF}

var
  LibHandle: TLibHandle;

begin
  WriteLn('Chargement de SQLite depuis : ', SQLITE_LIB);

  LibHandle := LoadLibrary(SQLITE_LIB);
  if LibHandle = NilHandle then
  begin
    WriteLn('Erreur : Impossible de charger ', SQLITE_LIB);
    Halt(1);
  end;

  WriteLn('Biblioth√®que charg√©e avec succ√®s');

  // Utiliser la biblioth√®que...

  UnloadLibrary(LibHandle);
end.
```

### 3. Tests automatis√©s multi-plateformes

Cr√©ez une suite de tests qui s'ex√©cute sur toutes vos toolchains :

**test_suite.sh :**
```bash
#!/bin/bash

# Suite de tests multi-plateformes
# Utilise QEMU pour les architectures non natives

set -e  # Arr√™t en cas d'erreur

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

TESTS_PASSED=0
TESTS_FAILED=0

# Fonction pour ex√©cuter un test
run_test() {
    local name=$1
    local command=$2

    echo -e "${YELLOW}Test : ${name}${NC}"

    if eval $command > /dev/null 2>&1; then
        echo -e "${GREEN}‚úì ${name} : PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}‚úó ${name} : FAIL${NC}"
        ((TESTS_FAILED++))
        return 1
    fi
}

echo "======================================="
echo " Suite de tests multi-plateformes"
echo "======================================="
echo ""

# Test Linux x64 (natif)
if [ -f "build/monprojet_linux-x64" ]; then
    run_test "Linux x64 (natif)" "./build/monprojet_linux-x64"
fi

# Test Windows x64 (Wine)
if [ -f "build/monprojet_windows-x64.exe" ]; then
    if command -v wine64 &> /dev/null; then
        run_test "Windows x64 (Wine)" "wine64 build/monprojet_windows-x64.exe"
    else
        echo -e "${YELLOW}‚äò Windows x64 : Wine non install√© (ignor√©)${NC}"
    fi
fi

# Test Windows x86 (Wine)
if [ -f "build/monprojet_windows-x86.exe" ]; then
    if command -v wine &> /dev/null; then
        run_test "Windows x86 (Wine)" "wine build/monprojet_windows-x86.exe"
    else
        echo -e "${YELLOW}‚äò Windows x86 : Wine non install√© (ignor√©)${NC}"
    fi
fi

# Test ARM (QEMU)
if [ -f "build/monprojet_linux-arm" ]; then
    if command -v qemu-arm &> /dev/null; then
        run_test "Linux ARM (QEMU)" "qemu-arm -L /usr/arm-linux-gnueabihf build/monprojet_linux-arm"
    else
        echo -e "${YELLOW}‚äò Linux ARM : QEMU non install√© (ignor√©)${NC}"
    fi
fi

# Test ARM64 (QEMU)
if [ -f "build/monprojet_linux-arm64" ]; then
    if command -v qemu-aarch64 &> /dev/null; then
        run_test "Linux ARM64 (QEMU)" "qemu-aarch64 -L /usr/aarch64-linux-gnu build/monprojet_linux-arm64"
    else
        echo -e "${YELLOW}‚äò Linux ARM64 : QEMU non install√© (ignor√©)${NC}"
    fi
fi

# R√©sum√©
echo ""
echo "======================================="
echo " R√©sum√© des tests"
echo "======================================="
echo -e "${GREEN}Tests r√©ussis : ${TESTS_PASSED}${NC}"
echo -e "${RED}Tests √©chou√©s  : ${TESTS_FAILED}${NC}"
echo ""

if [ $TESTS_FAILED -eq 0 ]; then
    echo -e "${GREEN}Tous les tests sont pass√©s !${NC}"
    exit 0
else
    echo -e "${RED}Certains tests ont √©chou√©${NC}"
    exit 1
fi
```

### 4. Documentation des toolchains

Cr√©ez un fichier `TOOLCHAINS.md` dans votre projet :

````markdown
# Guide des Toolchains

## Toolchains support√©es

### Linux x86_64 (natif)
- **Cible** : Linux 64 bits
- **Compilateur** : fpc natif
- **Configuration** : build_configs/fpc-linux-x64.cfg
- **Commande** : `fpc @build_configs/fpc-linux-x64.cfg src/monprojet.pas`

### Windows x86_64 (cross-compilation)
- **Cible** : Windows 64 bits
- **Compilateur** : fpc avec MinGW-w64
- **Pr√©requis** : `sudo apt install mingw-w64 binutils-mingw-w64-x86-64`
- **Configuration** : build_configs/fpc-win64.cfg
- **Commande** : `fpc @build_configs/fpc-win64.cfg src/monprojet.pas`
- **Test** : `wine64 monprojet.exe`

### ARM Linux (cross-compilation)
- **Cible** : Linux ARM (Raspberry Pi)
- **Compilateur** : fpc avec gcc-arm-linux-gnueabihf
- **Pr√©requis** : `sudo apt install gcc-arm-linux-gnueabihf`
- **Configuration** : build_configs/fpc-arm.cfg
- **Commande** : `fpc @build_configs/fpc-arm.cfg src/monprojet.pas`
- **Test** : `qemu-arm -L /usr/arm-linux-gnueabihf monprojet`

## Installation rapide

```bash
# Script d'installation complet
./scripts/setup_toolchains.sh
```

## Compilation pour toutes les plateformes

```bash
# Makefile
make all

# Ou script bash
./scripts/build_all.sh
```

## Tests

```bash
# Tester toutes les plateformes
./scripts/test_all.sh
```
````

### 5. Validation de l'environnement

Cr√©ez un script qui v√©rifie que toutes les toolchains sont correctement install√©es :

**check_toolchains.sh :**
```bash
#!/bin/bash

# V√©rification de l'environnement de d√©veloppement

GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}======================================="
echo " V√©rification des toolchains"
echo "=======================================${NC}"
echo ""

check_command() {
    local cmd=$1
    local name=$2
    local required=$3

    if command -v $cmd &> /dev/null; then
        local version=$($cmd --version 2>&1 | head -n1)
        echo -e "${GREEN}‚úì ${name} : Install√©${NC}"
        echo "  Version : ${version}"
        return 0
    else
        if [ "$required" = "required" ]; then
            echo -e "${RED}‚úó ${name} : NON INSTALL√â (requis)${NC}"
            return 1
        else
            echo -e "${YELLOW}‚äò ${name} : Non install√© (optionnel)${NC}"
            return 0
        fi
    fi
}

ERRORS=0

# V√©rifications essentielles
echo -e "${BLUE}Outils essentiels :${NC}"
check_command "fpc" "FreePascal Compiler" "required" || ((ERRORS++))
echo ""

# Toolchain Windows
echo -e "${BLUE}Toolchain Windows :${NC}"
check_command "x86_64-w64-mingw32-gcc" "MinGW-w64 GCC (64-bit)" "optional"
check_command "x86_64-w64-mingw32-ld" "MinGW-w64 Linker (64-bit)" "optional"
check_command "i686-w64-mingw32-gcc" "MinGW-w64 GCC (32-bit)" "optional"
echo ""

# Toolchain ARM
echo -e "${BLUE}Toolchain ARM :${NC}"
check_command "arm-linux-gnueabihf-gcc" "ARM GCC (hard-float)" "optional"
check_command "arm-linux-gnueabihf-ld" "ARM Linker" "optional"
check_command "aarch64-linux-gnu-gcc" "ARM64 GCC" "optional"
echo ""

# Outils de test
echo -e "${BLUE}Outils de test :${NC}"
check_command "wine64" "Wine (64-bit)" "optional"
check_command "wine" "Wine (32-bit)" "optional"
check_command "qemu-arm" "QEMU ARM" "optional"
check_command "qemu-aarch64" "QEMU ARM64" "optional"
echo ""

# V√©rifier les unit√©s FPC pour diff√©rentes plateformes
echo -e "${BLUE}Unit√©s FreePascal :${NC}"

check_units() {
    local target=$1
    local name=$2

    if [ -d "/usr/lib/fpc/*/units/${target}" ]; then
        echo -e "${GREEN}‚úì ${name} : Install√©${NC}"
        echo "  Path : /usr/lib/fpc/*/units/${target}"
        return 0
    else
        echo -e "${YELLOW}‚äò ${name} : Non install√©${NC}"
        return 1
    fi
}

check_units "x86_64-linux" "Linux x86_64"
check_units "x86_64-win64" "Windows x86_64"
check_units "i386-win32" "Windows i386"
check_units "arm-linux" "ARM Linux"
echo ""

# R√©sum√©
echo -e "${BLUE}======================================="
echo " R√©sum√©"
echo "=======================================${NC}"

if [ $ERRORS -eq 0 ]; then
    echo -e "${GREEN}‚úì Environnement de base OK${NC}"
    echo ""
    echo "Toolchains optionnelles non install√©es peuvent √™tre"
    echo "ajout√©es avec : ./scripts/setup_toolchains.sh"
    exit 0
else
    echo -e "${RED}‚úó $ERRORS erreur(s) critique(s) trouv√©e(s)${NC}"
    echo ""
    echo "Installez les composants manquants avec :"
    echo "  sudo apt install fpc fpc-source"
    exit 1
fi
```

## Optimisations sp√©cifiques par architecture

### Optimisations pour x86_64

```bash
# Compilation optimis√©e pour processeurs modernes
fpc -Tlinux -Px86_64 \
    -O4 \                    # Optimisation maximale
    -Cppentium4 \            # Cible au minimum Pentium 4
    -CfSSE2 \                # Utiliser les instructions SSE2
    -CfSSE3 \                # Utiliser les instructions SSE3
    -Ooloopunroll \          # D√©rouler les boucles
    -Oofastmath \            # Optimisations math√©matiques
    monprojet.pas

# Pour processeurs tr√®s r√©cents (AVX2)
fpc -Tlinux -Px86_64 \
    -CpCOREAVX2 \           # Optimisations AVX2
    -O4 \
    monprojet.pas
```

### Optimisations pour ARM

```bash
# Raspberry Pi 3/4 (ARMv7-A / ARMv8)
fpc -Tlinux -Parm \
    -CpARMV7A \             # Architecture ARMv7-A
    -CfVFPV3 \              # Virgule flottante VFPv3
    -O3 \
    monprojet.pas

# Raspberry Pi Zero/1 (ARMv6)
fpc -Tlinux -Parm \
    -CpARMV6 \              # Architecture ARMv6
    -O2 \                   # Optimisation mod√©r√©e
    monprojet.pas

# ARM 64 bits moderne
fpc -Tlinux -Paarch64 \
    -CpARMV8 \
    -O4 \
    monprojet.pas
```

### Optimisations pour taille d'ex√©cutable

Quand la taille est critique (syst√®mes embarqu√©s) :

```bash
fpc -Tlinux -Parm \
    -Os \                   # Optimiser pour la taille
    -XX \                   # Smart linking
    -CX \                   # Smart linking
    -Xs \                   # Strip symbols
    -Xd \                   # Ne pas utiliser les biblioth√®ques standards
    monprojet.pas

# Compresser encore plus avec UPX
upx --best --ultra-brute monprojet
```

## D√©bogage multi-plateforme

### GDB avec binaires cross-compil√©s

Pour d√©boguer un binaire ARM depuis x86_64 :

```bash
# Compiler avec symboles de d√©bogage
fpc -Tlinux -Parm -g -gl monprojet.pas

# D√©boguer avec gdb-multiarch
gdb-multiarch monprojet

# Dans GDB
(gdb) set architecture arm
(gdb) target remote localhost:1234  # Si d√©bogage distant
(gdb) break main
(gdb) run
```

### Debugging √† distance sur Raspberry Pi

Sur votre Raspberry Pi :
```bash
# Lancer gdbserver
gdbserver :1234 monprojet
```

Sur votre PC de d√©veloppement :
```bash
# Connecter gdb
gdb-multiarch monprojet
(gdb) target remote raspberry-pi-ip:1234
(gdb) continue
```

### Logs de compilation d√©taill√©s

Pour comprendre les probl√®mes de toolchain :

```bash
# Afficher tous les d√©tails de compilation
fpc -Twin64 -Px86_64 \
    -va \               # Afficher tout
    -vn \               # Afficher les notes
    -vh \               # Afficher les hints
    -vw \               # Afficher les warnings
    -vl \               # Afficher les num√©ros de ligne
    -vb \               # Afficher les informations de build
    monprojet.pas > build.log 2>&1

# Analyser le log
less build.log
```

## Gestion des versions de toolchains

### Plusieurs versions de FPC

Vous pouvez avoir plusieurs versions de FPC install√©es :

```bash
# Structure recommand√©e
/opt/fpc/
‚îú‚îÄ‚îÄ 3.2.0/
‚îÇ   ‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îú‚îÄ‚îÄ 3.2.2/
‚îÇ   ‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îî‚îÄ‚îÄ trunk/
    ‚îú‚îÄ‚îÄ bin/
    ‚îî‚îÄ‚îÄ lib/

# Cr√©er des alias
alias fpc-3.2.0='/opt/fpc/3.2.0/bin/fpc'
alias fpc-3.2.2='/opt/fpc/3.2.2/bin/fpc'
alias fpc-trunk='/opt/fpc/trunk/bin/fpc'

# Ou utiliser des variables d'environnement
export FPC_VERSION=3.2.2
export PATH=/opt/fpc/${FPC_VERSION}/bin:$PATH
```

### Script de gestion de versions

**switch_fpc_version.sh :**
```bash
#!/bin/bash

# Gestionnaire de versions FPC

FPC_BASE="/opt/fpc"
AVAILABLE_VERSIONS=$(ls -1 ${FPC_BASE})

if [ -z "$1" ]; then
    echo "Versions disponibles :"
    echo "$AVAILABLE_VERSIONS"
    echo ""
    echo "Utilisation : $0 <version>"
    exit 1
fi

VERSION=$1

if [ ! -d "${FPC_BASE}/${VERSION}" ]; then
    echo "Erreur : Version ${VERSION} non trouv√©e"
    exit 1
fi

# Mettre √† jour les liens symboliques
sudo rm -f /usr/local/bin/fpc
sudo ln -s ${FPC_BASE}/${VERSION}/bin/fpc /usr/local/bin/fpc

echo "FPC version ${VERSION} activ√©e"
fpc -i | grep "Compiler version"
```

## Conteneurisation des toolchains

### Docker pour builds reproductibles

Cr√©ez un conteneur Docker avec toutes vos toolchains :

**Dockerfile.build :**
```dockerfile
FROM ubuntu:22.04

# Variables d'environnement
ENV DEBIAN_FRONTEND=noninteractive
ENV FPC_VERSION=3.2.2

# Installer les d√©pendances de base
RUN apt-get update && apt-get install -y \
    build-essential \
    wget \
    git \
    && rm -rf /var/lib/apt/lists/*

# Installer FreePascal
RUN apt-get update && apt-get install -y \
    fpc \
    fpc-source \
    && rm -rf /var/lib/apt/lists/*

# Installer les toolchains cross-compilation
RUN apt-get update && apt-get install -y \
    mingw-w64 \
    binutils-mingw-w64-x86-64 \
    binutils-mingw-w64-i686 \
    gcc-arm-linux-gnueabihf \
    binutils-arm-linux-gnueabihf \
    gcc-aarch64-linux-gnu \
    binutils-aarch64-linux-gnu \
    && rm -rf /var/lib/apt/lists/*

# Installer les outils de test
RUN apt-get update && apt-get install -y \
    wine64 \
    wine32 \
    qemu-user \
    qemu-user-static \
    && rm -rf /var/lib/apt/lists/*

# Cr√©er un utilisateur non-root
RUN useradd -m -s /bin/bash builder
USER builder
WORKDIR /home/builder

# Script d'entr√©e
COPY --chown=builder:builder entrypoint.sh /home/builder/
RUN chmod +x /home/builder/entrypoint.sh

ENTRYPOINT ["/home/builder/entrypoint.sh"]
```

**entrypoint.sh :**
```bash
#!/bin/bash

# Point d'entr√©e du conteneur de build

if [ $# -eq 0 ]; then
    echo "Conteneur de build FreePascal multi-plateforme"
    echo ""
    echo "Utilisation :"
    echo "  docker run --rm -v \$(pwd):/src builder <commande>"
    echo ""
    echo "Exemples :"
    echo "  docker run --rm -v \$(pwd):/src builder make all"
    echo "  docker run --rm -v \$(pwd):/src builder ./scripts/build_all.sh"
    exit 0
fi

cd /src
exec "$@"
```

**Construire et utiliser :**
```bash
# Construire l'image
docker build -f Dockerfile.build -t fpc-builder .

# Utiliser pour compiler
docker run --rm -v $(pwd):/src fpc-builder make all

# Ou pour un build sp√©cifique
docker run --rm -v $(pwd):/src fpc-builder \
    fpc -Twin64 -Px86_64 monprojet.pas
```

### Docker Compose pour environnement complet

**docker-compose.yml :**
```yaml
version: '3.8'

services:
  builder:
    build:
      context: .
      dockerfile: Dockerfile.build
    volumes:
      - .:/src
      - build-cache:/home/builder/.cache
    working_dir: /src
    command: make all

  tester:
    build:
      context: .
      dockerfile: Dockerfile.build
    volumes:
      - .:/src
    working_dir: /src
    command: ./scripts/test_all.sh
    depends_on:
      - builder

volumes:
  build-cache:
```

Utilisation :
```bash
# Builder tout
docker-compose up builder

# Tester
docker-compose up tester

# Builder et tester
docker-compose up
```

## Packaging multi-plateforme

### Structure de distribution

Organisez vos binaires pour distribution :

```
releases/
‚îú‚îÄ‚îÄ v1.0.0/
‚îÇ   ‚îú‚îÄ‚îÄ linux/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ x64/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monprojet
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ README.txt
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ install.sh
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ arm/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ windows/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ x64/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monprojet.exe
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ README.txt
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ setup.exe
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ x86/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ archives/
‚îÇ       ‚îú‚îÄ‚îÄ monprojet-v1.0.0-linux-x64.tar.gz
‚îÇ       ‚îú‚îÄ‚îÄ monprojet-v1.0.0-linux-arm.tar.gz
‚îÇ       ‚îú‚îÄ‚îÄ monprojet-v1.0.0-windows-x64.zip
‚îÇ       ‚îî‚îÄ‚îÄ monprojet-v1.0.0-windows-x86.zip
‚îî‚îÄ‚îÄ latest -> v1.0.0
```

### Script de packaging

**package_all.sh :**
```bash
#!/bin/bash

# Script de packaging multi-plateforme

VERSION="1.0.0"
PROJECT="monprojet"
RELEASE_DIR="releases/v${VERSION}"

echo "Packaging ${PROJECT} v${VERSION}"
echo ""

# Cr√©er la structure
mkdir -p ${RELEASE_DIR}/{linux/{x64,arm},windows/{x64,x86},archives}

# Copier les binaires Linux
cp build/${PROJECT}_linux-x64 ${RELEASE_DIR}/linux/x64/${PROJECT}
cp build/${PROJECT}_linux-arm ${RELEASE_DIR}/linux/arm/${PROJECT}

# Copier les binaires Windows
cp build/${PROJECT}_windows-x64.exe ${RELEASE_DIR}/windows/x64/
cp build/${PROJECT}_windows-x86.exe ${RELEASE_DIR}/windows/x86/

# Ajouter la documentation
for dir in ${RELEASE_DIR}/linux/*/ ${RELEASE_DIR}/windows/*/; do
    cp README.md "${dir}README.txt"
    cp LICENSE "${dir}LICENSE.txt"
done

# Cr√©er les archives
echo "Cr√©ation des archives..."

cd ${RELEASE_DIR}/linux/x64
tar czf ../../archives/${PROJECT}-v${VERSION}-linux-x64.tar.gz *
cd -

cd ${RELEASE_DIR}/linux/arm
tar czf ../../archives/${PROJECT}-v${VERSION}-linux-arm.tar.gz *
cd -

cd ${RELEASE_DIR}/windows/x64
zip -r ../../archives/${PROJECT}-v${VERSION}-windows-x64.zip *
cd -

cd ${RELEASE_DIR}/windows/x86
zip -r ../../archives/${PROJECT}-v${VERSION}-windows-x86.zip *
cd -

# Cr√©er le lien vers latest
rm -f releases/latest
ln -s v${VERSION} releases/latest

echo ""
echo "Packaging termin√© !"
echo "Fichiers disponibles dans : ${RELEASE_DIR}/archives/"
ls -lh ${RELEASE_DIR}/archives/
```

## Automatisation compl√®te

### Script ma√Ætre

**master_build.sh :**
```bash
#!/bin/bash

# Script ma√Ætre pour compilation, test et packaging complet

set -e  # Arr√™t en cas d'erreur

BLUE='\033[0;34m'
GREEN='\033[0;32m'
NC='\033[0m'

step() {
    echo -e "${BLUE}==> $1${NC}"
}

step "1. V√©rification de l'environnement"
./scripts/check_toolchains.sh

step "2. Nettoyage"
make clean

step "3. Compilation pour toutes les plateformes"
./scripts/build_all.sh

step "4. Tests"
./scripts/test_all.sh

step "5. Packaging"
./scripts/package_all.sh

echo -e "${GREEN}"
echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë   Build complet termin√© avec succ√®s!  ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
echo -e "${NC}"
```

## Conclusion

La ma√Ætrise des toolchains crois√©es avec FreePascal ouvre des possibilit√©s consid√©rables :

‚úÖ **D√©veloppement unifi√©** sur un seul poste pour toutes les plateformes  
‚úÖ **Automatisation compl√®te** du processus de build  
‚úÖ **Tests syst√©matiques** sur toutes les architectures  
‚úÖ **D√©ploiement simplifi√©** avec packaging automatique  
‚úÖ **Environnements reproductibles** via Docker  
‚úÖ **CI/CD efficace** avec pipelines multi-plateformes

Les toolchains crois√©es sont particuli√®rement puissantes pour :
- Les projets open source multi-plateformes
- Le d√©veloppement de syst√®mes embarqu√©s
- Les √©quipes distribu√©es travaillant sur diff√©rents OS
- Les pipelines de d√©ploiement automatis√©s
- Le support de multiples architectures (x86, ARM, etc.)

Avec une configuration initiale bien pens√©e et les bons scripts d'automatisation, la cross-compilation devient transparente et s'int√®gre naturellement dans votre workflow de d√©veloppement quotidien.

Pour aller plus loin, explorez :
- La documentation officielle de FreePascal sur les cibles support√©es
- Les exemples de la communaut√© Lazarus
- Les projets open source utilisant FreePascal en multi-plateforme
- Les outils modernes de conteneurisation pour builds reproductibles

‚è≠Ô∏è [Int√©gration WSL/WSL2](/24-compilateur-outils-avances/09-integration-wsl-wsl2.md)
