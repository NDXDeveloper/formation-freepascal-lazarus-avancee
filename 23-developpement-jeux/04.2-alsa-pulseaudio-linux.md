üîù Retour au [Sommaire](/SOMMAIRE.md)

# 23.4.2 ALSA/PulseAudio (Linux)

## Introduction

Sur Linux, l'audio est g√©r√© par plusieurs couches et syst√®mes. Contrairement √† Windows qui propose des API unifi√©es comme DirectSound ou XAudio2, Linux offre une architecture plus modulaire et flexible. Les deux technologies principales sont **ALSA** (couche basse niveau) et **PulseAudio** (serveur son moderne).

### Qu'est-ce que ALSA ?

**ALSA** (Advanced Linux Sound Architecture) est le syst√®me audio de bas niveau int√©gr√© au noyau Linux. C'est l'√©quivalent Linux des pilotes audio Windows.

**Avantages** :
- Latence tr√®s faible
- Acc√®s direct au mat√©riel
- L√©ger et rapide
- Pas de d√©pendances
- Contr√¥le total

**Inconv√©nients** :
- API complexe
- Difficile √† utiliser correctement
- Pas de mixage automatique (un seul programme peut utiliser la carte son)
- Configuration manuelle parfois n√©cessaire
- Peu adapt√© aux applications de bureau

### Qu'est-ce que PulseAudio ?

**PulseAudio** est un serveur son qui se place au-dessus d'ALSA. C'est le standard sur la plupart des distributions Linux modernes (Ubuntu, Fedora, etc.).

**Avantages** :
- Mixage automatique (plusieurs applications simultan√©ment)
- API simple et intuitive
- Gestion r√©seau (son sur le r√©seau)
- Contr√¥le par application
- Compatible avec la plupart des distributions
- Int√©gration avec les environnements de bureau

**Inconv√©nients** :
- Latence l√©g√®rement plus √©lev√©e qu'ALSA
- Consomme plus de ressources
- Peut √™tre instable sur certaines configurations
- Ajoute une couche d'abstraction

### Qu'est-ce que PipeWire ?

**PipeWire** est le nouveau syst√®me audio moderne qui remplace progressivement PulseAudio. Il est r√©trocompatible avec PulseAudio et offre de meilleures performances, particuli√®rement pour l'audio professionnel et la vid√©o.

**Note** : PipeWire peut √©muler l'API PulseAudio, donc le code PulseAudio fonctionnera avec PipeWire.

### Quelle technologie choisir ?

**Utilisez PulseAudio si** :
- Vous d√©veloppez un jeu de bureau standard
- Vous voulez une compatibilit√© maximale
- Vous n'avez pas besoin de latence ultra-faible
- Vous voulez un d√©veloppement simple

**Utilisez ALSA si** :
- Vous avez besoin d'une latence minimale (<10ms)
- Vous d√©veloppez pour un syst√®me embarqu√©
- Vous voulez un contr√¥le total du mat√©riel
- Vous acceptez la complexit√© suppl√©mentaire

**Recommandation** : Pour la plupart des jeux, **PulseAudio** est le meilleur choix.

## PulseAudio

### Installation des biblioth√®ques

Sur Ubuntu/Debian :
```bash
sudo apt-get install libpulse-dev
```

Sur Fedora/RHEL :
```bash
sudo dnf install pulseaudio-libs-devel
```

Sur Arch Linux :
```bash
sudo pacman -S libpulse
```

### V√©rifier que PulseAudio fonctionne

```bash
# V√©rifier que le serveur tourne
pulseaudio --check
echo $?  # Doit retourner 0

# Lister les p√©riph√©riques audio
pactl list sinks

# Jouer un son de test
paplay /usr/share/sounds/alsa/Front_Center.wav
```

### Cr√©er les bindings Pascal pour PulseAudio

```pascal
unit PulseAudio;

{$mode objfpc}{$H+}
{$PACKRECORDS C}

interface

const
  {$IFDEF LINUX}
  PULSE_LIB = 'libpulse-simple.so.0';
  {$ENDIF}

type
  // Format d'√©chantillonnage
  pa_sample_format_t = (
    PA_SAMPLE_U8,           // Unsigned 8 bit
    PA_SAMPLE_ALAW,         // 8 bit a-Law
    PA_SAMPLE_ULAW,         // 8 bit mu-Law
    PA_SAMPLE_S16LE,        // Signed 16 bit Little Endian
    PA_SAMPLE_S16BE,        // Signed 16 bit Big Endian
    PA_SAMPLE_FLOAT32LE,    // 32 bit IEEE floating point Little Endian
    PA_SAMPLE_FLOAT32BE,    // 32 bit IEEE floating point Big Endian
    PA_SAMPLE_S32LE,        // Signed 32 bit Little Endian
    PA_SAMPLE_S32BE,        // Signed 32 bit Big Endian
    PA_SAMPLE_S24LE,        // Signed 24 bit Little Endian
    PA_SAMPLE_S24BE,        // Signed 24 bit Big Endian
    PA_SAMPLE_S24_32LE,     // Signed 24 bit in 32 bit Little Endian
    PA_SAMPLE_S24_32BE,     // Signed 24 bit in 32 bit Big Endian
    PA_SAMPLE_MAX,
    PA_SAMPLE_INVALID = -1
  );

  // Direction du flux
  pa_stream_direction_t = (
    PA_STREAM_NODIRECTION,
    PA_STREAM_PLAYBACK,     // Lecture
    PA_STREAM_RECORD,       // Enregistrement
    PA_STREAM_UPLOAD
  );

  // Sp√©cification des √©chantillons
  pa_sample_spec = record
    format: pa_sample_format_t;  // Format des √©chantillons
    rate: LongWord;              // Fr√©quence (Hz)
    channels: Byte;              // Nombre de canaux
  end;
  Ppa_sample_spec = ^pa_sample_spec;

  // Attributs de buffer
  pa_buffer_attr = record
    maxlength: LongWord;    // Taille maximale du buffer
    tlength: LongWord;      // Longueur cible pour la lecture
    prebuf: LongWord;       // Pr√©-buffering
    minreq: LongWord;       // Requ√™te minimale
    fragsize: LongWord;     // Taille de fragment
  end;
  Ppa_buffer_attr = ^pa_buffer_attr;

  // Mapping de canaux
  pa_channel_position_t = Integer;

  pa_channel_map = record
    channels: Byte;
    map: array[0..31] of pa_channel_position_t;
  end;
  Ppa_channel_map = ^pa_channel_map;

  // Pointeurs opaques
  pa_simple = Pointer;
  pa_context = Pointer;
  pa_stream = Pointer;
  pa_mainloop = Pointer;
  pa_operation = Pointer;

// API Simple (recommand√©e pour d√©buter)

// Cr√©er une connexion simple
function pa_simple_new(
  const server: PChar;              // Serveur (nil = d√©faut)
  const name: PChar;                // Nom de l'application
  dir: pa_stream_direction_t;       // Direction
  const dev: PChar;                 // P√©riph√©rique (nil = d√©faut)
  const stream_name: PChar;         // Nom du flux
  const ss: Ppa_sample_spec;        // Sp√©cifications
  const map: Ppa_channel_map;       // Mapping de canaux (nil = d√©faut)
  const attr: Ppa_buffer_attr;      // Attributs (nil = d√©faut)
  var error: Integer                // Code d'erreur
): pa_simple; cdecl; external PULSE_LIB;

// Lib√©rer la connexion
procedure pa_simple_free(s: pa_simple); cdecl; external PULSE_LIB;

// √âcrire des donn√©es
function pa_simple_write(
  s: pa_simple;
  const data: Pointer;
  bytes: Cardinal;
  var error: Integer
): Integer; cdecl; external PULSE_LIB;

// Vider le buffer
function pa_simple_drain(
  s: pa_simple;
  var error: Integer
): Integer; cdecl; external PULSE_LIB;

// Lire des donn√©es
function pa_simple_read(
  s: pa_simple;
  data: Pointer;
  bytes: Cardinal;
  var error: Integer
): Integer; cdecl; external PULSE_LIB;

// Obtenir la latence
function pa_simple_get_latency(
  s: pa_simple;
  var error: Integer
): Int64; cdecl; external PULSE_LIB;

// Vider le buffer imm√©diatement
function pa_simple_flush(
  s: pa_simple;
  var error: Integer
): Integer; cdecl; external PULSE_LIB;

// Obtenir une description d'erreur
function pa_strerror(error: Integer): PChar; cdecl; external PULSE_LIB;

// Canaux standards
const
  PA_CHANNEL_POSITION_MONO = 0;
  PA_CHANNEL_POSITION_FRONT_LEFT = 1;
  PA_CHANNEL_POSITION_FRONT_RIGHT = 2;
  PA_CHANNEL_POSITION_FRONT_CENTER = 3;
  PA_CHANNEL_POSITION_REAR_CENTER = 4;
  PA_CHANNEL_POSITION_REAR_LEFT = 5;
  PA_CHANNEL_POSITION_REAR_RIGHT = 6;
  PA_CHANNEL_POSITION_LFE = 7;

implementation

end.
```

### Wrapper de haut niveau pour PulseAudio

```pascal
unit PulseAudioWrapper;

{$mode objfpc}{$H+}

interface

uses
  PulseAudio, Classes, SysUtils;

type
  TPulseAudioSound = class
  private
    FConnection: pa_simple;
    FAudioData: PByte;
    FAudioSize: Cardinal;
    FSampleRate: Cardinal;
    FChannels: Byte;
    FBitsPerSample: Word;
    FPlaying: Boolean;
    FVolume: Single;
  public
    constructor Create(const Filename: string);
    destructor Destroy; override;

    procedure Play(Loop: Boolean = False);
    procedure Stop;
    procedure Pause;
    procedure Resume;

    function IsPlaying: Boolean;

    property Volume: Single read FVolume write SetVolume;
    property SampleRate: Cardinal read FSampleRate;
    property Channels: Byte read FChannels;
  end;

  TPulseAudioSystem = class
  private
    FSounds: TList;
    FAppName: string;
  public
    constructor Create(const AppName: string);
    destructor Destroy; override;

    function LoadSound(const Filename: string): TPulseAudioSound;
    procedure UnloadSound(Sound: TPulseAudioSound);

    procedure StopAllSounds;
  end;

implementation

{ TPulseAudioSound }

constructor TPulseAudioSound.Create(const Filename: string);
var
  WaveFile: TFileStream;
  Header: array[0..43] of Byte;
  SampleSpec: pa_sample_spec;
  Error: Integer;
begin
  inherited Create;

  FVolume := 1.0;
  FPlaying := False;

  // Charger le fichier WAV
  WaveFile := TFileStream.Create(Filename, fmOpenRead);
  try
    // Lire l'en-t√™te WAV
    WaveFile.Read(Header, 44);

    // V√©rifier le format
    if (Chr(Header[0]) + Chr(Header[1]) + Chr(Header[2]) + Chr(Header[3]) <> 'RIFF') or
       (Chr(Header[8]) + Chr(Header[9]) + Chr(Header[10]) + Chr(Header[11]) <> 'WAVE') then
      raise Exception.Create('Format WAV invalide');

    // Extraire les informations
    FChannels := PWord(@Header[22])^;
    FSampleRate := PLongWord(@Header[24])^;
    FBitsPerSample := PWord(@Header[34])^;
    FAudioSize := PLongWord(@Header[40])^;

    // Allouer et charger les donn√©es audio
    GetMem(FAudioData, FAudioSize);
    WaveFile.Read(FAudioData^, FAudioSize);

  finally
    WaveFile.Free;
  end;

  // Configurer PulseAudio
  FillChar(SampleSpec, SizeOf(SampleSpec), 0);

  case FBitsPerSample of
    8:  SampleSpec.format := PA_SAMPLE_U8;
    16: SampleSpec.format := PA_SAMPLE_S16LE;
    32: SampleSpec.format := PA_SAMPLE_S32LE;
    else
      raise Exception.Create('Format non support√©: ' + IntToStr(FBitsPerSample) + ' bits');
  end;

  SampleSpec.rate := FSampleRate;
  SampleSpec.channels := FChannels;

  // Cr√©er la connexion PulseAudio
  FConnection := pa_simple_new(
    nil,                          // Serveur par d√©faut
    'GameAudio',                  // Nom de l'application
    PA_STREAM_PLAYBACK,          // Lecture
    nil,                         // P√©riph√©rique par d√©faut
    'Sound Effect',              // Nom du flux
    @SampleSpec,                 // Sp√©cifications
    nil,                         // Channel map par d√©faut
    nil,                         // Buffer attr par d√©faut
    Error
  );

  if FConnection = nil then
    raise Exception.Create('Impossible de se connecter √† PulseAudio: ' +
                          string(pa_strerror(Error)));
end;

destructor TPulseAudioSound.Destroy;
begin
  Stop;

  if FConnection <> nil then
  begin
    pa_simple_free(FConnection);
    FConnection := nil;
  end;

  if FAudioData <> nil then
    FreeMem(FAudioData);

  inherited;
end;

procedure TPulseAudioSound.Play(Loop: Boolean = False);
var
  Error: Integer;
  BytesWritten: Cardinal;
  Offset: Cardinal;
const
  CHUNK_SIZE = 4096;
begin
  if FConnection = nil then Exit;

  FPlaying := True;

  repeat
    Offset := 0;

    // √âcrire les donn√©es par morceaux
    while Offset < FAudioSize do
    begin
      BytesWritten := CHUNK_SIZE;
      if Offset + BytesWritten > FAudioSize then
        BytesWritten := FAudioSize - Offset;

      if pa_simple_write(FConnection, FAudioData + Offset, BytesWritten, Error) < 0 then
      begin
        WriteLn('Erreur PulseAudio write: ', string(pa_strerror(Error)));
        FPlaying := False;
        Exit;
      end;

      Inc(Offset, BytesWritten);

      if not FPlaying then
        Break;
    end;

  until not Loop or not FPlaying;

  // Attendre que tout soit jou√©
  if FPlaying then
    pa_simple_drain(FConnection, Error);

  FPlaying := False;
end;

procedure TPulseAudioSound.Stop;
var
  Error: Integer;
begin
  FPlaying := False;

  if FConnection <> nil then
    pa_simple_flush(FConnection, Error);
end;

procedure TPulseAudioSound.Pause;
begin
  FPlaying := False;
end;

procedure TPulseAudioSound.Resume;
begin
  // PulseAudio Simple API ne supporte pas vraiment pause/resume
  // Il faudrait utiliser l'API asynchrone compl√®te
  WriteLn('Pause/Resume non support√© avec l''API simple');
end;

function TPulseAudioSound.IsPlaying: Boolean;
begin
  Result := FPlaying;
end;

procedure TPulseAudioSound.SetVolume(Value: Single);
begin
  FVolume := Value;
  if FVolume < 0 then FVolume := 0;
  if FVolume > 1 then FVolume := 1;

  // Note: Le volume devrait √™tre appliqu√© en multipliant les √©chantillons
  // ou en utilisant l'API asynchrone de PulseAudio
end;

{ TPulseAudioSystem }

constructor TPulseAudioSystem.Create(const AppName: string);
begin
  inherited Create;
  FAppName := AppName;
  FSounds := TList.Create;
end;

destructor TPulseAudioSystem.Destroy;
var
  i: Integer;
begin
  for i := FSounds.Count - 1 downto 0 do
    TPulseAudioSound(FSounds[i]).Free;

  FSounds.Free;

  inherited;
end;

function TPulseAudioSystem.LoadSound(const Filename: string): TPulseAudioSound;
begin
  Result := TPulseAudioSound.Create(Filename);
  FSounds.Add(Result);
end;

procedure TPulseAudioSystem.UnloadSound(Sound: TPulseAudioSound);
begin
  if Assigned(Sound) then
  begin
    FSounds.Remove(Sound);
    Sound.Free;
  end;
end;

procedure TPulseAudioSystem.StopAllSounds;
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    TPulseAudioSound(FSounds[i]).Stop;
end;

end.
```

### Utilisation basique de PulseAudio

```pascal
program PulseAudioDemo;

{$mode objfpc}{$H+}

uses
  PulseAudioWrapper, SysUtils;

var
  Audio: TPulseAudioSystem;
  Music: TPulseAudioSound;
  JumpSound: TPulseAudioSound;

begin
  WriteLn('D√©mo PulseAudio');

  // Cr√©er le syst√®me audio
  Audio := TPulseAudioSystem.Create('MonJeu');

  try
    // Charger les sons
    WriteLn('Chargement des sons...');
    Music := Audio.LoadSound('music.wav');
    JumpSound := Audio.LoadSound('jump.wav');

    WriteLn('Sons charg√©s !');
    WriteLn('Appuyez sur J pour sauter, M pour musique, Q pour quitter');

    while True do
    begin
      Write('> ');
      case ReadKey of
        'j', 'J':
        begin
          WriteLn('Jump!');
          JumpSound.Play;
        end;

        'm', 'M':
        begin
          WriteLn('Musique...');
          Music.Play(True); // En boucle
        end;

        's', 'S':
        begin
          WriteLn('Stop musique');
          Music.Stop;
        end;

        'q', 'Q':
        begin
          WriteLn('Quitter');
          Break;
        end;
      end;
    end;

  finally
    Audio.Free;
  end;
end.
```

## API PulseAudio asynchrone (avanc√©e)

Pour un contr√¥le plus fin (volume, pause/resume, etc.), utilisez l'API asynchrone compl√®te.

```pascal
unit PulseAudioAsync;

{$mode objfpc}{$H+}

interface

uses
  PulseAudio, Classes;

type
  TAsyncPulseAudioSound = class
  private
    FContext: pa_context;
    FMainloop: pa_mainloop;
    FStream: pa_stream;
    FAudioData: PByte;
    FAudioSize: Cardinal;
    FVolume: Single;
  public
    constructor Create(const Filename: string);
    destructor Destroy; override;

    procedure Play;
    procedure Stop;
    procedure SetVolume(Volume: Single);
    procedure SetPan(Pan: Single); // -1.0 (gauche) √† 1.0 (droite)

    procedure Update; // √Ä appeler r√©guli√®rement
  end;

implementation

// Cette impl√©mentation est complexe et n√©cessite une compr√©hension
// approfondie de l'API asynchrone de PulseAudio
// Pour les jeux simples, l'API simple suffit

end.
```

## ALSA

### Quand utiliser ALSA directement

ALSA est recommand√© pour :
- Audio professionnel/temps r√©el
- Syst√®mes embarqu√©s
- Latence <10ms n√©cessaire
- Pas de serveur son disponible

### Installation

```bash
sudo apt-get install libasound2-dev
```

### Bindings Pascal pour ALSA

```pascal
unit ALSA;

{$mode objfpc}{$H+}
{$PACKRECORDS C}

interface

const
  {$IFDEF LINUX}
  ALSA_LIB = 'libasound.so.2';
  {$ENDIF}

type
  // Pointeurs opaques
  snd_pcm_t = Pointer;
  snd_pcm_hw_params_t = Pointer;
  snd_pcm_sw_params_t = Pointer;

  // Types d'acc√®s
  snd_pcm_stream_t = Integer;
  snd_pcm_access_t = Integer;
  snd_pcm_format_t = Integer;

const
  // Direction du flux
  SND_PCM_STREAM_PLAYBACK = 0;
  SND_PCM_STREAM_CAPTURE = 1;

  // Mode d'ouverture
  SND_PCM_NONBLOCK = $0001;
  SND_PCM_ASYNC = $0002;

  // Type d'acc√®s
  SND_PCM_ACCESS_MMAP_INTERLEAVED = 0;
  SND_PCM_ACCESS_MMAP_NONINTERLEAVED = 1;
  SND_PCM_ACCESS_MMAP_COMPLEX = 2;
  SND_PCM_ACCESS_RW_INTERLEAVED = 3;
  SND_PCM_ACCESS_RW_NONINTERLEAVED = 4;

  // Formats
  SND_PCM_FORMAT_UNKNOWN = -1;
  SND_PCM_FORMAT_S8 = 0;
  SND_PCM_FORMAT_U8 = 1;
  SND_PCM_FORMAT_S16_LE = 2;
  SND_PCM_FORMAT_S16_BE = 3;
  SND_PCM_FORMAT_U16_LE = 4;
  SND_PCM_FORMAT_U16_BE = 5;
  SND_PCM_FORMAT_S24_LE = 6;
  SND_PCM_FORMAT_S32_LE = 10;
  SND_PCM_FORMAT_FLOAT_LE = 14;

// Ouvrir un p√©riph√©rique
function snd_pcm_open(
  var pcm: snd_pcm_t;
  const name: PChar;
  stream: snd_pcm_stream_t;
  mode: Integer
): Integer; cdecl; external ALSA_LIB;

// Fermer
function snd_pcm_close(pcm: snd_pcm_t): Integer; cdecl; external ALSA_LIB;

// Pr√©parer
function snd_pcm_prepare(pcm: snd_pcm_t): Integer; cdecl; external ALSA_LIB;

// √âcrire des donn√©es
function snd_pcm_writei(
  pcm: snd_pcm_t;
  const buffer: Pointer;
  size: Cardinal
): Integer; cdecl; external ALSA_LIB;

// Drainer
function snd_pcm_drain(pcm: snd_pcm_t): Integer; cdecl; external ALSA_LIB;

// Param√®tres mat√©riels
function snd_pcm_hw_params_malloc(var params: snd_pcm_hw_params_t): Integer; cdecl; external ALSA_LIB;
procedure snd_pcm_hw_params_free(params: snd_pcm_hw_params_t); cdecl; external ALSA_LIB;

function snd_pcm_hw_params_any(
  pcm: snd_pcm_t;
  params: snd_pcm_hw_params_t
): Integer; cdecl; external ALSA_LIB;

function snd_pcm_hw_params_set_access(
  pcm: snd_pcm_t;
  params: snd_pcm_hw_params_t;
  access: snd_pcm_access_t
): Integer; cdecl; external ALSA_LIB;

function snd_pcm_hw_params_set_format(
  pcm: snd_pcm_t;
  params: snd_pcm_hw_params_t;
  format: snd_pcm_format_t
): Integer; cdecl; external ALSA_LIB;

function snd_pcm_hw_params_set_channels(
  pcm: snd_pcm_t;
  params: snd_pcm_hw_params_t;
  channels: Cardinal
): Integer; cdecl; external ALSA_LIB;

function snd_pcm_hw_params_set_rate_near(
  pcm: snd_pcm_t;
  params: snd_pcm_hw_params_t;
  var rate: Cardinal;
  var dir: Integer
): Integer; cdecl; external ALSA_LIB;

function snd_pcm_hw_params(
  pcm: snd_pcm_t;
  params: snd_pcm_hw_params_t
): Integer; cdecl; external ALSA_LIB;

// R√©cup√©ration d'erreurs
function snd_strerror(errnum: Integer): PChar; cdecl; external ALSA_LIB;

implementation

end.
```

### Wrapper simple pour ALSA

```pascal
unit ALSAWrapper;

{$mode objfpc}{$H+}

interface

uses
  ALSA, Classes, SysUtils;

type
  TALSASound = class
  private
    FPCM: snd_pcm_t;
    FAudioData: PByte;
    FAudioSize: Cardinal;
    FSampleRate: Cardinal;
    FChannels: Byte;
    FBitsPerSample: Word;
  public
    constructor Create(const Filename: string);
    destructor Destroy; override;

    procedure Play;
    procedure Stop;
  end;

implementation

constructor TALSASound.Create(const Filename: string);
var
  WaveFile: TFileStream;
  Header: array[0..43] of Byte;
  HWParams: snd_pcm_hw_params_t;
  Rate: Cardinal;
  Dir: Integer;
  Ret: Integer;
begin
  inherited Create;

  // Charger le WAV (comme avant)
  WaveFile := TFileStream.Create(Filename, fmOpenRead);
  try
    WaveFile.Read(Header, 44);

    FChannels := PWord(@Header[22])^;
    FSampleRate := PLongWord(@Header[24])^;
    FBitsPerSample := PWord(@Header[34])^;
    FAudioSize := PLongWord(@Header[40])^;

    GetMem(FAudioData, FAudioSize);
    WaveFile.Read(FAudioData^, FAudioSize);
  finally
    WaveFile.Free;
  end;

  // Ouvrir ALSA
  Ret := snd_pcm_open(FPCM, 'default', SND_PCM_STREAM_PLAYBACK, 0);
  if Ret < 0 then
    raise Exception.Create('Impossible d''ouvrir ALSA: ' + string(snd_strerror(Ret)));

  // Configurer les param√®tres
  snd_pcm_hw_params_malloc(HWParams);
  try
    snd_pcm_hw_params_any(FPCM, HWParams);
    snd_pcm_hw_params_set_access(FPCM, HWParams, SND_PCM_ACCESS_RW_INTERLEAVED);

    // Format
    case FBitsPerSample of
      8:  snd_pcm_hw_params_set_format(FPCM, HWParams, SND_PCM_FORMAT_U8);
      16: snd_pcm_hw_params_set_format(FPCM, HWParams, SND_PCM_FORMAT_S16_LE);
      32: snd_pcm_hw_params_set_format(FPCM, HWParams, SND_PCM_FORMAT_S32_LE);
    end;

    // Canaux et fr√©quence
    snd_pcm_hw_params_set_channels(FPCM, HWParams, FChannels);
    Rate := FSampleRate;
    Dir := 0;
    snd_pcm_hw_params_set_rate_near(FPCM, HWParams, Rate, Dir);

    // Appliquer
    snd_pcm_hw_params(FPCM, HWParams);
  finally
    snd_pcm_hw_params_free(HWParams);
  end;
end;

destructor TALSASound.Destroy;
begin
  if FPCM <> nil then
  begin
    snd_pcm_drain(FPCM);
    snd_pcm_close(FPCM);
  end;

  if FAudioData <> nil then
    FreeMem(FAudioData);

  inherited;
end;

procedure TALSASound.Play;
var
  Frames: Cardinal;
  BytesPerFrame: Cardinal;
  Ret: Integer;
begin
  snd_pcm_prepare(FPCM);

  BytesPerFrame := (FBitsPerSample div 8) * FChannels;
  Frames := FAudioSize div BytesPerFrame;

  Ret := snd_pcm_writei(FPCM, FAudioData, Frames);
  if Ret < 0 then
    WriteLn('Erreur ALSA write: ', string(snd_strerror(Ret)));

  snd_pcm_drain(FPCM);
end;

procedure TALSASound.Stop;
begin
  if FPCM <> nil then
    snd_pcm_drop(FPCM); // Arr√™ter imm√©diatement
end;

end.
```

### Utilisation d'ALSA

```pascal
program ALSADemo;

{$mode objfpc}{$H+}

uses
  ALSAWrapper;

var
  Sound: TALSASound;

begin
  WriteLn('D√©mo ALSA');

  try
    Sound := TALSASound.Create('test.wav');
    try
      WriteLn('Lecture du son...');
      Sound.Play;
      WriteLn('Termin√©');
    finally
      Sound.Free;
    end;
  except
    on E: Exception do
      WriteLn('Erreur: ', E.Message);
  end;
end.
```

## OpenAL - Solution multi-plateforme recommand√©e

**OpenAL** (Open Audio Library) est une API audio 3D multi-plateforme qui fonctionne sur Linux, Windows, macOS et plus encore. C'est souvent le meilleur choix pour les jeux.

### Avantages d'OpenAL

- Multi-plateforme (m√™me code sur Linux, Windows, macOS)
- Audio 3D spatial natif
- Gestion automatique du mat√©riel
- API simple et intuitive
- Bien document√©
- Largement utilis√© dans l'industrie du jeu

### Installation d'OpenAL sur Linux

```bash
# Ubuntu/Debian
sudo apt-get install libopenal-dev

# Fedora
sudo dnf install openal-soft-devel

# Arch Linux
sudo pacman -S openal
```

### Bindings Pascal pour OpenAL

```pascal
unit OpenAL;

{$mode objfpc}{$H+}

interface

const
  {$IFDEF LINUX}
  OPENAL_LIB = 'libopenal.so.1';
  {$ENDIF}
  {$IFDEF WINDOWS}
  OPENAL_LIB = 'OpenAL32.dll';
  {$ENDIF}
  {$IFDEF DARWIN}
  OPENAL_LIB = 'OpenAL.framework/OpenAL';
  {$ENDIF}

type
  ALboolean = Boolean;
  ALchar = Char;
  ALbyte = ShortInt;
  ALubyte = Byte;
  ALshort = SmallInt;
  ALushort = Word;
  ALint = Integer;
  ALuint = Cardinal;
  ALsizei = Integer;
  ALenum = Integer;
  ALfloat = Single;
  ALdouble = Double;

const
  // Boolean
  AL_FALSE = 0;
  AL_TRUE = 1;

  // Formats
  AL_FORMAT_MONO8 = $1100;
  AL_FORMAT_MONO16 = $1101;
  AL_FORMAT_STEREO8 = $1102;
  AL_FORMAT_STEREO16 = $1103;

  // √âtats
  AL_INITIAL = $1011;
  AL_PLAYING = $1012;
  AL_PAUSED = $1013;
  AL_STOPPED = $1014;

  // Propri√©t√©s de source
  AL_PITCH = $1003;
  AL_GAIN = $100A;
  AL_MIN_GAIN = $100D;
  AL_MAX_GAIN = $100E;
  AL_MAX_DISTANCE = $1023;
  AL_ROLLOFF_FACTOR = $1021;
  AL_CONE_OUTER_GAIN = $1022;
  AL_CONE_INNER_ANGLE = $1001;
  AL_CONE_OUTER_ANGLE = $1002;
  AL_REFERENCE_DISTANCE = $1020;
  AL_POSITION = $1004;
  AL_VELOCITY = $1006;
  AL_DIRECTION = $1005;
  AL_SOURCE_RELATIVE = $202;
  AL_SOURCE_TYPE = $1027;
  AL_LOOPING = $1007;
  AL_BUFFER = $1009;
  AL_SOURCE_STATE = $1010;

  // Propri√©t√©s de listener
  AL_ORIENTATION = $100F;

  // Erreurs
  AL_NO_ERROR = 0;
  AL_INVALID_NAME = $A001;
  AL_INVALID_ENUM = $A002;
  AL_INVALID_VALUE = $A003;
  AL_INVALID_OPERATION = $A004;
  AL_OUT_OF_MEMORY = $A005;

// Gestion du contexte
function alcCreateContext(device: Pointer; attrlist: PInteger): Pointer; cdecl; external OPENAL_LIB;
function alcMakeContextCurrent(context: Pointer): ALboolean; cdecl; external OPENAL_LIB;
procedure alcDestroyContext(context: Pointer); cdecl; external OPENAL_LIB;
function alcOpenDevice(devicename: PChar): Pointer; cdecl; external OPENAL_LIB;
function alcCloseDevice(device: Pointer): ALboolean; cdecl; external OPENAL_LIB;

// Gestion des buffers
procedure alGenBuffers(n: ALsizei; buffers: PALuint); cdecl; external OPENAL_LIB;
procedure alDeleteBuffers(n: ALsizei; const buffers: PALuint); cdecl; external OPENAL_LIB;
function alIsBuffer(buffer: ALuint): ALboolean; cdecl; external OPENAL_LIB;
procedure alBufferData(buffer: ALuint; format: ALenum; const data: Pointer; size: ALsizei; freq: ALsizei); cdecl; external OPENAL_LIB;

// Gestion des sources
procedure alGenSources(n: ALsizei; sources: PALuint); cdecl; external OPENAL_LIB;
procedure alDeleteSources(n: ALsizei; const sources: PALuint); cdecl; external OPENAL_LIB;
function alIsSource(source: ALuint): ALboolean; cdecl; external OPENAL_LIB;

// Propri√©t√©s des sources
procedure alSourcef(source: ALuint; param: ALenum; value: ALfloat); cdecl; external OPENAL_LIB;
procedure alSource3f(source: ALuint; param: ALenum; value1, value2, value3: ALfloat); cdecl; external OPENAL_LIB;
procedure alSourcefv(source: ALuint; param: ALenum; const values: PALfloat); cdecl; external OPENAL_LIB;
procedure alSourcei(source: ALuint; param: ALenum; value: ALint); cdecl; external OPENAL_LIB;
procedure alGetSourcei(source: ALuint; param: ALenum; value: PALint); cdecl; external OPENAL_LIB;

// Contr√¥le de lecture
procedure alSourcePlay(source: ALuint); cdecl; external OPENAL_LIB;
procedure alSourceStop(source: ALuint); cdecl; external OPENAL_LIB;
procedure alSourceRewind(source: ALuint); cdecl; external OPENAL_LIB;
procedure alSourcePause(source: ALuint); cdecl; external OPENAL_LIB;

// Contr√¥le du listener (joueur/cam√©ra)
procedure alListenerf(param: ALenum; value: ALfloat); cdecl; external OPENAL_LIB;
procedure alListener3f(param: ALenum; value1, value2, value3: ALfloat); cdecl; external OPENAL_LIB;
procedure alListenerfv(param: ALenum; const values: PALfloat); cdecl; external OPENAL_LIB;

// Gestion d'erreurs
function alGetError: ALenum; cdecl; external OPENAL_LIB;
function alGetString(param: ALenum): PChar; cdecl; external OPENAL_LIB;

implementation

end.
```

### Wrapper OpenAL de haut niveau

```pascal
unit OpenALWrapper;

{$mode objfpc}{$H+}

interface

uses
  OpenAL, Classes, SysUtils;

type
  TOpenALSound = class
  private
    FBuffer: ALuint;
    FSource: ALuint;
    FLooping: Boolean;
  public
    constructor Create(const Filename: string);
    destructor Destroy; override;

    procedure Play(Loop: Boolean = False);
    procedure Stop;
    procedure Pause;
    procedure Resume;

    function IsPlaying: Boolean;

    procedure SetVolume(Volume: Single);
    procedure SetPitch(Pitch: Single);
    procedure SetPosition(X, Y, Z: Single);
    procedure SetVelocity(VX, VY, VZ: Single);

    property Looping: Boolean read FLooping write SetLooping;
  end;

  TOpenALSystem = class
  private
    FDevice: Pointer;
    FContext: Pointer;
    FSounds: TList;
  public
    constructor Create;
    destructor Destroy; override;

    function LoadSound(const Filename: string): TOpenALSound;
    procedure UnloadSound(Sound: TOpenALSound);

    procedure SetListenerPosition(X, Y, Z: Single);
    procedure SetListenerVelocity(VX, VY, VZ: Single);
    procedure SetListenerOrientation(ForwardX, ForwardY, ForwardZ, UpX, UpY, UpZ: Single);

    procedure StopAllSounds;
  end;

implementation

{ TOpenALSound }

constructor TOpenALSound.Create(const Filename: string);
var
  WaveFile: TFileStream;
  Header: array[0..43] of Byte;
  AudioData: PByte;
  AudioSize: Cardinal;
  Channels: Word;
  SampleRate: Cardinal;
  BitsPerSample: Word;
  Format: ALenum;
begin
  inherited Create;

  // Charger le fichier WAV
  WaveFile := TFileStream.Create(Filename, fmOpenRead);
  try
    WaveFile.Read(Header, 44);

    // V√©rifier le format
    if (Chr(Header[0]) + Chr(Header[1]) + Chr(Header[2]) + Chr(Header[3]) <> 'RIFF') or
       (Chr(Header[8]) + Chr(Header[9]) + Chr(Header[10]) + Chr(Header[11]) <> 'WAVE') then
      raise Exception.Create('Format WAV invalide');

    // Extraire les informations
    Channels := PWord(@Header[22])^;
    SampleRate := PLongWord(@Header[24])^;
    BitsPerSample := PWord(@Header[34])^;
    AudioSize := PLongWord(@Header[40])^;

    // D√©terminer le format OpenAL
    if (Channels = 1) and (BitsPerSample = 8) then
      Format := AL_FORMAT_MONO8
    else if (Channels = 1) and (BitsPerSample = 16) then
      Format := AL_FORMAT_MONO16
    else if (Channels = 2) and (BitsPerSample = 8) then
      Format := AL_FORMAT_STEREO8
    else if (Channels = 2) and (BitsPerSample = 16) then
      Format := AL_FORMAT_STEREO16
    else
      raise Exception.Create('Format audio non support√©');

    // Charger les donn√©es audio
    GetMem(AudioData, AudioSize);
    try
      WaveFile.Read(AudioData^, AudioSize);

      // Cr√©er le buffer OpenAL
      alGenBuffers(1, @FBuffer);
      alBufferData(FBuffer, Format, AudioData, AudioSize, SampleRate);

      // V√©rifier les erreurs
      if alGetError <> AL_NO_ERROR then
        raise Exception.Create('Erreur lors de la cr√©ation du buffer OpenAL');

    finally
      FreeMem(AudioData);
    end;

  finally
    WaveFile.Free;
  end;

  // Cr√©er la source
  alGenSources(1, @FSource);
  alSourcei(FSource, AL_BUFFER, FBuffer);

  FLooping := False;
end;

destructor TOpenALSound.Destroy;
begin
  if FSource <> 0 then
  begin
    alSourceStop(FSource);
    alDeleteSources(1, @FSource);
  end;

  if FBuffer <> 0 then
    alDeleteBuffers(1, @FBuffer);

  inherited;
end;

procedure TOpenALSound.Play(Loop: Boolean = False);
begin
  FLooping := Loop;
  alSourcei(FSource, AL_LOOPING, Ord(Loop));
  alSourcePlay(FSource);
end;

procedure TOpenALSound.Stop;
begin
  alSourceStop(FSource);
end;

procedure TOpenALSound.Pause;
begin
  alSourcePause(FSource);
end;

procedure TOpenALSound.Resume;
begin
  alSourcePlay(FSource);
end;

function TOpenALSound.IsPlaying: Boolean;
var
  State: ALint;
begin
  alGetSourcei(FSource, AL_SOURCE_STATE, @State);
  Result := (State = AL_PLAYING);
end;

procedure TOpenALSound.SetVolume(Volume: Single);
begin
  alSourcef(FSource, AL_GAIN, Volume);
end;

procedure TOpenALSound.SetPitch(Pitch: Single);
begin
  alSourcef(FSource, AL_PITCH, Pitch);
end;

procedure TOpenALSound.SetPosition(X, Y, Z: Single);
begin
  alSource3f(FSource, AL_POSITION, X, Y, Z);
end;

procedure TOpenALSound.SetVelocity(VX, VY, VZ: Single);
begin
  alSource3f(FSource, AL_VELOCITY, VX, VY, VZ);
end;

procedure TOpenALSound.SetLooping(Value: Boolean);
begin
  FLooping := Value;
  alSourcei(FSource, AL_LOOPING, Ord(Value));
end;

{ TOpenALSystem }

constructor TOpenALSystem.Create;
begin
  inherited Create;

  FSounds := TList.Create;

  // Ouvrir le p√©riph√©rique audio par d√©faut
  FDevice := alcOpenDevice(nil);
  if FDevice = nil then
    raise Exception.Create('Impossible d''ouvrir le p√©riph√©rique audio');

  // Cr√©er le contexte
  FContext := alcCreateContext(FDevice, nil);
  if FContext = nil then
  begin
    alcCloseDevice(FDevice);
    raise Exception.Create('Impossible de cr√©er le contexte OpenAL');
  end;

  // Activer le contexte
  if not alcMakeContextCurrent(FContext) then
  begin
    alcDestroyContext(FContext);
    alcCloseDevice(FDevice);
    raise Exception.Create('Impossible d''activer le contexte OpenAL');
  end;

  WriteLn('OpenAL initialis√© avec succ√®s');
end;

destructor TOpenALSystem.Destroy;
var
  i: Integer;
begin
  // Lib√©rer tous les sons
  for i := FSounds.Count - 1 downto 0 do
    TOpenALSound(FSounds[i]).Free;

  FSounds.Free;

  // Lib√©rer OpenAL
  alcMakeContextCurrent(nil);
  if FContext <> nil then
    alcDestroyContext(FContext);
  if FDevice <> nil then
    alcCloseDevice(FDevice);

  inherited;
end;

function TOpenALSystem.LoadSound(const Filename: string): TOpenALSound;
begin
  Result := TOpenALSound.Create(Filename);
  FSounds.Add(Result);
end;

procedure TOpenALSystem.UnloadSound(Sound: TOpenALSound);
begin
  if Assigned(Sound) then
  begin
    FSounds.Remove(Sound);
    Sound.Free;
  end;
end;

procedure TOpenALSystem.SetListenerPosition(X, Y, Z: Single);
begin
  alListener3f(AL_POSITION, X, Y, Z);
end;

procedure TOpenALSystem.SetListenerVelocity(VX, VY, VZ: Single);
begin
  alListener3f(AL_VELOCITY, VX, VY, VZ);
end;

procedure TOpenALSystem.SetListenerOrientation(ForwardX, ForwardY, ForwardZ, UpX, UpY, UpZ: Single);
var
  Orientation: array[0..5] of ALfloat;
begin
  Orientation[0] := ForwardX;
  Orientation[1] := ForwardY;
  Orientation[2] := ForwardZ;
  Orientation[3] := UpX;
  Orientation[4] := UpY;
  Orientation[5] := UpZ;

  alListenerfv(AL_ORIENTATION, @Orientation[0]);
end;

procedure TOpenALSystem.StopAllSounds;
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    TOpenALSound(FSounds[i]).Stop;
end;

end.
```

### Utilisation d'OpenAL

```pascal
program OpenALDemo;

{$mode objfpc}{$H+}

uses
  OpenALWrapper, SysUtils;

var
  Audio: TOpenALSystem;
  Music: TOpenALSound;
  Footstep: TOpenALSound;
  Ambient: TOpenALSound;

begin
  WriteLn('D√©mo OpenAL - Audio 3D Multi-plateforme');

  // Cr√©er le syst√®me audio
  Audio := TOpenALSystem.Create;

  try
    // Charger les sons
    Music := Audio.LoadSound('music.wav');
    Footstep := Audio.LoadSound('footstep.wav');
    Ambient := Audio.LoadSound('forest.wav');

    // Configurer le listener (joueur)
    Audio.SetListenerPosition(0, 0, 0);
    Audio.SetListenerOrientation(0, 0, -1, 0, 1, 0); // Regarde vers -Z, haut = +Y

    // Jouer la musique en fond (pas de position 3D)
    Music.SetVolume(0.5);
    Music.Play(True);

    // Son ambiant lointain
    Ambient.SetPosition(10, 0, 5);
    Ambient.SetVolume(0.3);
    Ambient.Play(True);

    // Simulation de mouvement
    WriteLn('Simulation de pas...');
    Footstep.SetPosition(-2, 0, 0);
    Footstep.Play;
    Sleep(500);

    Footstep.SetPosition(-1, 0, 0);
    Footstep.Play;
    Sleep(500);

    Footstep.SetPosition(0, 0, 0);
    Footstep.Play;
    Sleep(500);

    Footstep.SetPosition(1, 0, 0);
    Footstep.Play;
    Sleep(500);

    WriteLn('Termin√© !');
    Sleep(2000);

  finally
    Audio.Free;
  end;
end.
```

## Audio 3D avec OpenAL

### Positionnement spatial

```pascal
procedure Demo3DAudio;
var
  Sound: TOpenALSound;
  Angle: Single;
  X, Z: Single;
  i: Integer;
begin
  Sound := Audio.LoadSound('helicopter.wav');
  Sound.Looping := True;
  Sound.Play;

  // Faire tourner le son autour du listener
  for i := 0 to 360 do
  begin
    Angle := i * Pi / 180;
    X := Cos(Angle) * 5.0; // Rayon de 5 m√®tres
    Z := Sin(Angle) * 5.0;

    Sound.SetPosition(X, 0, Z);

    Sleep(50); // 50ms par frame
  end;
end;
```

### Effet Doppler

```pascal
procedure DemoDoppler;
var
  Sound: TOpenALSound;
  Position, Velocity: Single;
begin
  Sound := Audio.LoadSound('car.wav');
  Sound.Play(True);

  // Voiture qui passe de gauche √† droite
  Position := -20;

  while Position < 20 do
  begin
    Velocity := 10; // 10 m/s

    Sound.SetPosition(Position, 0, 0);
    Sound.SetVelocity(Velocity, 0, 0);

    Position := Position + Velocity * 0.016; // ~60 FPS
    Sleep(16);
  end;
end;
```

### Att√©nuation par distance

```pascal
procedure ConfigureAttenuation(Sound: TOpenALSound);
begin
  // Distance de r√©f√©rence (volume maximum)
  alSourcef(Sound.Source, AL_REFERENCE_DISTANCE, 1.0);

  // Distance maximale
  alSourcef(Sound.Source, AL_MAX_DISTANCE, 50.0);

  // Facteur d'att√©nuation (0 = pas d'att√©nuation, 1 = normal)
  alSourcef(Sound.Source, AL_ROLLOFF_FACTOR, 1.0);
end;
```

## Comparaison des solutions Linux

| Caract√©ristique | ALSA | PulseAudio | OpenAL |
|----------------|------|------------|--------|
| **Complexit√©** | √âlev√©e | Moyenne | Faible |
| **Latence** | Tr√®s faible | Moyenne | Faible |
| **Audio 3D** | Manuel | Non | Natif |
| **Multi-app** | Non | Oui | Oui |
| **Multi-plateforme** | Linux uniquement | Linux uniquement | Oui |
| **Recommand√© pour jeux** | Non | Oui (simple) | Oui (3D) |

## Gestionnaire audio multi-plateforme

Cr√©ons un gestionnaire qui d√©tecte automatiquement le syst√®me et utilise la meilleure API.

```pascal
unit CrossPlatformAudio;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils
  {$IFDEF WINDOWS}, XAudio2Wrapper{$ENDIF}
  {$IFDEF LINUX}, OpenALWrapper{$ENDIF};

type
  TCrossPlatformSound = class
  private
    {$IFDEF WINDOWS}
    FWindowsSound: TXAudio2Sound;
    {$ENDIF}
    {$IFDEF LINUX}
    FLinuxSound: TOpenALSound;
    {$ENDIF}
  public
    procedure Play(Loop: Boolean = False);
    procedure Stop;
    procedure SetVolume(Volume: Single);
    procedure SetPosition(X, Y, Z: Single);
  end;

  TCrossPlatformAudioSystem = class
  private
    {$IFDEF WINDOWS}
    FWindowsAudio: TXAudio2System;
    {$ENDIF}
    {$IFDEF LINUX}
    FLinuxAudio: TOpenALSystem;
    {$ENDIF}
  public
    constructor Create;
    destructor Destroy; override;

    function LoadSound(const Filename: string): TCrossPlatformSound;
    procedure SetListenerPosition(X, Y, Z: Single);
  end;

implementation

{ TCrossPlatformSound }

procedure TCrossPlatformSound.Play(Loop: Boolean);
begin
  {$IFDEF WINDOWS}
  FWindowsSound.Play(Loop);
  {$ENDIF}
  {$IFDEF LINUX}
  FLinuxSound.Play(Loop);
  {$ENDIF}
end;

procedure TCrossPlatformSound.Stop;
begin
  {$IFDEF WINDOWS}
  FWindowsSound.Stop;
  {$ENDIF}
  {$IFDEF LINUX}
  FLinuxSound.Stop;
  {$ENDIF}
end;

procedure TCrossPlatformSound.SetVolume(Volume: Single);
begin
  {$IFDEF WINDOWS}
  FWindowsSound.Volume := Volume;
  {$ENDIF}
  {$IFDEF LINUX}
  FLinuxSound.SetVolume(Volume);
  {$ENDIF}
end;

procedure TCrossPlatformSound.SetPosition(X, Y, Z: Single);
begin
  {$IFDEF WINDOWS}
  // XAudio2 3D (n√©cessite X3DAudio)
  {$ENDIF}
  {$IFDEF LINUX}
  FLinuxSound.SetPosition(X, Y, Z);
  {$ENDIF}
end;

{ TCrossPlatformAudioSystem }

constructor TCrossPlatformAudioSystem.Create;
begin
  inherited Create;

  {$IFDEF WINDOWS}
  WriteLn('Initialisation XAudio2 (Windows)');
  FWindowsAudio := TXAudio2System.Create;
  {$ENDIF}

  {$IFDEF LINUX}
  WriteLn('Initialisation OpenAL (Linux)');
  FLinuxAudio := TOpenALSystem.Create;
  {$ENDIF}
end;

destructor TCrossPlatformAudioSystem.Destroy;
begin
  {$IFDEF WINDOWS}
  FWindowsAudio.Free;
  {$ENDIF}
  {$IFDEF LINUX}
  FLinuxAudio.Free;
  {$ENDIF}

  inherited;
end;

function TCrossPlatformAudioSystem.LoadSound(const Filename: string): TCrossPlatformSound;
begin
  Result := TCrossPlatformSound.Create;

  {$IFDEF WINDOWS}
  Result.FWindowsSound := FWindowsAudio.LoadSound(Filename);
  {$ENDIF}
  {$IFDEF LINUX}
  Result.FLinuxSound := FLinuxAudio.LoadSound(Filename);
  {$ENDIF}
end;

procedure TCrossPlatformAudioSystem.SetListenerPosition(X, Y, Z: Single);
begin
  {$IFDEF WINDOWS}
  // Configuration listener Windows
  {$ENDIF}
  {$IFDEF LINUX}
  FLinuxAudio.SetListenerPosition(X, Y, Z);
  {$ENDIF}
end;

end.
```

## Configuration syst√®me

### V√©rifier la configuration audio Linux

```bash
# Lister les cartes son
aplay -l

# Tester PulseAudio
pactl info

# Volume
pactl set-sink-volume @DEFAULT_SINK@ 50%

# Lister les applications audio actives
pactl list sink-inputs

# Configuration ALSA
cat /proc/asound/cards
```

### Fichier de configuration ALSA

`~/.asoundrc` :
```
pcm.!default {
    type plug
    slave.pcm "dmixer"
}

pcm.dmixer {
    type dmix
    ipc_key 1024
    slave {
        pcm "hw:0,0"
        period_time 0
        period_size 1024
        buffer_size 4096
        rate 44100
    }
    bindings {
        0 0
        1 1
    }
}
```

## D√©bogage audio Linux

### Outils de diagnostic

```bash
# V√©rifier les processus audio
ps aux | grep -E 'pulseaudio|pipewire'

# Logs PulseAudio
journalctl --user -u pulseaudio

# Tester la sortie audio
speaker-test -t wav -c 2

# V√©rifier les permissions
groups $USER | grep audio
```

### Messages d'erreur courants

**"Connection refused"** :
```bash
# Relancer PulseAudio
pulseaudio --kill
pulseaudio --start
```

**"Device or resource busy"** :
```bash
# Un autre programme utilise la carte son
lsof /dev/snd/*
```

**"No such device"** :
```bash
# V√©rifier les pilotes
lsmod | grep snd
```

## Bonnes pratiques Linux

### 1. Toujours pr√©f√©rer OpenAL pour les jeux

OpenAL est multi-plateforme et offre toutes les fonctionnalit√©s n√©cessaires.

### 2. Tester sur diff√©rentes distributions

- Ubuntu (PulseAudio)
- Fedora (PipeWire)
- Arch Linux (configuration variable)

### 3. Gestion des d√©pendances

Dans votre `README.md` :
````markdown
## D√©pendances audio Linux

```bash
# Ubuntu/Debian
sudo apt-get install libopenal1

# Fedora
sudo dnf install openal-soft

# Arch
sudo pacman -S openal
```
````

### 4. D√©tecter les capacit√©s audio

```pascal
function CheckAudioAvailable: Boolean;
var
  Device: Pointer;
begin
  Device := alcOpenDevice(nil);
  Result := Device <> nil;
  if Result then
    alcCloseDevice(Device);
end;
```

### 5. Mode sans audio

```pascal
if not CheckAudioAvailable then
begin
  WriteLn('ATTENTION: Aucun p√©riph√©rique audio d√©tect√©');
  WriteLn('Le jeu fonctionnera sans son');
  // Continuer en mode silencieux
end;
```

## Conclusion

L'audio sur Linux offre plusieurs options, chacune avec ses avantages. Pour la plupart des jeux FreePascal/Lazarus, **OpenAL** est le meilleur choix car il est :
- Multi-plateforme (m√™me code sur Windows/Linux/macOS)
- Simple √† utiliser
- Performant
- Supporte l'audio 3D nativement

### Points cl√©s √† retenir

‚úÖ **OpenAL** : Recommand√© pour les jeux (multi-plateforme)  
‚úÖ **PulseAudio** : Simple pour audio 2D basique  
‚úÖ **ALSA** : Uniquement si latence ultra-faible n√©cessaire  
‚úÖ **PipeWire** : Futur de l'audio Linux (compatible PulseAudio)  
‚úÖ **Tests** : Toujours tester sur plusieurs distributions  
‚úÖ **Fallback** : Pr√©voir un mode sans audio

Avec OpenAL et FreePascal, vous pouvez cr√©er des jeux avec un excellent audio 3D qui fonctionnent identiquement sur Windows et Linux

‚è≠Ô∏è [OpenAL (universel)](/23-developpement-jeux/04.3-openal-universel.md)
