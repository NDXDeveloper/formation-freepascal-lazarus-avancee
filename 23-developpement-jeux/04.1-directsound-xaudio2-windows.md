üîù Retour au [Sommaire](/SOMMAIRE.md)

# 23.4.1 DirectSound/XAudio2 (Windows)

## Introduction

L'audio est un √©l√©ment crucial pour l'immersion dans les jeux. Sur Windows, Microsoft fournit deux API principales pour g√©rer le son : **DirectSound** (ancienne g√©n√©ration) et **XAudio2** (moderne). Ces technologies font partie de DirectX et offrent des fonctionnalit√©s avanc√©es pour jouer des sons, g√©rer le volume, appliquer des effets et cr√©er du son spatial 3D.

### Qu'est-ce que DirectSound ?

**DirectSound** est l'API audio historique de DirectX, introduite en 1995. Bien qu'elle soit consid√©r√©e comme obsol√®te depuis Windows Vista, elle reste largement support√©e et simple √† utiliser pour des besoins audio basiques.

**Avantages** :
- Simple et bien document√©e
- Largement compatible (Windows XP √† Windows 11)
- Suffisante pour la plupart des jeux 2D
- Bonne pour l'apprentissage

**Inconv√©nients** :
- Performance limit√©e
- Pas de support mat√©riel moderne
- API vieillissante
- Latence plus √©lev√©e que XAudio2

### Qu'est-ce que XAudio2 ?

**XAudio2** est l'API audio moderne de Microsoft, introduite avec DirectX 10. Elle remplace DirectSound et offre de meilleures performances, une latence plus faible et plus de flexibilit√©.

**Avantages** :
- Haute performance et faible latence
- Support du multi-threading
- Effets audio avanc√©s
- API moderne et bien maintenue
- Meilleure gestion des ressources

**Inconv√©nients** :
- Plus complexe que DirectSound
- N√©cessite Windows 7 minimum (Windows 10 pour les derni√®res versions)
- Documentation parfois technique

### Quand utiliser quoi ?

**Utilisez DirectSound si** :
- Vous d√©butez dans la programmation audio
- Vous cr√©ez un jeu 2D simple
- Vous devez supporter Windows XP
- Vous avez besoin d'une solution simple et rapide

**Utilisez XAudio2 si** :
- Vous cr√©ez un jeu 3D
- Vous avez besoin de basse latence
- Vous voulez appliquer des effets complexes
- Vous ciblez Windows moderne (7+)
- Vous avez besoin de performances maximales

## DirectSound

### Installation et pr√©requis

DirectSound est inclus dans Windows, aucune installation suppl√©mentaire n'est n√©cessaire. Les fichiers n√©cessaires :
- `dsound.dll` - Biblioth√®que DirectSound (pr√©sente sur tous les Windows)

### Cr√©er les bindings Pascal

DirectSound est une API COM (Component Object Model). Nous devons cr√©er des bindings Pascal pour l'utiliser.

```pascal
unit DirectSound;

{$mode objfpc}{$H+}

interface

uses
  Windows, ActiveX;

const
  // Constantes DirectSound
  DSSCL_NORMAL = $00000001;
  DSSCL_PRIORITY = $00000002;
  DSSCL_EXCLUSIVE = $00000003;
  DSSCL_WRITEPRIMARY = $00000004;

  DSBCAPS_PRIMARYBUFFER = $00000001;
  DSBCAPS_STATIC = $00000002;
  DSBCAPS_LOCHARDWARE = $00000004;
  DSBCAPS_LOCSOFTWARE = $00000008;
  DSBCAPS_CTRL3D = $00000010;
  DSBCAPS_CTRLFREQUENCY = $00000020;
  DSBCAPS_CTRLPAN = $00000040;
  DSBCAPS_CTRLVOLUME = $00000080;
  DSBCAPS_CTRLPOSITIONNOTIFY = $00000100;
  DSBCAPS_CTRLFX = $00000200;
  DSBCAPS_STICKYFOCUS = $00004000;
  DSBCAPS_GLOBALFOCUS = $00008000;
  DSBCAPS_GETCURRENTPOSITION2 = $00010000;
  DSBCAPS_MUTE3DATMAXDISTANCE = $00020000;
  DSBCAPS_LOCDEFER = $00040000;

  DSBPLAY_LOOPING = $00000001;
  DSBPLAY_LOCHARDWARE = $00000002;
  DSBPLAY_LOCSOFTWARE = $00000004;
  DSBPLAY_TERMINATEBY_TIME = $00000008;
  DSBPLAY_TERMINATEBY_DISTANCE = $00000010;
  DSBPLAY_TERMINATEBY_PRIORITY = $00000020;

  // Volume (√©chelle logarithmique en centi√®mes de d√©cibels)
  DSBVOLUME_MIN = -10000;
  DSBVOLUME_MAX = 0;

  // Pan (balance gauche/droite)
  DSBPAN_LEFT = -10000;
  DSBPAN_RIGHT = 10000;

type
  // GUID pour DirectSound
  TGUID_DirectSound = TGUID;

const
  CLSID_DirectSound: TGUID = '{47D4D946-62E8-11CF-93BC-444553540000}';
  IID_IDirectSound: TGUID = '{279AFA83-4981-11CE-A521-0020AF0BE560}';
  IID_IDirectSoundBuffer: TGUID = '{279AFA85-4981-11CE-A521-0020AF0BE560}';

type
  // Structure de format audio WAV
  TWaveFormatEx = packed record
    wFormatTag: Word;           // Type de format (1 = PCM)
    nChannels: Word;            // Nombre de canaux (1 = mono, 2 = st√©r√©o)
    nSamplesPerSec: DWORD;      // Fr√©quence d'√©chantillonnage (ex: 44100 Hz)
    nAvgBytesPerSec: DWORD;     // D√©bit moyen
    nBlockAlign: Word;          // Alignement des blocs
    wBitsPerSample: Word;       // Bits par √©chantillon (8, 16, etc.)
    cbSize: Word;               // Taille des donn√©es suppl√©mentaires
  end;
  PWaveFormatEx = ^TWaveFormatEx;

  // Description d'un buffer DirectSound
  TDSBufferDesc = packed record
    dwSize: DWORD;              // Taille de la structure
    dwFlags: DWORD;             // Flags de capacit√©s
    dwBufferBytes: DWORD;       // Taille du buffer en octets
    dwReserved: DWORD;          // R√©serv√©
    lpwfxFormat: PWaveFormatEx; // Format audio
    guid3DAlgorithm: TGUID;     // Algorithme 3D (optionnel)
  end;
  PDSBufferDesc = ^TDSBufferDesc;

  // Interface DirectSound
  IDirectSound = interface(IUnknown)
    ['{279AFA83-4981-11CE-A521-0020AF0BE560}']
    function CreateSoundBuffer(const dsbd: TDSBufferDesc; out dsbuffer: IDirectSoundBuffer; unkOuter: IUnknown): HResult; stdcall;
    function GetCaps(var dscaps: TDSCaps): HResult; stdcall;
    function DuplicateSoundBuffer(dsbufferOriginal: IDirectSoundBuffer; out dsbufferDuplicate: IDirectSoundBuffer): HResult; stdcall;
    function SetCooperativeLevel(hwnd: HWND; dwLevel: DWORD): HResult; stdcall;
    function Compact: HResult; stdcall;
    function GetSpeakerConfig(var dwSpeakerConfig: DWORD): HResult; stdcall;
    function SetSpeakerConfig(dwSpeakerConfig: DWORD): HResult; stdcall;
    function Initialize(const guid: TGUID): HResult; stdcall;
  end;

  // Interface d'un buffer son
  IDirectSoundBuffer = interface(IUnknown)
    ['{279AFA85-4981-11CE-A521-0020AF0BE560}']
    function GetCaps(var dsbcaps: TDSBCaps): HResult; stdcall;
    function GetCurrentPosition(var dwCurrentPlayCursor, dwCurrentWriteCursor: DWORD): HResult; stdcall;
    function GetFormat(var wfxFormat: TWaveFormatEx; dwSizeAllocated: DWORD; var dwSizeWritten: DWORD): HResult; stdcall;
    function GetVolume(var lVolume: Integer): HResult; stdcall;
    function GetPan(var lPan: Integer): HResult; stdcall;
    function GetFrequency(var dwFrequency: DWORD): HResult; stdcall;
    function GetStatus(var dwStatus: DWORD): HResult; stdcall;
    function Initialize(ds: IDirectSound; const dsbd: TDSBufferDesc): HResult; stdcall;
    function Lock(dwOffset, dwBytes: DWORD; var ppvAudioPtr1: Pointer; var dwAudioBytes1: DWORD; var ppvAudioPtr2: Pointer; var dwAudioBytes2: DWORD; dwFlags: DWORD): HResult; stdcall;
    function Play(dwReserved1, dwPriority, dwFlags: DWORD): HResult; stdcall;
    function SetCurrentPosition(dwNewPosition: DWORD): HResult; stdcall;
    function SetFormat(const wfxFormat: TWaveFormatEx): HResult; stdcall;
    function SetVolume(lVolume: Integer): HResult; stdcall;
    function SetPan(lPan: Integer): HResult; stdcall;
    function SetFrequency(dwFrequency: DWORD): HResult; stdcall;
    function Stop: HResult; stdcall;
    function Unlock(pvAudioPtr1: Pointer; dwAudioBytes1: DWORD; pvAudioPtr2: Pointer; dwAudioBytes2: DWORD): HResult; stdcall;
    function Restore: HResult; stdcall;
  end;

  TDSCaps = packed record
    dwSize: DWORD;
    dwFlags: DWORD;
    dwMinSecondarySampleRate: DWORD;
    dwMaxSecondarySampleRate: DWORD;
    dwPrimaryBuffers: DWORD;
    dwMaxHwMixingAllBuffers: DWORD;
    dwMaxHwMixingStaticBuffers: DWORD;
    dwMaxHwMixingStreamingBuffers: DWORD;
    dwFreeHwMixingAllBuffers: DWORD;
    dwFreeHwMixingStaticBuffers: DWORD;
    dwFreeHwMixingStreamingBuffers: DWORD;
    dwMaxHw3DAllBuffers: DWORD;
    dwMaxHw3DStaticBuffers: DWORD;
    dwMaxHw3DStreamingBuffers: DWORD;
    dwFreeHw3D3AllBuffers: DWORD;
    dwFreeHw3DStaticBuffers: DWORD;
    dwFreeHw3DStreamingBuffers: DWORD;
    dwTotalHwMemBytes: DWORD;
    dwFreeHwMemBytes: DWORD;
    dwMaxContigFreeHwMemBytes: DWORD;
    dwUnlockTransferRateHwBuffers: DWORD;
    dwPlayCpuOverheadSwBuffers: DWORD;
    dwReserved1: DWORD;
    dwReserved2: DWORD;
  end;

  TDSBCaps = packed record
    dwSize: DWORD;
    dwFlags: DWORD;
    dwBufferBytes: DWORD;
    dwUnlockTransferRate: DWORD;
    dwPlayCpuOverhead: DWORD;
  end;

// Fonction pour cr√©er un objet DirectSound
function DirectSoundCreate(lpGuid: PGUID; out ds: IDirectSound; unkOuter: IUnknown): HResult; stdcall; external 'dsound.dll';

implementation

end.
```

### Wrapper de haut niveau

Cr√©ons une classe Pascal plus facile √† utiliser :

```pascal
unit DirectSoundWrapper;

{$mode objfpc}{$H+}

interface

uses
  Windows, DirectSound, Classes, SysUtils;

type
  TSoundBuffer = class
  private
    FBuffer: IDirectSoundBuffer;
    FVolume: Integer;
    FPan: Integer;
    FFrequency: DWORD;
    FLooping: Boolean;
  public
    constructor Create(DS: IDirectSound; const Filename: string);
    destructor Destroy; override;

    procedure Play(Loop: Boolean = False);
    procedure Stop;
    procedure Pause;
    procedure Resume;

    function IsPlaying: Boolean;

    property Volume: Integer read FVolume write SetVolume;
    property Pan: Integer read FPan write SetPan;
    property Frequency: DWORD read FFrequency write SetFrequency;
  end;

  TDirectSoundSystem = class
  private
    FDirectSound: IDirectSound;
    FSounds: TList;
  public
    constructor Create(WindowHandle: HWND);
    destructor Destroy; override;

    function LoadSound(const Filename: string): TSoundBuffer;
    procedure UnloadSound(Sound: TSoundBuffer);

    procedure SetMasterVolume(Volume: Single); // 0.0 √† 1.0
    procedure StopAllSounds;
  end;

implementation

{ TSoundBuffer }

constructor TSoundBuffer.Create(DS: IDirectSound; const Filename: string);  
var
  WaveFile: TFileStream;
  BufferDesc: TDSBufferDesc;
  WaveFormat: TWaveFormatEx;
  AudioData: Pointer;
  AudioSize: DWORD;
  Ptr1, Ptr2: Pointer;
  Bytes1, Bytes2: DWORD;
  Header: array[0..43] of Byte;
begin
  inherited Create;

  // Charger le fichier WAV
  WaveFile := TFileStream.Create(Filename, fmOpenRead);
  try
    // Lire l'en-t√™te WAV (44 octets)
    WaveFile.Read(Header, 44);

    // V√©rifier le format (doit √™tre "RIFF" et "WAVE")
    if (Chr(Header[0]) + Chr(Header[1]) + Chr(Header[2]) + Chr(Header[3]) <> 'RIFF') or
       (Chr(Header[8]) + Chr(Header[9]) + Chr(Header[10]) + Chr(Header[11]) <> 'WAVE') then
      raise Exception.Create('Format de fichier WAV invalide');

    // Extraire les informations du format
    FillChar(WaveFormat, SizeOf(WaveFormat), 0);
    WaveFormat.wFormatTag := 1; // PCM
    WaveFormat.nChannels := PWord(@Header[22])^;
    WaveFormat.nSamplesPerSec := PDWORD(@Header[24])^;
    WaveFormat.nAvgBytesPerSec := PDWORD(@Header[28])^;
    WaveFormat.nBlockAlign := PWord(@Header[32])^;
    WaveFormat.wBitsPerSample := PWord(@Header[34])^;
    WaveFormat.cbSize := 0;

    // Taille des donn√©es audio
    AudioSize := PDWORD(@Header[40])^;

    // Cr√©er le buffer DirectSound
    FillChar(BufferDesc, SizeOf(BufferDesc), 0);
    BufferDesc.dwSize := SizeOf(TDSBufferDesc);
    BufferDesc.dwFlags := DSBCAPS_CTRLVOLUME or DSBCAPS_CTRLPAN or DSBCAPS_CTRLFREQUENCY or DSBCAPS_STATIC;
    BufferDesc.dwBufferBytes := AudioSize;
    BufferDesc.lpwfxFormat := @WaveFormat;

    if Failed(DS.CreateSoundBuffer(BufferDesc, FBuffer, nil)) then
      raise Exception.Create('Impossible de cr√©er le buffer DirectSound');

    // Verrouiller le buffer pour y √©crire les donn√©es
    if Failed(FBuffer.Lock(0, AudioSize, Ptr1, Bytes1, Ptr2, Bytes2, 0)) then
      raise Exception.Create('Impossible de verrouiller le buffer');

    try
      // Lire les donn√©es audio
      WaveFile.Read(Ptr1^, Bytes1);
      if Bytes2 > 0 then
        WaveFile.Read(Ptr2^, Bytes2);
    finally
      FBuffer.Unlock(Ptr1, Bytes1, Ptr2, Bytes2);
    end;

    // Valeurs par d√©faut
    FVolume := DSBVOLUME_MAX; // Volume maximum
    FPan := 0; // Centr√©
    FBuffer.GetFrequency(FFrequency); // Fr√©quence originale

  finally
    WaveFile.Free;
  end;
end;

destructor TSoundBuffer.Destroy;  
begin
  if Assigned(FBuffer) then
  begin
    FBuffer.Stop;
    FBuffer := nil;
  end;
  inherited;
end;

procedure TSoundBuffer.Play(Loop: Boolean = False);  
var
  Flags: DWORD;
begin
  if not Assigned(FBuffer) then Exit;

  FLooping := Loop;
  Flags := 0;
  if Loop then
    Flags := DSBPLAY_LOOPING;

  FBuffer.SetCurrentPosition(0);
  FBuffer.Play(0, 0, Flags);
end;

procedure TSoundBuffer.Stop;  
begin
  if Assigned(FBuffer) then
  begin
    FBuffer.Stop;
    FBuffer.SetCurrentPosition(0);
  end;
end;

procedure TSoundBuffer.Pause;  
begin
  if Assigned(FBuffer) then
    FBuffer.Stop;
end;

procedure TSoundBuffer.Resume;  
var
  Flags: DWORD;
begin
  if not Assigned(FBuffer) then Exit;

  Flags := 0;
  if FLooping then
    Flags := DSBPLAY_LOOPING;

  FBuffer.Play(0, 0, Flags);
end;

function TSoundBuffer.IsPlaying: Boolean;  
var
  Status: DWORD;
begin
  Result := False;
  if Assigned(FBuffer) then
  begin
    if Succeeded(FBuffer.GetStatus(Status)) then
      Result := (Status and DSBSTATUS_PLAYING) <> 0;
  end;
end;

procedure TSoundBuffer.SetVolume(Value: Integer);  
begin
  FVolume := Value;
  if FVolume < DSBVOLUME_MIN then FVolume := DSBVOLUME_MIN;
  if FVolume > DSBVOLUME_MAX then FVolume := DSBVOLUME_MAX;

  if Assigned(FBuffer) then
    FBuffer.SetVolume(FVolume);
end;

procedure TSoundBuffer.SetPan(Value: Integer);  
begin
  FPan := Value;
  if FPan < DSBPAN_LEFT then FPan := DSBPAN_LEFT;
  if FPan > DSBPAN_RIGHT then FPan := DSBPAN_RIGHT;

  if Assigned(FBuffer) then
    FBuffer.SetPan(FPan);
end;

procedure TSoundBuffer.SetFrequency(Value: DWORD);  
begin
  FFrequency := Value;
  if Assigned(FBuffer) then
    FBuffer.SetFrequency(FFrequency);
end;

{ TDirectSoundSystem }

constructor TDirectSoundSystem.Create(WindowHandle: HWND);  
begin
  inherited Create;

  FSounds := TList.Create;

  // Cr√©er l'objet DirectSound
  if Failed(DirectSoundCreate(nil, FDirectSound, nil)) then
    raise Exception.Create('Impossible de cr√©er DirectSound');

  // D√©finir le niveau de coop√©ration
  if Failed(FDirectSound.SetCooperativeLevel(WindowHandle, DSSCL_PRIORITY)) then
    raise Exception.Create('Impossible de d√©finir le niveau de coop√©ration');
end;

destructor TDirectSoundSystem.Destroy;  
var
  i: Integer;
begin
  // Lib√©rer tous les sons
  for i := FSounds.Count - 1 downto 0 do
    TSoundBuffer(FSounds[i]).Free;

  FSounds.Free;
  FDirectSound := nil;

  inherited;
end;

function TDirectSoundSystem.LoadSound(const Filename: string): TSoundBuffer;  
begin
  Result := TSoundBuffer.Create(FDirectSound, Filename);
  FSounds.Add(Result);
end;

procedure TDirectSoundSystem.UnloadSound(Sound: TSoundBuffer);  
begin
  if Assigned(Sound) then
  begin
    FSounds.Remove(Sound);
    Sound.Free;
  end;
end;

procedure TDirectSoundSystem.SetMasterVolume(Volume: Single);  
var
  i: Integer;
  VolumeDB: Integer;
begin
  // Convertir 0.0-1.0 en d√©cibels (-10000 √† 0)
  if Volume <= 0 then
    VolumeDB := DSBVOLUME_MIN
  else if Volume >= 1.0 then
    VolumeDB := DSBVOLUME_MAX
  else
    VolumeDB := Round(2000 * Log10(Volume));

  // Appliquer √† tous les sons
  for i := 0 to FSounds.Count - 1 do
    TSoundBuffer(FSounds[i]).Volume := VolumeDB;
end;

procedure TDirectSoundSystem.StopAllSounds;  
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    TSoundBuffer(FSounds[i]).Stop;
end;

end.
```

### Utilisation basique

```pascal
program DirectSoundDemo;

uses
  DirectSoundWrapper, Windows;

var
  SoundSystem: TDirectSoundSystem;
  BackgroundMusic: TSoundBuffer;
  JumpSound: TSoundBuffer;
  CoinSound: TSoundBuffer;

begin
  // Cr√©er le syst√®me audio
  SoundSystem := TDirectSoundSystem.Create(GetForegroundWindow);

  try
    // Charger les sons
    BackgroundMusic := SoundSystem.LoadSound('music/background.wav');
    JumpSound := SoundSystem.LoadSound('sfx/jump.wav');
    CoinSound := SoundSystem.LoadSound('sfx/coin.wav');

    // Jouer la musique en boucle
    BackgroundMusic.Volume := -1000; // Un peu plus bas
    BackgroundMusic.Play(True); // Loop = True

    WriteLn('Musique en cours de lecture...');
    WriteLn('Appuyez sur J pour sauter, C pour pi√®ce, Q pour quitter');

    // Boucle principale
    while True do
    begin
      if KeyPressed then
      begin
        case ReadKey of
          'j', 'J': JumpSound.Play;
          'c', 'C': CoinSound.Play;
          'q', 'Q': Break;
        end;
      end;

      Sleep(10);
    end;

  finally
    SoundSystem.Free;
  end;
end.
```

### Contr√¥le du volume et du pan

```pascal
procedure DemoVolumeAndPan;  
var
  Sound: TSoundBuffer;
  Volume: Single;
  Pan: Integer;
begin
  Sound := SoundSystem.LoadSound('test.wav');

  // Volume : de 0.0 (silence) √† 1.0 (maximum)
  Volume := 0.5; // 50%
  Sound.Volume := Round(2000 * Log10(Volume));

  // Pan : de -10000 (gauche) √† 10000 (droite), 0 = centr√©
  Pan := -5000; // L√©g√®rement √† gauche
  Sound.Pan := Pan;

  Sound.Play;
end;
```

### Changer la fr√©quence (pitch)

```pascal
procedure DemoPitch;  
var
  Sound: TSoundBuffer;
  OriginalFreq: DWORD;
begin
  Sound := SoundSystem.LoadSound('voice.wav');

  // Obtenir la fr√©quence originale
  OriginalFreq := Sound.Frequency;

  // Jouer √† la fr√©quence normale
  Sound.Play;
  Sleep(2000);

  // Jouer plus aigu (2x plus rapide)
  Sound.Frequency := OriginalFreq * 2;
  Sound.Play;
  Sleep(2000);

  // Jouer plus grave (0.5x plus lent)
  Sound.Frequency := OriginalFreq div 2;
  Sound.Play;
end;
```

## Gestion avanc√©e

### Syst√®me de cat√©gories audio

```pascal
type
  TAudioCategory = (acMusic, acSFX, acVoice, acAmbient);

  TCategorizedSound = class(TSoundBuffer)
  private
    FCategory: TAudioCategory;
    FBaseVolume: Integer;
  public
    property Category: TAudioCategory read FCategory write FCategory;
    property BaseVolume: Integer read FBaseVolume write FBaseVolume;
  end;

  TAudioManager = class
  private
    FSoundSystem: TDirectSoundSystem;
    FSounds: TList;
    FCategoryVolumes: array[TAudioCategory] of Single;
  public
    constructor Create(WindowHandle: HWND);

    function LoadSound(const Filename: string; Category: TAudioCategory): TCategorizedSound;

    procedure SetCategoryVolume(Category: TAudioCategory; Volume: Single);
    procedure UpdateVolumes;
  end;

procedure TAudioManager.SetCategoryVolume(Category: TAudioCategory; Volume: Single);  
var
  i: Integer;
  Sound: TCategorizedSound;
begin
  FCategoryVolumes[Category] := Volume;

  // Mettre √† jour tous les sons de cette cat√©gorie
  for i := 0 to FSounds.Count - 1 do
  begin
    Sound := TCategorizedSound(FSounds[i]);
    if Sound.Category = Category then
    begin
      Sound.Volume := Round(Sound.BaseVolume * Volume);
    end;
  end;
end;
```

### Pool de sons pour effets fr√©quents

```pascal
type
  TSoundPool = class
  private
    FInstances: array of TSoundBuffer;
    FCurrentIndex: Integer;
  public
    constructor Create(DS: IDirectSound; const Filename: string; PoolSize: Integer);

    procedure PlayNext;
  end;

constructor TSoundPool.Create(DS: IDirectSound; const Filename: string; PoolSize: Integer);  
var
  i: Integer;
begin
  SetLength(FInstances, PoolSize);

  for i := 0 to PoolSize - 1 do
    FInstances[i] := TSoundBuffer.Create(DS, Filename);

  FCurrentIndex := 0;
end;

procedure TSoundPool.PlayNext;  
begin
  FInstances[FCurrentIndex].Play;

  FCurrentIndex := (FCurrentIndex + 1) mod Length(FInstances);
end;

// Utilisation
var
  GunfirePool: TSoundPool;

begin
  // Cr√©er un pool de 10 instances du son de tir
  GunfirePool := TSoundPool.Create(SoundSystem.DirectSound, 'gunfire.wav', 10);

  // Tirer rapidement sans coupure
  for i := 1 to 20 do
  begin
    GunfirePool.PlayNext;
    Sleep(50);
  end;
end;
```

### Fondu encha√Æn√© (crossfade)

```pascal
procedure CrossfadeMusic(OldMusic, NewMusic: TSoundBuffer; Duration: Single);  
var
  Steps: Integer;
  i: Integer;
  OldVol, NewVol: Single;
begin
  Steps := Round(Duration * 60); // Assuming 60 FPS

  NewMusic.Volume := DSBVOLUME_MIN;
  NewMusic.Play(True);

  for i := 0 to Steps do
  begin
    // Volume de l'ancienne musique diminue
    OldVol := 1.0 - (i / Steps);
    OldMusic.Volume := Round(2000 * Log10(OldVol + 0.0001));

    // Volume de la nouvelle musique augmente
    NewVol := i / Steps;
    NewMusic.Volume := Round(2000 * Log10(NewVol + 0.0001));

    Sleep(Round((Duration * 1000) / Steps));
  end;

  OldMusic.Stop;
end;
```

---
---

## XAudio2

### Introduction √† XAudio2

**XAudio2** est l'API audio moderne de Microsoft, offrant des performances sup√©rieures et une latence minimale. Elle est particuli√®rement adapt√©e aux jeux modernes n√©cessitant un grand nombre de sons simultan√©s et des effets audio avanc√©s.

### Versions de XAudio2

- **XAudio 2.7** : Incluse dans le DirectX SDK (Windows Vista/7)
- **XAudio 2.8** : Incluse dans Windows 8/8.1
- **XAudio 2.9** : Incluse dans Windows 10/11

Pour une compatibilit√© maximale, nous utiliserons XAudio2.9, qui est disponible sur tous les syst√®mes Windows modernes.

### Installation et pr√©requis

XAudio2.9 est int√©gr√© √† Windows 10/11, aucune installation suppl√©mentaire n'est n√©cessaire. Les fichiers n√©cessaires :
- `xaudio2_9.dll` - Biblioth√®que XAudio2 (pr√©sente sur Windows 10+)

### Cr√©er les bindings Pascal pour XAudio2

```pascal
unit XAudio2;

{$mode objfpc}{$H+}

interface

uses
  Windows, ActiveX;

const
  // GUID XAudio2
  CLSID_XAudio2: TGUID = '{5a508685-a254-4fba-9b82-9a24b00306af}';
  IID_IXAudio2: TGUID = '{2b02e3cf-2e0b-4ec3-be45-1b2a3fe7210d}';

  // Flags
  XAUDIO2_DEBUG_ENGINE = $0001;
  XAUDIO2_VOICE_NOSRC = $0004;
  XAUDIO2_VOICE_USEFILTER = $0008;

  // Constantes de volume
  XAUDIO2_MAX_BUFFER_BYTES = $80000000;
  XAUDIO2_MAX_QUEUED_BUFFERS = 64;
  XAUDIO2_MAX_AUDIO_CHANNELS = 64;
  XAUDIO2_MIN_SAMPLE_RATE = 1000;
  XAUDIO2_MAX_SAMPLE_RATE = 200000;

  // Callbacks
  XAUDIO2_END_OF_STREAM = $0040;

type
  // Format audio
  TWAVEFORMATEX = packed record
    wFormatTag: Word;
    nChannels: Word;
    nSamplesPerSec: DWORD;
    nAvgBytesPerSec: DWORD;
    nBlockAlign: Word;
    wBitsPerSample: Word;
    cbSize: Word;
  end;
  PWAVEFORMATEX = ^TWAVEFORMATEX;

  // Buffer audio
  TXAUDIO2_BUFFER = packed record
    Flags: DWORD;
    AudioBytes: DWORD;
    pAudioData: PByte;
    PlayBegin: DWORD;
    PlayLength: DWORD;
    LoopBegin: DWORD;
    LoopLength: DWORD;
    LoopCount: DWORD;
    pContext: Pointer;
  end;
  PXAUDIO2_BUFFER = ^TXAUDIO2_BUFFER;

  // √âtat de la voice
  TXAUDIO2_VOICE_STATE = packed record
    pCurrentBufferContext: Pointer;
    BuffersQueued: DWORD;
    SamplesPlayed: UINT64;
  end;

  // Param√®tres de filtre
  TXAUDIO2_FILTER_PARAMETERS = packed record
    FilterType: DWORD;
    Frequency: Single;
    OneOverQ: Single;
  end;

  // Param√®tres de volume
  TXAUDIO2_VOLUME_METER = packed record
    pPeakLevels: PSingle;
    pRMSLevels: PSingle;
    ChannelCount: DWORD;
  end;

  // Callback pour les √©v√©nements
  IXAudio2VoiceCallback = interface
    ['{8bcf1f58-9fe7-4583-8ac6-e2adc465c8bb}']
    procedure OnVoiceProcessingPassStart(BytesRequired: DWORD); stdcall;
    procedure OnVoiceProcessingPassEnd; stdcall;
    procedure OnStreamEnd; stdcall;
    procedure OnBufferStart(pBufferContext: Pointer); stdcall;
    procedure OnBufferEnd(pBufferContext: Pointer); stdcall;
    procedure OnLoopEnd(pBufferContext: Pointer); stdcall;
    procedure OnVoiceError(pBufferContext: Pointer; Error: HResult); stdcall;
  end;

  // Interface Voice (base pour toutes les voices)
  IXAudio2Voice = interface(IUnknown)
    ['{UNKNOWN}']
    procedure GetVoiceDetails(out pVoiceDetails: Pointer); stdcall;
    function SetOutputVoices(pSendList: Pointer): HResult; stdcall;
    function SetEffectChain(pEffectChain: Pointer): HResult; stdcall;
    function EnableEffect(EffectIndex: DWORD; OperationSet: DWORD = 0): HResult; stdcall;
    function DisableEffect(EffectIndex: DWORD; OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetEffectState(EffectIndex: DWORD; out pEnabled: BOOL); stdcall;
    function SetEffectParameters(EffectIndex: DWORD; pParameters: Pointer; ParametersByteSize: DWORD; OperationSet: DWORD = 0): HResult; stdcall;
    function GetEffectParameters(EffectIndex: DWORD; pParameters: Pointer; ParametersByteSize: DWORD): HResult; stdcall;
    function SetFilterParameters(const pParameters: TXAUDIO2_FILTER_PARAMETERS; OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetFilterParameters(out pParameters: TXAUDIO2_FILTER_PARAMETERS); stdcall;
    function SetOutputFilterParameters(pDestinationVoice: IXAudio2Voice; const pParameters: TXAUDIO2_FILTER_PARAMETERS; OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetOutputFilterParameters(pDestinationVoice: IXAudio2Voice; out pParameters: TXAUDIO2_FILTER_PARAMETERS); stdcall;
    function SetVolume(Volume: Single; OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetVolume(out pVolume: Single); stdcall;
    function SetChannelVolumes(Channels: DWORD; pVolumes: PSingle; OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetChannelVolumes(Channels: DWORD; pVolumes: PSingle); stdcall;
    function SetOutputMatrix(pDestinationVoice: IXAudio2Voice; SourceChannels: DWORD; DestinationChannels: DWORD; pLevelMatrix: PSingle; OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetOutputMatrix(pDestinationVoice: IXAudio2Voice; SourceChannels: DWORD; DestinationChannels: DWORD; pLevelMatrix: PSingle); stdcall;
    procedure DestroyVoice; stdcall;
  end;

  // Interface Source Voice (pour jouer des sons)
  IXAudio2SourceVoice = interface(IXAudio2Voice)
    ['{UNKNOWN}']
    function Start(Flags: DWORD = 0; OperationSet: DWORD = 0): HResult; stdcall;
    function Stop(Flags: DWORD = 0; OperationSet: DWORD = 0): HResult; stdcall;
    function SubmitSourceBuffer(const pBuffer: TXAUDIO2_BUFFER; pBufferWMA: Pointer = nil): HResult; stdcall;
    function FlushSourceBuffers: HResult; stdcall;
    function Discontinuity: HResult; stdcall;
    function ExitLoop(OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetState(out pVoiceState: TXAUDIO2_VOICE_STATE; Flags: DWORD = 0); stdcall;
    function SetFrequencyRatio(Ratio: Single; OperationSet: DWORD = 0): HResult; stdcall;
    procedure GetFrequencyRatio(out pRatio: Single); stdcall;
    function SetSourceSampleRate(NewSourceSampleRate: DWORD): HResult; stdcall;
  end;

  // Interface Mastering Voice (sortie audio finale)
  IXAudio2MasteringVoice = interface(IXAudio2Voice)
    ['{UNKNOWN}']
    function GetChannelMask(out pChannelMask: DWORD): HResult; stdcall;
  end;

  // Interface principale XAudio2
  IXAudio2 = interface(IUnknown)
    ['{2b02e3cf-2e0b-4ec3-be45-1b2a3fe7210d}']
    function RegisterForCallbacks(pCallback: Pointer): HResult; stdcall;
    procedure UnregisterForCallbacks(pCallback: Pointer); stdcall;
    function CreateSourceVoice(out ppSourceVoice: IXAudio2SourceVoice; const pSourceFormat: TWAVEFORMATEX; Flags: DWORD = 0; MaxFrequencyRatio: Single = 2.0; pCallback: IXAudio2VoiceCallback = nil; pSendList: Pointer = nil; pEffectChain: Pointer = nil): HResult; stdcall;
    function CreateSubmixVoice(out ppSubmixVoice: Pointer; InputChannels: DWORD; InputSampleRate: DWORD; Flags: DWORD = 0; ProcessingStage: DWORD = 0; pSendList: Pointer = nil; pEffectChain: Pointer = nil): HResult; stdcall;
    function CreateMasteringVoice(out ppMasteringVoice: IXAudio2MasteringVoice; InputChannels: DWORD = 2; InputSampleRate: DWORD = 44100; Flags: DWORD = 0; szDeviceId: PWideChar = nil; pEffectChain: Pointer = nil; StreamCategory: DWORD = 0): HResult; stdcall;
    function StartEngine: HResult; stdcall;
    procedure StopEngine; stdcall;
    function CommitChanges(OperationSet: DWORD): HResult; stdcall;
    procedure GetPerformanceData(out pPerfData: Pointer); stdcall;
    procedure SetDebugConfiguration(pDebugConfiguration: Pointer; pReserved: Pointer = nil); stdcall;
  end;

// Fonction pour cr√©er XAudio2
function XAudio2Create(out ppXAudio2: IXAudio2; Flags: DWORD = 0; XAudio2Processor: DWORD = 1): HResult; stdcall; external 'xaudio2_9.dll';

implementation

end.
```

### Wrapper de haut niveau pour XAudio2

```pascal
unit XAudio2Wrapper;

{$mode objfpc}{$H+}

interface

uses
  Windows, XAudio2, Classes, SysUtils;

type
  // Callback simple pour les √©v√©nements
  TXAudio2VoiceCallback = class(TInterfacedObject, IXAudio2VoiceCallback)
  private
    FOnBufferEnd: TNotifyEvent;
    FOnStreamEnd: TNotifyEvent;
  public
    procedure OnVoiceProcessingPassStart(BytesRequired: DWORD); stdcall;
    procedure OnVoiceProcessingPassEnd; stdcall;
    procedure OnStreamEnd; stdcall;
    procedure OnBufferStart(pBufferContext: Pointer); stdcall;
    procedure OnBufferEnd(pBufferContext: Pointer); stdcall;
    procedure OnLoopEnd(pBufferContext: Pointer); stdcall;
    procedure OnVoiceError(pBufferContext: Pointer; Error: HResult); stdcall;

    property OnBufferEnd: TNotifyEvent read FOnBufferEnd write FOnBufferEnd;
    property OnStreamEnd: TNotifyEvent read FOnStreamEnd write FOnStreamEnd;
  end;

  TXAudio2Sound = class
  private
    FSourceVoice: IXAudio2SourceVoice;
    FAudioData: PByte;
    FAudioSize: DWORD;
    FWaveFormat: TWAVEFORMATEX;
    FCallback: TXAudio2VoiceCallback;
    FVolume: Single;
    FPitch: Single;
  public
    constructor Create(XAudio2: IXAudio2; const Filename: string);
    destructor Destroy; override;

    procedure Play(Loop: Boolean = False);
    procedure Stop;
    procedure Pause;
    procedure Resume;

    function IsPlaying: Boolean;

    property Volume: Single read FVolume write SetVolume;
    property Pitch: Single read FPitch write SetPitch;
  end;

  TXAudio2System = class
  private
    FXAudio2: IXAudio2;
    FMasterVoice: IXAudio2MasteringVoice;
    FSounds: TList;
  public
    constructor Create;
    destructor Destroy; override;

    function LoadSound(const Filename: string): TXAudio2Sound;
    procedure UnloadSound(Sound: TXAudio2Sound);

    procedure SetMasterVolume(Volume: Single);
    procedure StopAllSounds;
  end;

implementation

{ TXAudio2VoiceCallback }

procedure TXAudio2VoiceCallback.OnVoiceProcessingPassStart(BytesRequired: DWORD);  
begin
  // Non utilis√© dans cet exemple
end;

procedure TXAudio2VoiceCallback.OnVoiceProcessingPassEnd;  
begin
  // Non utilis√©
end;

procedure TXAudio2VoiceCallback.OnStreamEnd;  
begin
  if Assigned(FOnStreamEnd) then
    FOnStreamEnd(Self);
end;

procedure TXAudio2VoiceCallback.OnBufferStart(pBufferContext: Pointer);  
begin
  // Non utilis√©
end;

procedure TXAudio2VoiceCallback.OnBufferEnd(pBufferContext: Pointer);  
begin
  if Assigned(FOnBufferEnd) then
    FOnBufferEnd(Self);
end;

procedure TXAudio2VoiceCallback.OnLoopEnd(pBufferContext: Pointer);  
begin
  // Non utilis√©
end;

procedure TXAudio2VoiceCallback.OnVoiceError(pBufferContext: Pointer; Error: HResult);  
begin
  WriteLn('Erreur XAudio2 Voice: ', Error);
end;

{ TXAudio2Sound }

constructor TXAudio2Sound.Create(XAudio2: IXAudio2; const Filename: string);  
var
  WaveFile: TFileStream;
  Header: array[0..43] of Byte;
begin
  inherited Create;

  FCallback := TXAudio2VoiceCallback.Create;
  FVolume := 1.0;
  FPitch := 1.0;

  // Charger le fichier WAV
  WaveFile := TFileStream.Create(Filename, fmOpenRead);
  try
    // Lire l'en-t√™te
    WaveFile.Read(Header, 44);

    // V√©rifier le format
    if (Chr(Header[0]) + Chr(Header[1]) + Chr(Header[2]) + Chr(Header[3]) <> 'RIFF') or
       (Chr(Header[8]) + Chr(Header[9]) + Chr(Header[10]) + Chr(Header[11]) <> 'WAVE') then
      raise Exception.Create('Format WAV invalide');

    // Extraire le format
    FillChar(FWaveFormat, SizeOf(FWaveFormat), 0);
    FWaveFormat.wFormatTag := 1; // PCM
    FWaveFormat.nChannels := PWord(@Header[22])^;
    FWaveFormat.nSamplesPerSec := PDWORD(@Header[24])^;
    FWaveFormat.nAvgBytesPerSec := PDWORD(@Header[28])^;
    FWaveFormat.nBlockAlign := PWord(@Header[32])^;
    FWaveFormat.wBitsPerSample := PWord(@Header[34])^;
    FWaveFormat.cbSize := 0;

    // Taille des donn√©es audio
    FAudioSize := PDWORD(@Header[40])^;

    // Allouer et lire les donn√©es audio
    GetMem(FAudioData, FAudioSize);
    WaveFile.Read(FAudioData^, FAudioSize);

  finally
    WaveFile.Free;
  end;

  // Cr√©er la source voice
  if Failed(XAudio2.CreateSourceVoice(FSourceVoice, FWaveFormat, 0, 2.0, FCallback, nil, nil)) then
    raise Exception.Create('Impossible de cr√©er la source voice');
end;

destructor TXAudio2Sound.Destroy;  
begin
  if Assigned(FSourceVoice) then
  begin
    FSourceVoice.Stop;
    FSourceVoice.DestroyVoice;
    FSourceVoice := nil;
  end;

  if Assigned(FAudioData) then
    FreeMem(FAudioData);

  FCallback := nil;

  inherited;
end;

procedure TXAudio2Sound.Play(Loop: Boolean = False);  
var
  Buffer: TXAUDIO2_BUFFER;
begin
  if not Assigned(FSourceVoice) then Exit;

  // Arr√™ter et vider les buffers existants
  FSourceVoice.Stop;
  FSourceVoice.FlushSourceBuffers;

  // Pr√©parer le buffer
  FillChar(Buffer, SizeOf(Buffer), 0);
  Buffer.AudioBytes := FAudioSize;
  Buffer.pAudioData := FAudioData;
  Buffer.Flags := XAUDIO2_END_OF_STREAM;

  if Loop then
    Buffer.LoopCount := 255 // Boucle infinie
  else
    Buffer.LoopCount := 0;

  // Soumettre le buffer
  if Failed(FSourceVoice.SubmitSourceBuffer(Buffer, nil)) then
    raise Exception.Create('Impossible de soumettre le buffer');

  // D√©marrer la lecture
  FSourceVoice.Start;
end;

procedure TXAudio2Sound.Stop;  
begin
  if Assigned(FSourceVoice) then
  begin
    FSourceVoice.Stop;
    FSourceVoice.FlushSourceBuffers;
  end;
end;

procedure TXAudio2Sound.Pause;  
begin
  if Assigned(FSourceVoice) then
    FSourceVoice.Stop;
end;

procedure TXAudio2Sound.Resume;  
begin
  if Assigned(FSourceVoice) then
    FSourceVoice.Start;
end;

function TXAudio2Sound.IsPlaying: Boolean;  
var
  State: TXAUDIO2_VOICE_STATE;
begin
  Result := False;
  if Assigned(FSourceVoice) then
  begin
    FSourceVoice.GetState(State);
    Result := State.BuffersQueued > 0;
  end;
end;

procedure TXAudio2Sound.SetVolume(Value: Single);  
begin
  FVolume := Value;
  if FVolume < 0 then FVolume := 0;
  if FVolume > 1 then FVolume := 1;

  if Assigned(FSourceVoice) then
    FSourceVoice.SetVolume(FVolume);
end;

procedure TXAudio2Sound.SetPitch(Value: Single);  
begin
  FPitch := Value;

  // XAudio2 utilise un ratio de fr√©quence (0.5 = moiti√©, 2.0 = double)
  if Assigned(FSourceVoice) then
    FSourceVoice.SetFrequencyRatio(FPitch);
end;

{ TXAudio2System }

constructor TXAudio2System.Create;  
begin
  inherited Create;

  FSounds := TList.Create;

  // Initialiser COM
  CoInitializeEx(nil, COINIT_MULTITHREADED);

  // Cr√©er XAudio2
  if Failed(XAudio2Create(FXAudio2, 0, 1)) then
    raise Exception.Create('Impossible de cr√©er XAudio2');

  // Cr√©er la mastering voice
  if Failed(FXAudio2.CreateMasteringVoice(FMasterVoice, 2, 44100, 0, nil, nil, 0)) then
    raise Exception.Create('Impossible de cr√©er la mastering voice');

  // D√©marrer le moteur
  FXAudio2.StartEngine;
end;

destructor TXAudio2System.Destroy;  
var
  i: Integer;
begin
  // Lib√©rer tous les sons
  for i := FSounds.Count - 1 downto 0 do
    TXAudio2Sound(FSounds[i]).Free;

  FSounds.Free;

  // Arr√™ter le moteur
  if Assigned(FXAudio2) then
    FXAudio2.StopEngine;

  // Lib√©rer la mastering voice
  if Assigned(FMasterVoice) then
  begin
    FMasterVoice.DestroyVoice;
    FMasterVoice := nil;
  end;

  FXAudio2 := nil;

  CoUninitialize;

  inherited;
end;

function TXAudio2System.LoadSound(const Filename: string): TXAudio2Sound;  
begin
  Result := TXAudio2Sound.Create(FXAudio2, Filename);
  FSounds.Add(Result);
end;

procedure TXAudio2System.UnloadSound(Sound: TXAudio2Sound);  
begin
  if Assigned(Sound) then
  begin
    FSounds.Remove(Sound);
    Sound.Free;
  end;
end;

procedure TXAudio2System.SetMasterVolume(Volume: Single);  
begin
  if Assigned(FMasterVoice) then
    FMasterVoice.SetVolume(Volume);
end;

procedure TXAudio2System.StopAllSounds;  
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    TXAudio2Sound(FSounds[i]).Stop;
end;

end.
```

### Utilisation basique de XAudio2

```pascal
program XAudio2Demo;

uses
  XAudio2Wrapper, Windows;

var
  Audio: TXAudio2System;
  Music: TXAudio2Sound;
  Explosion: TXAudio2Sound;

begin
  // Cr√©er le syst√®me audio
  Audio := TXAudio2System.Create;

  try
    // Charger les sons
    Music := Audio.LoadSound('music.wav');
    Explosion := Audio.LoadSound('explosion.wav');

    // Jouer la musique en boucle
    Music.Volume := 0.7;
    Music.Play(True);

    WriteLn('Musique en cours...');
    WriteLn('Appuyez sur E pour explosion, Q pour quitter');

    while True do
    begin
      if KeyPressed then
      begin
        case ReadKey of
          'e', 'E':
          begin
            Explosion.Volume := 1.0;
            Explosion.Play;
          end;
          'q', 'Q': Break;
        end;
      end;

      Sleep(10);
    end;

  finally
    Audio.Free;
  end;
end.
```

## Fonctionnalit√©s avanc√©es XAudio2

### Audio 3D avec XAudio2

XAudio2 offre un support natif pour l'audio spatial 3D.

```pascal
unit XAudio23D;

interface

uses
  XAudio2, Windows;

type
  TX3DAUDIO_VECTOR = record
    x, y, z: Single;
  end;

  TX3DAUDIO_LISTENER = record
    OrientFront: TX3DAUDIO_VECTOR;
    OrientTop: TX3DAUDIO_VECTOR;
    Position: TX3DAUDIO_VECTOR;
    Velocity: TX3DAUDIO_VECTOR;
    pCone: Pointer;
  end;

  TX3DAUDIO_EMITTER = record
    pCone: Pointer;
    OrientFront: TX3DAUDIO_VECTOR;
    OrientTop: TX3DAUDIO_VECTOR;
    Position: TX3DAUDIO_VECTOR;
    Velocity: TX3DAUDIO_VECTOR;
    InnerRadius: Single;
    InnerRadiusAngle: Single;
    ChannelCount: DWORD;
    ChannelRadius: Single;
    pChannelAzimuths: PSingle;
    pVolumeCurve: Pointer;
    pLFECurve: Pointer;
    pLPFDirectCurve: Pointer;
    pLPFReverbCurve: Pointer;
    pReverbCurve: Pointer;
    CurveDistanceScaler: Single;
    DopplerScaler: Single;
  end;

  T3DAudioSound = class(TXAudio2Sound)
  private
    FEmitter: TX3DAUDIO_EMITTER;
    FPosition: TX3DAUDIO_VECTOR;
  public
    procedure SetPosition(X, Y, Z: Single);
    procedure SetVelocity(VX, VY, VZ: Single);
    procedure Update3D(const Listener: TX3DAUDIO_LISTENER);
  end;

implementation

procedure T3DAudioSound.SetPosition(X, Y, Z: Single);  
begin
  FPosition.x := X;
  FPosition.y := Y;
  FPosition.z := Z;
  FEmitter.Position := FPosition;
end;

procedure T3DAudioSound.SetVelocity(VX, VY, VZ: Single);  
begin
  FEmitter.Velocity.x := VX;
  FEmitter.Velocity.y := VY;
  FEmitter.Velocity.z := VZ;
end;

procedure T3DAudioSound.Update3D(const Listener: TX3DAUDIO_LISTENER);  
var
  Distance: Single;
  DX, DY, DZ: Single;
  Attenuation: Single;
  Pan: Single;
begin
  // Calculer la distance
  DX := FPosition.x - Listener.Position.x;
  DY := FPosition.y - Listener.Position.y;
  DZ := FPosition.z - Listener.Position.z;
  Distance := Sqrt(DX * DX + DY * DY + DZ * DZ);

  // Att√©nuation bas√©e sur la distance
  if Distance < 1.0 then
    Attenuation := 1.0
  else
    Attenuation := 1.0 / Distance;

  // Calculer le pan (gauche/droite)
  // Simplifi√© : bas√© sur la position X relative
  Pan := DX / (Distance + 0.001);

  // Appliquer le volume
  Volume := Attenuation;

  // Effet Doppler simplifi√© (bas√© sur la v√©locit√©)
  // TODO: Impl√©menter calcul Doppler complet
end;

end.
```

### Streaming audio pour fichiers volumineux

Pour les gros fichiers (musique de fond), le streaming √©vite de charger tout le fichier en m√©moire.

```pascal
type
  TStreamingSound = class
  private
    FSourceVoice: IXAudio2SourceVoice;
    FFile: TFileStream;
    FBuffers: array[0..2] of array of Byte; // Triple buffering
    FCurrentBuffer: Integer;
    FBufferSize: DWORD;
    FCallback: TXAudio2VoiceCallback;
    FStreaming: Boolean;
  public
    constructor Create(XAudio2: IXAudio2; const Filename: string);
    destructor Destroy; override;

    procedure Start;
    procedure Stop;
    procedure Update; // √Ä appeler r√©guli√®rement
  private
    procedure FillNextBuffer;
    procedure OnBufferEnd(Sender: TObject);
  end;

constructor TStreamingSound.Create(XAudio2: IXAudio2; const Filename: string);  
var
  WaveFormat: TWAVEFORMATEX;
  Header: array[0..43] of Byte;
  i: Integer;
begin
  inherited Create;

  FBufferSize := 65536; // 64 KB par buffer
  FCurrentBuffer := 0;
  FStreaming := False;

  // Ouvrir le fichier
  FFile := TFileStream.Create(Filename, fmOpenRead or fmShareDenyWrite);

  // Lire l'en-t√™te
  FFile.Read(Header, 44);

  // Extraire le format
  WaveFormat.wFormatTag := 1;
  WaveFormat.nChannels := PWord(@Header[22])^;
  WaveFormat.nSamplesPerSec := PDWORD(@Header[24])^;
  WaveFormat.nAvgBytesPerSec := PDWORD(@Header[28])^;
  WaveFormat.nBlockAlign := PWord(@Header[32])^;
  WaveFormat.wBitsPerSample := PWord(@Header[34])^;
  WaveFormat.cbSize := 0;

  // Cr√©er les buffers
  for i := 0 to 2 do
    SetLength(FBuffers[i], FBufferSize);

  // Cr√©er le callback
  FCallback := TXAudio2VoiceCallback.Create;
  FCallback.OnBufferEnd := @Self.OnBufferEnd;

  // Cr√©er la source voice
  if Failed(XAudio2.CreateSourceVoice(FSourceVoice, WaveFormat, 0, 2.0, FCallback, nil, nil)) then
    raise Exception.Create('Impossible de cr√©er la source voice');
end;

destructor TStreamingSound.Destroy;  
begin
  Stop;

  if Assigned(FSourceVoice) then
  begin
    FSourceVoice.DestroyVoice;
    FSourceVoice := nil;
  end;

  FFile.Free;
  FCallback := nil;

  inherited;
end;

procedure TStreamingSound.Start;  
var
  i: Integer;
begin
  FStreaming := True;

  // Rembobiner le fichier
  FFile.Position := 44; // Apr√®s l'en-t√™te WAV

  // Remplir et soumettre les premiers buffers
  for i := 0 to 2 do
    FillNextBuffer;

  // D√©marrer la lecture
  FSourceVoice.Start;
end;

procedure TStreamingSound.Stop;  
begin
  FStreaming := False;

  if Assigned(FSourceVoice) then
  begin
    FSourceVoice.Stop;
    FSourceVoice.FlushSourceBuffers;
  end;
end;

procedure TStreamingSound.FillNextBuffer;  
var
  BytesRead: Integer;
  Buffer: TXAUDIO2_BUFFER;
begin
  if not FStreaming then Exit;

  // Lire les donn√©es du fichier
  BytesRead := FFile.Read(FBuffers[FCurrentBuffer][0], FBufferSize);

  if BytesRead > 0 then
  begin
    // Pr√©parer le buffer XAudio2
    FillChar(Buffer, SizeOf(Buffer), 0);
    Buffer.AudioBytes := BytesRead;
    Buffer.pAudioData := @FBuffers[FCurrentBuffer][0];

    // Si on est √† la fin du fichier, boucler
    if BytesRead < FBufferSize then
    begin
      // Rembobiner pour boucler
      FFile.Position := 44;
      Buffer.Flags := XAUDIO2_END_OF_STREAM;
    end;

    // Soumettre le buffer
    FSourceVoice.SubmitSourceBuffer(Buffer, nil);

    // Passer au buffer suivant
    FCurrentBuffer := (FCurrentBuffer + 1) mod 3;
  end;
end;

procedure TStreamingSound.OnBufferEnd(Sender: TObject);  
begin
  // Un buffer est termin√©, remplir le suivant
  FillNextBuffer;
end;

procedure TStreamingSound.Update;  
var
  State: TXAUDIO2_VOICE_STATE;
begin
  if not FStreaming then Exit;

  // V√©rifier l'√©tat
  FSourceVoice.GetState(State);

  // Si on a moins de 2 buffers en attente, en ajouter
  while State.BuffersQueued < 2 do
  begin
    FillNextBuffer;
    FSourceVoice.GetState(State);
  end;
end;
```

### Utilisation du streaming

```pascal
var
  StreamingMusic: TStreamingSound;

begin
  Audio := TXAudio2System.Create;

  // Cr√©er un son en streaming
  StreamingMusic := TStreamingSound.Create(Audio.XAudio2, 'long_music.wav');

  StreamingMusic.Start;

  // Dans la boucle principale du jeu
  while GameRunning do
  begin
    StreamingMusic.Update; // IMPORTANT : appeler r√©guli√®rement

    UpdateGame;
    RenderGame;
  end;

  StreamingMusic.Free;
  Audio.Free;
end.
```

## Effets audio avec XAudio2

### Reverb (r√©verb√©ration)

La r√©verb√©ration simule l'√©cho naturel dans diff√©rents environnements.

```pascal
unit XAudio2Effects;

interface

uses
  XAudio2, Windows;

const
  // Presets de r√©verb√©ration
  XAUDIO2FX_REVERB_MIN_FRAMERATE = 20000;
  XAUDIO2FX_REVERB_MAX_FRAMERATE = 48000;

  XAUDIO2FX_REVERB_MIN_WET_DRY_MIX = 0.0;
  XAUDIO2FX_REVERB_MAX_WET_DRY_MIX = 100.0;

type
  TXAUDIO2FX_REVERB_PARAMETERS = packed record
    WetDryMix: Single;            // 0-100 (% d'effet)
    ReflectionsDelay: DWORD;      // 0-300 ms
    ReverbDelay: Byte;            // 0-85 ms
    RearDelay: Byte;              // 0-5 ms
    PositionLeft: Byte;           // 0-30
    PositionRight: Byte;          // 0-30
    PositionMatrixLeft: Byte;     // 0-30
    PositionMatrixRight: Byte;    // 0-30
    EarlyDiffusion: Byte;         // 0-15
    LateDiffusion: Byte;          // 0-15
    LowEQGain: Byte;              // 0-12
    LowEQCutoff: Byte;            // 0-9
    HighEQGain: Byte;             // 0-8
    HighEQCutoff: Byte;           // 0-14
    RoomFilterFreq: Single;       // 20-20000 Hz
    RoomFilterMain: Single;       // -100-0 dB
    RoomFilterHF: Single;         // -100-0 dB
    ReflectionsGain: Single;      // -100-20 dB
    ReverbGain: Single;           // -100-20 dB
    DecayTime: Single;            // 0.1-inf secondes
    Density: Single;              // 0-100 %
    RoomSize: Single;             // 1-100 feet
  end;

  TReverbPreset = (
    rpDefault,
    rpGeneric,
    rpPaddedCell,
    rpRoom,
    rpBathroom,
    rpLivingRoom,
    rpStoneRoom,
    rpAuditorium,
    rpConcertHall,
    rpCave,
    rpArena,
    rpHangar,
    rpCarpetedHallway,
    rpHallway,
    rpStoneCorridor,
    rpAlley,
    rpForest,
    rpCity,
    rpMountains,
    rpQuarry,
    rpPlain,
    rpParkingLot,
    rpSewerPipe,
    rpUnderwater
  );

  TXAudio2Reverb = class
  private
    FSourceVoice: IXAudio2SourceVoice;
    FSubmixVoice: Pointer;
    FParameters: TXAUDIO2FX_REVERB_PARAMETERS;
  public
    constructor Create(XAudio2: IXAudio2; SourceVoice: IXAudio2SourceVoice);

    procedure SetPreset(Preset: TReverbPreset);
    procedure SetWetDryMix(Mix: Single);
    procedure SetRoomSize(Size: Single);
    procedure SetDecayTime(Time: Single);

    procedure Apply;
  end;

implementation

constructor TXAudio2Reverb.Create(XAudio2: IXAudio2; SourceVoice: IXAudio2SourceVoice);  
begin
  inherited Create;
  FSourceVoice := SourceVoice;

  // Initialiser avec des valeurs par d√©faut
  SetPreset(rpDefault);
end;

procedure TXAudio2Reverb.SetPreset(Preset: TReverbPreset);  
begin
  // Valeurs par d√©faut
  FillChar(FParameters, SizeOf(FParameters), 0);

  case Preset of
    rpDefault:
    begin
      FParameters.WetDryMix := 100.0;
      FParameters.ReflectionsDelay := 7;
      FParameters.ReverbDelay := 11;
      FParameters.RearDelay := 2;
      FParameters.RoomSize := 50.0;
      FParameters.DecayTime := 1.49;
      FParameters.Density := 100.0;
    end;

    rpRoom:
    begin
      FParameters.WetDryMix := 50.0;
      FParameters.RoomSize := 10.0;
      FParameters.DecayTime := 0.4;
      FParameters.ReflectionsDelay := 2;
      FParameters.ReverbDelay := 3;
    end;

    rpBathroom:
    begin
      FParameters.WetDryMix := 70.0;
      FParameters.RoomSize := 5.0;
      FParameters.DecayTime := 1.4;
      FParameters.ReflectionsDelay := 7;
      FParameters.ReverbDelay := 11;
    end;

    rpConcertHall:
    begin
      FParameters.WetDryMix := 80.0;
      FParameters.RoomSize := 90.0;
      FParameters.DecayTime := 3.92;
      FParameters.ReflectionsDelay := 20;
      FParameters.ReverbDelay := 30;
    end;

    rpCave:
    begin
      FParameters.WetDryMix := 100.0;
      FParameters.RoomSize := 80.0;
      FParameters.DecayTime := 2.91;
      FParameters.ReflectionsDelay := 15;
      FParameters.ReverbDelay := 22;
    end;

    rpUnderwater:
    begin
      FParameters.WetDryMix := 80.0;
      FParameters.RoomSize := 30.0;
      FParameters.DecayTime := 1.5;
      FParameters.ReflectionsDelay := 7;
      FParameters.ReverbDelay := 11;
      FParameters.RoomFilterMain := -20.0;
    end;
  end;
end;

procedure TXAudio2Reverb.SetWetDryMix(Mix: Single);  
begin
  FParameters.WetDryMix := Mix;
  if FParameters.WetDryMix < 0 then FParameters.WetDryMix := 0;
  if FParameters.WetDryMix > 100 then FParameters.WetDryMix := 100;
end;

procedure TXAudio2Reverb.SetRoomSize(Size: Single);  
begin
  FParameters.RoomSize := Size;
  if FParameters.RoomSize < 1 then FParameters.RoomSize := 1;
  if FParameters.RoomSize > 100 then FParameters.RoomSize := 100;
end;

procedure TXAudio2Reverb.SetDecayTime(Time: Single);  
begin
  FParameters.DecayTime := Time;
  if FParameters.DecayTime < 0.1 then FParameters.DecayTime := 0.1;
end;

procedure TXAudio2Reverb.Apply;  
begin
  // Appliquer les param√®tres √† la source voice
  // Note: N√©cessite la cr√©ation d'un effect chain, simplifi√© ici
  FSourceVoice.SetEffectParameters(0, @FParameters, SizeOf(FParameters));
end;

end.
```

### Utilisation des effets de r√©verb√©ration

```pascal
var
  Sound: TXAudio2Sound;
  Reverb: TXAudio2Reverb;

begin
  Sound := Audio.LoadSound('footsteps.wav');

  // Cr√©er l'effet de r√©verb√©ration
  Reverb := TXAudio2Reverb.Create(Audio.XAudio2, Sound.SourceVoice);

  // Appliquer un preset de cave
  Reverb.SetPreset(rpCave);
  Reverb.Apply;

  Sound.Play;
end;
```

### Filtre passe-bas (Low-Pass Filter)

Utile pour simuler les sons √©touff√©s (derri√®re un mur, sous l'eau, etc.)

```pascal
procedure ApplyLowPassFilter(Sound: TXAudio2Sound; CutoffFrequency: Single);  
var
  FilterParams: TXAUDIO2_FILTER_PARAMETERS;
begin
  FilterParams.FilterType := LowPassFilter; // 0
  FilterParams.Frequency := CutoffFrequency; // 0.0 - 1.0 (normalis√©)
  FilterParams.OneOverQ := 1.0; // Qualit√© du filtre

  Sound.SourceVoice.SetFilterParameters(FilterParams);
end;

// Exemple d'utilisation
procedure SimulateUnderwater(Sound: TXAudio2Sound);  
begin
  // Fr√©quence de coupure basse pour effet sous l'eau
  ApplyLowPassFilter(Sound, 0.3);

  // R√©duire l√©g√®rement le volume
  Sound.Volume := 0.7;
end;
```

### Filtre passe-haut (High-Pass Filter)

Utile pour les voix radio, t√©l√©phones, etc.

```pascal
procedure ApplyHighPassFilter(Sound: TXAudio2Sound; CutoffFrequency: Single);  
var
  FilterParams: TXAUDIO2_FILTER_PARAMETERS;
begin
  FilterParams.FilterType := HighPassFilter; // 1
  FilterParams.Frequency := CutoffFrequency;
  FilterParams.OneOverQ := 1.0;

  Sound.SourceVoice.SetFilterParameters(FilterParams);
end;

// Effet radio
procedure SimulateRadio(Sound: TXAudio2Sound);  
begin
  ApplyHighPassFilter(Sound, 0.6);

  // Ajouter de la distorsion (simplifi√©)
  Sound.Volume := 0.9;
end;
```

## Mixer et Submix

Les **submix voices** permettent de grouper plusieurs sons et d'appliquer des effets √† l'ensemble.

```pascal
type
  TAudioMixer = class
  private
    FXAudio2: IXAudio2;
    FMasterVoice: IXAudio2MasteringVoice;
    FMusicSubmix: Pointer; // IXAudio2SubmixVoice
    FSFXSubmix: Pointer;
    FVoiceSubmix: Pointer;
  public
    constructor Create(XAudio2: IXAudio2);

    procedure SetMusicVolume(Volume: Single);
    procedure SetSFXVolume(Volume: Single);
    procedure SetVoiceVolume(Volume: Single);

    function GetMusicSubmix: Pointer;
    function GetSFXSubmix: Pointer;
    function GetVoiceSubmix: Pointer;
  end;

constructor TAudioMixer.Create(XAudio2: IXAudio2);  
begin
  inherited Create;
  FXAudio2 := XAudio2;

  // Cr√©er les submix voices
  FXAudio2.CreateSubmixVoice(FMusicSubmix, 2, 44100, 0, 0, nil, nil);
  FXAudio2.CreateSubmixVoice(FSFXSubmix, 2, 44100, 0, 0, nil, nil);
  FXAudio2.CreateSubmixVoice(FVoiceSubmix, 2, 44100, 0, 0, nil, nil);
end;

procedure TAudioMixer.SetMusicVolume(Volume: Single);  
begin
  IXAudio2Voice(FMusicSubmix).SetVolume(Volume);
end;

procedure TAudioMixer.SetSFXVolume(Volume: Single);  
begin
  IXAudio2Voice(FSFXSubmix).SetVolume(Volume);
end;

procedure TAudioMixer.SetVoiceVolume(Volume: Single);  
begin
  IXAudio2Voice(FVoiceSubmix).SetVolume(Volume);
end;
```

## Comparaison DirectSound vs XAudio2

### Tableau comparatif

| Caract√©ristique | DirectSound | XAudio2 |
|----------------|-------------|---------|
| **Performance** | Moyenne | Excellente |
| **Latence** | 20-50 ms | 5-20 ms |
| **Complexit√©** | Simple | Moyenne |
| **Effets int√©gr√©s** | Basiques | Avanc√©s |
| **Audio 3D** | Oui (ancien) | Oui (moderne) |
| **Multi-threading** | Limit√© | Excellent |
| **Windows XP** | Oui | Non |
| **Windows 10+** | Oui | Oui (natif) |
| **Streaming** | Possible | Optimis√© |
| **Nombre max de sons** | ~32 | Illimit√© (selon CPU) |

### Quand migrer de DirectSound vers XAudio2

**Migrez vers XAudio2 si** :
- Vous avez besoin de meilleures performances
- Vous voulez une latence plus faible
- Vous d√©veloppez un jeu moderne (2020+)
- Vous utilisez beaucoup de sons simultan√©s
- Vous avez besoin d'effets audio complexes

**Restez sur DirectSound si** :
- Vous devez supporter Windows XP
- Votre jeu est simple (peu de sons)
- Vous privil√©giez la simplicit√©
- Vous portez un ancien projet

## Gestionnaire audio complet

Voici un gestionnaire audio complet combinant les meilleures pratiques :

```pascal
unit GameAudioManager;

{$mode objfpc}{$H+}

interface

uses
  XAudio2Wrapper, Classes, SysUtils;

type
  TAudioCategory = (acMusic, acSFX, acVoice, acAmbient);

  TManagedSound = class
    Sound: TXAudio2Sound;
    Category: TAudioCategory;
    Priority: Integer;
    FadeTarget: Single;
    FadeSpeed: Single;
  end;

  TGameAudioManager = class
  private
    FAudioSystem: TXAudio2System;
    FSounds: TList;
    FCategoryVolumes: array[TAudioCategory] of Single;
    FMasterVolume: Single;
    FMuted: Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    // Chargement
    function LoadSound(const Filename: string; Category: TAudioCategory; Priority: Integer = 0): TManagedSound;
    procedure UnloadSound(Sound: TManagedSound);

    // Lecture
    procedure PlaySound(Sound: TManagedSound; Loop: Boolean = False);
    procedure StopSound(Sound: TManagedSound);
    procedure StopAllSounds;
    procedure StopCategory(Category: TAudioCategory);

    // Volume
    procedure SetMasterVolume(Volume: Single);
    procedure SetCategoryVolume(Category: TAudioCategory; Volume: Single);
    procedure Mute(Muted: Boolean);

    // Fondu
    procedure FadeIn(Sound: TManagedSound; Duration: Single);
    procedure FadeOut(Sound: TManagedSound; Duration: Single);

    // Mise √† jour
    procedure Update(DeltaTime: Single);

    // Sauvegarde des param√®tres
    procedure SaveSettings(const Filename: string);
    procedure LoadSettings(const Filename: string);
  end;

implementation

constructor TGameAudioManager.Create;  
var
  Cat: TAudioCategory;
begin
  inherited Create;

  FAudioSystem := TXAudio2System.Create;
  FSounds := TList.Create;

  // Valeurs par d√©faut
  FMasterVolume := 1.0;
  for Cat := Low(TAudioCategory) to High(TAudioCategory) do
    FCategoryVolumes[Cat] := 1.0;

  FMuted := False;
end;

destructor TGameAudioManager.Destroy;  
var
  i: Integer;
begin
  for i := FSounds.Count - 1 downto 0 do
    TManagedSound(FSounds[i]).Free;

  FSounds.Free;
  FAudioSystem.Free;

  inherited;
end;

function TGameAudioManager.LoadSound(const Filename: string; Category: TAudioCategory; Priority: Integer): TManagedSound;  
begin
  Result := TManagedSound.Create;
  Result.Sound := FAudioSystem.LoadSound(Filename);
  Result.Category := Category;
  Result.Priority := Priority;
  Result.FadeTarget := 1.0;
  Result.FadeSpeed := 0.0;

  FSounds.Add(Result);
end;

procedure TGameAudioManager.UnloadSound(Sound: TManagedSound);  
begin
  if Assigned(Sound) then
  begin
    FSounds.Remove(Sound);
    FAudioSystem.UnloadSound(Sound.Sound);
    Sound.Free;
  end;
end;

procedure TGameAudioManager.PlaySound(Sound: TManagedSound; Loop: Boolean);  
var
  FinalVolume: Single;
begin
  if not Assigned(Sound) then Exit;

  // Calculer le volume final
  FinalVolume := FMasterVolume * FCategoryVolumes[Sound.Category];

  if FMuted then
    FinalVolume := 0.0;

  Sound.Sound.Volume := FinalVolume;
  Sound.Sound.Play(Loop);
end;

procedure TGameAudioManager.StopSound(Sound: TManagedSound);  
begin
  if Assigned(Sound) then
    Sound.Sound.Stop;
end;

procedure TGameAudioManager.StopAllSounds;  
var
  i: Integer;
begin
  for i := 0 to FSounds.Count - 1 do
    TManagedSound(FSounds[i]).Sound.Stop;
end;

procedure TGameAudioManager.StopCategory(Category: TAudioCategory);  
var
  i: Integer;
  MSound: TManagedSound;
begin
  for i := 0 to FSounds.Count - 1 do
  begin
    MSound := TManagedSound(FSounds[i]);
    if MSound.Category = Category then
      MSound.Sound.Stop;
  end;
end;

procedure TGameAudioManager.SetMasterVolume(Volume: Single);  
var
  i: Integer;
  MSound: TManagedSound;
  FinalVolume: Single;
begin
  FMasterVolume := Volume;
  if FMasterVolume < 0 then FMasterVolume := 0;
  if FMasterVolume > 1 then FMasterVolume := 1;

  // Mettre √† jour tous les sons actifs
  for i := 0 to FSounds.Count - 1 do
  begin
    MSound := TManagedSound(FSounds[i]);
    if MSound.Sound.IsPlaying then
    begin
      FinalVolume := FMasterVolume * FCategoryVolumes[MSound.Category];
      if FMuted then FinalVolume := 0.0;
      MSound.Sound.Volume := FinalVolume;
    end;
  end;
end;

procedure TGameAudioManager.SetCategoryVolume(Category: TAudioCategory; Volume: Single);  
var
  i: Integer;
  MSound: TManagedSound;
  FinalVolume: Single;
begin
  FCategoryVolumes[Category] := Volume;
  if FCategoryVolumes[Category] < 0 then FCategoryVolumes[Category] := 0;
  if FCategoryVolumes[Category] > 1 then FCategoryVolumes[Category] := 1;

  // Mettre √† jour les sons de cette cat√©gorie
  for i := 0 to FSounds.Count - 1 do
  begin
    MSound := TManagedSound(FSounds[i]);
    if (MSound.Category = Category) and MSound.Sound.IsPlaying then
    begin
      FinalVolume := FMasterVolume * FCategoryVolumes[Category];
      if FMuted then FinalVolume := 0.0;
      MSound.Sound.Volume := FinalVolume;
    end;
  end;
end;

procedure TGameAudioManager.Mute(Muted: Boolean);  
begin
  FMuted := Muted;

  if FMuted then
    FAudioSystem.SetMasterVolume(0.0)
  else
    SetMasterVolume(FMasterVolume);
end;

procedure TGameAudioManager.FadeIn(Sound: TManagedSound; Duration: Single);  
begin
  if not Assigned(Sound) then Exit;

  Sound.Sound.Volume := 0.0;
  Sound.FadeTarget := 1.0;
  Sound.FadeSpeed := 1.0 / Duration;
end;

procedure TGameAudioManager.FadeOut(Sound: TManagedSound; Duration: Single);  
begin
  if not Assigned(Sound) then Exit;

  Sound.FadeTarget := 0.0;
  Sound.FadeSpeed := -1.0 / Duration;
end;

procedure TGameAudioManager.Update(DeltaTime: Single);  
var
  i: Integer;
  MSound: TManagedSound;
  CurrentVolume, NewVolume: Single;
begin
  for i := 0 to FSounds.Count - 1 do
  begin
    MSound := TManagedSound(FSounds[i]);

    // G√©rer le fondu
    if MSound.FadeSpeed <> 0.0 then
    begin
      CurrentVolume := MSound.Sound.Volume;
      NewVolume := CurrentVolume + MSound.FadeSpeed * DeltaTime;

      // Limiter au target
      if MSound.FadeSpeed > 0 then
      begin
        if NewVolume >= MSound.FadeTarget then
        begin
          NewVolume := MSound.FadeTarget;
          MSound.FadeSpeed := 0.0;
        end;
      end
      else
      begin
        if NewVolume <= MSound.FadeTarget then
        begin
          NewVolume := MSound.FadeTarget;
          MSound.FadeSpeed := 0.0;

          // Arr√™ter si volume √† 0
          if NewVolume = 0.0 then
            MSound.Sound.Stop;
        end;
      end;

      MSound.Sound.Volume := NewVolume;
    end;
  end;
end;

procedure TGameAudioManager.SaveSettings(const Filename: string);  
var
  F: TextFile;
  Cat: TAudioCategory;
begin
  AssignFile(F, Filename);
  Rewrite(F);
  try
    WriteLn(F, 'MasterVolume=', FMasterVolume:0:2);
    WriteLn(F, 'Muted=', Ord(FMuted));

    for Cat := Low(TAudioCategory) to High(TAudioCategory) do
      WriteLn(F, GetEnumName(TypeInfo(TAudioCategory), Ord(Cat)), '=', FCategoryVolumes[Cat]:0:2);
  finally
    CloseFile(F);
  end;
end;

procedure TGameAudioManager.LoadSettings(const Filename: string);  
var
  F: TextFile;
  Line, Key, Value: string;
  P: Integer;
  Cat: TAudioCategory;
begin
  if not FileExists(Filename) then Exit;

  AssignFile(F, Filename);
  Reset(F);
  try
    while not Eof(F) do
    begin
      ReadLn(F, Line);
      P := Pos('=', Line);
      if P > 0 then
      begin
        Key := Copy(Line, 1, P - 1);
        Value := Copy(Line, P + 1, Length(Line));

        if Key = 'MasterVolume' then
          FMasterVolume := StrToFloatDef(Value, 1.0)
        else if Key = 'Muted' then
          FMuted := StrToIntDef(Value, 0) <> 0
        else
        begin
          // Tenter de parser une cat√©gorie
          for Cat := Low(TAudioCategory) to High(TAudioCategory) do
          begin
            if Key = GetEnumName(TypeInfo(TAudioCategory), Ord(Cat)) then
            begin
              FCategoryVolumes[Cat] := StrToFloatDef(Value, 1.0);
              Break;
            end;
          end;
        end;
      end;
    end;
  finally
    CloseFile(F);
  end;

  // Appliquer les param√®tres
  SetMasterVolume(FMasterVolume);
  Mute(FMuted);
end;

end.
```

### Utilisation du gestionnaire complet

```pascal
program GameWithAudio;

uses
  GameAudioManager;

var
  AudioMgr: TGameAudioManager;
  BackgroundMusic: TManagedSound;
  JumpSound: TManagedSound;
  VoiceClip: TManagedSound;

begin
  // Cr√©er le gestionnaire
  AudioMgr := TGameAudioManager.Create;

  try
    // Charger les param√®tres sauvegard√©s
    AudioMgr.LoadSettings('audio_settings.txt');

    // Charger les sons
    BackgroundMusic := AudioMgr.LoadSound('music.wav', acMusic, 10);
    JumpSound := AudioMgr.LoadSound('jump.wav', acSFX, 5);
    VoiceClip := AudioMgr.LoadSound('voice.wav', acVoice, 15);

    // Jouer la musique avec fondu entrant
    AudioMgr.FadeIn(BackgroundMusic, 2.0); // 2 secondes
    AudioMgr.PlaySound(BackgroundMusic, True);

    // Boucle de jeu
    while GameRunning do
    begin
      DeltaTime := CalculateDeltaTime;

      // Mettre √† jour l'audio (fondus, etc.)
      AudioMgr.Update(DeltaTime);

      // Interactions
      if PlayerJumps then
        AudioMgr.PlaySound(JumpSound);

      if TriggerCutscene then
      begin
        AudioMgr.FadeOut(BackgroundMusic, 1.0);
        AudioMgr.PlaySound(VoiceClip);
      end;

      // Options audio
      if MenuOpened then
      begin
        AudioMgr.SetMasterVolume(MasterVolumeSlider.Value);
        AudioMgr.SetCategoryVolume(acMusic, MusicVolumeSlider.Value);
        AudioMgr.SetCategoryVolume(acSFX, SFXVolumeSlider.Value);
      end;

      UpdateGame;
      RenderGame;
    end;

    // Sauvegarder les param√®tres audio avant de quitter
    AudioMgr.SaveSettings('audio_settings.txt');

  finally
    AudioMgr.Free;
  end;
end.
```

## Optimisation et bonnes pratiques

### 1. Limiter le nombre de sons simultan√©s

```pascal
type
  TVoicePool = class
  private
    FMaxVoices: Integer;
    FActiveSounds: TList;
  public
    constructor Create(MaxVoices: Integer);

    function CanPlay(Priority: Integer): Boolean;
    procedure RegisterSound(Sound: TManagedSound);
    procedure UnregisterSound(Sound: TManagedSound);
  end;

constructor TVoicePool.Create(MaxVoices: Integer);  
begin
  inherited Create;
  FMaxVoices := MaxVoices;
  FActiveSounds := TList.Create;
end;

function TVoicePool.CanPlay(Priority: Integer): Boolean;  
var
  i: Integer;
  LowestPriority: Integer;
  LowestIndex: Integer;
begin
  // Si on a de la place, on peut jouer
  if FActiveSounds.Count < FMaxVoices then
  begin
    Result := True;
    Exit;
  end;

  // Chercher le son de priorit√© la plus basse
  LowestPriority := MaxInt;
  LowestIndex := -1;

  for i := 0 to FActiveSounds.Count - 1 do
  begin
    if TManagedSound(FActiveSounds[i]).Priority < LowestPriority then
    begin
      LowestPriority := TManagedSound(FActiveSounds[i]).Priority;
      LowestIndex := i;
    end;
  end;

  // Si le nouveau son est plus prioritaire, arr√™ter le moins prioritaire
  if Priority > LowestPriority then
  begin
    TManagedSound(FActiveSounds[LowestIndex]).Sound.Stop;
    FActiveSounds.Delete(LowestIndex);
    Result := True;
  end
  else
    Result := False;
end;

procedure TVoicePool.RegisterSound(Sound: TManagedSound);  
begin
  FActiveSounds.Add(Sound);
end;

procedure TVoicePool.UnregisterSound(Sound: TManagedSound);  
begin
  FActiveSounds.Remove(Sound);
end;
```

### 2. Pr√©chargement intelligent

```pascal
type
  TAsyncSoundLoader = class(TThread)
  private
    FAudioMgr: TGameAudioManager;
    FFilename: string;
    FCategory: TAudioCategory;
    FOnLoaded: TNotifyEvent;
    FResult: TManagedSound;
  protected
    procedure Execute; override;
  public
    constructor Create(AudioMgr: TGameAudioManager; const Filename: string;
                      Category: TAudioCategory; OnLoaded: TNotifyEvent);
    property Result: TManagedSound read FResult;
  end;

constructor TAsyncSoundLoader.Create(AudioMgr: TGameAudioManager;
  const Filename: string; Category: TAudioCategory; OnLoaded: TNotifyEvent);
begin
  inherited Create(True);
  FAudioMgr := AudioMgr;
  FFilename := Filename;
  FCategory := Category;
  FOnLoaded := OnLoaded;
  FreeOnTerminate := True;
end;

procedure TAsyncSoundLoader.Execute;  
begin
  // Charger le son dans un thread s√©par√©
  FResult := FAudioMgr.LoadSound(FFilename, FCategory);

  // Notifier quand termin√©
  if Assigned(FOnLoaded) then
    Synchronize(@FOnLoaded);
end;

// Utilisation
procedure PreloadLevelSounds;  
var
  Loader: TAsyncSoundLoader;
begin
  Loader := TAsyncSoundLoader.Create(AudioMgr, 'level_music.wav', acMusic,
    @OnMusicLoaded);
  Loader.Start;

  // Continuer le chargement pendant que l'audio se charge en arri√®re-plan
  LoadLevelGeometry;
  LoadLevelTextures;
end;
```

### 3. Gestion de la m√©moire

```pascal
type
  TAudioCache = class
  private
    FSounds: TStringList; // Filename -> TManagedSound
    FMaxCacheSize: Int64;
    FCurrentCacheSize: Int64;
  public
    constructor Create(MaxSizeMB: Integer);

    function GetSound(const Filename: string): TManagedSound;
    procedure AddSound(const Filename: string; Sound: TManagedSound);
    procedure Clear;
    procedure PruneCache;
  end;

procedure TAudioCache.PruneCache;  
var
  i: Integer;
  Sound: TManagedSound;
begin
  // Supprimer les sons les moins r√©cemment utilis√©s
  while FCurrentCacheSize > FMaxCacheSize do
  begin
    if FSounds.Count = 0 then Break;

    Sound := TManagedSound(FSounds.Objects[0]);
    FCurrentCacheSize := FCurrentCacheSize - Sound.Sound.AudioSize;

    Sound.Free;
    FSounds.Delete(0);
  end;
end;
```

### 4. Gestion des formats audio

```pascal
function GetAudioFileInfo(const Filename: string): TAudioInfo;  
var
  Ext: string;
begin
  Ext := LowerCase(ExtractFileExt(Filename));

  case Ext of
    '.wav':
    begin
      Result := LoadWaveInfo(Filename);
      Result.Compressed := False;
    end;

    '.ogg':
    begin
      Result := LoadOggInfo(Filename);
      Result.Compressed := True;
    end;

    '.mp3':
    begin
      Result := LoadMP3Info(Filename);
      Result.Compressed := True;
    end;

    else
      raise Exception.Create('Format audio non support√©: ' + Ext);
  end;
end;
```

## D√©bogage audio

### Console de d√©bogage audio

```pascal
type
  TAudioDebugConsole = class
  private
    FAudioMgr: TGameAudioManager;
    FVisible: Boolean;
  public
    procedure Draw(Canvas: TCanvas);
    procedure Toggle;

    property Visible: Boolean read FVisible write FVisible;
  end;

procedure TAudioDebugConsole.Draw(Canvas: TCanvas);  
var
  i, Y: Integer;
  MSound: TManagedSound;
  Info: string;
begin
  if not FVisible then Exit;

  Canvas.Brush.Color := clBlack;
  Canvas.Brush.Style := bsSolid;
  Canvas.FillRect(10, 10, 400, 300);

  Canvas.Font.Color := clWhite;
  Y := 20;

  Canvas.TextOut(20, Y, 'AUDIO DEBUG CONSOLE');
  Inc(Y, 25);

  Canvas.TextOut(20, Y, Format('Master Volume: %.0f%%', [FAudioMgr.MasterVolume * 100]));
  Inc(Y, 20);

  Canvas.TextOut(20, Y, Format('Active Sounds: %d', [GetActiveSoundCount]));
  Inc(Y, 20);

  Canvas.TextOut(20, Y, '---');
  Inc(Y, 20);

  // Lister les sons actifs
  for i := 0 to FAudioMgr.Sounds.Count - 1 do
  begin
    MSound := TManagedSound(FAudioMgr.Sounds[i]);

    if MSound.Sound.IsPlaying then
    begin
      Info := Format('%s - Vol: %.0f%% - Cat: %s', [
        ExtractFileName(MSound.Sound.Filename),
        MSound.Sound.Volume * 100,
        GetEnumName(TypeInfo(TAudioCategory), Ord(MSound.Category))
      ]);

      Canvas.TextOut(20, Y, Info);
      Inc(Y, 15);
    end;
  end;
end;

procedure TAudioDebugConsole.Toggle;  
begin
  FVisible := not FVisible;
end;
```

### Visualisation du volume

```pascal
type
  TVolumeVisualizer = class
  private
    FSamples: array[0..99] of Single;
    FPosition: Integer;
  public
    procedure AddSample(Volume: Single);
    procedure Draw(Canvas: TCanvas; X, Y, Width, Height: Integer);
  end;

procedure TVolumeVisualizer.AddSample(Volume: Single);  
begin
  FSamples[FPosition] := Volume;
  FPosition := (FPosition + 1) mod 100;
end;

procedure TVolumeVisualizer.Draw(Canvas: TCanvas; X, Y, Width, Height: Integer);  
var
  i, BarHeight: Integer;
  Sample: Single;
begin
  Canvas.Brush.Color := clBlack;
  Canvas.FillRect(X, Y, X + Width, Y + Height);

  Canvas.Pen.Color := clLime;

  for i := 0 to 99 do
  begin
    Sample := FSamples[(FPosition + i) mod 100];
    BarHeight := Round(Sample * Height);

    Canvas.MoveTo(X + (i * Width div 100), Y + Height);
    Canvas.LineTo(X + (i * Width div 100), Y + Height - BarHeight);
  end;
end;
```

## Int√©gration avec l'interface utilisateur

### Menu des options audio

```pascal
type
  TAudioOptionsMenu = class
  private
    FAudioMgr: TGameAudioManager;
    FMasterSlider: TSlider;
    FMusicSlider: TSlider;
    FSFXSlider: TSlider;
    FVoiceSlider: TSlider;
    FMuteCheckbox: TCheckBox;
  public
    constructor Create(AudioMgr: TGameAudioManager);

    procedure Show;
    procedure Hide;
    procedure Apply;
    procedure Reset;
  end;

procedure TAudioOptionsMenu.Apply;  
begin
  // Appliquer les param√®tres depuis les contr√¥les UI
  FAudioMgr.SetMasterVolume(FMasterSlider.Value / 100);
  FAudioMgr.SetCategoryVolume(acMusic, FMusicSlider.Value / 100);
  FAudioMgr.SetCategoryVolume(acSFX, FSFXSlider.Value / 100);
  FAudioMgr.SetCategoryVolume(acVoice, FVoiceSlider.Value / 100);
  FAudioMgr.Mute(FMuteCheckbox.Checked);

  // Sauvegarder
  FAudioMgr.SaveSettings('audio_settings.txt');
end;

procedure TAudioOptionsMenu.Reset;  
begin
  // R√©initialiser aux valeurs par d√©faut
  FMasterSlider.Value := 100;
  FMusicSlider.Value := 80;
  FSFXSlider.Value := 100;
  FVoiceSlider.Value := 100;
  FMuteCheckbox.Checked := False;

  Apply;
end;
```

### Test de son dans le menu

```pascal
procedure TAudioOptionsMenu.TestSFXSound;  
var
  TestSound: TManagedSound;
begin
  // Charger et jouer un son de test
  TestSound := FAudioMgr.LoadSound('test_sfx.wav', acSFX);
  FAudioMgr.PlaySound(TestSound);

  // Nettoyer apr√®s 2 secondes
  SetTimer(2000, procedure
  begin
    FAudioMgr.UnloadSound(TestSound);
  end);
end;
```

## Gestion des erreurs

### D√©tection des probl√®mes

```pascal
type
  TAudioErrorHandler = class
  public
    class procedure HandleError(const Context: string; Error: HResult);
    class function IsAudioDeviceAvailable: Boolean;
    class procedure ShowErrorDialog(const Message: string);
  end;

class procedure TAudioErrorHandler.HandleError(const Context: string; Error: HResult);  
var
  ErrorMsg: string;
begin
  case Error of
    XAUDIO2_E_INVALID_CALL:
      ErrorMsg := 'Appel invalide √† XAudio2';
    XAUDIO2_E_DEVICE_INVALIDATED:
      ErrorMsg := 'P√©riph√©rique audio invalid√© (d√©branch√©?)';
    E_OUTOFMEMORY:
      ErrorMsg := 'M√©moire insuffisante pour l''audio';
    else
      ErrorMsg := Format('Erreur audio inconnue: 0x%x', [Error]);
  end;

  WriteLn('[ERREUR AUDIO] ', Context, ': ', ErrorMsg);
  ShowErrorDialog(Context + #13#10 + ErrorMsg);
end;

class function TAudioErrorHandler.IsAudioDeviceAvailable: Boolean;  
var
  TestAudio: IXAudio2;
  MasterVoice: IXAudio2MasteringVoice;
begin
  Result := False;

  try
    if Succeeded(XAudio2Create(TestAudio)) then
    begin
      if Succeeded(TestAudio.CreateMasteringVoice(MasterVoice, 2, 44100)) then
      begin
        Result := True;
        MasterVoice.DestroyVoice;
      end;
      TestAudio := nil;
    end;
  except
    Result := False;
  end;
end;
```

### Mode de secours sans audio

```pascal
type
  TAudioSystemWithFallback = class(TGameAudioManager)
  private
    FAudioAvailable: Boolean;
    FDummyMode: Boolean;
  public
    constructor Create; override;

    property AudioAvailable: Boolean read FAudioAvailable;
    property DummyMode: Boolean read FDummyMode;
  end;

constructor TAudioSystemWithFallback.Create;  
begin
  FAudioAvailable := TAudioErrorHandler.IsAudioDeviceAvailable;

  if FAudioAvailable then
  begin
    try
      inherited Create;
      FDummyMode := False;
    except
      on E: Exception do
      begin
        WriteLn('Impossible d''initialiser l''audio: ', E.Message);
        WriteLn('Passage en mode sans audio');
        FDummyMode := True;
        FAudioAvailable := False;
      end;
    end;
  end
  else
  begin
    WriteLn('Aucun p√©riph√©rique audio d√©tect√©');
    FDummyMode := True;
  end;
end;
```

## Performance et profilage

### Mesurer la latence audio

```pascal
type
  TAudioLatencyMeasure = class
  private
    FTriggerTime: QWord;
    FPlayTime: QWord;
    FLatency: Integer;
  public
    procedure TriggerSound;
    procedure OnSoundStart;

    property Latency: Integer read FLatency; // en millisecondes
  end;

procedure TAudioLatencyMeasure.TriggerSound;  
begin
  FTriggerTime := GetTickCount64;
end;

procedure TAudioLatencyMeasure.OnSoundStart;  
begin
  FPlayTime := GetTickCount64;
  FLatency := FPlayTime - FTriggerTime;

  WriteLn(Format('Latence audio: %d ms', [FLatency]));
end;
```

### Statistiques de performance

```pascal
type
  TAudioStats = record
    ActiveVoices: Integer;
    TotalSoundsLoaded: Integer;
    MemoryUsed: Int64;
    CPUUsage: Single;
    AverageLatency: Integer;
  end;

function GetAudioStats(AudioMgr: TGameAudioManager): TAudioStats;  
var
  i: Integer;
begin
  Result.ActiveVoices := 0;
  Result.TotalSoundsLoaded := AudioMgr.Sounds.Count;
  Result.MemoryUsed := 0;

  for i := 0 to AudioMgr.Sounds.Count - 1 do
  begin
    with TManagedSound(AudioMgr.Sounds[i]) do
    begin
      if Sound.IsPlaying then
        Inc(Result.ActiveVoices);

      Inc(Result.MemoryUsed, Sound.AudioSize);
    end;
  end;

  // CPU usage n√©cessiterait un profiler plus sophistiqu√©
  Result.CPUUsage := 0.0;
  Result.AverageLatency := 10; // Estimation
end;
```

## Conseils et bonnes pratiques

### 1. Organisation des fichiers audio

```
sounds/
‚îú‚îÄ‚îÄ music/
‚îÇ   ‚îú‚îÄ‚îÄ menu.wav
‚îÇ   ‚îú‚îÄ‚îÄ level1.wav
‚îÇ   ‚îî‚îÄ‚îÄ boss.wav
‚îú‚îÄ‚îÄ sfx/
‚îÇ   ‚îú‚îÄ‚îÄ jump.wav
‚îÇ   ‚îú‚îÄ‚îÄ coin.wav
‚îÇ   ‚îî‚îÄ‚îÄ explosion.wav
‚îú‚îÄ‚îÄ voice/
‚îÇ   ‚îú‚îÄ‚îÄ intro_fr.wav
‚îÇ   ‚îú‚îÄ‚îÄ intro_en.wav
‚îÇ   ‚îî‚îÄ‚îÄ tutorial.wav
‚îî‚îÄ‚îÄ ambient/
    ‚îú‚îÄ‚îÄ forest.wav
    ‚îî‚îÄ‚îÄ city.wav
```

### 2. Formats recommand√©s

**Pour la musique** :
- OGG Vorbis (compression avec perte, bonne qualit√©)
- Taux d'√©chantillonnage : 44100 Hz
- Bitrate : 128-192 kbps

**Pour les effets sonores** :
- WAV (non compress√©, latence minimale)
- Taux d'√©chantillonnage : 22050 ou 44100 Hz
- 16 bits, mono pour les petits sons

**Pour les voix** :
- WAV ou OGG selon la longueur
- 44100 Hz, 16 bits, mono ou st√©r√©o

### 3. Nommage des fichiers

```
categorie_nom_variation.extension

Exemples:  
sfx_jump_01.wav  
sfx_jump_02.wav  
music_menu_loop.ogg  
voice_tutorial_fr.wav  
ambient_forest_day.wav
```

### 4. Priorit√©s recommand√©es

```pascal
const
  PRIORITY_CRITICAL = 100;  // Dialogue important, sons UI
  PRIORITY_HIGH = 75;       // Effets de gameplay importants
  PRIORITY_NORMAL = 50;     // Effets standards
  PRIORITY_LOW = 25;        // Sons ambiants, d√©tails
  PRIORITY_MINIMAL = 10;    // Peut √™tre ignor√© si trop de sons
```

### 5. Volumes par d√©faut

```pascal
const
  DEFAULT_MASTER_VOLUME = 0.8;
  DEFAULT_MUSIC_VOLUME = 0.7;
  DEFAULT_SFX_VOLUME = 1.0;
  DEFAULT_VOICE_VOLUME = 0.9;
  DEFAULT_AMBIENT_VOLUME = 0.6;
```

## Checklist de d√©veloppement audio

### Avant de commencer

- [ ] Choisir entre DirectSound et XAudio2
- [ ] D√©finir les cat√©gories audio n√©cessaires
- [ ] Planifier l'organisation des fichiers
- [ ] √âtablir les conventions de nommage
- [ ] D√©cider des formats audio √† utiliser

### Pendant le d√©veloppement

- [ ] Impl√©menter le chargement de base
- [ ] Ajouter le contr√¥le du volume
- [ ] Impl√©menter les fondus encha√Æn√©s
- [ ] G√©rer les priorit√©s des sons
- [ ] Ajouter un menu d'options audio
- [ ] Impl√©menter la sauvegarde des param√®tres
- [ ] Tester sur diff√©rents mat√©riels

### Avant la release

- [ ] Tester tous les sons dans le jeu
- [ ] V√©rifier les niveaux de volume
- [ ] Optimiser la m√©moire audio
- [ ] Tester sans p√©riph√©rique audio
- [ ] V√©rifier la latence
- [ ] Valider le menu d'options
- [ ] Tester les transitions audio

## Ressources et outils

### Outils de cr√©ation audio

- **Audacity** : √âditeur audio gratuit et open-source
- **REAPER** : DAW professionnel abordable
- **FMOD Studio** : Middleware audio pour jeux
- **Wwise** : Solution audio professionnelle

### Biblioth√®ques de sons gratuits

- **Freesound.org** : Effets sonores libres
- **OpenGameArt.org** : Sons pour jeux
- **ZapSplat** : Effets sonores gratuits
- **Incompetech** : Musiques libres de droits

### Documentation

- Microsoft DirectSound Documentation
- Microsoft XAudio2 Documentation
- Game Audio Programming Guides
- FreePascal Audio Libraries Wiki

## Conclusion

Le d√©veloppement audio avec DirectSound et XAudio2 sur Windows offre un contr√¥le complet et des performances excellentes pour les jeux FreePascal/Lazarus.

### Points cl√©s √† retenir

‚úÖ **DirectSound** : Simple et compatible, id√©al pour d√©buter  
‚úÖ **XAudio2** : Moderne et performant, pour les jeux avanc√©s  
‚úÖ **Gestion des cat√©gories** : Organiser les sons par type  
‚úÖ **Priorit√©s** : G√©rer intelligemment les sons simultan√©s  
‚úÖ **Streaming** : Pour les fichiers volumineux (musique)  
‚úÖ **Effets** : Reverb, filtres pour l'immersion  
‚úÖ **Options utilisateur** : Menu complet de contr√¥le audio  
‚úÖ **Performance** : Optimiser m√©moire et CPU  
‚úÖ **Gestion d'erreurs** : Mode de secours sans audio

### L'audio fait le jeu

Un bon syst√®me audio peut transformer un jeu correct en une exp√©rience m√©morable. Avec FreePascal et les API Windows, vous avez tous les outils n√©cessaires pour cr√©er une ambiance sonore professionnelle.

N'oubliez pas : testez votre audio sur diff√©rents mat√©riels, offrez des options de personnalisation aux joueurs, et surtout, assurez-vous que vos sons contribuent au gameplay plut√¥t que de le distraire.

Bon d√©veloppement audio ! üéµüéÆ


‚è≠Ô∏è [ALSA/PulseAudio (Linux)](/23-developpement-jeux/04.2-alsa-pulseaudio-linux.md)
