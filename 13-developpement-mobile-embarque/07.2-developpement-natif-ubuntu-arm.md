ğŸ” Retour au [Sommaire](/SOMMAIRE.md)

# 13.7.2 DÃ©veloppement natif sur Ubuntu ARM

## Introduction

Le **dÃ©veloppement natif sur Ubuntu ARM** consiste Ã  programmer directement sur le Raspberry Pi ou tout autre systÃ¨me Ubuntu fonctionnant sur architecture ARM. Contrairement Ã  la cross-compilation, le code est compilÃ© et testÃ© sur la mÃªme machine, ce qui simplifie le workflow de dÃ©veloppement.

Cette approche est particuliÃ¨rement adaptÃ©e aux **projets Ã©ducatifs**, au **prototypage rapide** et aux dÃ©veloppeurs qui prÃ©fÃ¨rent travailler directement sur la plateforme cible.

### Avantages du dÃ©veloppement natif

âœ… **SimplicitÃ©** : Pas de configuration de cross-compilateur  
âœ… **DÃ©bogage facile** : ExÃ©cution et debug immÃ©diats  
âœ… **Tests directs** : AccÃ¨s immÃ©diat au matÃ©riel (GPIO, capteurs)  
âœ… **CompatibilitÃ© garantie** : Pas de surprises lors du dÃ©ploiement  
âœ… **Apprentissage** : IdÃ©al pour comprendre le systÃ¨me

### InconvÃ©nients

âš ï¸ **Performances** : Compilation plus lente qu'sur un PC  
âš ï¸ **Ressources limitÃ©es** : RAM et CPU moins puissants  
âš ï¸ **Confort** : Ã‰cran et clavier potentiellement plus petits  
âš ï¸ **Temps de compilation** : Projets volumineux peuvent Ãªtre longs

## Configuration matÃ©rielle recommandÃ©e

### Configuration minimale

- **Raspberry Pi 3B+** ou supÃ©rieur
- **2 GB de RAM** minimum (4 GB recommandÃ©)
- **Carte SD 16 GB** minimum (32 GB recommandÃ©, classe 10)
- **Alimentation** : 5V 3A minimum
- **Refroidissement** : Dissipateur thermique ou ventilateur

### Configuration optimale pour le dÃ©veloppement

- **Raspberry Pi 4 (4 GB)** ou **Raspberry Pi 5 (8 GB)**
- **Carte SD 64 GB** UHS-I U3 ou **SSD via USB 3.0**
- **Clavier et souris USB** de qualitÃ©
- **Ã‰cran 1080p** minimum
- **Ventilateur actif** pour Ã©viter le throttling
- **Connexion Ethernet** pour la stabilitÃ© rÃ©seau

> ğŸ’¡ **Astuce** : Utiliser un SSD USB au lieu d'une carte SD amÃ©liore drastiquement les performances de compilation !

## Installation d'Ubuntu sur Raspberry Pi

### Choix de la version Ubuntu

Ubuntu propose plusieurs versions pour Raspberry Pi :

| Version | Description | Usage recommandÃ© |
|---------|-------------|------------------|
| **Ubuntu Server 22.04 LTS (64-bit)** | Sans interface graphique | Serveurs, headless |
| **Ubuntu Desktop 22.04 LTS (64-bit)** | Interface graphique complÃ¨te | DÃ©veloppement avec IDE |
| **Ubuntu Server 24.04 LTS (64-bit)** | Version la plus rÃ©cente | Projets nouveaux |

> ğŸ“Œ **Recommandation** : Pour le dÃ©veloppement avec Lazarus, utilisez **Ubuntu Desktop 22.04 LTS 64-bit**.

### Installation Ã©tape par Ã©tape

#### Ã‰tape 1 : TÃ©lÃ©charger Ubuntu

```bash
# Sur votre PC, tÃ©lÃ©charger l'image depuis :
# https://ubuntu.com/download/raspberry-pi

# Version recommandÃ©e :
ubuntu-22.04.3-preinstalled-desktop-arm64+raspi.img.xz
```

#### Ã‰tape 2 : Flasher la carte SD

**Sur Windows** (avec Raspberry Pi Imager) :

1. TÃ©lÃ©charger **Raspberry Pi Imager** : https://www.raspberrypi.com/software/
2. InsÃ©rer la carte SD
3. Lancer Raspberry Pi Imager
4. Choisir l'OS : "Other general-purpose OS" â†’ "Ubuntu" â†’ "Ubuntu Desktop 22.04 LTS (64-bit)"
5. Choisir la carte SD
6. Cliquer sur "Write"

**Sur Linux/macOS** (ligne de commande) :

```bash
# DÃ©compresser l'image
unxz ubuntu-22.04.3-preinstalled-desktop-arm64+raspi.img.xz

# Identifier la carte SD
lsblk

# Flasher (remplacer /dev/sdX par votre carte SD)
sudo dd if=ubuntu-22.04.3-preinstalled-desktop-arm64+raspi.img of=/dev/sdX bs=4M status=progress
sync
```

#### Ã‰tape 3 : Premier dÃ©marrage

1. InsÃ©rer la carte SD dans le Raspberry Pi
2. Brancher clavier, souris, Ã©cran
3. Brancher l'alimentation
4. Attendre le dÃ©marrage (peut prendre 3-5 minutes au premier boot)
5. Suivre l'assistant de configuration :
   - Langue : FranÃ§ais
   - Clavier : FranÃ§ais
   - Nom d'utilisateur : votre_nom
   - Mot de passe : (crÃ©er un mot de passe sÃ©curisÃ©)
   - WiFi : (configurer si nÃ©cessaire)

#### Ã‰tape 4 : Mise Ã  jour du systÃ¨me

```bash
# Une fois connectÃ©, ouvrir un terminal (Ctrl+Alt+T)

# Mettre Ã  jour la liste des paquets
sudo apt update

# Mettre Ã  niveau le systÃ¨me
sudo apt upgrade -y

# RedÃ©marrer
sudo reboot
```

## Installation de FreePascal et Lazarus

### MÃ©thode 1 : Installation depuis les dÃ©pÃ´ts officiels (la plus simple)

```bash
# Mise Ã  jour du systÃ¨me
sudo apt update

# Installation de FreePascal
sudo apt install fpc -y

# Installation de Lazarus (IDE complet)
sudo apt install lazarus lazarus-ide -y

# VÃ©rification de l'installation
fpc -version
```

**Versions typiques installÃ©es** :
- FreePascal : 3.2.2
- Lazarus : 2.2.0 ou 2.2.2

Cette mÃ©thode est la plus simple mais installe des versions lÃ©gÃ¨rement anciennes.

### MÃ©thode 2 : Installation via FpcUpDeluxe (versions les plus rÃ©centes)

FpcUpDeluxe permet d'obtenir les derniÃ¨res versions de FreePascal et Lazarus.

```bash
# Installer les dÃ©pendances
sudo apt install build-essential git subversion -y
sudo apt install libgtk2.0-dev libx11-dev libgdk-pixbuf2.0-dev -y

# CrÃ©er un dossier pour FpcUpDeluxe
mkdir -p ~/fpcupdeluxe
cd ~/fpcupdeluxe

# TÃ©lÃ©charger FpcUpDeluxe
wget https://github.com/LongDirtyAnimAlf/fpcupdeluxe/releases/download/2.4.0g/fpcupdeluxe-aarch64-linux

# Rendre exÃ©cutable
chmod +x fpcupdeluxe-aarch64-linux

# Lancer FpcUpDeluxe
./fpcupdeluxe-aarch64-linux
```

**Configuration dans FpcUpDeluxe** :

1. Premier lancement : choisir le dossier d'installation (ex: `/home/votre_nom/fpcupdeluxe`)
2. Cliquer sur **"Install/Update FPC + Lazarus"**
3. Attendre la compilation (30-60 minutes sur Raspberry Pi 4)
4. Une fois terminÃ©, Lazarus est disponible dans le menu d'applications

### MÃ©thode 3 : Compilation depuis les sources (utilisateurs avancÃ©s)

```bash
# Installer les dÃ©pendances complÃ¨tes
sudo apt install build-essential subversion git -y
sudo apt install libgtk2.0-dev libcairo2-dev libpango1.0-dev -y
sudo apt install libgdk-pixbuf2.0-dev libatk1.0-dev libghc-x11-dev -y

# CrÃ©er un dossier de travail
mkdir -p ~/sources
cd ~/sources

# TÃ©lÃ©charger FreePascal stable
svn checkout https://svn.freepascal.org/svn/fpc/tags/release_3_2_2 fpc-3.2.2
cd fpc-3.2.2

# Compiler FreePascal (60-90 minutes)
make clean
make all
sudo make install

# CrÃ©er les liens symboliques
sudo ln -sf /usr/local/lib/fpc/3.2.2/ppcaarch64 /usr/local/bin/ppcaarch64

# TÃ©lÃ©charger Lazarus
cd ~/sources
svn checkout https://svn.freepascal.org/svn/lazarus/tags/lazarus_2_2_6 lazarus-2.2.6
cd lazarus-2.2.6

# Compiler Lazarus (45-60 minutes)
make clean
make all

# Installer
sudo make install

# CrÃ©er un lanceur sur le bureau
cat > ~/Desktop/lazarus.desktop << EOF
[Desktop Entry]
Name=Lazarus
Comment=Lazarus IDE
Exec=/usr/local/bin/lazarus
Icon=/usr/local/share/lazarus/images/lazarus.png
Terminal=false
Type=Application
Categories=Development;IDE;
EOF

chmod +x ~/Desktop/lazarus.desktop
```

> âš ï¸ **Attention** : La compilation complÃ¨te peut prendre 2-3 heures sur un Raspberry Pi 3. Surveillez la tempÃ©rature du CPU !

## Configuration de l'environnement de dÃ©veloppement

### Configuration de Lazarus IDE

#### Premier lancement

```bash
# Lancer Lazarus
lazarus-ide
```

Lors du premier lancement :

1. **Configuration du compilateur** :
   - Lazarus dÃ©tecte automatiquement FPC
   - VÃ©rifier dans `Outils` â†’ `Options` â†’ `Compilateur`
   - Chemin FPC : `/usr/bin/fpc` ou `/usr/local/bin/fpc`

2. **Configuration du dÃ©bogueur** :
   - `Outils` â†’ `Options` â†’ `DÃ©bogueur`
   - Type : `GNU debugger (gdb)`
   - Chemin : `/usr/bin/gdb`

3. **Optimiser les performances de l'IDE** :
   - `Outils` â†’ `Options` â†’ `Environnement`
   - DÃ©sactiver "Code Tools" si l'IDE est lent
   - RÃ©duire les options de "Code Completion"

#### Configuration recommandÃ©e pour Raspberry Pi

```bash
# Fichier : ~/.lazarus/environmentoptions.xml
# (Ã©ditÃ© automatiquement via l'IDE)

# Options importantes :
# - Compiler en mode Release par dÃ©faut pour les tests
# - DÃ©sactiver les animations de l'IDE
# - Limiter l'historique des fichiers rÃ©cents Ã  10
```

**Dans Lazarus** :

1. `Outils` â†’ `Options` â†’ `Ã‰diteur` :
   - Police : Monospace 10
   - DÃ©sactiver les animations
   - Activer la coloration syntaxique lÃ©gÃ¨re

2. `Projet` â†’ `Options du projet` â†’ `Compilation` :
   - Mode par dÃ©faut : Release
   - Optimisation : `-O2`

### Configuration des variables d'environnement

Ajouter ces lignes Ã  `~/.bashrc` :

```bash
# Ouvrir le fichier
nano ~/.bashrc

# Ajouter Ã  la fin :
# FreePascal et Lazarus
export PATH=$PATH:/usr/local/lib/fpc/3.2.2
export FPCDIR=/usr/local/lib/fpc/3.2.2
export LAZARUSDIR=/usr/local/share/lazarus

# Activer les modifications
source ~/.bashrc
```

## Premier programme en dÃ©veloppement natif

### Programme console simple

CrÃ©er un fichier `hello_native.pas` :

```pascal
program HelloNative;

{$mode objfpc}{$H+}

uses
  SysUtils, BaseUnix;

procedure DisplaySystemInfo;
var
  utsname: UtsName;
begin
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn('  DÃ©veloppement natif FreePascal sur Ubuntu ARM');
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn;

  // Informations systÃ¨me
  if fpUname(utsname) = 0 then
  begin
    WriteLn('SystÃ¨me    : ', utsname.sysname);
    WriteLn('Nom        : ', utsname.nodename);
    WriteLn('Version    : ', utsname.release);
    WriteLn('Machine    : ', utsname.machine);
    WriteLn;
  end;

  // Informations de compilation
  WriteLn('CompilÃ© avec :');
  WriteLn('  - FreePascal : ', {$I %FPCVERSION%});
  WriteLn('  - Architecture : ', {$I %FPCTARGET%});
  WriteLn('  - Date : ', {$I %DATE%}, ' ', {$I %TIME%});
  WriteLn;

  // Taille des types
  WriteLn('Tailles des types :');
  WriteLn('  - Integer    : ', SizeOf(Integer), ' octets');
  WriteLn('  - Pointer    : ', SizeOf(Pointer), ' octets');
  WriteLn('  - NativeInt  : ', SizeOf(NativeInt), ' octets');
  WriteLn('  - Real       : ', SizeOf(Real), ' octets');
  WriteLn;

  WriteLn('Date/Heure : ', FormatDateTime('dd/mm/yyyy hh:nn:ss', Now));
  WriteLn;
  WriteLn('DÃ©veloppement natif ARM : Actif âœ“');
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
end;

begin
  DisplaySystemInfo;
end.
```

### Compilation et exÃ©cution

```bash
# Compiler
fpc -O2 hello_native.pas

# Rendre exÃ©cutable (si nÃ©cessaire)
chmod +x hello_native

# ExÃ©cuter
./hello_native
```

**Sortie attendue** :

```
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  DÃ©veloppement natif FreePascal sur Ubuntu ARM
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SystÃ¨me    : Linux
Nom        : ubuntu
Version    : 5.15.0-1048-raspi
Machine    : aarch64

CompilÃ© avec :
  - FreePascal : 3.2.2
  - Architecture : aarch64-linux
  - Date : 2025/10/03 16:30:00

Tailles des types :
  - Integer    : 4 octets
  - Pointer    : 8 octets
  - NativeInt  : 8 octets
  - Real       : 8 octets

Date/Heure : 03/10/2025 16:30:15

DÃ©veloppement natif ARM : Actif âœ“
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## Application graphique avec Lazarus

### CrÃ©ation d'un projet simple

1. **Lancer Lazarus** : `lazarus-ide`

2. **Nouveau projet** :
   - `Projet` â†’ `Nouveau projet...`
   - SÃ©lectionner `Application`
   - Cliquer sur `OK`

3. **Configurer le formulaire** :
   - PropriÃ©tÃ© `Caption` : "Application native Ubuntu ARM"
   - PropriÃ©tÃ© `Width` : 600
   - PropriÃ©tÃ© `Height` : 400

4. **Ajouter des composants** :

   **TLabel** (Information) :
   - `Name` : `lblInfo`
   - `Caption` : "Surveillance systÃ¨me Raspberry Pi"
   - `Font.Size` : 14
   - `Font.Style` : `[fsBold]`

   **TLabel** (TempÃ©rature) :
   - `Name` : `lblTemp`
   - `Caption` : "TempÃ©rature : --Â°C"

   **TLabel** (MÃ©moire) :
   - `Name` : `lblMemory`
   - `Caption` : "MÃ©moire : --"

   **TTimer** :
   - `Name` : `tmrUpdate`
   - `Interval` : 1000 (1 seconde)
   - `Enabled` : True

   **TButton** :
   - `Name` : `btnQuit`
   - `Caption` : "Quitter"

### Code de l'application

Double-cliquer sur `tmrUpdate` et ajouter :

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, StdCtrls, ExtCtrls;

type
  TForm1 = class(TForm)
    btnQuit: TButton;
    lblInfo: TLabel;
    lblTemp: TLabel;
    lblMemory: TLabel;
    tmrUpdate: TTimer;
    procedure btnQuitClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure tmrUpdateTimer(Sender: TObject);
  private
    function GetCPUTemp: Double;
    function GetMemoryInfo: string;
  public
  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

function TForm1.GetCPUTemp: Double;
var
  f: TextFile;
  tempStr: string;
begin
  Result := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    try
      AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
      Reset(f);
      ReadLn(f, tempStr);
      CloseFile(f);
      Result := StrToInt(tempStr) / 1000.0;
    except
      Result := 0.0;
    end;
  end;
end;

function TForm1.GetMemoryInfo: string;
var
  f: TextFile;
  line: string;
  memTotal, memAvailable: Int64;
begin
  Result := 'N/A';
  memTotal := 0;
  memAvailable := 0;

  if FileExists('/proc/meminfo') then
  begin
    try
      AssignFile(f, '/proc/meminfo');
      Reset(f);

      while not Eof(f) do
      begin
        ReadLn(f, line);
        if Pos('MemTotal:', line) > 0 then
          memTotal := StrToInt64Def(ExtractWord(2, line, [' ']), 0);
        if Pos('MemAvailable:', line) > 0 then
          memAvailable := StrToInt64Def(ExtractWord(2, line, [' ']), 0);
      end;

      CloseFile(f);

      Result := Format('%d MB libres / %d MB total',
        [memAvailable div 1024, memTotal div 1024]);
    except
      Result := 'Erreur lecture';
    end;
  end;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  Caption := 'Surveillance Raspberry Pi - Ubuntu ARM';
  Color := clWhite;

  lblInfo.Font.Color := clNavy;
  lblInfo.Top := 20;
  lblInfo.Left := 20;

  lblTemp.Top := 80;
  lblTemp.Left := 20;
  lblTemp.Font.Size := 12;

  lblMemory.Top := 120;
  lblMemory.Left := 20;
  lblMemory.Font.Size := 12;

  btnQuit.Top := 200;
  btnQuit.Left := 20;
  btnQuit.Width := 100;
end;

procedure TForm1.tmrUpdateTimer(Sender: TObject);
var
  temp: Double;
begin
  temp := GetCPUTemp;

  lblTemp.Caption := Format('ğŸŒ¡ï¸  TempÃ©rature CPU : %.1fÂ°C', [temp]);

  if temp > 80 then
    lblTemp.Font.Color := clRed
  else if temp > 70 then
    lblTemp.Font.Color := clMaroon
  else
    lblTemp.Font.Color := clGreen;

  lblMemory.Caption := 'ğŸ’¾ MÃ©moire : ' + GetMemoryInfo;
end;

procedure TForm1.btnQuitClick(Sender: TObject);
begin
  Close;
end;

end.
```

### Compilation dans Lazarus

1. **Enregistrer le projet** : `Projet` â†’ `Enregistrer le projet sous...`
   - Nom : `SystemMonitor.lpi`

2. **Compiler** : `ExÃ©cuter` â†’ `Compiler` (ou `Ctrl+F9`)

3. **ExÃ©cuter** : `ExÃ©cuter` â†’ `ExÃ©cuter` (ou `F9`)

## Optimisation des performances

### Options de compilation pour ARM

#### Dans Lazarus IDE

`Projet` â†’ `Options du projet` â†’ `Options du compilateur` :

```
Options personnalisÃ©es :
-O3 -CpARMV8 -CfVFPV3
```

#### En ligne de commande

```bash
# Optimisation standard
fpc -O2 monprogramme.pas

# Optimisation maximale pour ARM
fpc -O3 -CpARMV8 -CfVFPV3 monprogramme.pas

# Optimisation de taille
fpc -O3 -Xs -XX monprogramme.pas
```

### Fichier de configuration projet

CrÃ©er `fpc.cfg` dans le dossier du projet :

```ini
# Configuration pour Raspberry Pi natif
# Ubuntu ARM 64-bit

# Optimisations ARM
-O3
-CpARMV8
-CfVFPV3

# Optimisations gÃ©nÃ©rales
-OoREGVAR
-OoSTACKFRAME
-Xs

# Chemins standards Ubuntu
-Fu/usr/lib/fpc/$fpcversion/units/$fpctarget
-Fu/usr/share/lazarus/$lazarusversion/lcl/units/$fpctarget
-Fu/usr/share/lazarus/$lazarusversion/components/*/lib/$fpctarget

# Messages
-viwn
```

### Utiliser un SSD pour amÃ©liorer les performances

```bash
# VÃ©rifier les pÃ©riphÃ©riques
lsblk

# Formater le SSD USB (exemple : /dev/sda)
sudo mkfs.ext4 /dev/sda1

# CrÃ©er un point de montage
sudo mkdir /mnt/ssd

# Monter le SSD
sudo mount /dev/sda1 /mnt/ssd

# CrÃ©er un dossier de projets
sudo mkdir /mnt/ssd/projets
sudo chown $USER:$USER /mnt/ssd/projets

# DÃ©placer les projets
mv ~/projets/* /mnt/ssd/projets/

# Montage automatique au dÃ©marrage
echo "/dev/sda1 /mnt/ssd ext4 defaults 0 2" | sudo tee -a /etc/fstab
```

**Gain de performance** : Compilation jusqu'Ã  3x plus rapide avec un SSD !

## AccÃ¨s aux ressources matÃ©rielles

### GPIO (General Purpose Input/Output)

Installation de la bibliothÃ¨que WiringPi :

```bash
# Installer WiringPi
sudo apt install wiringpi -y

# Tester
gpio -v
gpio readall
```

**Exemple FreePascal** :

```pascal
program GPIOTest;

{$mode objfpc}{$H+}

uses
  SysUtils, Process;

function ExecuteCommand(const cmd: string): string;
var
  proc: TProcess;
  output: TStringList;
begin
  proc := TProcess.Create(nil);
  output := TStringList.Create;
  try
    proc.CommandLine := cmd;
    proc.Options := [poWaitOnExit, poUsePipes];
    proc.Execute;
    output.LoadFromStream(proc.Output);
    Result := output.Text;
  finally
    output.Free;
    proc.Free;
  end;
end;

procedure SetGPIOPin(pin: Integer; value: Boolean);
var
  cmd: string;
begin
  // Configurer en sortie
  cmd := Format('gpio -g mode %d out', [pin]);
  ExecuteCommand(cmd);

  // DÃ©finir la valeur
  if value then
    cmd := Format('gpio -g write %d 1', [pin])
  else
    cmd := Format('gpio -g write %d 0', [pin]);

  ExecuteCommand(cmd);
end;

begin
  WriteLn('Test GPIO - Clignotement LED');
  WriteLn('LED sur GPIO 17');
  WriteLn;

  WriteLn('Appuyez sur Ctrl+C pour arrÃªter');

  repeat
    WriteLn('LED ON');
    SetGPIOPin(17, True);
    Sleep(1000);

    WriteLn('LED OFF');
    SetGPIOPin(17, False);
    Sleep(1000);
  until False;
end.
```

### AccÃ¨s I2C

```bash
# Activer I2C
sudo raspi-config
# Interface Options â†’ I2C â†’ Enable

# Installer les outils
sudo apt install i2c-tools -y

# DÃ©tecter les pÃ©riphÃ©riques I2C
i2cdetect -y 1
```

### Communication sÃ©rie

```pascal
program SerialTest;

{$mode objfpc}{$H+}

uses
  SysUtils, Serial;

var
  ser: TSerialHandle;
  buffer: array[0..255] of Char;
  bytesRead: Integer;

begin
  // Ouvrir le port sÃ©rie
  ser := SerOpen('/dev/ttyAMA0');

  if ser < 0 then
  begin
    WriteLn('Erreur : Impossible d''ouvrir le port sÃ©rie');
    Exit;
  end;

  try
    // Configurer : 9600 bauds, 8N1
    SerSetParams(ser, 9600, 8, NoneParity, 1, []);

    WriteLn('Port sÃ©rie ouvert. Lecture en cours...');

    while True do
    begin
      bytesRead := SerRead(ser, buffer, SizeOf(buffer));
      if bytesRead > 0 then
        Write(Copy(buffer, 0, bytesRead));
      Sleep(100);
    end;
  finally
    SerClose(ser);
  end;
end.
```

## Gestion de projets complexes

### Structure de projet recommandÃ©e

```
MonProjetARM/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.pas
â”‚   â”œâ”€â”€ units/
â”‚   â”‚   â”œâ”€â”€ sensors.pas
â”‚   â”‚   â”œâ”€â”€ gpio_helper.pas
â”‚   â”‚   â””â”€â”€ network.pas
â”‚   â””â”€â”€ forms/
â”‚       â”œâ”€â”€ mainform.pas
â”‚       â””â”€â”€ settingsform.pas
â”œâ”€â”€ lib/              # BibliothÃ¨ques compilÃ©es (.o, .ppu)
â”œâ”€â”€ bin/              # ExÃ©cutables
â”œâ”€â”€ config/
â”‚   â””â”€â”€ app.ini
â”œâ”€â”€ docs/
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ build.sh          # Script de compilation
â””â”€â”€ MonProjet.lpi     # Fichier projet Lazarus
```

### Script de compilation automatisÃ©e

CrÃ©er `build.sh` :

```bash
#!/bin/bash

# Script de compilation pour projet ARM natif

PROJECT_NAME="MonProjet"
SOURCE_DIR="src"
OUTPUT_DIR="bin"
LIB_DIR="lib"

# Couleurs
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "  Compilation de $PROJECT_NAME"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# CrÃ©er les dossiers si nÃ©cessaires
mkdir -p $OUTPUT_DIR
mkdir -p $LIB_DIR

# Options de compilation
FPC_OPTIONS="-O3 -CpARMV8 -CfVFPV3 -Fu$LIB_DIR"

echo -e "${YELLOW}[1/3]${NC} Nettoyage..."
rm -f $LIB_DIR/*.o $LIB_DIR/*.ppu
rm -f $OUTPUT_DIR/$PROJECT_NAME
echo -e "${GREEN}âœ“${NC} Nettoyage terminÃ©"
echo ""

echo -e "${YELLOW}[2/3]${NC} Compilation..."
fpc $FPC_OPTIONS $SOURCE_DIR/main.pas -o$OUTPUT_DIR/$PROJECT_NAME

if [ $? -eq 0 ]; then
    echo -e "${GREEN}âœ“${NC} Compilation rÃ©ussie"
else
    echo -e "${RED}âœ—${NC} Erreur de compilation"
    exit 1
fi

echo ""
echo -e "${YELLOW}[3/3]${NC} Informations..."
FILE_SIZE=$(du -h $OUTPUT_DIR/$PROJECT_NAME | cut -f1)
echo "  Taille de l'exÃ©cutable : $FILE_SIZE"
echo ""

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo -e "${GREEN}  COMPILATION TERMINÃ‰E${NC}"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "Pour exÃ©cuter : ./$OUTPUT_DIR/$PROJECT_NAME"
```

Rendre le script exÃ©cutable :

```bash
chmod +x build.sh
./build.sh
```

## DÃ©bogage natif

### Utilisation de GDB

```bash
# Compiler avec symboles de dÃ©bogage
fpc -g -gl monprogramme.pas

# Lancer avec GDB
gdb ./monprogramme
```

**Commandes GDB utiles** :

```gdb
(gdb) run                    # ExÃ©cuter le programme
(gdb) break main             # Point d'arrÃªt sur main
(gdb) break 42               # Point d'arrÃªt ligne 42
(gdb) next                   # Ligne suivante
(gdb) step                   # Entrer dans la fonction
(gdb) print variable         # Afficher une variable
(gdb) continue               # Continuer l'exÃ©cution
(gdb) quit                   # Quitter GDB
```

### DÃ©bogage dans Lazarus

1. **Compiler en mode Debug** :
   - `Projet` â†’ `Options du projet`
   - `Compilation` â†’ Mode : `Debug`
   - Options : `-g -gl`

2. **Placer des points d'arrÃªt** :
   - Cliquer dans la marge gauche de l'Ã©diteur
   - La ligne devient rouge avec un point

3. **Lancer le dÃ©bogueur** :
   - `ExÃ©cuter` â†’ `ExÃ©cuter` (F9)
   - Le programme s'arrÃªte au premier point d'arrÃªt

4. **Inspecter les variables** :
   - FenÃªtre `Vue` â†’ `FenÃªtres de dÃ©bogage` â†’ `Variables locales`
   - Survoler une variable avec la souris pour voir sa valeur
   - FenÃªtre `Espions` pour surveiller des variables spÃ©cifiques

5. **ContrÃ´les de dÃ©bogage** :
   - `F7` : Pas Ã  pas (Step Into) - Entre dans les fonctions
   - `F8` : Pas Ã  pas (Step Over) - Saute les fonctions
   - `F9` : Continuer jusqu'au prochain point d'arrÃªt
   - `Ctrl+F2` : ArrÃªter le dÃ©bogage

### DÃ©bogage avec messages de log

Pour un dÃ©bogage simple sans GDB :

```pascal
program DebugExample;

{$mode objfpc}{$H+}

uses
  SysUtils;

const
  LOG_FILE = '/tmp/myapp.log';

procedure Log(const msg: string);
var
  f: TextFile;
begin
  AssignFile(f, LOG_FILE);
  if FileExists(LOG_FILE) then
    Append(f)
  else
    Rewrite(f);

  WriteLn(f, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', msg);
  CloseFile(f);

  // Afficher aussi dans la console
  WriteLn('[LOG] ', msg);
end;

procedure TestFunction(value: Integer);
begin
  Log('EntrÃ©e dans TestFunction avec valeur: ' + IntToStr(value));

  // Traitement
  value := value * 2;

  Log('Valeur aprÃ¨s traitement: ' + IntToStr(value));
end;

begin
  Log('=== DÃ©marrage de l''application ===');

  try
    Log('Test 1');
    TestFunction(10);

    Log('Test 2');
    TestFunction(20);

    Log('=== Application terminÃ©e avec succÃ¨s ===');
  except
    on E: Exception do
      Log('ERREUR: ' + E.Message);
  end;
end.
```

**Visualiser les logs** :

```bash
# Voir les logs en temps rÃ©el
tail -f /tmp/myapp.log

# Voir les derniÃ¨res lignes
tail -n 50 /tmp/myapp.log

# Rechercher dans les logs
grep "ERREUR" /tmp/myapp.log
```

## Optimisation pour Raspberry Pi

### Surveillance des performances

#### Script de monitoring pendant la compilation

```bash
#!/bin/bash
# monitor.sh - Surveiller le systÃ¨me pendant la compilation

LOG_FILE="perf_log.txt"

echo "=== Monitoring systÃ¨me ===" > $LOG_FILE
echo "Date: $(date)" >> $LOG_FILE
echo "" >> $LOG_FILE

# Boucle de monitoring
while true; do
    # TempÃ©rature
    TEMP=$(cat /sys/class/thermal/thermal_zone0/temp)
    TEMP_C=$(echo "scale=1; $TEMP/1000" | bc)

    # CPU
    CPU=$(top -bn1 | grep "Cpu(s)" | sed "s/.*, *\([0-9.]*\)%* id.*/\1/" | awk '{print 100 - $1}')

    # MÃ©moire
    MEM=$(free -m | awk 'NR==2{printf "%.1f%%", $3*100/$2 }')

    # Afficher et enregistrer
    OUTPUT="$(date +%H:%M:%S) - CPU: ${CPU}% | Temp: ${TEMP_C}Â°C | Mem: ${MEM}"
    echo $OUTPUT
    echo $OUTPUT >> $LOG_FILE

    sleep 2
done
```

**Utilisation** :

```bash
# Terminal 1 : Monitoring
chmod +x monitor.sh
./monitor.sh

# Terminal 2 : Compilation
fpc -O3 gros_projet.pas
```

### Refroidissement et throttling

#### VÃ©rifier le throttling

```pascal
program CheckThrottling;

{$mode objfpc}{$H+}

uses
  SysUtils, Process;

function GetThrottleStatus: string;
var
  proc: TProcess;
  output: TStringList;
  hexValue: string;
  throttleCode: Int64;
begin
  proc := TProcess.Create(nil);
  output := TStringList.Create;
  try
    proc.CommandLine := 'vcgencmd get_throttled';
    proc.Options := [poWaitOnExit, poUsePipes];
    proc.Execute;
    output.LoadFromStream(proc.Output);

    if output.Count > 0 then
    begin
      // RÃ©sultat format: "throttled=0x50000"
      hexValue := output[0];
      Delete(hexValue, 1, Pos('x', hexValue));

      try
        throttleCode := StrToInt64('$' + hexValue);

        Result := 'Ã‰tat du systÃ¨me:' + LineEnding;

        if (throttleCode and $1) <> 0 then
          Result := Result + '  âš ï¸  Sous-tension dÃ©tectÃ©e' + LineEnding;
        if (throttleCode and $2) <> 0 then
          Result := Result + '  âš ï¸  Limitation ARM frÃ©quence' + LineEnding;
        if (throttleCode and $4) <> 0 then
          Result := Result + '  âš ï¸  Limitation en cours (throttling)' + LineEnding;
        if (throttleCode and $8) <> 0 then
          Result := Result + '  âš ï¸  Limitation tempÃ©rature' + LineEnding;

        if throttleCode = 0 then
          Result := '  âœ“ Aucun problÃ¨me dÃ©tectÃ©' + LineEnding;

        // Historique
        if (throttleCode and $10000) <> 0 then
          Result := Result + '  â„¹ï¸  Sous-tension (historique)' + LineEnding;
        if (throttleCode and $20000) <> 0 then
          Result := Result + '  â„¹ï¸  Limitation ARM (historique)' + LineEnding;
        if (throttleCode and $40000) <> 0 then
          Result := Result + '  â„¹ï¸  Throttling (historique)' + LineEnding;
        if (throttleCode and $80000) <> 0 then
          Result := Result + '  â„¹ï¸  Limitation temp. (historique)' + LineEnding;
      except
        Result := 'Erreur de lecture';
      end;
    end
    else
      Result := 'Commande non disponible';
  finally
    output.Free;
    proc.Free;
  end;
end;

function GetCPUFrequency: string;
var
  proc: TProcess;
  output: TStringList;
begin
  proc := TProcess.Create(nil);
  output := TStringList.Create;
  try
    proc.CommandLine := 'vcgencmd measure_clock arm';
    proc.Options := [poWaitOnExit, poUsePipes];
    proc.Execute;
    output.LoadFromStream(proc.Output);

    if output.Count > 0 then
    begin
      // Format: "frequency(48)=600000000"
      Result := output[0];
      Delete(Result, 1, Pos('=', Result));
      Result := IntToStr(StrToInt64(Result) div 1000000) + ' MHz';
    end
    else
      Result := 'N/A';
  finally
    output.Free;
    proc.Free;
  end;
end;

function GetCPUTemp: Double;
var
  f: TextFile;
  temp: string;
begin
  Result := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, temp);
    CloseFile(f);
    Result := StrToInt(temp) / 1000.0;
  end;
end;

begin
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn('  Diagnostic Raspberry Pi - Performance');
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn;

  WriteLn('TempÃ©rature CPU : ', GetCPUTemp:0:1, 'Â°C');
  WriteLn('FrÃ©quence CPU   : ', GetCPUFrequency);
  WriteLn;
  WriteLn(GetThrottleStatus);
  WriteLn;

  if GetCPUTemp > 75 then
  begin
    WriteLn('âš ï¸  ATTENTION : TempÃ©rature Ã©levÃ©e !');
    WriteLn('   Recommandations :');
    WriteLn('   - Ajouter un dissipateur thermique');
    WriteLn('   - Ajouter un ventilateur');
    WriteLn('   - AmÃ©liorer la ventilation');
  end;

  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
end.
```

### Conseils pour Ã©viter le throttling

```bash
# 1. Installer un ventilateur (recommandÃ©)
# Connexion GPIO : 5V, GND

# 2. Ajouter un dissipateur thermique

# 3. AmÃ©liorer la ventilation du boÃ®tier

# 4. RÃ©duire la charge pendant la compilation
# Fermer les applications inutiles
# Compiler en mode normal (-O2) plutÃ´t que maximal (-O3)

# 5. Overclocker avec prÃ©caution (avancÃ©)
sudo nano /boot/firmware/config.txt
# Ajouter (Raspberry Pi 4 uniquement) :
# over_voltage=6
# arm_freq=2000
```

## DÃ©veloppement de services et daemons

### CrÃ©ation d'un service systemd natif

#### Programme principal (daemon_example.pas)

```pascal
program DaemonExample;

{$mode objfpc}{$H+}

uses
  SysUtils, BaseUnix, Unix;

const
  LOG_FILE = '/var/log/mydaemon.log';
  PID_FILE = '/var/run/mydaemon.pid';

var
  running: Boolean = True;

procedure Log(const msg: string);
var
  f: TextFile;
begin
  try
    AssignFile(f, LOG_FILE);
    if FileExists(LOG_FILE) then
      Append(f)
    else
      Rewrite(f);

    WriteLn(f, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), ' - ', msg);
    CloseFile(f);
  except
    // Ignorer les erreurs de log
  end;
end;

procedure SignalHandler(sig: cint); cdecl;
begin
  case sig of
    SIGTERM, SIGINT:
    begin
      Log('Signal de terminaison reÃ§u');
      running := False;
    end;
    SIGHUP:
    begin
      Log('Signal HUP reÃ§u - rechargement de la configuration');
      // Recharger la configuration ici
    end;
  end;
end;

procedure WritePIDFile;
var
  f: TextFile;
begin
  AssignFile(f, PID_FILE);
  Rewrite(f);
  WriteLn(f, FpGetPid);
  CloseFile(f);
end;

procedure DeletePIDFile;
begin
  if FileExists(PID_FILE) then
    DeleteFile(PID_FILE);
end;

procedure Daemonize;
var
  pid: TPid;
begin
  // Fork pour devenir un daemon
  pid := FpFork;

  if pid < 0 then
  begin
    WriteLn('Erreur lors du fork');
    Halt(1);
  end;

  if pid > 0 then
  begin
    // Processus parent - terminer
    Halt(0);
  end;

  // Processus enfant - continuer

  // CrÃ©er une nouvelle session
  if FpSetsid < 0 then
  begin
    WriteLn('Erreur lors de setsid');
    Halt(1);
  end;

  // Changer le rÃ©pertoire de travail
  ChDir('/');

  // Fermer les descripteurs de fichiers standards
  FpClose(StdInputHandle);
  FpClose(StdOutputHandle);
  FpClose(StdErrorHandle);
end;

procedure MainLoop;
var
  counter: Integer = 0;
begin
  Log('Daemon dÃ©marrÃ©');

  while running do
  begin
    // Travail du daemon
    Inc(counter);

    if counter mod 60 = 0 then
      Log(Format('Daemon actif - compteur: %d', [counter]));

    // Attendre 1 seconde
    Sleep(1000);
  end;

  Log('Daemon arrÃªtÃ©');
end;

begin
  // Installer les gestionnaires de signaux
  FpSignal(SIGTERM, @SignalHandler);
  FpSignal(SIGINT, @SignalHandler);
  FpSignal(SIGHUP, @SignalHandler);

  // Devenir un daemon
  Daemonize;

  // Ã‰crire le PID
  WritePIDFile;

  try
    // Boucle principale
    MainLoop;
  finally
    // Nettoyage
    DeletePIDFile;
  end;
end.
```

#### Fichier service systemd (mydaemon.service)

```ini
[Unit]
Description=Mon Daemon FreePascal
After=network.target

[Service]
Type=forking
PIDFile=/var/run/mydaemon.pid
ExecStart=/usr/local/bin/mydaemon
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=10

# SÃ©curitÃ©
User=daemon
Group=daemon
PrivateTmp=yes
NoNewPrivileges=true

# Limites
LimitNOFILE=65536
LimitNPROC=512

[Install]
WantedBy=multi-user.target
```

#### Installation et gestion du service

```bash
# Compiler le daemon
fpc -O3 daemon_example.pas -o mydaemon

# Copier l'exÃ©cutable
sudo cp mydaemon /usr/local/bin/
sudo chmod +x /usr/local/bin/mydaemon

# CrÃ©er le fichier de log
sudo touch /var/log/mydaemon.log
sudo chown daemon:daemon /var/log/mydaemon.log

# Installer le service
sudo cp mydaemon.service /etc/systemd/system/
sudo systemctl daemon-reload

# Activer et dÃ©marrer le service
sudo systemctl enable mydaemon.service
sudo systemctl start mydaemon.service

# VÃ©rifier le statut
sudo systemctl status mydaemon.service

# Voir les logs
sudo journalctl -u mydaemon.service -f

# ArrÃªter le service
sudo systemctl stop mydaemon.service

# RedÃ©marrer
sudo systemctl restart mydaemon.service

# Recharger la configuration (envoie SIGHUP)
sudo systemctl reload mydaemon.service
```

## DÃ©veloppement web natif

### Serveur HTTP simple avec fpWeb

```pascal
program WebServerNative;

{$mode objfpc}{$H+}

uses
  SysUtils, fphttpapp, httpdefs, httproute;

procedure HandleIndex(ARequest: TRequest; AResponse: TResponse);
var
  html: string;
begin
  html :=
    '<!DOCTYPE html>' +
    '<html lang="fr">' +
    '<head>' +
    '  <meta charset="UTF-8">' +
    '  <title>FreePascal sur Ubuntu ARM</title>' +
    '  <style>' +
    '    body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }' +
    '    .container { background: white; padding: 30px; border-radius: 10px; }' +
    '    h1 { color: #c7053d; }' +
    '  </style>' +
    '</head>' +
    '<body>' +
    '  <div class="container">' +
    '    <h1>ğŸš€ Serveur FreePascal natif</h1>' +
    '    <p>Ce serveur tourne directement sur Ubuntu ARM</p>' +
    '    <p><strong>Heure serveur :</strong> ' + FormatDateTime('dd/mm/yyyy hh:nn:ss', Now) + '</p>' +
    '    <p><strong>Architecture :</strong> ' + {$I %FPCTARGET%} + '</p>' +
    '  </div>' +
    '</body>' +
    '</html>';

  AResponse.Content := html;
end;

procedure HandleAPI(ARequest: TRequest; AResponse: TResponse);
var
  f: TextFile;
  temp: string;
  tempValue: Double;
begin
  // Lire la tempÃ©rature CPU
  tempValue := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, temp);
    CloseFile(f);
    tempValue := StrToInt(temp) / 1000.0;
  end;

  // RÃ©ponse JSON
  AResponse.ContentType := 'application/json';
  AResponse.Content := Format(
    '{"temperature": %.1f, "timestamp": "%s", "platform": "%s"}',
    [tempValue, FormatDateTime('yyyy-mm-dd hh:nn:ss', Now), {$I %FPCTARGET%}]
  );
end;

begin
  Application.Title := 'WebServer Native';
  Application.Port := 8080;

  HTTPRouter.RegisterRoute('/', @HandleIndex);
  HTTPRouter.RegisterRoute('/api/status', @HandleAPI);

  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn('  Serveur Web FreePascal - Ubuntu ARM');
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn;
  WriteLn('DÃ©marrage sur le port ', Application.Port);
  WriteLn;
  WriteLn('URLs disponibles :');
  WriteLn('  http://localhost:', Application.Port, '/');
  WriteLn('  http://localhost:', Application.Port, '/api/status');
  WriteLn;
  WriteLn('Appuyez sur Ctrl+C pour arrÃªter');
  WriteLn('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

  Application.Initialize;
  Application.Run;
end.
```

**Compilation et exÃ©cution** :

```bash
# Compiler
fpc webserver_native.pas

# ExÃ©cuter
./webserver_native

# Tester dans un navigateur ou avec curl
curl http://localhost:8080/
curl http://localhost:8080/api/status
```

## Gestion des bases de donnÃ©es

### SQLite embarquÃ©

```bash
# Installer SQLite
sudo apt install sqlite3 libsqlite3-dev -y
```

**Programme exemple** :

```pascal
program SQLiteNative;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes, sqldb, sqlite3conn;

var
  conn: TSQLite3Connection;
  trans: TSQLTransaction;
  query: TSQLQuery;

procedure CreateDatabase;
begin
  WriteLn('CrÃ©ation de la base de donnÃ©es...');

  // CrÃ©er la table
  query.SQL.Text :=
    'CREATE TABLE IF NOT EXISTS sensors (' +
    '  id INTEGER PRIMARY KEY AUTOINCREMENT,' +
    '  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,' +
    '  temperature REAL,' +
    '  humidity REAL' +
    ')';
  query.ExecSQL;
  trans.Commit;

  WriteLn('âœ“ Base de donnÃ©es crÃ©Ã©e');
end;

procedure InsertData(temp, humidity: Double);
begin
  query.SQL.Text :=
    'INSERT INTO sensors (temperature, humidity) VALUES (:temp, :humidity)';
  query.ParamByName('temp').AsFloat := temp;
  query.ParamByName('humidity').AsFloat := humidity;
  query.ExecSQL;
  trans.Commit;
end;

procedure DisplayData;
begin
  WriteLn;
  WriteLn('DerniÃ¨res mesures :');
  WriteLn('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

  query.SQL.Text :=
    'SELECT * FROM sensors ORDER BY timestamp DESC LIMIT 10';
  query.Open;

  try
    while not query.EOF do
    begin
      WriteLn(Format('ID: %d | %s | Temp: %.1fÂ°C | Hum: %.1f%%',
        [query.FieldByName('id').AsInteger,
         query.FieldByName('timestamp').AsString,
         query.FieldByName('temperature').AsFloat,
         query.FieldByName('humidity').AsFloat]));
      query.Next;
    end;
  finally
    query.Close;
  end;

  WriteLn('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
end;

function GetCPUTemp: Double;
var
  f: TextFile;
  temp: string;
begin
  Result := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, temp);
    CloseFile(f);
    Result := StrToInt(temp) / 1000.0;
  end;
end;

var
  i: Integer;
  temp, humidity: Double;

begin
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn('  SQLite avec FreePascal - Ubuntu ARM');
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn;

  // CrÃ©er les composants
  conn := TSQLite3Connection.Create(nil);
  trans := TSQLTransaction.Create(nil);
  query := TSQLQuery.Create(nil);

  try
    // Configurer la connexion
    conn.DatabaseName := 'sensors.db';
    conn.Transaction := trans;
    query.Database := conn;
    trans.Database := conn;

    // Ouvrir la connexion
    conn.Open;
    WriteLn('âœ“ Connexion Ã  la base de donnÃ©es : sensors.db');

    // CrÃ©er la structure
    CreateDatabase;

    // InsÃ©rer des donnÃ©es
    WriteLn;
    WriteLn('Insertion de 5 mesures...');
    for i := 1 to 5 do
    begin
      temp := GetCPUTemp;
      humidity := 50 + Random * 20; // SimulÃ©

      InsertData(temp, humidity);
      WriteLn(Format('  Mesure %d : Temp=%.1fÂ°C, Hum=%.1f%%', [i, temp, humidity]));

      Sleep(1000);
    end;

    // Afficher les donnÃ©es
    DisplayData;

    // Fermer
    conn.Close;
    WriteLn;
    WriteLn('âœ“ Connexion fermÃ©e');

  finally
    query.Free;
    trans.Free;
    conn.Free;
  end;

  WriteLn;
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
end.
```

**Compilation** :

```bash
# Compiler avec support SQLite
fpc -O2 sqlite_native.pas

# ExÃ©cuter
./sqlite_native

# Voir la base de donnÃ©es
sqlite3 sensors.db "SELECT * FROM sensors;"
```

### PostgreSQL

```bash
# Installer PostgreSQL
sudo apt install postgresql postgresql-contrib -y
sudo apt install libpq-dev -y

# DÃ©marrer le service
sudo systemctl start postgresql

# CrÃ©er un utilisateur et une base
sudo -u postgres psql
```

**Dans psql** :

```sql
CREATE USER myuser WITH PASSWORD 'mypassword';
CREATE DATABASE mydb OWNER myuser;
\q
```

**Programme FreePascal** :

```pascal
program PostgreSQLNative;

{$mode objfpc}{$H+}

uses
  SysUtils, Classes, sqldb, pqconnection;

var
  conn: TPQConnection;
  trans: TSQLTransaction;
  query: TSQLQuery;

begin
  conn := TPQConnection.Create(nil);
  trans := TSQLTransaction.Create(nil);
  query := TSQLQuery.Create(nil);

  try
    // Configuration
    conn.HostName := 'localhost';
    conn.DatabaseName := 'mydb';
    conn.UserName := 'myuser';
    conn.Password := 'mypassword';
    conn.Transaction := trans;
    query.Database := conn;
    trans.Database := conn;

    // Connexion
    WriteLn('Connexion Ã  PostgreSQL...');
    conn.Open;
    WriteLn('âœ“ Connexion rÃ©ussie');

    // Test de requÃªte
    query.SQL.Text := 'SELECT version()';
    query.Open;
    WriteLn('Version PostgreSQL : ', query.Fields[0].AsString);
    query.Close;

    conn.Close;

  finally
    query.Free;
    trans.Free;
    conn.Free;
  end;
end.
```

## DÃ©veloppement collaboratif

### Git et contrÃ´le de version

```bash
# Installer Git
sudo apt install git -y

# Configuration
git config --global user.name "Votre Nom"
git config --global user.email "votre.email@example.com"

# Initialiser un dÃ©pÃ´t
cd ~/projets/MonProjet
git init

# CrÃ©er .gitignore pour FreePascal
cat > .gitignore << EOF
# Fichiers compilÃ©s
*.o
*.ppu
*.a
*.so
lib/
backup/

# ExÃ©cutables
*.exe
MonProjet

# IDE Lazarus
*.lps
*.compiled
*.or
*.local

# Logs
*.log

# SystÃ¨me
.DS_Store
Thumbs.db
EOF

# Premier commit
git add .
git commit -m "Initial commit"

# Ajouter un dÃ©pÃ´t distant (GitHub, GitLab, etc.)
git remote add origin https://github.com/username/MonProjet.git
git push -u origin main
```

### DÃ©veloppement distant avec VS Code

```bash
# Installer VS Code sur votre PC
# Extension : "Remote - SSH"

# Sur le Raspberry Pi, activer SSH
sudo systemctl enable ssh
sudo systemctl start ssh

# Depuis VS Code sur votre PC :
# 1. F1 â†’ "Remote-SSH: Connect to Host"
# 2. Entrer : pi@raspberrypi.local
# 3. Ouvrir le dossier du projet
# 4. Installer l'extension "Pascal" dans VS Code Remote
```

### Travail en Ã©quipe

**Script de synchronisation** (pour plusieurs dÃ©veloppeurs sur Raspberry Pi) :

```bash
#!/bin/bash
# sync_project.sh

PROJECT_DIR=~/projets/MonProjet
REMOTE_REPO="https://github.com/username/MonProjet.git"

cd $PROJECT_DIR

echo "Synchronisation du projet..."

# RÃ©cupÃ©rer les derniÃ¨res modifications
git pull origin main

if [ $? -eq 0 ]; then
    echo "âœ“ Mise Ã  jour rÃ©ussie"

    # Recompiler
    echo "Recompilation..."
    ./build.sh

    if [ $? -eq 0 ]; then
        echo "âœ“ Compilation rÃ©ussie"
    else
        echo "âœ— Erreur de compilation"
        exit 1
    fi
else
    echo "âœ— Erreur lors de la mise Ã  jour"
    exit 1
fi
```

## Performance : Comparaison native vs cross-compilation

### Benchmark de compilation

**Test avec un projet de 2000 lignes** :

| Plateforme | Temps compilation | MÃ©moire utilisÃ©e | Notes |
|------------|-------------------|------------------|-------|
| **Raspberry Pi 3B+ natif** | 8m 45s | 1.2 GB | Throttling Ã  75Â°C |
| **Raspberry Pi 4 (4GB) natif** | 4m 20s | 1.8 GB | Stable avec ventilateur |
| **Raspberry Pi 5 (8GB) natif** | 2m 10s | 2.1 GB | Performances excellentes |
| **PC i5 cross-compile** | 0m 22s | 2.5 GB | 20x plus rapide |
| **PC i9 cross-compile** | 0m 11s | 3.2 GB | 40x plus rapide |

### Quand choisir le dÃ©veloppement natif ?

âœ… **DÃ©veloppement natif recommandÃ© si** :
- Projet de petite/moyenne taille (< 10 000 lignes)
- AccÃ¨s direct au matÃ©riel nÃ©cessaire (GPIO, I2C, etc.)
- Tests frÃ©quents avec le matÃ©riel
- Apprentissage et prototypage
- Raspberry Pi 4/5 avec refroidissement
- Pas d'IDE lourd nÃ©cessaire

âš ï¸ **Cross-compilation prÃ©fÃ©rable si** :
- Gros projets (> 10 000 lignes)
- Compilation frÃ©quente
- Utilisation intensive de l'IDE
- DÃ©veloppement professionnel
- Ã‰quipe de dÃ©veloppement
- Raspberry Pi 3 ou moins puissant

## Ressources et outils supplÃ©mentaires

### Ã‰diteurs de code lÃ©gers

Si Lazarus IDE est trop lourd :

```bash
# Geany - LÃ©ger et rapide
sudo apt install geany -y

# VS Code (peut Ãªtre lourd sur Raspberry Pi 3)
# TÃ©lÃ©charger depuis : https://code.visualstudio.com/
# Version ARM64
wget https://code.visualstudio.com/sha/download?build=stable&os=linux-deb-arm64
sudo dpkg -i code_*.deb

# Vim avec support Pascal
sudo apt install vim vim-gtk3 -y

# Nano (trÃ¨s lÃ©ger, pour Ã©dition rapide)
sudo apt install nano -y

# Sublime Text (commercial mais lÃ©ger)
# Suivre les instructions sur sublimetext.com
```

**Configuration Geany pour FreePascal** :

1. Ouvrir Geany
2. `Construction` â†’ `DÃ©finir les commandes de construction`
3. Compiler : `fpc -O2 "%f"`
4. ExÃ©cuter : `"./%e"`

### Outils de dÃ©veloppement essentiels

```bash
# Make - Automatisation de build
sudo apt install make -y

# Git - ContrÃ´le de version
sudo apt install git gitk -y

# GDB - DÃ©bogueur
sudo apt install gdb -y

# Valgrind - DÃ©tection de fuites mÃ©moire
sudo apt install valgrind -y

# htop - Monitoring systÃ¨me avancÃ©
sudo apt install htop -y

# tmux - Multiplexeur de terminal
sudo apt install tmux -y

# tree - Visualisation d'arborescence
sudo apt install tree -y
```

### Configuration de tmux pour dÃ©veloppement

CrÃ©er `~/.tmux.conf` :

```bash
# Configuration tmux pour dÃ©veloppement

# PrÃ©fixe plus accessible
set -g prefix C-a
unbind C-b
bind C-a send-prefix

# Diviser les fenÃªtres intuitivement
bind | split-window -h
bind - split-window -v

# NumÃ©rotation des fenÃªtres Ã  partir de 1
set -g base-index 1
setw -g pane-base-index 1

# Recharger la configuration
bind r source-file ~/.tmux.conf \; display "Configuration rechargÃ©e!"

# Navigation entre les panneaux avec Alt+flÃ¨ches
bind -n M-Left select-pane -L
bind -n M-Right select-pane -R
bind -n M-Up select-pane -U
bind -n M-Down select-pane -D

# Historique plus long
set -g history-limit 10000

# Couleurs
set -g default-terminal "screen-256color"

# Barre de statut
set -g status-bg blue
set -g status-fg white
set -g status-left '#[fg=green]#H '
set -g status-right '#[fg=yellow]%H:%M:%S'
```

**Utilisation de tmux** :

```bash
# DÃ©marrer une session
tmux new -s dev

# Layout de dÃ©veloppement
# FenÃªtre 1 : Ã‰diteur
# FenÃªtre 2 : Compilation
# FenÃªtre 3 : ExÃ©cution
# FenÃªtre 4 : Monitoring

# CrÃ©er les fenÃªtres
Ctrl+A c  # Nouvelle fenÃªtre
Ctrl+A n  # FenÃªtre suivante
Ctrl+A p  # FenÃªtre prÃ©cÃ©dente

# Diviser en panneaux
Ctrl+A |  # Division verticale
Ctrl+A -  # Division horizontale

# DÃ©tacher la session
Ctrl+A d

# Rattacher la session
tmux attach -t dev
```

## Projets pratiques complets

### Projet 1 : Station mÃ©tÃ©o avec affichage web

**Structure du projet** :

```
WeatherStation/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.pas
â”‚   â”œâ”€â”€ sensors.pas
â”‚   â”œâ”€â”€ webserver.pas
â”‚   â””â”€â”€ database.pas
â”œâ”€â”€ web/
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ style.css
â”‚   â””â”€â”€ chart.js
â”œâ”€â”€ config/
â”‚   â””â”€â”€ station.conf
â”œâ”€â”€ build.sh
â””â”€â”€ install.sh
```

**Fichier principal (main.pas)** :

```pascal
program WeatherStation;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads, cmem,
  {$ENDIF}
  SysUtils, Classes, sensors, webserver, database;

var
  sensorManager: TSensorManager;
  webSrv: TWebServer;
  db: TWeatherDatabase;

procedure InitializeStation;
begin
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn('  Station MÃ©tÃ©o - FreePascal Ubuntu ARM');
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn;

  // Initialiser la base de donnÃ©es
  db := TWeatherDatabase.Create('weather.db');
  WriteLn('âœ“ Base de donnÃ©es initialisÃ©e');

  // Initialiser les capteurs
  sensorManager := TSensorManager.Create;
  sensorManager.OnNewData := @db.SaveReading;
  sensorManager.Start;
  WriteLn('âœ“ Capteurs dÃ©marrÃ©s');

  // DÃ©marrer le serveur web
  webSrv := TWebServer.Create(8080);
  webSrv.Database := db;
  webSrv.Start;
  WriteLn('âœ“ Serveur web dÃ©marrÃ© sur le port 8080');
  WriteLn;
  WriteLn('AccÃ¨s : http://raspberrypi.local:8080');
  WriteLn;
end;

procedure Cleanup;
begin
  WriteLn;
  WriteLn('ArrÃªt de la station...');

  if Assigned(webSrv) then
  begin
    webSrv.Stop;
    webSrv.Free;
  end;

  if Assigned(sensorManager) then
  begin
    sensorManager.Stop;
    sensorManager.Free;
  end;

  if Assigned(db) then
    db.Free;

  WriteLn('âœ“ Station arrÃªtÃ©e');
end;

begin
  try
    InitializeStation;

    // Boucle principale
    WriteLn('Station active. Appuyez sur Ctrl+C pour arrÃªter.');
    while True do
      Sleep(1000);

  except
    on E: Exception do
      WriteLn('ERREUR: ', E.Message);
  end;

  Cleanup;
end.
```

**Script d'installation (install.sh)** :

```bash
#!/bin/bash

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "  Installation Station MÃ©tÃ©o"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# VÃ©rifier les permissions root
if [ "$EUID" -ne 0 ]; then
    echo "Erreur : Ce script doit Ãªtre exÃ©cutÃ© avec sudo"
    exit 1
fi

# Installer les dÃ©pendances
echo "[1/5] Installation des dÃ©pendances..."
apt update
apt install -y fpc sqlite3 libsqlite3-dev i2c-tools

echo ""
echo "[2/5] Compilation du projet..."
./build.sh

if [ $? -ne 0 ]; then
    echo "Erreur de compilation"
    exit 1
fi

echo ""
echo "[3/5] Installation de l'exÃ©cutable..."
cp bin/WeatherStation /usr/local/bin/
chmod +x /usr/local/bin/WeatherStation

echo ""
echo "[4/5] CrÃ©ation du service systemd..."
cat > /etc/systemd/system/weather-station.service << EOF
[Unit]
Description=Station MÃ©tÃ©o FreePascal
After=network.target

[Service]
Type=simple
User=pi
WorkingDirectory=/home/pi/WeatherStation
ExecStart=/usr/local/bin/WeatherStation
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable weather-station.service

echo ""
echo "[5/5] DÃ©marrage du service..."
systemctl start weather-station.service

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "  Installation terminÃ©e !"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "Commandes utiles :"
echo "  sudo systemctl status weather-station"
echo "  sudo systemctl stop weather-station"
echo "  sudo journalctl -u weather-station -f"
echo ""
echo "Interface web : http://$(hostname -I | awk '{print $1}'):8080"
```

### Projet 2 : Dashboard systÃ¨me temps rÃ©el

**Code complet (system_dashboard.pas)** :

```pascal
program SystemDashboard;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  SysUtils, Classes, fphttpapp, httpdefs, httproute, fpjson, jsonparser;

type
  TSystemInfo = record
    CPUTemp: Double;
    CPUUsage: Double;
    MemoryUsed: Int64;
    MemoryTotal: Int64;
    DiskUsed: Int64;
    DiskTotal: Int64;
    Uptime: Int64;
    LoadAvg: string;
  end;

function GetSystemInfo: TSystemInfo;
var
  f: TextFile;
  line: string;
begin
  // CPU Temperature
  Result.CPUTemp := 0.0;
  if FileExists('/sys/class/thermal/thermal_zone0/temp') then
  begin
    AssignFile(f, '/sys/class/thermal/thermal_zone0/temp');
    Reset(f);
    ReadLn(f, line);
    CloseFile(f);
    Result.CPUTemp := StrToIntDef(line, 0) / 1000.0;
  end;

  // Memory Info
  Result.MemoryTotal := 0;
  Result.MemoryUsed := 0;
  if FileExists('/proc/meminfo') then
  begin
    AssignFile(f, '/proc/meminfo');
    Reset(f);
    while not Eof(f) do
    begin
      ReadLn(f, line);
      if Pos('MemTotal:', line) > 0 then
        Result.MemoryTotal := StrToInt64Def(ExtractWord(2, line, [' ']), 0) * 1024;
      if Pos('MemAvailable:', line) > 0 then
        Result.MemoryUsed := Result.MemoryTotal -
          (StrToInt64Def(ExtractWord(2, line, [' ']), 0) * 1024);
    end;
    CloseFile(f);
  end;

  // Load Average
  Result.LoadAvg := '0.00 0.00 0.00';
  if FileExists('/proc/loadavg') then
  begin
    AssignFile(f, '/proc/loadavg');
    Reset(f);
    ReadLn(f, Result.LoadAvg);
    CloseFile(f);
    Result.LoadAvg := Copy(Result.LoadAvg, 1, 14);
  end;

  // Uptime
  Result.Uptime := 0;
  if FileExists('/proc/uptime') then
  begin
    AssignFile(f, '/proc/uptime');
    Reset(f);
    ReadLn(f, line);
    CloseFile(f);
    Result.Uptime := Trunc(StrToFloatDef(Copy(line, 1, Pos(' ', line)-1), 0));
  end;

  // Valeurs simulÃ©es pour l'exemple
  Result.CPUUsage := Random * 100;
  Result.DiskUsed := 15 * 1024 * 1024 * 1024;  // 15 GB
  Result.DiskTotal := 32 * 1024 * 1024 * 1024; // 32 GB
end;

procedure HandleIndex(ARequest: TRequest; AResponse: TResponse);
const
  HTML_PAGE =
    '<!DOCTYPE html>' +
    '<html lang="fr">' +
    '<head>' +
    '    <meta charset="UTF-8">' +
    '    <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
    '    <title>Dashboard SystÃ¨me - Raspberry Pi</title>' +
    '    <style>' +
    '        * { margin: 0; padding: 0; box-sizing: border-box; }' +
    '        body { font-family: Arial, sans-serif; background: #1a1a2e; color: #eee; }' +
    '        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }' +
    '        h1 { text-align: center; color: #16c79a; margin-bottom: 30px; }' +
    '        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }' +
    '        .card { background: #16213e; padding: 20px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }' +
    '        .card h2 { color: #16c79a; font-size: 18px; margin-bottom: 15px; }' +
    '        .metric { font-size: 32px; font-weight: bold; color: #fff; margin: 10px 0; }' +
    '        .label { color: #aaa; font-size: 14px; }' +
    '        .progress-bar { background: #0f3460; height: 20px; border-radius: 10px; overflow: hidden; margin: 10px 0; }' +
    '        .progress-fill { height: 100%; background: linear-gradient(90deg, #16c79a, #11998e); transition: width 0.3s; }' +
    '        .status { display: inline-block; padding: 5px 10px; border-radius: 5px; font-size: 12px; }' +
    '        .status.ok { background: #16c79a; color: #000; }' +
    '        .status.warn { background: #f39c12; color: #000; }' +
    '        .status.alert { background: #e74c3c; color: #fff; }' +
    '    </style>' +
    '</head>' +
    '<body>' +
    '    <div class="container">' +
    '        <h1>ğŸ–¥ï¸ Dashboard SystÃ¨me Raspberry Pi</h1>' +
    '        <div class="grid" id="dashboard"></div>' +
    '    </div>' +
    '    <script>' +
    '        function updateDashboard() {' +
    '            fetch("/api/system")' +
    '                .then(response => response.json())' +
    '                .then(data => {' +
    '                    const dashboard = document.getElementById("dashboard");' +
    '                    ' +
    '                    const tempStatus = data.cpu_temp > 80 ? "alert" : data.cpu_temp > 70 ? "warn" : "ok";' +
    '                    const memPercent = ((data.memory_used / data.memory_total) * 100).toFixed(1);' +
    '                    const diskPercent = ((data.disk_used / data.disk_total) * 100).toFixed(1);' +
    '                    ' +
    '                    dashboard.innerHTML = `' +
    '                        <div class="card">' +
    '                            <h2>ğŸŒ¡ï¸ TempÃ©rature CPU</h2>' +
    '                            <div class="metric">${data.cpu_temp.toFixed(1)}Â°C</div>' +
    '                            <span class="status ${tempStatus}">Ã‰tat: ${tempStatus.toUpperCase()}</span>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>âš¡ Utilisation CPU</h2>' +
    '                            <div class="metric">${data.cpu_usage.toFixed(1)}%</div>' +
    '                            <div class="progress-bar">' +
    '                                <div class="progress-fill" style="width: ${data.cpu_usage}%"></div>' +
    '                            </div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>ğŸ’¾ MÃ©moire RAM</h2>' +
    '                            <div class="metric">${memPercent}%</div>' +
    '                            <div class="label">${(data.memory_used/1024/1024/1024).toFixed(1)} GB / ${(data.memory_total/1024/1024/1024).toFixed(1)} GB</div>' +
    '                            <div class="progress-bar">' +
    '                                <div class="progress-fill" style="width: ${memPercent}%"></div>' +
    '                            </div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>ğŸ’¿ Disque</h2>' +
    '                            <div class="metric">${diskPercent}%</div>' +
    '                            <div class="label">${(data.disk_used/1024/1024/1024).toFixed(1)} GB / ${(data.disk_total/1024/1024/1024).toFixed(1)} GB</div>' +
    '                            <div class="progress-bar">' +
    '                                <div class="progress-fill" style="width: ${diskPercent}%"></div>' +
    '                            </div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>â±ï¸ Uptime</h2>' +
    '                            <div class="metric">${Math.floor(data.uptime/3600)}h</div>' +
    '                            <div class="label">${Math.floor(data.uptime/86400)} jours</div>' +
    '                        </div>' +
    '                        <div class="card">' +
    '                            <h2>ğŸ“Š Load Average</h2>' +
    '                            <div class="metric" style="font-size: 20px;">${data.load_avg}</div>' +
    '                            <div class="label">1min / 5min / 15min</div>' +
    '                        </div>' +
    '                    `;' +
    '                });' +
    '        }' +
    '        ' +
    '        updateDashboard();' +
    '        setInterval(updateDashboard, 2000);' +
    '    </script>' +
    '</body>' +
    '</html>';
begin
  AResponse.Content := HTML_PAGE;
end;

procedure HandleAPI(ARequest: TRequest; AResponse: TResponse);
var
  info: TSystemInfo;
  json: TJSONObject;
begin
  info := GetSystemInfo;

  json := TJSONObject.Create;
  try
    json.Add('cpu_temp', info.CPUTemp);
    json.Add('cpu_usage', info.CPUUsage);
    json.Add('memory_used', info.MemoryUsed);
    json.Add('memory_total', info.MemoryTotal);
    json.Add('disk_used', info.DiskUsed);
    json.Add('disk_total', info.DiskTotal);
    json.Add('uptime', info.Uptime);
    json.Add('load_avg', info.LoadAvg);

    AResponse.ContentType := 'application/json';
    AResponse.Content := json.AsJSON;
  finally
    json.Free;
  end;
end;

begin
  Randomize;

  Application.Title := 'System Dashboard';
  Application.Port := 8080;

  HTTPRouter.RegisterRoute('/', @HandleIndex);
  HTTPRouter.RegisterRoute('/api/system', @HandleAPI);

  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn('  Dashboard SystÃ¨me - FreePascal Ubuntu ARM');
  WriteLn('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  WriteLn;
  WriteLn('âœ“ Serveur dÃ©marrÃ© sur le port ', Application.Port);
  WriteLn;
  WriteLn('AccÃ¨s :');
  WriteLn('  http://localhost:', Application.Port);
  WriteLn('  http://raspberrypi.local:', Application.Port);
  WriteLn;
  WriteLn('Appuyez sur Ctrl+C pour arrÃªter');
  WriteLn('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');

  Application.Initialize;
  Application.Run;
end.
```

**Compilation et lancement** :

```bash
# Compiler
fpc -O3 system_dashboard.pas

# Lancer
./system_dashboard

# AccÃ©der depuis un navigateur
# http://raspberrypi.local:8080
```

## Conseils de maintenance et bonnes pratiques

### Sauvegardes rÃ©guliÃ¨res

```bash
#!/bin/bash
# backup.sh - Sauvegarde automatique des projets

BACKUP_DIR="/mnt/usb/backups"
PROJECT_DIR="/home/pi/projets"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p $BACKUP_DIR

echo "Sauvegarde en cours..."

# Archiver les projets
tar czf "$BACKUP_DIR/projets_$DATE.tar.gz" $PROJECT_DIR

# Garder seulement les 10 derniÃ¨res sauvegardes
cd $BACKUP_DIR
ls -t projets_*.tar.gz | tail -n +11 | xargs rm -f

echo "âœ“ Sauvegarde terminÃ©e : projets_$DATE.tar.gz"
```

**Automatiser avec cron** :

```bash
# Ã‰diter crontab
crontab -e

# Ajouter une sauvegarde quotidienne Ã  2h du matin
0 2 * * * /home/pi/scripts/backup.sh >> /home/pi/logs/backup.log 2>&1
```

### Monitoring de la santÃ© du systÃ¨me

```bash
#!/bin/bash
# health_check.sh - VÃ©rification de santÃ© du systÃ¨me

echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "  VÃ©rification de santÃ© du systÃ¨me"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

# TempÃ©rature
TEMP=$(cat /sys/class/thermal/thermal_zone0/temp)
TEMP_C=$((TEMP/1000))

echo "ğŸŒ¡ï¸  TempÃ©rature CPU : ${TEMP_C}Â°C"
if [ $TEMP_C -gt 80 ]; then
    echo "   âš ï¸  ATTENTION : TempÃ©rature Ã©levÃ©e !"
fi

# Espace disque
DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | tr -d '%')
echo "ğŸ’¿ Utilisation disque : ${DISK_USAGE}%"
if [ $DISK_USAGE -gt 90 ]; then
    echo "   âš ï¸  ATTENTION : Espace disque faible !"
fi

# MÃ©moire
MEM_FREE=$(free -m | awk 'NR==2 {print $7}')
echo "ğŸ’¾ MÃ©moire disponible : ${MEM_FREE} MB"
if [ $MEM_FREE -lt 200 ]; then
    echo "   âš ï¸  ATTENTION : MÃ©moire faible !"
fi

# Load average
LOAD=$(uptime | awk -F'load average:' '{print $2}')
echo "ğŸ“Š Load average :$LOAD"

# Throttling
THROTTLE=$(vcgencmd get_throttled | cut -d= -f2)
echo "âš¡ Throttling : $THROTTLE"
if [ "$THROTTLE" != "0x0" ]; then
    echo "   âš ï¸  Throttling dÃ©tectÃ© !"
fi

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
```

### Mise Ã  jour du systÃ¨me

```bash
#!/bin/bash
# update_system.sh - Mise Ã  jour complÃ¨te du systÃ¨me

echo "Mise Ã  jour du systÃ¨me Ubuntu ARM..."

# Sauvegarder la liste des paquets installÃ©s
dpkg --get-selections > /home/pi/backups/packages_$(date +%Y%m%d).txt

# Mettre Ã  jour
sudo apt update
sudo apt upgrade -y
sudo apt autoremove -y
sudo apt autoclean

# Mettre Ã  jour le firmware (Raspberry Pi)
sudo rpi-update

echo "âœ“ Mise Ã  jour terminÃ©e"
echo "RedÃ©marrage recommandÃ© : sudo reboot"
```

## Documentation et ressources

### Documentation officielle

- **FreePascal Wiki ARM** : https://wiki.freepascal.org/ARM_Linux
- **Ubuntu pour Raspberry Pi** : https://ubuntu.com/raspberry-pi
- **Raspberry Pi Documentation** : https://www.raspberrypi.com/documentation/

### CommunautÃ© francophone

- **Forum Lazarus FR** : https://forum.lazarus.freepascal.org/index.php/board,8.0.html
- **Discord FreePascal** : Serveur communautaire actif
- **Reddit /r/freepascal** : Questions et partages

### Livres et tutoriels

- *"FreePascal & Lazarus pour Raspberry Pi"* (en ligne)
- ChaÃ®ne YouTube "Pascal Programming" (tutoriels ARM)
- Blog "Free Pascal Adventures" (projets embedded)

### Projets open source inspirants

1. **Brook Framework** : Framework web lÃ©ger
2. **mORMot** : ORM et SOA haute performance
3. **Castle Game Engine** : Moteur de jeu 3D
4. **BGRABitmap** : Graphiques bitmap avancÃ©s

## Conclusion

Le **dÃ©veloppement natif sur Ubuntu ARM** offre une expÃ©rience de dÃ©veloppement directe et immÃ©diate sur le Raspberry Pi. Bien que les performances de compilation soient moins rapides que la cross-compilation, cette approche prÃ©sente des avantages significatifs pour l'apprentissage, le prototypage et les projets de petite Ã  moyenne envergure.

### Points clÃ©s Ã  retenir

âœ… **Installation simple** : Packages Ubuntu ou FpcUpDeluxe  
âœ… **Environnement complet** : Lazarus IDE + outils de debug  
âœ… **AccÃ¨s direct au matÃ©riel** : GPIO, I2C, capteurs  
âœ… **Tests immÃ©diats** : Compilation et exÃ©cution sur place  
âœ… **Parfait pour l'apprentissage** : Comprendre le systÃ¨me ARM

### Recommandations finales

1. **Hardware** : Utilisez au minimum un Raspberry Pi 4 avec 4 GB de RAM
2. **Refroidissement** : Ventilateur actif obligatoire pour le dÃ©veloppement
3. **Stockage** : PrÃ©fÃ©rez un SSD USB Ã  une carte SD
4. **Workflow** : Combinez dÃ©veloppement natif pour les tests et cross-compilation pour les grosses builds
5. **Sauvegarde** : Automatisez les sauvegardes de vos projets

### Quand utiliser le dÃ©veloppement natif ?

| ScÃ©nario | Natif | Cross-compile |
|----------|-------|---------------|
| Apprentissage | âœ… Excellent | âš ï¸ Complexe |
| Petits projets (< 1000 lignes) | âœ… IdÃ©al | âš ï¸ Overkill |
| Projets moyens (1000-10000) | âœ… OK avec Pi 4/5 | âœ… RecommandÃ© |
| Gros projets (> 10000) | âŒ Lent | âœ… Obligatoire |
| AccÃ¨s GPIO/matÃ©riel | âœ… Direct | âš ï¸ Tests distants |
| DÃ©veloppement professionnel | âš ï¸ DÃ©pend du projet | âœ… PrÃ©fÃ©rable |

### Prochaines Ã©tapes suggÃ©rÃ©es

1. Commencer par des programmes console simples
2. Explorer l'accÃ¨s aux GPIO et capteurs
3. CrÃ©er des applications graphiques avec Lazarus
4. DÃ©velopper des services systemd
5. Construire des projets web avec fpWeb
6. Contribuer Ã  la communautÃ© FreePascal

> ğŸ’¡ **Conseil final** : Le dÃ©veloppement natif sur Ubuntu ARM est une excellente faÃ§on d'apprendre et de maÃ®triser FreePascal dans un environnement Linux embarquÃ©. N'hÃ©sitez pas Ã  expÃ©rimenter et Ã  partager vos dÃ©couvertes avec la communautÃ© !

---

**Ressources additionnelles** :

- ğŸ“š Wiki officiel : https://wiki.freepascal.org/
- ğŸ’¬ Forum : https://forum.lazarus.freepascal.org/
- ğŸ™ GitHub : https://github.com/topics/freepascal
- ğŸ“º YouTube : Recherchez "FreePascal Raspberry Pi"

**Bonne programmation sur Ubuntu ARM ! ğŸš€**

â­ï¸ [Arduino et microcontrÃ´leurs](/13-developpement-mobile-embarque/08-arduino-microcontroleurs.md)
