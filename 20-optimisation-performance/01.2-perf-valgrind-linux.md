üîù Retour au [Sommaire](/SOMMAIRE.md)

# 20.1.2 Perf et Valgrind (Linux)

## Introduction

Sous Linux (et sp√©cifiquement Ubuntu), les outils de profilage les plus utilis√©s sont **Perf** et **Valgrind**. Ces deux outils compl√©mentaires permettent d'analyser et d'optimiser les performances de vos applications FreePascal/Lazarus de mani√®re professionnelle et gratuite.

## Diff√©rences entre Perf et Valgrind

### Perf
- **Type** : Profilage par √©chantillonnage (sampling)
- **Usage** : Analyse des performances CPU et identification des hotspots
- **Overhead** : Tr√®s faible (< 5%)
- **Quand l'utiliser** : Pour mesurer les performances r√©elles en production

### Valgrind
- **Type** : Instrumentation du code
- **Usage** : Analyse m√©moire, d√©tection de fuites, profilage d√©taill√©
- **Overhead** : √âlev√© (10x √† 50x plus lent)
- **Quand l'utiliser** : Pour d√©tecter les bugs et probl√®mes m√©moire

**R√®gle simple** : Utilisez **Perf** pour optimiser les performances, **Valgrind** pour corriger les bugs m√©moire.

---

# PARTIE 1 : PERF

## Qu'est-ce que Perf ?

**Perf** (ou `perf_events`) est l'outil de profilage officiel du noyau Linux. Il acc√®de directement aux compteurs de performance mat√©riels (PMU - Performance Monitoring Unit) du processeur pour mesurer les performances avec une grande pr√©cision.

## Installation de Perf sur Ubuntu

### V√©rifier si Perf est install√©

```bash
perf --version
```

Si la commande n'est pas trouv√©e, installez-le :

### Installation

```bash
sudo apt update  
sudo apt install linux-tools-common linux-tools-generic linux-tools-$(uname -r)
```

**Explication des paquets** :
- `linux-tools-common` : Outils de base
- `linux-tools-generic` : Version g√©n√©rique
- `linux-tools-$(uname -r)` : Version correspondant √† votre noyau actuel

### V√©rification post-installation

```bash
perf --version
# Affiche : perf version 5.15.x ou similaire
```

### Permissions n√©cessaires

Par d√©faut, Perf n√©cessite les privil√®ges root. Pour autoriser les utilisateurs normaux :

```bash
# M√©thode temporaire (jusqu'au red√©marrage)
sudo sysctl -w kernel.perf_event_paranoid=-1

# M√©thode permanente
echo "kernel.perf_event_paranoid = -1" | sudo tee -a /etc/sysctl.conf  
sudo sysctl -p
```

**Niveaux de paranoid** :
- `2` : Utilisateur peut seulement profiler ses propres processus (mode restreint)
- `1` : Utilisateur peut acc√©der aux compteurs CPU
- `0` : Utilisateur peut acc√©der √† la plupart des donn√©es
- `-1` : Acc√®s complet (recommand√© pour le d√©veloppement)

## Pr√©parer une application FreePascal pour Perf

### Compilation avec symboles de d√©bogage

Comme avec VTune, il faut compiler avec les informations de d√©bogage :

**Dans Lazarus** :
- `Project` ‚Üí `Project Options` ‚Üí `Debugging`
- Cochez `Generate debug info for GDB (-g)`
- D√©cochez `Strip symbols from executable (-Xs)`

**En ligne de commande** :
```bash
fpc -g -gl monprogramme.pas
```

### Compilation avec frame pointers

Pour une meilleure pr√©cision des stack traces avec Perf, ajoutez l'option de frame pointer :

```bash
fpc -g -gl -Xg monprogramme.pas
```

L'option `-Xg` g√©n√®re des frame pointers qui facilitent le d√©roulement de la pile d'appels.

## Utilisation de Perf

### Commande de base : perf stat

`perf stat` donne des statistiques globales sur l'ex√©cution d'un programme :

```bash
perf stat ./monprogramme
```

**Exemple de sortie** :
```
 Performance counter stats for './monprogramme':

          1,234.56 msec task-clock                #    0.998 CPUs utilized
                 3      context-switches          #    2.430 /sec
                 0      cpu-migrations            #    0.000 /sec
               456      page-faults               #  369.380 /sec
     4,567,890,123      cycles                    #    3.700 GHz
     3,456,789,012      instructions              #    0.76  insn per cycle
       789,012,345      branches                  #  639.000 M/sec
        12,345,678      branch-misses             #    1.56% of all branches

       1.236789012 seconds time elapsed
       1.234567890 seconds user
       0.001234567 seconds sys
```

**Interpr√©tation des m√©triques importantes** :

- **task-clock** : Temps CPU r√©el utilis√©
- **context-switches** : Nombre de changements de contexte (plus c'est bas, mieux c'est)
- **cycles** : Nombre de cycles CPU ex√©cut√©s
- **instructions** : Nombre d'instructions ex√©cut√©es
- **insn per cycle** : Instructions par cycle (IPC) - id√©alement > 1.0
- **branches** : Nombre de branchements
- **branch-misses** : Pr√©dictions de branchement rat√©es (< 5% est bon)

### Commande de profilage : perf record

Pour identifier les fonctions qui consomment le plus de CPU :

```bash
perf record -g ./monprogramme
```

**Options importantes** :
- `-g` : Enregistre la pile d'appels (call graph)
- `-F 999` : Fr√©quence d'√©chantillonnage (999 Hz par d√©faut)
- `--call-graph dwarf` : Utilise les infos DWARF pour un call graph plus pr√©cis

**Exemple complet** :
```bash
perf record -g --call-graph dwarf -F 999 ./monprogramme
```

Cela cr√©e un fichier `perf.data` contenant les donn√©es de profilage.

### Visualisation des r√©sultats : perf report

Apr√®s `perf record`, visualisez les r√©sultats :

```bash
perf report
```

**Interface interactive** :

```
Samples: 10K of event 'cycles', Event count (approx.): 4567890123  
Overhead  Command      Shared Object        Symbol
  45.23%  monprogramme monprogramme         [.] TMONOBJET_CALCULCOMPLEXE
  16.45%  monprogramme monprogramme         [.] SYSTEM_MOVE
  12.34%  monprogramme libc-2.31.so         [.] __memcpy_avx_unaligned
   8.76%  monprogramme monprogramme         [.] TFORM1_BUTTON1CLICK
   5.43%  monprogramme libgtk-3.so.0        [.] gtk_widget_draw
   ...
```

**Navigation** :
- `‚Üë` / `‚Üì` : Naviguer dans la liste
- `Enter` : Voir les d√©tails d'une fonction (annotated source)
- `+` : D√©velopper le call graph
- `-` : R√©duire le call graph
- `q` : Quitter

**Colonnes importantes** :
- **Overhead** : Pourcentage du temps CPU (les plus hauts sont vos hotspots)
- **Shared Object** : Biblioth√®que ou ex√©cutable
- **Symbol** : Nom de la fonction

### Visualisation du code annot√©

Appuyez sur `Enter` sur une fonction pour voir le code source avec les pourcentages :

```pascal
Percent‚îÇ      procedure TMonObjet.CalculComplexe;
       ‚îÇ      var i: Integer;
       ‚îÇ      begin
  2.34%‚îÇ        for i := 0 to 1000000 do
       ‚îÇ        begin
 58.76%‚îÇ          ResultatArray[i] := Sqrt(i) * Sin(i);
       ‚îÇ        end;
  1.23%‚îÇ      end;
```

Les lignes avec les pourcentages les plus √©lev√©s sont celles √† optimiser en priorit√©.

### G√©n√©ration de rapports texte

Pour sauvegarder un rapport dans un fichier :

```bash
perf report --stdio > rapport_perf.txt
```

Ou en format CSV pour analyse externe :

```bash
perf report --stdio --fields=overhead,symbol,dso | grep -v "^#" > rapport.csv
```

## Analyse avanc√©e avec Perf

### perf top : Profilage en temps r√©el

Comme `top` mais pour le profilage :

```bash
sudo perf top
```

Affiche en temps r√©el les fonctions les plus actives sur le syst√®me. Utile pour identifier les processus gourmands.

### perf annotate : Annotation du code assembleur

Pour voir le code assembleur annot√© d'une fonction sp√©cifique :

```bash
perf annotate TMONOBJET_CALCULCOMPLEXE
```

Affiche l'assembleur avec les pourcentages par instruction (pour optimisations tr√®s avanc√©es).

### Analyse de la m√©moire cache

Mesurer les d√©fauts de cache (cache misses) :

```bash
perf stat -e cache-references,cache-misses,instructions ./monprogramme
```

**Sortie exemple** :
```
   456,789,012      cache-references
    12,345,678      cache-misses              #    2.70% of all cache refs
 3,456,789,012      instructions
```

Un taux de cache miss > 10% indique des probl√®mes potentiels de localit√© m√©moire.

### Flamegraphs avec Perf

Les **flamegraphs** sont des visualisations populaires des call stacks. Installation :

```bash
git clone https://github.com/brendangregg/FlameGraph  
cd FlameGraph
```

G√©n√©ration d'un flamegraph :

```bash
# 1. Enregistrer les donn√©es
perf record -g -F 999 ./monprogramme

# 2. G√©n√©rer le fichier pour flamegraph
perf script > out.perf

# 3. Cr√©er le flamegraph SVG
./FlameGraph/stackcollapse-perf.pl out.perf > out.folded
./FlameGraph/flamegraph.pl out.folded > flamegraph.svg

# 4. Ouvrir dans un navigateur
firefox flamegraph.svg
```

Le flamegraph montre visuellement la hi√©rarchie des appels, avec les fonctions les plus co√ªteuses en largeur.

## Workflow typique avec Perf

1. **Statistiques globales** : `perf stat ./monprogramme` pour avoir une vue d'ensemble
2. **Enregistrement** : `perf record -g ./monprogramme` pour capturer les donn√©es
3. **Analyse** : `perf report` pour identifier les hotspots
4. **Optimisation** : Modifier le code des fonctions co√ªteuses
5. **Validation** : Re-profiler pour v√©rifier l'am√©lioration

---

# PARTIE 2 : VALGRIND

## Qu'est-ce que Valgrind ?

**Valgrind** est une suite d'outils d'analyse de programmes. Le plus utilis√© est **Memcheck**, qui d√©tecte les erreurs m√©moire (fuites, acc√®s invalides, etc.). Valgrind inclut aussi **Callgrind** pour le profilage d√©taill√©.

## Installation de Valgrind sur Ubuntu

```bash
sudo apt update  
sudo apt install valgrind
```

### V√©rification

```bash
valgrind --version
# Affiche : valgrind-3.18.1 ou similaire
```

## Utilisation de Valgrind Memcheck

### D√©tection d'erreurs m√©moire

**Memcheck** est l'outil par d√©faut de Valgrind. Pour l'utiliser :

```bash
valgrind ./monprogramme
```

Ou avec plus de d√©tails :

```bash
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./monprogramme
```

**Options expliqu√©es** :
- `--leak-check=full` : Affiche les d√©tails de toutes les fuites m√©moire
- `--show-leak-kinds=all` : Montre tous les types de fuites (definite, possible, reachable)
- `--track-origins=yes` : Suit l'origine des valeurs non initialis√©es

### Exemple de sortie Memcheck

```
==12345== Memcheck, a memory error detector
==12345== Command: ./monprogramme
==12345==
Programme s'ex√©cute...
==12345==
==12345== HEAP SUMMARY:
==12345==     in use at exit: 1,024 bytes in 1 blocks
==12345==   total heap usage: 100 allocs, 99 frees, 102,400 bytes allocated
==12345==
==12345== 1,024 bytes in 1 blocks are definitely lost in loss record 1 of 1
==12345==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck.so)
==12345==    by 0x400567: SYSTEM_GETMEM (system.inc:1234)
==12345==    by 0x400678: TMONOBJET_CREATE (monobjet.pas:45)
==12345==    by 0x400789: main (monprogramme.pas:78)
==12345==
==12345== LEAK SUMMARY:
==12345==    definitely lost: 1,024 bytes in 1 blocks
==12345==    indirectly lost: 0 bytes in 0 blocks
==12345==      possibly lost: 0 bytes in 0 blocks
==12345==    still reachable: 0 bytes in 0 blocks
==12345==         suppressed: 0 bytes in 0 blocks
```

**Interpr√©tation** :

- **definitely lost** : Fuites certaines (m√©moire jamais lib√©r√©e et inaccessible)
- **indirectly lost** : Fuites indirectes (d√©pendent d'autres fuites)
- **possibly lost** : Fuites possibles (pointeurs mal g√©r√©s)
- **still reachable** : M√©moire accessible mais non lib√©r√©e (pas grave √† la sortie du programme)

### Types d'erreurs d√©tect√©es

Valgrind d√©tecte automatiquement :

1. **Fuites m√©moire** (memory leaks)
   ```pascal
   // Probl√®me : GetMem sans FreeMem correspondant
   P := GetMem(1024);
   // ... utilisation ...
   // Oubli de FreeMem(P);
   ```

2. **Acc√®s √† m√©moire lib√©r√©e** (use after free)
   ```pascal
   FreeMem(P);
   P^[0] := 42;  // ‚ùå Erreur : acc√®s apr√®s lib√©ration
   ```

3. **D√©bordements de buffer** (buffer overflows)
   ```pascal
   SetLength(Tableau, 10);
   Tableau[15] := 42;  // ‚ùå Erreur : acc√®s hors limites
   ```

4. **Lectures de valeurs non initialis√©es**
   ```pascal
   var X: Integer;
   begin
     WriteLn(X);  // ‚ùå Erreur : X non initialis√©
   end;
   ```

## Utilisation de Valgrind Callgrind

**Callgrind** est un profiler qui enregistre tous les appels de fonctions et le co√ªt de chaque instruction.

### Lancer Callgrind

```bash
valgrind --tool=callgrind ./monprogramme
```

Cela g√©n√®re un fichier `callgrind.out.XXXXX` (o√π XXXXX est le PID du processus).

**Attention** : Callgrind ralentit √©norm√©ment l'ex√©cution (20x √† 50x plus lent). Ne l'utilisez que pour des analyses approfondies.

### Visualiser les r√©sultats avec KCachegrind

**KCachegrind** est une interface graphique pour visualiser les donn√©es Callgrind.

Installation :
```bash
sudo apt install kcachegrind
```

Lancement :
```bash
kcachegrind callgrind.out.12345
```

**Interface KCachegrind** :

1. **Liste des fonctions** : Tri√©es par co√ªt (Self, Incl.)
   - **Self** : Temps dans la fonction elle-m√™me
   - **Incl.** : Temps incluant les sous-fonctions

2. **Call Graph** : Graphe visuel des appels de fonctions

3. **Source Code** : Code annot√© avec le co√ªt par ligne

4. **Caller/Callee Map** : Qui appelle qui et combien de fois

### Analyse en ligne de commande

Sans interface graphique, utilisez `callgrind_annotate` :

```bash
callgrind_annotate callgrind.out.12345
```

**Sortie exemple** :
```
--------------------------------------------------------------------------------
Profile data file 'callgrind.out.12345' (creator: callgrind-3.18.1)
--------------------------------------------------------------------------------
I1 cache: 32768 B, 64 B, 8-way associative  
D1 cache: 32768 B, 64 B, 8-way associative  
LL cache: 262144 B, 64 B, 8-way associative  
Command: ./monprogramme  
Data file: callgrind.out.12345  
Events recorded: Ir  
Events shown: Ir  
Event sort order: Ir  
Thresholds: 99  
Include dirs:  
User annotated:  
Auto-annotation: off

--------------------------------------------------------------------------------
         Ir
--------------------------------------------------------------------------------
4,567,890 (100.0%)  PROGRAM TOTALS

  2,087,234 (45.7%)  monprogramme'TMONOBJET_CALCULCOMPLEXE
    751,234 (16.4%)  /lib/x86_64-linux-gnu/libc.so.6'__memcpy_sse2_unaligned
    563,987 (12.3%)  monprogramme'TFORM1_BUTTON1CLICK
    ...
```

**Ir** = Instruction reads (nombre d'instructions ex√©cut√©es)

## Autres outils Valgrind

### Massif : Profilage du tas (heap)

Pour analyser l'utilisation de la m√©moire heap au fil du temps :

```bash
valgrind --tool=massif ./monprogramme
```

G√©n√®re `massif.out.XXXXX`. Visualisation :

```bash
ms_print massif.out.12345
```

Affiche un graphique en texte de l'utilisation m√©moire :

```
    MB
1.5 ^                                                    #
    |                                                    #
    |                                          @         #
1.0 +                                    @@@@@#@@@      #
    |                                @@@@       #  @     #
    |                        ::::@@@:           #   @    #
0.5 +            :::::::::::@    :              #    @   #
    |    ::@@@@@@           @    :              #     @  #
    |@@@@:  :                                   #      @@#
0.0 +----------------------------------------------------------------------->s
    0                                                                    10.5
```

Le graphique montre comment la m√©moire augmente au fil de l'ex√©cution.

### Helgrind : D√©tection de probl√®mes de threading

Pour d√©tecter les race conditions et deadlocks dans les applications multi-threads :

```bash
valgrind --tool=helgrind ./monprogramme_multithread
```

Helgrind d√©tecte :
- Race conditions (acc√®s concurrent non prot√©g√©)
- Utilisation incorrecte de mutex
- Ordre d'acquisition de locks probl√©matique

## Comparaison Perf vs Valgrind

| Crit√®re | Perf | Valgrind |
|---------|------|----------|
| **Overhead** | Faible (< 5%) | Tr√®s √©lev√© (10x-50x) |
| **Usage principal** | Profilage performance | D√©tection bugs m√©moire |
| **Pr√©cision** | √âchantillonnage | Instrumentation compl√®te |
| **Symboles requis** | Oui (pour noms fonctions) | Oui |
| **D√©tection fuites** | Non | Oui |
| **En production** | Oui, possible | Non (trop lent) |
| **Interface graphique** | Flamegraphs (externe) | KCachegrind |

## Workflow recommand√©

### Phase 1 : D√©veloppement

1. **Valgrind Memcheck** : V√©rifier l'absence de fuites m√©moire
   ```bash
   valgrind --leak-check=full ./monprogramme
   ```

2. **Corriger tous les probl√®mes** d√©tect√©s avant d'optimiser

### Phase 2 : Optimisation

3. **Perf stat** : Vue d'ensemble des performances
   ```bash
   perf stat ./monprogramme
   ```

4. **Perf record + report** : Identifier les hotspots
   ```bash
   perf record -g ./monprogramme
   perf report
   ```

5. **Optimiser** les fonctions les plus co√ªteuses

6. **Valgrind Callgrind** (si n√©cessaire) : Analyse d√©taill√©e
   ```bash
   valgrind --tool=callgrind ./monprogramme
   kcachegrind callgrind.out.*
   ```

### Phase 3 : Validation

7. **Re-profiler avec Perf** : V√©rifier les am√©liorations
8. **Tests de non-r√©gression** : S'assurer que le code reste correct

## Exemples pratiques d'optimisation

### Exemple 1 : Fuite m√©moire d√©tect√©e

**Valgrind d√©tecte** :
```
==12345== 10,240 bytes in 10 blocks are definitely lost
==12345==    at 0x400567: SYSTEM_GETMEM
==12345==    by 0x400678: TMONOBJET_CHARGERDATA
```

**Code probl√©matique** :
```pascal
procedure TMonObjet.ChargerData;  
var
  Buffer: PChar;
  i: Integer;
begin
  for i := 1 to 10 do
  begin
    Buffer := GetMem(1024);
    // ... traitement ...
    // ‚ùå Manque FreeMem(Buffer);
  end;
end;
```

**Code corrig√©** :
```pascal
procedure TMonObjet.ChargerData;  
var
  Buffer: PChar;
  i: Integer;
begin
  for i := 1 to 10 do
  begin
    Buffer := GetMem(1024);
    try
      // ... traitement ...
    finally
      FreeMem(Buffer);  // ‚úÖ Lib√©ration garantie
    end;
  end;
end;
```

### Exemple 2 : Hotspot identifi√© par Perf

**Perf report montre** :
```
  58.76%  monprogramme  TMONOBJET_CALCULCOMPLEXE
```

**Perf annotate r√©v√®le** :
```pascal
procedure TMonObjet.CalculComplexe;  
begin
  for i := 0 to 1000000 do
  begin
    ResultatArray[i] := Sqrt(i) * Sin(i);  // ‚Üê 95% du temps ici
  end;
end;
```

**Optimisation** :
```pascal
// M√©mo√Øsation des valeurs calcul√©es
const
  MaxValue = 1000000;
var
  CacheResultat: array[0..MaxValue] of Double;
  CacheInitialise: Boolean = False;

procedure TMonObjet.CalculComplexe;  
var i: Integer;  
begin
  if not CacheInitialise then
  begin
    for i := 0 to MaxValue do
      CacheResultat[i] := Sqrt(i) * Sin(i);
    CacheInitialise := True;
  end;

  // Simple copie du cache (beaucoup plus rapide)
  Move(CacheResultat, ResultatArray, SizeOf(CacheResultat));
end;
```

**R√©sultat** : Temps d'ex√©cution divis√© par 100 !

## Scripts d'automatisation

### Script de profilage complet

Cr√©ez `profile.sh` :

```bash
#!/bin/bash

PROGRAM="./monprogramme"

echo "=== PHASE 1 : V√©rification m√©moire avec Valgrind ==="  
valgrind --leak-check=full --log-file=valgrind_memcheck.log $PROGRAM  
echo "Voir valgrind_memcheck.log"

echo ""  
echo "=== PHASE 2 : Statistiques Perf ==="  
perf stat $PROGRAM 2> perf_stat.log  
cat perf_stat.log

echo ""  
echo "=== PHASE 3 : Profilage Perf ==="  
perf record -g -F 999 $PROGRAM  
perf report --stdio > perf_report.txt  
echo "Voir perf_report.txt"

echo ""  
echo "=== PHASE 4 : G√©n√©ration Flamegraph ==="  
if [ -d "FlameGraph" ]; then
    perf script > out.perf
    FlameGraph/stackcollapse-perf.pl out.perf > out.folded
    FlameGraph/flamegraph.pl out.folded > flamegraph.svg
    echo "Flamegraph g√©n√©r√© : flamegraph.svg"
fi

echo ""  
echo "=== Profilage termin√© ==="
```

Rendez-le ex√©cutable :
```bash
chmod +x profile.sh
./profile.sh
```

## Int√©gration avec Lazarus

### Configuration des outils externes

Dans Lazarus, vous pouvez ajouter Perf et Valgrind comme outils externes :

1. `Tools` ‚Üí `Configure External Tools`
2. Cliquez `Add`
3. **Pour Valgrind** :
   - Title : `Valgrind Memcheck`
   - Program : `/usr/bin/valgrind`
   - Parameters : `--leak-check=full $TargetFile`
4. **Pour Perf** :
   - Title : `Perf Record`
   - Program : `/usr/bin/perf`
   - Parameters : `record -g $TargetFile`

Ensuite, apr√®s compilation, utilisez `Tools` ‚Üí `Valgrind Memcheck` ou `Perf Record`.

## D√©pannage courant

### Perf : "Permission denied"

Si vous obtenez une erreur de permission :

```bash
sudo sysctl -w kernel.perf_event_paranoid=-1
```

### Valgrind : "No debug info available"

Recompilez avec `-g` :
```bash
fpc -g -gl monprogramme.pas
```

### Symboles manquants dans Perf

Installez les symboles de d√©bogage des biblioth√®ques syst√®me :

```bash
sudo apt install libc6-dbg libgtk-3-0-dbgsym
```

### Perf : "Failed to open [kernel.kallsyms]"

Normal pour un utilisateur non-root. Les symboles du noyau ne seront pas r√©solus, mais cela n'affecte pas le profilage de votre application.

## Ressources compl√©mentaires

### Documentation officielle

- **Perf Wiki** : https://perf.wiki.kernel.org/
- **Valgrind Manual** : https://valgrind.org/docs/manual/manual.html
- **Brendan Gregg's Perf Examples** : https://www.brendangregg.com/perf.html

### Tutoriels recommand√©s

- "Linux perf Examples" par Brendan Gregg
- "Valgrind Quick Start Guide" (valgrind.org)
- Documentation FreePascal sur l'optimisation

### Forums

- Lazarus Forum (Performance) : https://forum.lazarus.freepascal.org/
- Stack Overflow tag `valgrind` et `perf`

## R√©sum√©

Les outils de profilage Linux sont puissants et gratuits :

‚úÖ **Perf** : Profilage l√©ger et pr√©cis
  - `perf stat` pour statistiques globales
  - `perf record + report` pour identifier hotspots
  - Flamegraphs pour visualisation

‚úÖ **Valgrind** : D√©tection de bugs et analyse m√©moire
  - Memcheck pour les fuites m√©moire
  - Callgrind pour profilage d√©taill√©
  - Helgrind pour probl√®mes multi-threading

‚úÖ **Workflow** :
  1. Valgrind ‚Üí corriger bugs m√©moire
  2. Perf ‚Üí identifier hotspots
  3. Optimiser ‚Üí re-profiler

**Diff√©rence avec Windows** : Contrairement √† Intel VTune (section 20.1.1), Perf et Valgrind sont des outils en ligne de commande, mais tout aussi puissants et compl√®tement gratuits.

---

*Note : Ce tutoriel fait partie de la formation "FreePascal/Lazarus - Niveau D√©veloppeur Avanc√© - Edition Multi-plateforme Windows/Ubuntu"*

‚è≠Ô∏è [Optimisation m√©moire et caches](/20-optimisation-performance/02-optimisation-memoire-caches.md)
