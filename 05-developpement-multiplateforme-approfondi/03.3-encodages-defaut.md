üîù Retour au [Sommaire](/SOMMAIRE.md)

# Gestion des encodages par d√©faut en FreePascal/Lazarus
## D√©veloppement multi-plateforme Windows/Linux

## Introduction

Avez-vous d√©j√† ouvert un fichier texte et vu des caract√®res bizarres comme ÔøΩ ou ‚ñ° √† la place des accents ? Ou envoy√© un fichier √† un coll√®gue qui se plaint que "√ßa s'affiche mal" ? C'est un probl√®me d'encodage de caract√®res !

L'encodage d√©termine comment les caract√®res (lettres, chiffres, symboles) sont stock√©s en m√©moire ou dans les fichiers. Windows et Linux utilisent parfois des encodages diff√©rents par d√©faut, ce qui peut cr√©er des probl√®mes quand on d√©veloppe des applications multi-plateformes.

Ce tutoriel vous expliquera tout ce que vous devez savoir sur les encodages pour cr√©er des applications FreePascal/Lazarus qui fonctionnent parfaitement partout.

## Comprendre les encodages de caract√®res

### Qu'est-ce qu'un encodage ?

Un encodage est une table de correspondance entre :
- Les caract√®res que nous voyons (A, √©, ‚Ç¨, ‰Ω†...)
- Les nombres binaires stock√©s dans l'ordinateur

Par exemple, la lettre 'A' :
- En ASCII/UTF-8 : code 65 (01000001 en binaire)
- Toujours le m√™me dans tous les encodages modernes

Mais le caract√®re '√©' :
- En ISO-8859-1 (Latin-1) : code 233
- En Windows-1252 : code 233 aussi
- En UTF-8 : s√©quence de 2 octets (195, 169)

### Les principaux encodages

**ASCII (American Standard Code)**
- 7 bits, 128 caract√®res
- Lettres anglaises, chiffres, ponctuation basique
- Pas d'accents ni de caract√®res sp√©ciaux
- Identique partout (c'est la base)

**ISO-8859-1 (Latin-1)**
- 8 bits, 256 caract√®res
- Extension d'ASCII avec accents europ√©ens occidentaux
- Souvent utilis√© sur Linux/Unix historiquement
- Un octet par caract√®re

**Windows-1252 (CP1252)**
- 8 bits, 256 caract√®res
- Version Microsoft de Latin-1 avec quelques diff√©rences
- Encodage par d√©faut sur Windows occidental
- Un octet par caract√®re

**UTF-8**
- 1 √† 4 octets par caract√®re
- Peut repr√©senter TOUS les caract√®res du monde
- Compatible ASCII pour les caract√®res anglais
- Standard moderne, de plus en plus utilis√© partout

**UTF-16**
- 2 ou 4 octets par caract√®re
- Utilis√© en interne par Windows et Java
- Plus efficace pour les langues asiatiques

### Encodages par d√©faut selon les syst√®mes

**Windows (occidental) :**
- Console : CP850 ou CP437 (DOS)
- Applications GUI : Windows-1252 (ANSI)
- Notepad moderne : UTF-8 avec BOM
- Interne : UTF-16

**Linux/Ubuntu :**
- Presque tout : UTF-8
- Quelques vieux syst√®mes : ISO-8859-1
- Terminal : UTF-8

**macOS :**
- UTF-8 partout

## D√©tection et configuration en FreePascal

### Obtenir l'encodage syst√®me

```pascal
uses
  SysUtils;

procedure AfficherEncodageSysteme;
begin
  WriteLn('Encodage par d√©faut du syst√®me :');
  WriteLn('DefaultSystemCodePage : ', DefaultSystemCodePage);
  WriteLn('DefaultUnicodeCodePage : ', DefaultUnicodeCodePage);
  WriteLn('DefaultFileSystemCodePage : ', DefaultFileSystemCodePage);
  WriteLn('DefaultRTLFileSystemCodePage : ', DefaultRTLFileSystemCodePage);

  // Affichage des noms d'encodage
  case DefaultSystemCodePage of
    1252: WriteLn('Windows-1252 (Windows Latin-1)');
    65001: WriteLn('UTF-8');
    850: WriteLn('CP850 (DOS Latin-1)');
    1250: WriteLn('Windows-1250 (Europe Centrale)');
    else WriteLn('Autre encodage : ', DefaultSystemCodePage);
  end;
end;
```

### Configuration de l'encodage console

```pascal
{$IFDEF WINDOWS}
uses
  Windows;
{$ENDIF}

procedure ConfigurerConsoleUTF8;
begin
  {$IFDEF WINDOWS}
  // Sur Windows, configurer la console en UTF-8
  SetConsoleCP(CP_UTF8);        // Entr√©e
  SetConsoleOutputCP(CP_UTF8);  // Sortie
  WriteLn('Console Windows configur√©e en UTF-8');
  {$ENDIF}

  {$IFDEF UNIX}
  // Linux/Unix est g√©n√©ralement d√©j√† en UTF-8
  WriteLn('Console Unix (probablement d√©j√† en UTF-8)');
  {$ENDIF}
end;
```

## Gestion des cha√Ænes de caract√®res

### Types de cha√Ænes en FreePascal

```pascal
program TypesDeChaines;

var
  s1: AnsiString;      // Cha√Æne 8-bits, encodage selon syst√®me
  s2: UTF8String;      // Cha√Æne UTF-8 garantie
  s3: UnicodeString;   // Cha√Æne UTF-16
  s4: WideString;      // Cha√Æne UTF-16 (compatible COM sur Windows)
  s5: String;          // Type par d√©faut (AnsiString ou UnicodeString selon config)
  s6: RawByteString;   // Cha√Æne sans encodage sp√©cifique

begin
  // Exemple avec accent
  s2 := 'Caf√© fran√ßais ‚Ç¨';  // UTF-8
  s3 := 'Caf√© fran√ßais ‚Ç¨';  // UTF-16

  WriteLn('Longueur UTF8String : ', Length(s2), ' caract√®res');
  WriteLn('Octets UTF8String : ', Length(s2) * SizeOf(s2[1]), ' octets');

  WriteLn('Longueur UnicodeString : ', Length(s3), ' caract√®res');
  WriteLn('Octets UnicodeString : ', Length(s3) * SizeOf(s3[1]), ' octets');
end;
```

### Conversion entre encodages

```pascal
uses
  SysUtils, LConvEncoding;

function ConvertirEncodage(const Texte: string;
                          DeEncodage, VersEncodage: string): string;
begin
  // Utilisation de l'unit√© LConvEncoding de Lazarus
  Result := ConvertEncoding(Texte, DeEncodage, VersEncodage);
end;

procedure ExemplesConversion;
var
  texteOriginal, texteConverti: string;
begin
  texteOriginal := 'Voil√† des caract√®res accentu√©s : √© √® √™ √´ ‚Ç¨';

  // Convertir de Windows-1252 vers UTF-8
  texteConverti := ConvertEncoding(texteOriginal, 'cp1252', 'utf8');

  // Convertir de UTF-8 vers ISO-8859-1
  texteConverti := ConvertEncoding(texteOriginal, 'utf8', 'iso88591');

  // Constantes pratiques disponibles
  texteConverti := ConvertEncoding(texteOriginal, EncodingCP1252, EncodingUTF8);

  // D√©tecter et convertir automatiquement vers UTF-8
  texteConverti := ConvertEncodingToUTF8(texteOriginal);
end;
```

## Lecture et √©criture de fichiers avec encodage

### Lecture de fichiers avec d√©tection d'encodage

```pascal
uses
  Classes, SysUtils, LConvEncoding;

function LireFichierAvecEncodage(const NomFichier: string;
                                 DetecterAuto: Boolean = True): string;
var
  flux: TFileStream;
  octets: TBytes;
  encodageDetecte: string;
begin
  flux := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyWrite);
  try
    SetLength(octets, flux.Size);
    flux.ReadBuffer(octets[0], flux.Size);
  finally
    flux.Free;
  end;

  if DetecterAuto then
  begin
    // D√©tection automatique avec GuessEncoding
    encodageDetecte := GuessEncoding(PChar(@octets[0]));
    WriteLn('Encodage d√©tect√© : ', encodageDetecte);
    Result := ConvertEncodingToUTF8(TEncoding.Default.GetString(octets), encodageDetecte);
  end
  else
  begin
    // Supposer encodage syst√®me par d√©faut
    Result := TEncoding.Default.GetString(octets);
  end;
end;
```

### √âcriture de fichiers avec encodage sp√©cifique

```pascal
uses
  Classes, SysUtils, LConvEncoding;

procedure EcrireFichierUTF8(const NomFichier, Contenu: string;
                           AvecBOM: Boolean = False);
var
  flux: TFileStream;
  utf8Bytes: TBytes;
  bom: array[0..2] of Byte = ($EF, $BB, $BF);  // BOM UTF-8
begin
  flux := TFileStream.Create(NomFichier, fmCreate);
  try
    // Ajouter BOM si demand√© (aide certains √©diteurs Windows)
    if AvecBOM then
      flux.WriteBuffer(bom, 3);

    // Convertir en UTF-8 et √©crire
    utf8Bytes := TEncoding.UTF8.GetBytes(Contenu);
    flux.WriteBuffer(utf8Bytes[0], Length(utf8Bytes));
  finally
    flux.Free;
  end;

  WriteLn('Fichier √©crit en UTF-8',
          IfThen(AvecBOM, ' avec BOM', ' sans BOM'));
end;

procedure EcrireFichierEncodage(const NomFichier, Contenu, Encodage: string);
var
  liste: TStringList;
begin
  liste := TStringList.Create;
  try
    liste.Text := Contenu;

    // M√©thode simple avec TStringList
    if (LowerCase(Encodage) = 'utf8') or (LowerCase(Encodage) = 'utf-8') then
      liste.SaveToFile(NomFichier, TEncoding.UTF8)
    else if (LowerCase(Encodage) = 'utf16') or (LowerCase(Encodage) = 'utf-16') then
      liste.SaveToFile(NomFichier, TEncoding.Unicode)
    else if LowerCase(Encodage) = 'ascii' then
      liste.SaveToFile(NomFichier, TEncoding.ASCII)
    else
      liste.SaveToFile(NomFichier, TEncoding.Default);
  finally
    liste.Free;
  end;
end;
```

## Le BOM (Byte Order Mark)

### Qu'est-ce que le BOM ?

Le BOM est une s√©quence d'octets au d√©but d'un fichier qui indique :
- L'encodage utilis√©
- L'ordre des octets (big-endian ou little-endian)

**BOM par encodage :**
- UTF-8 : EF BB BF (3 octets)
- UTF-16 LE : FF FE (2 octets)
- UTF-16 BE : FE FF (2 octets)
- UTF-32 LE : FF FE 00 00 (4 octets)

### D√©tecter et g√©rer le BOM

```pascal
type
  TBOMType = (bomNone, bomUTF8, bomUTF16LE, bomUTF16BE, bomUTF32LE, bomUTF32BE);

function DetecterBOM(const NomFichier: string): TBOMType;
var
  flux: TFileStream;
  octets: array[0..3] of Byte;
  lu: Integer;
begin
  Result := bomNone;

  flux := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyWrite);
  try
    lu := flux.Read(octets, 4);

    if lu >= 3 then
    begin
      // V√©rifier UTF-8 BOM
      if (octets[0] = $EF) and (octets[1] = $BB) and (octets[2] = $BF) then
        Exit(bomUTF8);
    end;

    if lu >= 2 then
    begin
      // V√©rifier UTF-16 BOM
      if (octets[0] = $FF) and (octets[1] = $FE) then
      begin
        if (lu >= 4) and (octets[2] = $00) and (octets[3] = $00) then
          Exit(bomUTF32LE)
        else
          Exit(bomUTF16LE);
      end;

      if (octets[0] = $FE) and (octets[1] = $FF) then
        Exit(bomUTF16BE);
    end;
  finally
    flux.Free;
  end;
end;

procedure LireFichierSansBOM(const NomFichier: string; out Contenu: string);
var
  flux: TFileStream;
  tailleBOM: Integer;
  octets: TBytes;
  bomType: TBOMType;
begin
  bomType := DetecterBOM(NomFichier);

  case bomType of
    bomUTF8:    tailleBOM := 3;
    bomUTF16LE,
    bomUTF16BE: tailleBOM := 2;
    bomUTF32LE,
    bomUTF32BE: tailleBOM := 4;
    else        tailleBOM := 0;
  end;

  flux := TFileStream.Create(NomFichier, fmOpenRead);
  try
    // Sauter le BOM s'il existe
    flux.Seek(tailleBOM, soFromBeginning);

    SetLength(octets, flux.Size - tailleBOM);
    flux.ReadBuffer(octets[0], Length(octets));

    // Convertir selon le type d√©tect√©
    case bomType of
      bomUTF8:    Contenu := TEncoding.UTF8.GetString(octets);
      bomUTF16LE: Contenu := TEncoding.Unicode.GetString(octets);
      bomUTF16BE: Contenu := TEncoding.BigEndianUnicode.GetString(octets);
      else        Contenu := TEncoding.Default.GetString(octets);
    end;
  finally
    flux.Free;
  end;
end;
```

## Probl√®mes courants et solutions

### Probl√®me 1 : Affichage incorrect des accents

```pascal
procedure CorrigerAffichageAccents;
var
  texte: string;
begin
  // Texte avec accents
  texte := 'Les √©l√®ves fran√ßais √©tudient √† l''√©cole';

  {$IFDEF WINDOWS}
  // Sur Windows, s'assurer que la console supporte UTF-8
  SetConsoleOutputCP(CP_UTF8);
  {$ENDIF}

  // Convertir explicitement en UTF-8 pour l'affichage
  WriteLn(UTF8Encode(texte));

  // Ou utiliser UTF8String
  var texteUTF8: UTF8String;
  texteUTF8 := texte;
  WriteLn(texteUTF8);
end;
```

### Probl√®me 2 : Fichiers CSV avec caract√®res sp√©ciaux

```pascal
uses
  Classes, SysUtils, LConvEncoding;

procedure TraiterCSVMultiEncodage(const NomFichier: string);
var
  lignes: TStringList;
  i: Integer;
  ligne: string;
begin
  lignes := TStringList.Create;
  try
    // Charger en d√©tectant l'encodage
    lignes.LoadFromFile(NomFichier);

    // Si probl√®me d'affichage, essayer conversion explicite
    for i := 0 to lignes.Count - 1 do
    begin
      ligne := lignes[i];

      // D√©tecter si la ligne contient des caract√®res mal encod√©s
      if Pos('ÔøΩ', ligne) > 0 then
      begin
        WriteLn('Ligne mal encod√©e d√©tect√©e, tentative de correction...');
        ligne := ConvertEncodingToUTF8(ligne, GuessEncoding(ligne));
        lignes[i] := ligne;
      end;
    end;

    // Sauvegarder en UTF-8 pour √©viter les probl√®mes futurs
    lignes.SaveToFile(ChangeFileExt(NomFichier, '_utf8.csv'), TEncoding.UTF8);
  finally
    lignes.Free;
  end;
end;
```

### Probl√®me 3 : Communication r√©seau entre syst√®mes

```pascal
uses
  SysUtils, Sockets;

procedure EnvoyerDonneesReseau(Socket: TSocket; const Message: string);
var
  utf8Bytes: TBytes;
begin
  // TOUJOURS utiliser UTF-8 pour la communication r√©seau
  utf8Bytes := TEncoding.UTF8.GetBytes(Message);

  // Envoyer la taille d'abord (pour que le r√©cepteur sache combien lire)
  var taille: Integer := Length(utf8Bytes);
  Send(Socket, taille, SizeOf(taille), 0);

  // Puis envoyer les donn√©es
  Send(Socket, utf8Bytes[0], Length(utf8Bytes), 0);
end;

function RecevoirDonneesReseau(Socket: TSocket): string;
var
  taille: Integer;
  utf8Bytes: TBytes;
begin
  // Recevoir la taille
  Recv(Socket, taille, SizeOf(taille), 0);

  // Recevoir les donn√©es
  SetLength(utf8Bytes, taille);
  Recv(Socket, utf8Bytes[0], taille, 0);

  // Convertir de UTF-8 vers string
  Result := TEncoding.UTF8.GetString(utf8Bytes);
end;
```

## Gestion dans l'interface graphique

### Configuration des composants visuels

```pascal
procedure ConfigurerComposantsUTF8(Form: TForm);
begin
  // Pour un TEdit
  Form.Edit1.Text := UTF8Decode('Texte avec √© √® √† √ß');

  // Pour un TMemo
  Form.Memo1.Lines.Text := UTF8Decode('Premi√®re ligne accentu√©e' + LineEnding +
                                      'Deuxi√®me ligne avec ‚Ç¨');

  // Pour un TLabel
  Form.Label1.Caption := UTF8Decode('√âtiquette avec accents');

  // Lazarus g√®re g√©n√©ralement bien UTF-8 automatiquement
  // mais parfois la conversion explicite est n√©cessaire
end;
```

### Lecture de fichiers dans l'interface

```pascal
procedure ChargerFichierDansInterface(const NomFichier: string; Memo: TMemo);
var
  flux: TFileStream;
  octets: TBytes;
  contenu: string;
  encodage: string;
begin
  flux := TFileStream.Create(NomFichier, fmOpenRead);
  try
    SetLength(octets, flux.Size);
    flux.Read(octets[0], flux.Size);
  finally
    flux.Free;
  end;

  // D√©tection automatique de l'encodage
  encodage := GuessEncoding(PChar(@octets[0]));

  case encodage of
    EncodingUTF8:
      contenu := TEncoding.UTF8.GetString(octets);
    EncodingCP1252:
      contenu := TEncoding.GetEncoding(1252).GetString(octets);
    else
      contenu := TEncoding.Default.GetString(octets);
  end;

  // Afficher dans le Memo
  Memo.Lines.Text := contenu;

  // Afficher l'encodage d√©tect√© dans la barre de statut
  Application.MainForm.Caption := Format('Fichier : %s [%s]',
                                        [ExtractFileName(NomFichier), encodage]);
end;
```

## Base de donn√©es et encodages

### Configuration de la connexion

```pascal
uses
  SQLdb;

procedure ConfigurerConnexionUTF8(Connection: TSQLConnection);
begin
  // Pour MySQL/MariaDB
  if Connection is TMySQL57Connection then
  begin
    Connection.CharSet := 'utf8mb4';  // Support complet UTF-8 incluant emojis
    Connection.Params.Add('charset=utf8mb4');
  end;

  // Pour PostgreSQL
  if Connection is TPQConnection then
  begin
    Connection.CharSet := 'UTF8';
    Connection.Params.Add('client_encoding=UTF8');
  end;

  // Pour SQLite
  if Connection is TSQLite3Connection then
  begin
    // SQLite utilise UTF-8 par d√©faut
    Connection.Params.Add('StringFormat=Unicode');
  end;

  // Pour Firebird
  if Connection is TIBConnection then
  begin
    Connection.CharSet := 'UTF8';
    Connection.Params.Add('lc_ctype=UTF8');
  end;
end;
```

### Insertion et r√©cup√©ration de donn√©es

```pascal
procedure GererDonneesUnicode(Connection: TSQLConnection);
var
  query: TSQLQuery;
  texteAvecEmoji: string;
begin
  texteAvecEmoji := 'Bonjour üòä √áa va? ‚Ç¨100 Âåó‰∫¨';

  query := TSQLQuery.Create(nil);
  try
    query.Database := Connection;

    // Insertion
    query.SQL.Text := 'INSERT INTO messages (contenu) VALUES (:contenu)';
    query.ParamByName('contenu').AsString := UTF8Encode(texteAvecEmoji);
    query.ExecSQL;

    // Lecture
    query.SQL.Text := 'SELECT contenu FROM messages';
    query.Open;

    while not query.EOF do
    begin
      WriteLn('Message : ', UTF8Decode(query.FieldByName('contenu').AsString));
      query.Next;
    end;
  finally
    query.Free;
  end;
end;
```

## Configuration de projet pour UTF-8

### Directives de compilation

```pascal
{$codepage UTF8}           // Force UTF-8 pour les constantes string
{$mode objfpc}{$H+}       // Mode Object Pascal avec strings longues

program MonProgrammeUTF8;

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  Classes, SysUtils;

begin
  // Configuration globale UTF-8
  SetMultiByteConversionCodePage(CP_UTF8);
  SetMultiByteFileSystemCodePage(CP_UTF8);
  SetMultiByteRTLFileSystemCodePage(CP_UTF8);

  WriteLn('Programme configur√© en UTF-8');
end.
```

### Options de projet Lazarus

```xml
<!-- Dans le fichier .lpi du projet -->
<CompilerOptions>
  <Target>
    <Filename Value="monprojet"/>
  </Target>
  <SearchPaths>
    <IncludeFiles Value="$(ProjOutDir)"/>
  </SearchPaths>
  <Parsing>
    <SyntaxOptions>
      <UseAnsiStrings Value="False"/>  <!-- Utiliser UnicodeString -->
    </SyntaxOptions>
  </Parsing>
  <CodeGeneration>
    <SmartLinkUnit Value="True"/>
  </CodeGeneration>
  <Other>
    <!-- Force UTF-8 -->
    <CustomOptions Value="-FcUTF8"/>
  </Other>
</CompilerOptions>
```

## Outils de d√©bogage pour les encodages

### Analyser un fichier

```pascal
procedure AnalyserEncodageFichier(const NomFichier: string);
var
  flux: TFileStream;
  echantillon: array[0..1023] of Byte;
  lu: Integer;
  i: Integer;
  aASCII, aUTF8Valide, aLatin1: Boolean;
  sequenceUTF8: Integer;
begin
  flux := TFileStream.Create(NomFichier, fmOpenRead);
  try
    lu := flux.Read(echantillon, SizeOf(echantillon));

    aASCII := True;
    aUTF8Valide := True;
    aLatin1 := False;
    sequenceUTF8 := 0;

    for i := 0 to lu - 1 do
    begin
      // V√©rifier ASCII pur
      if echantillon[i] > 127 then
        aASCII := False;

      // V√©rifier s√©quences UTF-8
      if sequenceUTF8 > 0 then
      begin
        if (echantillon[i] and $C0) <> $80 then
          aUTF8Valide := False;
        Dec(sequenceUTF8);
      end
      else if echantillon[i] >= $80 then
      begin
        if (echantillon[i] and $E0) = $C0 then
          sequenceUTF8 := 1
        else if (echantillon[i] and $F0) = $E0 then
          sequenceUTF8 := 2
        else if (echantillon[i] and $F8) = $F0 then
          sequenceUTF8 := 3
        else if echantillon[i] >= $A0 then
          aLatin1 := True;
      end;
    end;

    WriteLn('Analyse du fichier : ', NomFichier);
    WriteLn('Taille √©chantillon : ', lu, ' octets');

    if aASCII then
      WriteLn('=> ASCII pur (7-bit)')
    else if aUTF8Valide and (sequenceUTF8 = 0) then
      WriteLn('=> UTF-8 valide')
    else if aLatin1 then
      WriteLn('=> Probablement ISO-8859-1 ou Windows-1252')
    else
      WriteLn('=> Encodage inconnu ou fichier binaire');

    // V√©rifier BOM
    case DetecterBOM(NomFichier) of
      bomUTF8:    WriteLn('   BOM UTF-8 d√©tect√©');
      bomUTF16LE: WriteLn('   BOM UTF-16 LE d√©tect√©');
      bomUTF16BE: WriteLn('   BOM UTF-16 BE d√©tect√©');
    end;
  finally
    flux.Free;
  end;
end;
```

### Afficher les codes des caract√®res

```pascal
procedure AfficherCodesCaracteres(const Texte: string);
var
  i: Integer;
  c: Char;
  b: Byte;
  utf8Bytes: TBytes;
begin
  WriteLn('Analyse caract√®re par caract√®re :');
  WriteLn('-----------------------------------');

  for i := 1 to Length(Texte) do
  begin
    c := Texte[i];
    Write(Format('"%s" : ', [c]));
    Write(Format('Code=%d (0x%2.2X) ', [Ord(c), Ord(c)]));

    // Afficher les octets UTF-8
    utf8Bytes := TEncoding.UTF8.GetBytes(c);
    Write('UTF-8=[');
    for b in utf8Bytes do
      Write(Format('0x%2.2X ', [b]));
    Write('] ');

    WriteLn;
  end;
end;

// Utilisation
begin
  AfficherCodesCaracteres('Caf√© ‚Ç¨');
  // Affichera quelque chose comme :
  // "C" : Code=67 (0x43) UTF-8=[0x43]
  // "a" : Code=97 (0x61) UTF-8=[0x61]
  // "f" : Code=102 (0x66) UTF-8=[0x66]
  // "√©" : Code=233 (0xE9) UTF-8=[0xC3 0xA9]
  // " " : Code=32 (0x20) UTF-8=[0x20]
  // "‚Ç¨" : Code=8364 (0x20AC) UTF-8=[0xE2 0x82 0xAC]
end;
```

## Exemple complet : √âditeur de texte multi-encodage

```pascal
program EditeurMultiEncodage;

uses
  SysUtils, Classes, LConvEncoding;

type
  TEditeurEncodage = class
  private
    FContenu: string;
    FEncodageActuel: string;
    FNomFichier: string;
  public
    constructor Create;

    procedure ChargerFichier(const NomFichier: string);
    procedure SauvegarderFichier(const NomFichier: string;
                                const Encodage: string = '');
    procedure ConvertirEncodage(const NouvelEncodage: string);
    procedure AfficherInfos;

    property Contenu: string read FContenu write FContenu;
    property EncodageActuel: string read FEncodageActuel;
  end;

constructor TEditeurEncodage.Create;
begin
  FEncodageActuel := EncodingUTF8;
  FContenu := '';
end;

procedure TEditeurEncodage.ChargerFichier(const NomFichier: string);
var
  flux: TFileStream;
  octets: TBytes;
  bomType: TBOMType;
  decalage: Integer;
begin
  FNomFichier := NomFichier;

  // D√©tecter BOM
  bomType := DetecterBOM(NomFichier);
  case bomType of
    bomUTF8:    begin decalage := 3; FEncodageActuel := EncodingUTF8; end;
    bomUTF16LE: begin decalage := 2; FEncodageActuel := EncodingUCS2LE; end;
    bomUTF16BE: begin decalage := 2; FEncodageActuel := EncodingUCS2BE; end;
    else        begin decalage := 0; FEncodageActuel := ''; end;
  end;

  // Lire le fichier
  flux := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyWrite);
  try
    flux.Seek(decalage, soFromBeginning);
    SetLength(octets, flux.Size - decalage);
    if Length(octets) > 0 then
      flux.ReadBuffer(octets[0], Length(octets));
  finally
    flux.Free;
  end;

  // Si pas de BOM, essayer de d√©tecter l'encodage
  if FEncodageActuel = '' then
  begin
    FEncodageActuel := GuessEncoding(PChar(@octets[0]));
    WriteLn('Encodage auto-d√©tect√© : ', FEncodageActuel);
  end
  else
    WriteLn('BOM d√©tect√©, encodage : ', FEncodageActuel);

  // Convertir en string selon l'encodage
  case FEncodageActuel of
    EncodingUTF8:
      FContenu := TEncoding.UTF8.GetString(octets);
    EncodingUCS2LE:
      FContenu := TEncoding.Unicode.GetString(octets);
    EncodingUCS2BE:
      FContenu := TEncoding.BigEndianUnicode.GetString(octets);
    EncodingCP1252:
      FContenu := TEncoding.GetEncoding(1252).GetString(octets);
    else
      // Par d√©faut, utiliser l'encodage syst√®me
      FContenu := TEncoding.Default.GetString(octets);
  end;

  WriteLn('Fichier charg√© : ', ExtractFileName(NomFichier));
  WriteLn('Taille : ', Length(FContenu), ' caract√®res');
end;

procedure TEditeurEncodage.SauvegarderFichier(const NomFichier: string;
                                              const Encodage: string = '');
var
  flux: TFileStream;
  octets: TBytes;
  encodageUtilise: string;
  ajouterBOM: Boolean;
  bom: array[0..3] of Byte;
  bomTaille: Integer;
begin
  // D√©terminer l'encodage √† utiliser
  if Encodage <> '' then
    encodageUtilise := Encodage
  else
    encodageUtilise := FEncodageActuel;

  ajouterBOM := False;
  bomTaille := 0;

  // Pr√©parer le BOM si n√©cessaire
  case encodageUtilise of
    EncodingUTF8:
      begin
        // Optionnel pour UTF-8, mais aide certains √©diteurs Windows
        if MessageDlg('Ajouter BOM UTF-8?', mtConfirmation, [mbYes, mbNo], 0) = mrYes then
        begin
          ajouterBOM := True;
          bom[0] := $EF; bom[1] := $BB; bom[2] := $BF;
          bomTaille := 3;
        end;
        octets := TEncoding.UTF8.GetBytes(FContenu);
      end;

    EncodingUCS2LE:
      begin
        ajouterBOM := True;
        bom[0] := $FF; bom[1] := $FE;
        bomTaille := 2;
        octets := TEncoding.Unicode.GetBytes(FContenu);
      end;

    EncodingUCS2BE:
      begin
        ajouterBOM := True;
        bom[0] := $FE; bom[1] := $FF;
        bomTaille := 2;
        octets := TEncoding.BigEndianUnicode.GetBytes(FContenu);
      end;

    EncodingCP1252:
      octets := TEncoding.GetEncoding(1252).GetBytes(FContenu);

    else
      octets := TEncoding.Default.GetBytes(FContenu);
  end;

  // √âcrire le fichier
  flux := TFileStream.Create(NomFichier, fmCreate);
  try
    // √âcrire BOM si n√©cessaire
    if ajouterBOM then
      flux.WriteBuffer(bom[0], bomTaille);

    // √âcrire le contenu
    if Length(octets) > 0 then
      flux.WriteBuffer(octets[0], Length(octets));
  finally
    flux.Free;
  end;

  FEncodageActuel := encodageUtilise;
  WriteLn('Fichier sauvegard√© : ', ExtractFileName(NomFichier));
  WriteLn('Encodage : ', encodageUtilise);
  if ajouterBOM then
    WriteLn('BOM ajout√©');
end;

procedure TEditeurEncodage.ConvertirEncodage(const NouvelEncodage: string);
begin
  WriteLn('Conversion de ', FEncodageActuel, ' vers ', NouvelEncodage);

  // La conversion est implicite car FContenu est en Unicode interne
  // Il suffit de changer l'encodage pour la prochaine sauvegarde
  FEncodageActuel := NouvelEncodage;

  WriteLn('Conversion effectu√©e (sera appliqu√©e √† la sauvegarde)');
end;

procedure TEditeurEncodage.AfficherInfos;
var
  i: Integer;
  nbASCII, nbLatin1, nbUnicode: Integer;
begin
  WriteLn('=== Informations sur le contenu ===');
  WriteLn('Encodage actuel : ', FEncodageActuel);
  WriteLn('Nombre de caract√®res : ', Length(FContenu));

  // Analyser les caract√®res
  nbASCII := 0;
  nbLatin1 := 0;
  nbUnicode := 0;

  for i := 1 to Length(FContenu) do
  begin
    if Ord(FContenu[i]) < 128 then
      Inc(nbASCII)
    else if Ord(FContenu[i]) < 256 then
      Inc(nbLatin1)
    else
      Inc(nbUnicode);
  end;

  WriteLn('Caract√®res ASCII (0-127) : ', nbASCII);
  WriteLn('Caract√®res Latin-1 (128-255) : ', nbLatin1);
  WriteLn('Caract√®res Unicode (>255) : ', nbUnicode);

  // Afficher les premiers caract√®res
  Write('D√©but du texte : "');
  for i := 1 to Min(50, Length(FContenu)) do
  begin
    if FContenu[i] in [#13, #10] then
      Write('¬∂')
    else
      Write(FContenu[i]);
  end;
  WriteLn('"...');
end;

// Programme principal de test
var
  editeur: TEditeurEncodage;
  choix: string;
begin
  {$IFDEF WINDOWS}
  SetConsoleCP(CP_UTF8);
  SetConsoleOutputCP(CP_UTF8);
  {$ENDIF}

  editeur := TEditeurEncodage.Create;
  try
    WriteLn('=== √âditeur Multi-Encodage ===');
    WriteLn;

    // Test 1 : Cr√©er et sauvegarder en diff√©rents encodages
    editeur.Contenu := 'Test avec accents : √© √® √† √ß √π' + LineEnding +
                      'Symboles : ‚Ç¨ ¬£ ¬•' + LineEnding +
                      'Autres : ≈ì √¶ √± √∏' + LineEnding +
                      'Emoji : üòä (si support√©)';

    editeur.AfficherInfos;
    WriteLn;

    // Sauvegarder en UTF-8
    editeur.SauvegarderFichier('test_utf8.txt', EncodingUTF8);

    // Sauvegarder en Windows-1252
    editeur.ConvertirEncodage(EncodingCP1252);
    editeur.SauvegarderFichier('test_cp1252.txt');

    // Sauvegarder en UTF-16
    editeur.ConvertirEncodage(EncodingUCS2LE);
    editeur.SauvegarderFichier('test_utf16.txt');

    WriteLn;
    WriteLn('Test 2 : Recharger les fichiers');
    WriteLn;

    // Recharger et v√©rifier
    editeur.ChargerFichier('test_utf8.txt');
    editeur.AfficherInfos;

    WriteLn;
    editeur.ChargerFichier('test_cp1252.txt');
    editeur.AfficherInfos;

  finally
    editeur.Free;
  end;

  WriteLn;
  WriteLn('Appuyez sur Entr√©e pour terminer...');
  ReadLn;
end.
```

## Bonnes pratiques pour la gestion des encodages

### 1. Standardiser sur UTF-8

UTF-8 est le meilleur choix pour la portabilit√© :

```pascal
// ‚úÖ BON : Utiliser UTF-8 partout
procedure InitialiserApplicationUTF8;
begin
  {$IFDEF WINDOWS}
  // Configurer Windows pour UTF-8
  SetConsoleCP(CP_UTF8);
  SetConsoleOutputCP(CP_UTF8);
  {$ENDIF}

  // Configurer FreePascal pour UTF-8
  SetMultiByteConversionCodePage(CP_UTF8);
  SetMultiByteFileSystemCodePage(CP_UTF8);

  // Utiliser UTF-8 pour tous les fichiers
  DefaultSystemCodePage := CP_UTF8;
end;

// ‚ùå MAUVAIS : M√©langer les encodages
procedure MauvaiseGestion;
var
  texte: string;
begin
  // Ne pas faire √ßa !
  texte := LoadFromFile('data.txt');  // Encodage inconnu
  SaveToFile('output.txt', texte);    // Encodage syst√®me par d√©faut
end;
```

### 2. Toujours sp√©cifier l'encodage explicitement

```pascal
// ‚úÖ BON : Encodage explicite
procedure BonneGestionFichiers;
var
  liste: TStringList;
begin
  liste := TStringList.Create;
  try
    // Charger avec encodage sp√©cifique
    liste.LoadFromFile('data.txt', TEncoding.UTF8);

    // Traiter...

    // Sauvegarder avec encodage sp√©cifique
    liste.SaveToFile('output.txt', TEncoding.UTF8);
  finally
    liste.Free;
  end;
end;

// ‚ùå MAUVAIS : Encodage implicite
procedure MauvaiseGestionFichiers;
var
  liste: TStringList;
begin
  liste := TStringList.Create;
  try
    liste.LoadFromFile('data.txt');  // Utilise l'encodage par d√©faut
    liste.SaveToFile('output.txt');  // Peut √™tre diff√©rent !
  finally
    liste.Free;
  end;
end;
```

### 3. G√©rer les erreurs d'encodage

```pascal
procedure GestionRobuste(const NomFichier: string);
var
  contenu: string;
  encodages: array[0..3] of string = (EncodingUTF8, EncodingCP1252,
                                      EncodingAnsi, EncodingUTF16LE);
  i: Integer;
  succes: Boolean;
begin
  succes := False;

  // Essayer plusieurs encodages
  for i := 0 to High(encodages) do
  begin
    try
      contenu := ConvertEncodingToUTF8(LoadFileToString(NomFichier), encodages[i]);

      // V√©rifier si le r√©sultat semble correct
      if Pos('ÔøΩ', contenu) = 0 then
      begin
        WriteLn('Encodage d√©tect√© : ', encodages[i]);
        succes := True;
        Break;
      end;
    except
      on E: Exception do
        WriteLn('√âchec avec ', encodages[i], ': ', E.Message);
    end;
  end;

  if not succes then
    raise Exception.Create('Impossible de d√©terminer l''encodage du fichier');
end;
```

### 4. Documenter les encodages utilis√©s

```pascal
{ Configuration d'encodage pour ce projet :
  - Tous les fichiers sources : UTF-8 sans BOM
  - Fichiers de configuration : UTF-8 avec BOM (compatibilit√© Windows)
  - Communication r√©seau : UTF-8
  - Base de donn√©es : UTF-8 (charset utf8mb4 pour MySQL)
  - Fichiers d'export : Windows-1252 pour Excel ancien, UTF-8 pour le reste }

type
  TEncodageProjet = (
    epSource,      // UTF-8 sans BOM
    epConfig,      // UTF-8 avec BOM
    epReseau,      // UTF-8
    epBaseDonnees, // UTF-8
    epExportExcel, // Windows-1252
    epExportTexte  // UTF-8
  );

function ObtenirEncodage(TypeFichier: TEncodageProjet): string;
begin
  case TypeFichier of
    epSource, epReseau, epBaseDonnees, epExportTexte:
      Result := EncodingUTF8;
    epConfig:
      Result := EncodingUTF8BOM;
    epExportExcel:
      Result := EncodingCP1252;
  end;
end;
```

## Cas d'usage sp√©cifiques

### Importation de fichiers Excel/CSV

```pascal
procedure ImporterCSV(const NomFichier: string);
var
  lignes: TStringList;
  encodageDetecte: string;
  separateur: Char;
begin
  lignes := TStringList.Create;
  try
    // Excel exporte souvent en Windows-1252 ou UTF-16
    encodageDetecte := GuessEncoding(LoadFileToString(NomFichier));

    if encodageDetecte = EncodingUTF16LE then
    begin
      // Excel moderne avec Unicode
      lignes.LoadFromFile(NomFichier, TEncoding.Unicode);
    end
    else if encodageDetecte = EncodingCP1252 then
    begin
      // Excel ancien ou export standard
      lignes.LoadFromFile(NomFichier, TEncoding.GetEncoding(1252));
    end
    else
    begin
      // Essayer UTF-8 par d√©faut
      lignes.LoadFromFile(NomFichier, TEncoding.UTF8);
    end;

    // D√©tecter le s√©parateur (peut varier selon les r√©gions)
    if Pos(#9, lignes.Text) > 0 then
      separateur := #9  // Tab
    else if Pos(';', lignes.Text) > Pos(',', lignes.Text) then
      separateur := ';'  // Point-virgule (Europe)
    else
      separateur := ','; // Virgule (US/UK)

    lignes.Delimiter := separateur;
    lignes.StrictDelimiter := True;

    // Traiter les donn√©es...
    ProcesserDonneesCSV(lignes);

  finally
    lignes.Free;
  end;
end;
```

### G√©n√©ration de rapports HTML

```pascal
procedure GenererRapportHTML(const Titre, Contenu: string;
                            const NomFichier: string);
var
  html: TStringList;
begin
  html := TStringList.Create;
  try
    html.Add('<!DOCTYPE html>');
    html.Add('<html lang="fr">');
    html.Add('<head>');
    html.Add('  <meta charset="UTF-8">');  // D√©claration UTF-8
    html.Add('  <meta name="viewport" content="width=device-width, initial-scale=1.0">');
    html.Add('  <title>' + HTMLEncode(Titre) + '</title>');
    html.Add('</head>');
    html.Add('<body>');
    html.Add('  <h1>' + HTMLEncode(Titre) + '</h1>');
    html.Add('  <div class="content">');
    html.Add('    ' + HTMLEncode(Contenu));
    html.Add('  </div>');
    html.Add('</body>');
    html.Add('</html>');

    // Sauvegarder en UTF-8 pour compatibilit√© maximale
    html.SaveToFile(NomFichier, TEncoding.UTF8);

    WriteLn('Rapport HTML g√©n√©r√© : ', NomFichier);
  finally
    html.Free;
  end;
end;

function HTMLEncode(const S: string): string;
begin
  Result := StringReplace(S, '&', '&amp;', [rfReplaceAll]);
  Result := StringReplace(Result, '<', '&lt;', [rfReplaceAll]);
  Result := StringReplace(Result, '>', '&gt;', [rfReplaceAll]);
  Result := StringReplace(Result, '"', '&quot;', [rfReplaceAll]);
  Result := StringReplace(Result, '''', '&#39;', [rfReplaceAll]);
end;
```

### Logs multi-plateformes

```pascal
type
  TLoggerMultiPlateforme = class
  private
    FNomFichier: string;
    FEncodage: TEncoding;
  public
    constructor Create(const NomFichier: string);
    destructor Destroy; override;
    procedure Log(const Message: string);
    procedure LogErreur(const Erreur: string);
  end;

constructor TLoggerMultiPlateforme.Create(const NomFichier: string);
var
  flux: TFileStream;
  bom: array[0..2] of Byte;
begin
  FNomFichier := NomFichier;

  // UTF-8 pour tous les logs (portable)
  FEncodage := TEncoding.UTF8;

  // Cr√©er le fichier avec BOM pour meilleure compatibilit√© Windows
  if not FileExists(FNomFichier) then
  begin
    flux := TFileStream.Create(FNomFichier, fmCreate);
    try
      // Ajouter BOM UTF-8
      bom[0] := $EF;
      bom[1] := $BB;
      bom[2] := $BF;
      flux.WriteBuffer(bom, 3);
    finally
      flux.Free;
    end;
  end;
end;

procedure TLoggerMultiPlateforme.Log(const Message: string);
var
  flux: TFileStream;
  ligne: string;
  octets: TBytes;
begin
  ligne := FormatDateTime('yyyy-mm-dd hh:nn:ss', Now) + ' | INFO | ' +
           Message + LineEnding;

  octets := FEncodage.GetBytes(ligne);

  flux := TFileStream.Create(FNomFichier, fmOpenWrite or fmShareDenyWrite);
  try
    flux.Seek(0, soFromEnd);
    flux.WriteBuffer(octets[0], Length(octets));
  finally
    flux.Free;
  end;
end;

procedure TLoggerMultiPlateforme.LogErreur(const Erreur: string);
begin
  Log('ERREUR : ' + Erreur);
end;
```

## Tableau r√©capitulatif des encodages

| Aspect | Windows | Linux/Ubuntu | Solution FreePascal |
|--------|---------|--------------|-------------------|
| **Console** | CP850/CP437 | UTF-8 | SetConsoleCP(CP_UTF8) |
| **GUI** | Windows-1252 | UTF-8 | UTF8String |
| **Fichiers texte** | ANSI/UTF-16 | UTF-8 | TEncoding.UTF8 |
| **BOM** | Souvent pr√©sent | Rarement utilis√© | D√©tecter avec DetecterBOM() |
| **Base de donn√©es** | Varie | UTF-8 | CharSet := 'UTF8' |
| **Web** | UTF-8 recommand√© | UTF-8 | Content-Type: charset=utf-8 |
| **Source code** | ANSI ou UTF-8 | UTF-8 | {$codepage UTF8} |

## Points cl√©s √† retenir

1. **UTF-8 est votre ami** : C'est le seul encodage vraiment universel et portable

2. **Soyez explicite** : Sp√©cifiez toujours l'encodage au lieu de compter sur les valeurs par d√©faut

3. **Testez sur les deux plateformes** : Un fichier qui s'affiche bien sur Windows peut avoir des probl√®mes sur Linux et vice versa

4. **G√©rez le BOM avec soin** : Windows l'aime, Linux ne l'exige pas, d√©tectez-le toujours

5. **Convertissez aux fronti√®res** : Lors de l'import/export, convertissez imm√©diatement vers votre encodage interne (UTF-8)

6. **Documentez vos choix** : Indiquez clairement quel encodage est utilis√© pour chaque type de fichier

## Conclusion

La gestion correcte des encodages est essentielle pour cr√©er des applications FreePascal/Lazarus v√©ritablement portables. Les diff√©rences entre Windows (souvent Windows-1252) et Linux (UTF-8 quasi-universel) peuvent causer des probl√®mes subtils mais frustrants.

En suivant les bonnes pratiques pr√©sent√©es dans ce tutoriel - notamment l'utilisation syst√©matique d'UTF-8, la sp√©cification explicite des encodages et la gestion appropri√©e du BOM - vous pouvez cr√©er des applications robustes qui fonctionnent parfaitement sur toutes les plateformes, quelle que soit la langue ou les caract√®res sp√©ciaux utilis√©s.

N'oubliez pas : quand vous voyez des caract√®res ÔøΩ ou ‚ñ°, c'est presque toujours un probl√®me d'encodage. Avec les outils et techniques pr√©sent√©s ici, vous saurez les diagnostiquer et les r√©soudre efficacement.

‚è≠Ô∏è [Sensibilit√© √† la casse](/05-developpement-multiplateforme-approfondi/03.4-sensibilite-casse.md)
