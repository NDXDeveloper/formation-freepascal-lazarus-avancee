üîù Retour au [Sommaire](/SOMMAIRE.md)

# 5.2.1 Win32/Win64 pour Windows

## Introduction au Widgetset Windows

Le widgetset Win32/Win64 est l'impl√©mentation native de Lazarus pour Windows. Il utilise directement l'API Windows (Win32 API) pour cr√©er et g√©rer tous les composants graphiques. C'est le choix le plus naturel et le plus performant pour d√©velopper des applications Windows avec Lazarus.

### Qu'est-ce que Win32/Win64 ?

- **Win32** : API 32 bits de Windows, existe depuis Windows 95
- **Win64** : Extension 64 bits de Win32, compatible avec les syst√®mes 64 bits
- Les deux utilisent les m√™mes fonctions, avec des diff√©rences mineures pour la gestion de la m√©moire

Dans Lazarus, on parle g√©n√©ralement de "Win32" m√™me pour les applications 64 bits, car l'API reste fondamentalement la m√™me.

### Pourquoi Choisir Win32/Win64 ?

**Avantages majeurs :**
- ‚úì **100% natif** : Vos applications ont exactement le look Windows
- ‚úì **Aucune d√©pendance** : Pas besoin d'installer de biblioth√®ques suppl√©mentaires
- ‚úì **Performance optimale** : Communication directe avec Windows
- ‚úì **Taille minimale** : Ex√©cutables plus petits
- ‚úì **Int√©gration parfaite** : Support complet des fonctionnalit√©s Windows

## Architecture du Widgetset Win32

### Comment √ßa Fonctionne ?

```
Votre Code Lazarus
    ‚Üì
TButton (LCL)
    ‚Üì
TWin32WSButton (Widgetset Win32)
    ‚Üì
CreateWindow('BUTTON', ...) (API Windows)
    ‚Üì
Bouton Windows Natif
```

Chaque composant LCL a une classe correspondante dans le widgetset Win32 qui sait comment cr√©er et g√©rer le contr√¥le Windows √©quivalent.

### Exemple Concret : Cr√©ation d'un Bouton

Quand vous √©crivez :
```pascal
Button1 := TButton.Create(Form1);
Button1.Parent := Form1;
Button1.Caption := 'Cliquer';
```

Voici ce qui se passe en coulisses :

```pascal
// Le widgetset Win32 appelle l'API Windows
hButton := CreateWindowEx(
  0,                          // Styles √©tendus
  'BUTTON',                   // Classe Windows pour les boutons
  'Cliquer',                  // Texte du bouton
  WS_CHILD or WS_VISIBLE or BS_PUSHBUTTON, // Styles
  10, 10, 75, 25,            // Position et taille
  Form1.Handle,               // Handle de la fen√™tre parent
  0,                          // ID du menu
  HInstance,                  // Instance de l'application
  nil                         // Donn√©es suppl√©mentaires
);
```

## Configuration et Utilisation

### S√©lectionner Win32/Win64

#### Dans l'IDE Lazarus

1. Ouvrez votre projet
2. Menu **Projet** ‚Üí **Options du projet**
3. Section **Compilateur** ‚Üí **Ajouts et Substitutions**
4. **LCLWidgetType** ‚Üí S√©lectionnez **win32**

#### En Ligne de Commande

```bash
# Compiler pour Windows 32 bits
lazbuild --os=win32 --ws=win32 monprojet.lpi

# Compiler pour Windows 64 bits
lazbuild --os=win64 --ws=win32 monprojet.lpi
```

#### Dans le Code

```pascal
program MonApplication;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}
  cthreads,
  {$ENDIF}
  Interfaces, // Initialise le widgetset (Win32 sur Windows)
  Forms,
  Unit1;

begin
  RequireDerivedFormResource := True;
  Application.Scaled := True;
  Application.Initialize;
  Application.CreateForm(TForm1, Form1);
  Application.Run;
end.
```

### V√©rifier le Widgetset Actif

```pascal
uses LCLPlatformDef, InterfaceBase;

procedure AfficherInfoWidgetset;
begin
  if WidgetSet.LCLPlatform = lpWin32 then
    ShowMessage('Application Win32 32-bits')
  else if WidgetSet.LCLPlatform = lpWin64 then
    ShowMessage('Application Win32 64-bits');

  // Afficher la version Windows
  ShowMessage(Format('Windows %d.%d Build %d',
    [Win32MajorVersion, Win32MinorVersion, Win32BuildNumber]));
end;
```

## Fonctionnalit√©s Sp√©cifiques Win32

### 1. Styles Windows et Th√®mes

Le widgetset Win32 supporte automatiquement les th√®mes visuels Windows :

```pascal
uses Themes;

procedure AppliquerTheme;
begin
  // Les contr√¥les utilisent automatiquement le th√®me Windows actif
  // Mais on peut le v√©rifier :
  if ThemeServices.ThemesEnabled then
    ShowMessage('Th√®mes visuels activ√©s')
  else
    ShowMessage('Mode classique Windows');
end;

// Dessiner avec le th√®me actuel
procedure TForm1.Paint;
var
  Details: TThemedElementDetails;
  R: TRect;
begin
  if ThemeServices.ThemesEnabled then
  begin
    R := Rect(10, 10, 110, 40);
    Details := ThemeServices.GetElementDetails(tbPushButtonNormal);
    ThemeServices.DrawElement(Canvas.Handle, Details, R);
    ThemeServices.DrawText(Canvas.Handle, Details, 'Bouton th√®me', R,
      DT_CENTER or DT_VCENTER or DT_SINGLELINE, 0);
  end;
end;
```

### 2. Ic√¥nes et Ressources Windows

```pascal
// Charger une ic√¥ne depuis les ressources Windows
procedure ChargerIconeSysteme;
var
  Icon: TIcon;
begin
  Icon := TIcon.Create;
  try
    // Charger une ic√¥ne syst√®me Windows
    Icon.Handle := LoadIcon(0, IDI_INFORMATION);
    Image1.Picture.Icon := Icon;
  finally
    Icon.Free;
  end;
end;

// Utiliser les ic√¥nes de shell Windows
uses ShellAPI;

procedure AfficherIconeFichier(const FileName: string);
var
  SHFileInfo: TSHFileInfo;
  Icon: TIcon;
begin
  // Obtenir l'ic√¥ne associ√©e √† un type de fichier
  SHGetFileInfo(PChar(FileName), 0, SHFileInfo, SizeOf(SHFileInfo),
    SHGFI_ICON or SHGFI_LARGEICON);

  Icon := TIcon.Create;
  try
    Icon.Handle := SHFileInfo.hIcon;
    Image1.Picture.Icon := Icon;
  finally
    Icon.Free;
  end;
end;
```

### 3. Bo√Ætes de Dialogue Natives

```pascal
uses ComDlgs, ShlObj;

// Utiliser le dialogue de s√©lection de dossier Windows
function SelectionnerDossier: string;
var
  BrowseInfo: TBrowseInfo;
  ItemIDList: PItemIDList;
  Buffer: array[0..MAX_PATH] of Char;
begin
  Result := '';

  FillChar(BrowseInfo, SizeOf(BrowseInfo), 0);
  BrowseInfo.hwndOwner := Application.MainForm.Handle;
  BrowseInfo.pszDisplayName := Buffer;
  BrowseInfo.lpszTitle := 'S√©lectionner un dossier';
  BrowseInfo.ulFlags := BIF_RETURNONLYFSDIRS or BIF_NEWDIALOGSTYLE;

  ItemIDList := SHBrowseForFolder(BrowseInfo);
  if ItemIDList <> nil then
  begin
    SHGetPathFromIDList(ItemIDList, Buffer);
    Result := Buffer;
    CoTaskMemFree(ItemIDList);
  end;
end;

// Dialogue de propri√©t√©s de fichier
procedure AfficherProprietesFichier(const FileName: string);
var
  SEI: TShellExecuteInfo;
begin
  FillChar(SEI, SizeOf(SEI), 0);
  SEI.cbSize := SizeOf(SEI);
  SEI.lpFile := PChar(FileName);
  SEI.lpVerb := 'properties';
  SEI.fMask := SEE_MASK_INVOKEIDLIST;
  ShellExecuteEx(@SEI);
end;
```

### 4. Int√©gration avec l'Explorateur Windows

```pascal
// Menu contextuel de l'Explorateur
uses ComObj, ActiveX, ShlObj;

procedure AfficherMenuContextuel(const FileName: string; X, Y: Integer);
var
  Desktop: IShellFolder;
  Folder: IShellFolder;
  ItemIDList: PItemIDList;
  ContextMenu: IContextMenu;
  Menu: HMENU;
  Cmd: Integer;
  ICI: TCMInvokeCommandInfo;
begin
  OleCheck(SHGetDesktopFolder(Desktop));
  OleCheck(Desktop.ParseDisplayName(0, nil, PWideChar(WideString(ExtractFilePath(FileName))),
    ULONG(nil^), ItemIDList, ULONG(nil^)));
  OleCheck(Desktop.BindToObject(ItemIDList, nil, IShellFolder, Folder));

  // Obtenir le menu contextuel
  OleCheck(Folder.GetUIObjectOf(0, 1, ItemIDList, IContextMenu, nil, ContextMenu));

  Menu := CreatePopupMenu;
  try
    ContextMenu.QueryContextMenu(Menu, 0, 1, $7FFF, CMF_NORMAL);

    // Afficher le menu
    Cmd := TrackPopupMenu(Menu, TPM_LEFTALIGN or TPM_RETURNCMD, X, Y, 0,
      Application.MainForm.Handle, nil);

    if Cmd > 0 then
    begin
      // Ex√©cuter la commande
      FillChar(ICI, SizeOf(ICI), 0);
      ICI.cbSize := SizeOf(ICI);
      ICI.lpVerb := MakeIntResource(Cmd - 1);
      ICI.nShow := SW_SHOWNORMAL;
      ContextMenu.InvokeCommand(ICI);
    end;
  finally
    DestroyMenu(Menu);
  end;
end;
```

### 5. Notifications Syst√®me Windows

```pascal
uses ShellAPI;

type
  TForm1 = class(TForm)
  private
    FTrayIcon: TNotifyIconData;
    procedure InitTrayIcon;
    procedure ShowBalloonTip(const Title, Text: string);
  end;

procedure TForm1.InitTrayIcon;
begin
  FillChar(FTrayIcon, SizeOf(FTrayIcon), 0);
  FTrayIcon.cbSize := SizeOf(FTrayIcon);
  FTrayIcon.Wnd := Handle;
  FTrayIcon.uID := 1;
  FTrayIcon.uFlags := NIF_ICON or NIF_MESSAGE or NIF_TIP;
  FTrayIcon.uCallbackMessage := WM_USER + 1;
  FTrayIcon.hIcon := Application.Icon.Handle;
  StrCopy(FTrayIcon.szTip, 'Mon Application');

  Shell_NotifyIcon(NIM_ADD, @FTrayIcon);
end;

procedure TForm1.ShowBalloonTip(const Title, Text: string);
begin
  FTrayIcon.uFlags := NIF_INFO;
  StrCopy(FTrayIcon.szInfoTitle, PChar(Title));
  StrCopy(FTrayIcon.szInfo, PChar(Text));
  FTrayIcon.dwInfoFlags := NIIF_INFO;
  FTrayIcon.uTimeout := 3000;

  Shell_NotifyIcon(NIM_MODIFY, @FTrayIcon);
end;
```

## Gestion des Messages Windows

### Intercepter les Messages Windows

```pascal
type
  TForm1 = class(TForm)
  protected
    procedure WndProc(var Message: TMessage); override;
  end;

procedure TForm1.WndProc(var Message: TMessage);
begin
  case Message.Msg of
    WM_NCHITTEST:
      begin
        // Personnaliser les zones de la fen√™tre
        inherited WndProc(Message);
        if Message.Result = htClient then
          Message.Result := htCaption; // Permet de d√©placer la fen√™tre depuis le client
      end;

    WM_POWERBROADCAST:
      begin
        // D√©tecter les changements d'alimentation
        case Message.WParam of
          PBT_APMSUSPEND:
            ShowMessage('Le syst√®me va se mettre en veille');
          PBT_APMRESUMEAUTOMATIC:
            ShowMessage('R√©veil du syst√®me');
        end;
      end;

    WM_DEVICECHANGE:
      begin
        // D√©tecter l'insertion/retrait de p√©riph√©riques USB
        if Message.WParam = DBT_DEVICEARRIVAL then
          ShowMessage('P√©riph√©rique USB connect√©')
        else if Message.WParam = DBT_DEVICEREMOVECOMPLETE then
          ShowMessage('P√©riph√©rique USB d√©connect√©');
      end;
  else
    inherited WndProc(Message);
  end;
end;
```

### Envoyer des Messages √† d'Autres Applications

```pascal
// Trouver et communiquer avec une autre application
procedure EnvoyerMessageAutreApp;
var
  Wnd: HWND;
  CopyData: TCopyDataStruct;
  Msg: string;
begin
  // Trouver une fen√™tre par son titre
  Wnd := FindWindow(nil, 'Notepad');
  if Wnd <> 0 then
  begin
    // Envoyer un message simple
    SendMessage(Wnd, WM_CLOSE, 0, 0);

    // Ou envoyer des donn√©es
    Msg := 'Bonjour depuis Lazarus!';
    CopyData.dwData := 0;
    CopyData.cbData := Length(Msg) + 1;
    CopyData.lpData := PChar(Msg);
    SendMessage(Wnd, WM_COPYDATA, Handle, LPARAM(@CopyData));
  end;
end;
```

## Optimisations Sp√©cifiques Win32

### 1. Double Buffering pour √âviter le Scintillement

```pascal
// Activer le double buffering sur un formulaire
procedure TForm1.FormCreate(Sender: TObject);
begin
  DoubleBuffered := True;

  // Pour les contr√¥les enfants aussi
  Panel1.DoubleBuffered := True;

  // Alternative : utiliser WS_EX_COMPOSITED
  SetWindowLong(Handle, GWL_EXSTYLE,
    GetWindowLong(Handle, GWL_EXSTYLE) or WS_EX_COMPOSITED);
end;
```

### 2. Gestion Optimis√©e du Dessin

```pascal
procedure TForm1.PaintBox1Paint(Sender: TObject);
var
  DC: HDC;
  OldPen: HPEN;
  OldBrush: HBRUSH;
begin
  DC := PaintBox1.Canvas.Handle;

  // Utiliser directement l'API GDI pour la performance
  OldPen := SelectObject(DC, GetStockObject(BLACK_PEN));
  OldBrush := SelectObject(DC, GetStockObject(WHITE_BRUSH));

  // Dessiner directement avec GDI
  Rectangle(DC, 10, 10, 100, 100);

  // Restaurer les objets originaux
  SelectObject(DC, OldPen);
  SelectObject(DC, OldBrush);
end;
```

### 3. R√©duction de l'Utilisation M√©moire

```pascal
// Lib√©rer la m√©moire de travail (Working Set)
procedure ReduceMemoryUsage;
begin
  if Win32Platform = VER_PLATFORM_WIN32_NT then
  begin
    SetProcessWorkingSetSize(GetCurrentProcess, DWORD(-1), DWORD(-1));
  end;
end;

// Appeler apr√®s le chargement de l'application
procedure TForm1.FormShow(Sender: TObject);
begin
  Application.ProcessMessages;
  ReduceMemoryUsage;
end;
```

## Gestion des Versions Windows

### D√©tecter la Version de Windows

```pascal
uses Windows, SysUtils;

function GetWindowsVersion: string;
var
  VersionInfo: TOSVersionInfoEx;
begin
  FillChar(VersionInfo, SizeOf(VersionInfo), 0);
  VersionInfo.dwOSVersionInfoSize := SizeOf(VersionInfo);

  if GetVersionEx(@VersionInfo) then
  begin
    Result := Format('Windows %d.%d Build %d SP%d',
      [VersionInfo.dwMajorVersion,
       VersionInfo.dwMinorVersion,
       VersionInfo.dwBuildNumber,
       VersionInfo.wServicePackMajor]);

    // Identifier la version
    case VersionInfo.dwMajorVersion of
      10: Result := Result + ' (Windows 10/11)';
      6:
        case VersionInfo.dwMinorVersion of
          3: Result := Result + ' (Windows 8.1)';
          2: Result := Result + ' (Windows 8)';
          1: Result := Result + ' (Windows 7)';
          0: Result := Result + ' (Windows Vista)';
        end;
      5:
        case VersionInfo.dwMinorVersion of
          2: Result := Result + ' (Windows XP 64/Server 2003)';
          1: Result := Result + ' (Windows XP)';
        end;
    end;
  end;
end;
```

### Adapter le Comportement Selon la Version

```pascal
procedure AdapterSelonWindows;
begin
  // Utiliser Aero sur Windows Vista+
  if (Win32MajorVersion >= 6) then
  begin
    // Activer la transparence Aero
    Form1.AlphaBlend := True;
    Form1.AlphaBlendValue := 240;
  end;

  // Utiliser les notifications modernes sur Windows 10+
  if (Win32MajorVersion >= 10) then
  begin
    // Utiliser les toast notifications
    ShowToastNotification('Notification moderne');
  end
  else
  begin
    // Utiliser les balloon tips classiques
    ShowBalloonTip('Notification classique');
  end;
end;
```

## Gestion du DPI et Mise √† l'√âchelle

### Support du High DPI

```pascal
// Rendre l'application DPI-aware
procedure InitDPIAwareness;
type
  TSetProcessDPIAware = function: BOOL; stdcall;
var
  SetProcessDPIAware: TSetProcessDPIAware;
  UserLib: HMODULE;
begin
  // Pour Windows Vista+
  UserLib := LoadLibrary('user32.dll');
  if UserLib <> 0 then
  begin
    SetProcessDPIAware := GetProcAddress(UserLib, 'SetProcessDPIAware');
    if Assigned(SetProcessDPIAware) then
      SetProcessDPIAware;
    FreeLibrary(UserLib);
  end;
end;

// Obtenir le DPI actuel
function GetCurrentDPI: Integer;
var
  DC: HDC;
begin
  DC := GetDC(0);
  try
    Result := GetDeviceCaps(DC, LOGPIXELSX);
  finally
    ReleaseDC(0, DC);
  end;
end;

// Adapter les tailles selon le DPI
procedure AdapterAuDPI;
var
  DPI: Integer;
  ScaleFactor: Double;
begin
  DPI := GetCurrentDPI;
  ScaleFactor := DPI / 96; // 96 est le DPI standard

  // Adapter les tailles
  Form1.Width := Round(800 * ScaleFactor);
  Form1.Height := Round(600 * ScaleFactor);

  // Adapter les polices
  Form1.Font.Size := Round(9 * ScaleFactor);
end;
```

## Probl√®mes Courants et Solutions

### 1. Scintillement lors du Redimensionnement

**Probl√®me :** La fen√™tre scintille quand on la redimensionne.

**Solution :**
```pascal
type
  TForm1 = class(TForm)
  protected
    procedure CreateParams(var Params: TCreateParams); override;
  end;

procedure TForm1.CreateParams(var Params: TCreateParams);
begin
  inherited CreateParams(Params);
  // Ajouter le style CS_HREDRAW et CS_VREDRAW
  Params.WindowClass.style := Params.WindowClass.style and not (CS_HREDRAW or CS_VREDRAW);
end;
```

### 2. Contr√¥les qui ne se Rafra√Æchissent Pas

**Probl√®me :** Les contr√¥les ne se mettent pas √† jour correctement.

**Solution :**
```pascal
// Forcer le rafra√Æchissement
Control.Invalidate;  // Marque pour repeindre
Control.Update;      // Force le repeint imm√©diat

// Ou pour toute la fen√™tre
InvalidateRect(Handle, nil, True);
UpdateWindow(Handle);
```

### 3. Probl√®mes avec les Th√®mes Windows

**Probl√®me :** Les contr√¥les personnalis√©s n'utilisent pas le th√®me.

**Solution :**
```pascal
uses Themes, UxTheme;

procedure TCustomControl.Paint;
var
  Theme: HTHEME;
  R: TRect;
begin
  if ThemeServices.ThemesEnabled then
  begin
    Theme := OpenThemeData(Handle, 'BUTTON');
    if Theme <> 0 then
    begin
      R := ClientRect;
      DrawThemeBackground(Theme, Canvas.Handle, BP_PUSHBUTTON, PBS_NORMAL, @R, nil);
      CloseThemeData(Theme);
    end;
  end
  else
    // Dessiner sans th√®me
    Canvas.Rectangle(ClientRect);
end;
```

## D√©ploiement d'Applications Win32

### Fichiers Requis

Pour une application Win32 pure Lazarus, vous n'avez besoin que de :
- Votre fichier .exe
- √âventuellement des DLL si vous utilisez des biblioth√®ques externes

**Pas besoin de :**
- Runtime sp√©cifique
- Biblioth√®ques graphiques suppl√©mentaires
- Fichiers de configuration syst√®me

### Cr√©ation d'un Installateur

```pascal
// Script Inno Setup pour installer votre application
[Setup]
AppName=Mon Application
AppVersion=1.0
DefaultDirName={pf}\MonApp
DefaultGroupName=Mon Application
OutputBaseFilename=Setup_MonApp

[Files]
Source: "MonApp.exe"; DestDir: "{app}"
Source: "Readme.txt"; DestDir: "{app}"; Flags: isreadme

[Icons]
Name: "{group}\Mon Application"; Filename: "{app}\MonApp.exe"
Name: "{group}\D√©sinstaller"; Filename: "{uninstallexe}"
Name: "{commondesktop}\Mon Application"; Filename: "{app}\MonApp.exe"

[Run]
Filename: "{app}\MonApp.exe"; Description: "Lancer Mon Application"; Flags: nowait postinstall skipifsilent
```

## Bonnes Pratiques Win32

### 1. Toujours Lib√©rer les Ressources Windows

```pascal
var
  Bitmap: HBITMAP;
  DC: HDC;
  Font: HFONT;
begin
  // Cr√©er les ressources
  DC := GetDC(Handle);
  Bitmap := CreateBitmap(100, 100, 1, 32, nil);
  Font := CreateFont(...);

  try
    // Utiliser les ressources
    SelectObject(DC, Bitmap);
    SelectObject(DC, Font);
    // ...
  finally
    // TOUJOURS lib√©rer
    DeleteObject(Bitmap);
    DeleteObject(Font);
    ReleaseDC(Handle, DC);
  end;
end;
```

### 2. G√©rer les Handles avec Pr√©caution

```pascal
// V√©rifier que le handle existe avant de l'utiliser
if IsWindow(Handle) then
begin
  // Utiliser le handle
end;

// V√©rifier qu'un contr√¥le a un handle
if Button1.HandleAllocated then
begin
  // Utiliser Button1.Handle
end;
```

### 3. Utiliser les Constantes Windows Correctement

```pascal
// Utiliser les constantes pr√©d√©finies
ShowWindow(Handle, SW_MAXIMIZE);  // Correct
ShowWindow(Handle, 3);            // √Ä √©viter

// Combiner les flags correctement
Style := WS_VISIBLE or WS_CHILD or WS_BORDER;  // Correct
Style := WS_VISIBLE + WS_CHILD + WS_BORDER;    // Fonctionne mais moins clair
```

## Conclusion

Le widgetset Win32/Win64 est le choix optimal pour d√©velopper des applications Windows avec Lazarus. Il offre :

- **Performance maximale** gr√¢ce √† l'utilisation directe de l'API Windows
- **Int√©gration parfaite** avec toutes les fonctionnalit√©s Windows
- **Aucune d√©pendance externe** pour une distribution simple
- **Taille d'ex√©cutable r√©duite** compar√© aux autres widgetsets
- **Look and feel 100% Windows** respectant les pr√©f√©rences utilisateur

En ma√Ætrisant le widgetset Win32, vous pouvez cr√©er des applications Windows professionnelles qui s'int√®grent parfaitement au syst√®me, tout en conservant la portabilit√© de votre code Lazarus pour d'autres plateformes si n√©cessaire.

‚è≠Ô∏è [GTK2/GTK3 pour Ubuntu/Linux](/05-developpement-multiplateforme-approfondi/02.2-gtk2-gtk3-ubuntu-linux.md)
