üîù Retour au [Sommaire](/SOMMAIRE.md)

# Gestion des fins de ligne (CRLF vs LF) en FreePascal/Lazarus
## D√©veloppement multi-plateforme Windows/Linux

## Introduction

Quand vous tapez sur la touche "Entr√©e" de votre clavier pour passer √† la ligne suivante dans un fichier texte, votre ordinateur ins√®re des caract√®res invisibles sp√©ciaux. Le probl√®me ? Windows et Linux n'utilisent pas les m√™mes caract√®res pour repr√©senter cette fin de ligne !

Cette diff√©rence peut causer des probl√®mes subtils mais frustrants : des fichiers qui s'affichent mal, des scripts qui ne fonctionnent pas, ou des comparaisons de texte qui √©chouent myst√©rieusement. Ce tutoriel vous expliquera tout ce que vous devez savoir pour g√©rer correctement les fins de ligne dans vos applications FreePascal/Lazarus.

## Comprendre les caract√®res de fin de ligne

### Les caract√®res invisibles

Les fins de ligne sont repr√©sent√©es par des caract√®res de contr√¥le invisibles :

- **CR (Carriage Return)** : Retour chariot - Code ASCII 13 - Repr√©sent√© par `\r`
- **LF (Line Feed)** : Saut de ligne - Code ASCII 10 - Repr√©sent√© par `\n`

### Les conventions par syst√®me

**Windows (CRLF) :**
- Utilise la s√©quence CR+LF (deux caract√®res)
- En hexad√©cimal : 0D 0A
- En Pascal : #13#10
- Repr√©sentation : `\r\n`

**Linux/Unix/macOS moderne (LF) :**
- Utilise uniquement LF (un seul caract√®re)
- En hexad√©cimal : 0A
- En Pascal : #10
- Repr√©sentation : `\n`

**Mac classique (avant macOS X) :**
- Utilisait uniquement CR
- En hexad√©cimal : 0D
- En Pascal : #13
- Repr√©sentation : `\r`
- (Rarement rencontr√© aujourd'hui)

### Visualisation de l'impact

Imaginons un fichier texte simple avec deux lignes :
```
Bonjour  
Monde
```

**En m√©moire sur Windows (CRLF) :**
```
B o n j o u r [CR][LF] M o n d e [CR][LF]
```

**En m√©moire sur Linux (LF) :**
```
B o n j o u r [LF] M o n d e [LF]
```

## Les constantes FreePascal pour la portabilit√©

FreePascal fournit des constantes qui s'adaptent automatiquement au syst√®me :

### LineEnding - La constante universelle

```pascal
uses
  SysUtils;

var
  texte: string;
begin
  // LineEnding contient automatiquement la bonne s√©quence
  // #13#10 sur Windows, #10 sur Linux
  texte := 'Premi√®re ligne' + LineEnding + 'Deuxi√®me ligne';

  WriteLn('Fin de ligne sur ce syst√®me : ');
  WriteLn('Longueur : ', Length(LineEnding), ' caract√®re(s)');

  // Sur Windows : affichera "2 caract√®re(s)"
  // Sur Linux : affichera "1 caract√®re(s)"
end;
```

### sLineBreak - Alternative √† LineEnding

```pascal
uses
  SysUtils;

var
  message: string;
begin
  // sLineBreak est un synonyme de LineEnding
  message := 'Ligne 1' + sLineBreak + 'Ligne 2' + sLineBreak + 'Ligne 3';

  WriteLn(message);
end;
```

## Probl√®mes courants et leurs solutions

### Probl√®me 1 : Lecture de fichiers cr√©√©s sur un autre syst√®me

Quand vous lisez un fichier Windows sur Linux (ou inversement), les fins de ligne peuvent poser probl√®me.

```pascal
uses
  SysUtils, Classes;

procedure LireFichierMultiPlateforme(const NomFichier: string);  
var
  lignes: TStringList;
  i: Integer;
begin
  lignes := TStringList.Create;
  try
    // TStringList g√®re automatiquement les diff√©rentes fins de ligne !
    lignes.LoadFromFile(NomFichier);

    WriteLn('Nombre de lignes : ', lignes.Count);

    for i := 0 to lignes.Count - 1 do
    begin
      WriteLn('Ligne ', i + 1, ': ', lignes[i]);
      // Les fins de ligne ont √©t√© automatiquement normalis√©es
    end;
  finally
    lignes.Free;
  end;
end;
```

### Probl√®me 2 : √âcriture de fichiers portables

Pour cr√©er des fichiers qui fonctionnent bien sur toutes les plateformes :

```pascal
uses
  SysUtils, Classes;

procedure EcrireFichierPortable(const NomFichier: string;
                                ForcerWindows: Boolean = False);
var
  lignes: TStringList;
begin
  lignes := TStringList.Create;
  try
    lignes.Add('Premi√®re ligne');
    lignes.Add('Deuxi√®me ligne');
    lignes.Add('Troisi√®me ligne');

    if ForcerWindows then
    begin
      // Force le format Windows m√™me sur Linux
      lignes.LineBreak := #13#10;
    end
    else
    begin
      // Utilise le format natif du syst√®me
      lignes.LineBreak := LineEnding;
    end;

    lignes.SaveToFile(NomFichier);
  finally
    lignes.Free;
  end;
end;
```

## Conversion entre formats

### Convertir un texte vers le format local

```pascal
function NormaliserFinsDeLigne(const Texte: string): string;  
var
  temp: string;
begin
  // Remplace toutes les variantes par le format local
  temp := StringReplace(Texte, #13#10, #10, [rfReplaceAll]); // CRLF -> LF
  temp := StringReplace(temp, #13, #10, [rfReplaceAll]);      // CR -> LF

  // Maintenant convertir LF vers le format local
  if LineEnding = #13#10 then
    Result := StringReplace(temp, #10, #13#10, [rfReplaceAll])
  else
    Result := temp;
end;
```

### Fonction de conversion universelle

```pascal
uses
  SysUtils, StrUtils;

type
  TLineEndingStyle = (lesWindows, lesUnix, lesMac, lesSystem);

function ConvertirFinsDeLigne(const Texte: string;
                              Style: TLineEndingStyle = lesSystem): string;
var
  temp: string;
  nouvelleFin: string;
begin
  // D'abord, normaliser tout en LF
  temp := StringReplace(Texte, #13#10, #10, [rfReplaceAll]);
  temp := StringReplace(temp, #13, #10, [rfReplaceAll]);

  // D√©terminer la nouvelle fin de ligne
  case Style of
    lesWindows: nouvelleFin := #13#10;
    lesUnix:    nouvelleFin := #10;
    lesMac:     nouvelleFin := #13;
    lesSystem:  nouvelleFin := LineEnding;
  end;

  // Appliquer le nouveau format
  if nouvelleFin = #10 then
    Result := temp
  else
    Result := StringReplace(temp, #10, nouvelleFin, [rfReplaceAll]);
end;
```

## D√©tection du format d'un fichier

Il est souvent utile de d√©tecter quel format de fin de ligne utilise un fichier :

```pascal
type
  TFormatFinLigne = (fflInconnu, fflWindows, fflUnix, fflMac, fflMixte);

function DetecterFormatFinLigne(const NomFichier: string): TFormatFinLigne;  
var
  flux: TFileStream;
  buffer: array[0..1023] of Byte;
  lu: Integer;
  i: Integer;
  aCRLF, aLF, aCR: Boolean;
begin
  Result := fflInconnu;
  aCRLF := False;
  aLF := False;
  aCR := False;

  flux := TFileStream.Create(NomFichier, fmOpenRead or fmShareDenyNone);
  try
    while flux.Position < flux.Size do
    begin
      lu := flux.Read(buffer, SizeOf(buffer));

      for i := 0 to lu - 1 do
      begin
        if (i < lu - 1) and (buffer[i] = 13) and (buffer[i + 1] = 10) then
        begin
          aCRLF := True;
          Inc(i); // Sauter le LF
        end
        else if buffer[i] = 10 then
          aLF := True
        else if buffer[i] = 13 then
          aCR := True;
      end;
    end;
  finally
    flux.Free;
  end;

  // D√©terminer le format bas√© sur ce qu'on a trouv√©
  if aCRLF and not aLF and not aCR then
    Result := fflWindows
  else if aLF and not aCRLF and not aCR then
    Result := fflUnix
  else if aCR and not aCRLF and not aLF then
    Result := fflMac
  else if aCRLF or aLF or aCR then
    Result := fflMixte;
end;
```

## Gestion dans les composants visuels

### TMemo et fins de ligne

Le composant TMemo g√®re automatiquement les fins de ligne :

```pascal
procedure ManipulerMemo(Memo: TMemo);  
var
  texte: string;
begin
  // Ajouter du texte avec la bonne fin de ligne
  Memo.Lines.Add('Nouvelle ligne');

  // Ou avec concat√©nation manuelle
  texte := 'Ligne 1' + LineEnding + 'Ligne 2' + LineEnding + 'Ligne 3';
  Memo.Text := texte;

  // R√©cup√©rer le texte (les fins de ligne sont normalis√©es)
  texte := Memo.Text;

  // Acc√®s ligne par ligne (sans se soucier des fins de ligne)
  if Memo.Lines.Count > 0 then
    WriteLn('Premi√®re ligne : ', Memo.Lines[0]);
end;
```

### TSynEdit et configuration des fins de ligne

Pour les √©diteurs de code avanc√©s :

```pascal
uses
  SynEdit;

procedure ConfigurerSynEdit(Editor: TSynEdit);  
begin
  // Afficher les fins de ligne (optionnel, pour d√©bogage)
  Editor.Options := Editor.Options + [eoShowSpecialChars];

  // G√©rer automatiquement les conversions
  Editor.Lines.TextLineBreakStyle := tlbsCRLF; // Force Windows
  // ou
  Editor.Lines.TextLineBreakStyle := tlbsLF;   // Force Unix
  // ou
  Editor.Lines.TextLineBreakStyle := tlbsCR;   // Force Mac
end;
```

## Traitement des fichiers CSV

Les fichiers CSV peuvent avoir des fins de ligne dans les donn√©es, ce qui complique leur traitement :

```pascal
uses
  SysUtils, Classes;

procedure TraiterCSVMultiPlateforme(const NomFichier: string);  
var
  lignes: TStringList;
  i: Integer;
  ligne: string;
begin
  lignes := TStringList.Create;
  try
    // Charger le fichier (gestion auto des fins de ligne)
    lignes.LoadFromFile(NomFichier);

    // Pour un CSV, on peut avoir des fins de ligne dans les champs
    lignes.StrictDelimiter := True;
    lignes.Delimiter := ',';

    for i := 0 to lignes.Count - 1 do
    begin
      ligne := lignes[i];

      // Normaliser les fins de ligne dans les champs
      ligne := StringReplace(ligne, #13#10, ' ', [rfReplaceAll]);
      ligne := StringReplace(ligne, #10, ' ', [rfReplaceAll]);
      ligne := StringReplace(ligne, #13, ' ', [rfReplaceAll]);

      // Traiter la ligne CSV normalis√©e
      ProcesserLigneCSV(ligne);
    end;
  finally
    lignes.Free;
  end;
end;
```

## Communication r√©seau et fins de ligne

Pour les protocoles r√©seau, les standards sont importants :

```pascal
uses
  SysUtils, Sockets;

procedure EnvoyerCommandeHTTP(Socket: TSocket; const Commande: string);  
var
  requete: string;
begin
  // HTTP utilise TOUJOURS CRLF, peu importe le syst√®me
  requete := 'GET / HTTP/1.1' + #13#10 +
             'Host: example.com' + #13#10 +
             'User-Agent: MonApp/1.0' + #13#10 +
             #13#10; // Ligne vide = fin des en-t√™tes

  // Envoyer avec les bonnes fins de ligne
  Send(Socket, requete[1], Length(requete), 0);
end;

procedure EnvoyerEmailSMTP(const Serveur, Message: string);  
begin
  // SMTP utilise aussi CRLF obligatoirement
  // Convertir le message local vers CRLF
  EnvoyerDonnees(ConvertirFinsDeLigne(Message, lesWindows));
end;
```

## Scripts et ex√©cutables

### Scripts Bash sur Linux depuis Windows

```pascal
procedure CreerScriptBash(const NomFichier: string);  
var
  script: TStringList;
begin
  script := TStringList.Create;
  try
    script.Add('#!/bin/bash');
    script.Add('echo "Script cr√©√© sous Windows"');
    script.Add('ls -la');

    // IMPORTANT : Forcer LF pour les scripts bash
    script.LineBreak := #10;
    script.SaveToFile(NomFichier);

    WriteLn('Script bash cr√©√© avec fins de ligne Unix');
  finally
    script.Free;
  end;
end;
```

### Scripts Batch sur Windows depuis Linux

```pascal
procedure CreerScriptBatch(const NomFichier: string);  
var
  script: TStringList;
begin
  script := TStringList.Create;
  try
    script.Add('@echo off');
    script.Add('echo Script cr√©√© sous Linux');
    script.Add('dir');

    // Forcer CRLF pour les scripts batch Windows
    script.LineBreak := #13#10;
    script.SaveToFile(NomFichier);

    WriteLn('Script batch cr√©√© avec fins de ligne Windows');
  finally
    script.Free;
  end;
end;
```

## Bonnes pratiques

### 1. Utiliser TStringList pour les fichiers texte

TStringList g√®re automatiquement les diff√©rences de fins de ligne :

```pascal
// ‚úÖ Bon - Portable automatiquement
procedure LireFichier(const NomFichier: string);  
var
  lignes: TStringList;
begin
  lignes := TStringList.Create;
  try
    lignes.LoadFromFile(NomFichier);
    // Traiter les lignes...
  finally
    lignes.Free;
  end;
end;

// ‚ùå Mauvais - Gestion manuelle complexe
procedure LireFichierManuel(const NomFichier: string);  
var
  fichier: TextFile;
  ligne: string;
begin
  AssignFile(fichier, NomFichier);
  Reset(fichier);
  while not Eof(fichier) do
  begin
    ReadLn(fichier, ligne);
    // Probl√®mes potentiels avec les fins de ligne...
  end;
  CloseFile(fichier);
end;
```

### 2. Toujours utiliser LineEnding pour la construction de texte

```pascal
// ‚úÖ Bon
texte := 'Ligne 1' + LineEnding + 'Ligne 2';

// ‚ùå Mauvais
texte := 'Ligne 1' + #13#10 + 'Ligne 2';  // Windows seulement  
texte := 'Ligne 1' + #10 + 'Ligne 2';      // Linux seulement
```

### 3. Documenter le format attendu

```pascal
{ Cette fonction g√©n√®re un fichier de configuration
  Format : Toujours Unix (LF) pour compatibilit√© Git }
procedure GenererConfig(const NomFichier: string);  
var
  config: TStringList;
begin
  config := TStringList.Create;
  try
    config.LineBreak := #10;  // Force Unix
    config.Add('# Configuration');
    config.Add('version=1.0');
    config.SaveToFile(NomFichier);
  finally
    config.Free;
  end;
end;
```

## D√©bogage des probl√®mes de fins de ligne

### Afficher les caract√®res invisibles

```pascal
function AfficherCaracteresInvisibles(const Texte: string): string;  
var
  i: Integer;
begin
  Result := '';
  for i := 1 to Length(Texte) do
  begin
    case Ord(Texte[i]) of
      13: Result := Result + '[CR]';
      10: Result := Result + '[LF]';
      9:  Result := Result + '[TAB]';
      32: Result := Result + '¬∑';  // Espace
    else
      Result := Result + Texte[i];
    end;
  end;
end;

// Utilisation
var
  texte: string;
begin
  texte := 'Hello' + #13#10 + 'World' + #10;
  WriteLn(AfficherCaracteresInvisibles(texte));
  // Affiche : Hello[CR][LF]World[LF]
end;
```

### Analyser un fichier

```pascal
procedure AnalyserFichier(const NomFichier: string);  
var
  flux: TFileStream;
  octet: Byte;
  nbCR, nbLF, nbCRLF: Integer;
  precedent: Byte;
begin
  nbCR := 0;
  nbLF := 0;
  nbCRLF := 0;
  precedent := 0;

  flux := TFileStream.Create(NomFichier, fmOpenRead);
  try
    while flux.Read(octet, 1) = 1 do
    begin
      if (precedent = 13) and (octet = 10) then
      begin
        Inc(nbCRLF);
        Dec(nbCR);  // Ce n'√©tait pas un CR seul
      end
      else if octet = 13 then
        Inc(nbCR)
      else if octet = 10 then
        Inc(nbLF);

      precedent := octet;
    end;
  finally
    flux.Free;
  end;

  WriteLn('Analyse du fichier : ', NomFichier);
  WriteLn('CRLF (Windows) : ', nbCRLF);
  WriteLn('LF seuls (Unix) : ', nbLF);
  WriteLn('CR seuls (Mac) : ', nbCR);

  if (nbCRLF > 0) and (nbLF = 0) and (nbCR = 0) then
    WriteLn('Format : Windows')
  else if (nbLF > 0) and (nbCRLF = 0) and (nbCR = 0) then
    WriteLn('Format : Unix/Linux')
  else if (nbCR > 0) and (nbCRLF = 0) and (nbLF = 0) then
    WriteLn('Format : Mac classique')
  else
    WriteLn('Format : Mixte (probl√©matique!)');
end;
```

## Exemple complet : √âditeur de texte portable

```pascal
program EditeurPortable;

uses
  SysUtils, Classes;

type
  TEditeurTexte = class
  private
    FLignes: TStringList;
    FFormatOriginal: string;
  public
    constructor Create;
    destructor Destroy; override;

    procedure Charger(const NomFichier: string);
    procedure Sauvegarder(const NomFichier: string; PreserverFormat: Boolean = True);
    procedure AjouterLigne(const Texte: string);
    function ObtenirTexte: string;
    procedure ConvertirVers(const NouveauFormat: string);
  end;

constructor TEditeurTexte.Create;  
begin
  FLignes := TStringList.Create;
  FFormatOriginal := LineEnding;  // Par d√©faut, format du syst√®me
end;

destructor TEditeurTexte.Destroy;  
begin
  FLignes.Free;
  inherited;
end;

procedure TEditeurTexte.Charger(const NomFichier: string);  
var
  temp: string;
begin
  // Charger le fichier
  FLignes.LoadFromFile(NomFichier);

  // D√©tecter le format original
  if FLignes.Count > 0 then
  begin
    temp := FLignes.Text;
    if Pos(#13#10, temp) > 0 then
      FFormatOriginal := #13#10
    else if Pos(#10, temp) > 0 then
      FFormatOriginal := #10
    else if Pos(#13, temp) > 0 then
      FFormatOriginal := #13
    else
      FFormatOriginal := LineEnding;
  end;

  WriteLn('Fichier charg√©. Format d√©tect√© : ');
  case Length(FFormatOriginal) of
    1: if FFormatOriginal = #10 then
         WriteLn('Unix (LF)')
       else
         WriteLn('Mac classique (CR)');
    2: WriteLn('Windows (CRLF)');
  end;
end;

procedure TEditeurTexte.Sauvegarder(const NomFichier: string; PreserverFormat: Boolean);  
begin
  if PreserverFormat then
    FLignes.LineBreak := FFormatOriginal
  else
    FLignes.LineBreak := LineEnding;

  FLignes.SaveToFile(NomFichier);
  WriteLn('Fichier sauvegard√© avec fins de ligne : ',
          IfThen(PreserverFormat, 'originales', 'syst√®me'));
end;

procedure TEditeurTexte.AjouterLigne(const Texte: string);  
begin
  FLignes.Add(Texte);
end;

function TEditeurTexte.ObtenirTexte: string;  
begin
  Result := FLignes.Text;
end;

procedure TEditeurTexte.ConvertirVers(const NouveauFormat: string);  
begin
  FLignes.LineBreak := NouveauFormat;
  FFormatOriginal := NouveauFormat;
  WriteLn('Conversion effectu√©e');
end;

// Programme principal
var
  editeur: TEditeurTexte;
begin
  editeur := TEditeurTexte.Create;
  try
    // Cr√©er un fichier de test
    editeur.AjouterLigne('Premi√®re ligne de test');
    editeur.AjouterLigne('Deuxi√®me ligne avec du texte');
    editeur.AjouterLigne('Troisi√®me et derni√®re ligne');

    // Sauvegarder en format syst√®me
    editeur.Sauvegarder('test_systeme.txt', False);

    // Convertir et sauvegarder en format Windows
    editeur.ConvertirVers(#13#10);
    editeur.Sauvegarder('test_windows.txt', True);

    // Convertir et sauvegarder en format Unix
    editeur.ConvertirVers(#10);
    editeur.Sauvegarder('test_unix.txt', True);

  finally
    editeur.Free;
  end;
end.
```

## Conclusion

La gestion des fins de ligne est un aspect crucial du d√©veloppement multi-plateforme. Les diff√©rences entre CRLF (Windows) et LF (Linux/Unix) peuvent sembler mineures, mais elles peuvent causer des probl√®mes significatifs si elles ne sont pas correctement g√©r√©es.

Points cl√©s √† retenir :
- Utilisez toujours `LineEnding` pour du code portable
- `TStringList` g√®re automatiquement les conversions
- Soyez explicite pour les protocoles r√©seau (HTTP, SMTP utilisent CRLF)
- Testez vos applications avec des fichiers cr√©√©s sur diff√©rents syst√®mes
- Documentez le format attendu quand c'est important

En suivant ces principes et en utilisant les outils fournis par FreePascal, vous pouvez cr√©er des applications robustes qui fonctionnent parfaitement sur Windows et Linux, sans vous soucier des probl√®mes de fins de ligne.

‚è≠Ô∏è  [Encodages par d√©faut](/05-developpement-multiplateforme-approfondi/03.3-encodages-defaut.md)
