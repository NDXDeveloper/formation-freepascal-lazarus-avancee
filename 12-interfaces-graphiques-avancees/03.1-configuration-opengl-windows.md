üîù Retour au [Sommaire](/SOMMAIRE.md)

# 12.3.1 Configuration OpenGL Windows

## Introduction

Windows inclut OpenGL de mani√®re native depuis Windows 95. L'impl√©mentation de base est fournie par **opengl32.dll**, une biblioth√®que syst√®me pr√©sente sur toutes les versions modernes de Windows. Cette section vous guidera pas √† pas pour configurer et utiliser OpenGL avec FreePascal/Lazarus sur Windows.

---

## Pr√©requis syst√®me

### Configuration minimale requise

| Composant | Minimum | Recommand√© |
|-----------|---------|------------|
| **OS** | Windows 7 | Windows 10/11 |
| **Carte graphique** | Compatible OpenGL 2.0 | Compatible OpenGL 3.3+ |
| **Pilotes** | Pilotes de base | Pilotes r√©cents du fabricant |
| **RAM** | 2 GB | 4 GB+ |
| **Lazarus** | 2.0+ | Version r√©cente |

### V√©rifier le support OpenGL

Avant de commencer, v√©rifiez que votre syst√®me supporte OpenGL :

#### M√©thode 1 : Via les informations syst√®me

1. Appuyez sur **Windows + R**
2. Tapez `dxdiag` et appuyez sur **Entr√©e**
3. Allez dans l'onglet **Affichage**
4. Recherchez les informations sur **DirectX** et les pilotes

#### M√©thode 2 : Via un outil d√©di√©

T√©l√©chargez et ex√©cutez **OpenGL Extensions Viewer** :
- Site : http://www.realtech-vr.com/glview/
- Gratuit et portable
- Affiche toutes les informations OpenGL de votre syst√®me

#### M√©thode 3 : Via le code (apr√®s configuration)

```pascal
// Code √† ex√©cuter une fois OpenGL configur√©
var
  Version: PChar;
  Major, Minor: Integer;
begin
  Version := glGetString(GL_VERSION);
  WriteLn('Version OpenGL: ', Version);

  // R√©cup√©rer les versions majeures et mineures
  glGetIntegerv(GL_MAJOR_VERSION, @Major);
  glGetIntegerv(GL_MINOR_VERSION, @Minor);
  WriteLn(Format('Version: %d.%d', [Major, Minor]));
end;
```

---

## Installation des pilotes graphiques

### Pilotes fournis par Windows

Windows inclut des pilotes OpenGL de base qui fonctionnent sur toutes les cartes, mais avec :
- ‚ùå Performance limit√©e (rendu logiciel)
- ‚ùå Support OpenGL 1.1 uniquement
- ‚ùå Pas d'acc√©l√©ration mat√©rielle

### Pilotes optimis√©s par fabricant

Pour de meilleures performances, installez les pilotes officiels :

#### NVIDIA

1. Visitez : https://www.nvidia.com/Download/index.aspx
2. S√©lectionnez votre carte graphique
3. T√©l√©chargez et installez **GeForce Game Ready Driver** ou **Studio Driver**
4. Red√©marrez votre ordinateur

**Support OpenGL** : Jusqu'√† OpenGL 4.6

#### AMD/ATI

1. Visitez : https://www.amd.com/en/support
2. D√©tectez automatiquement votre mat√©riel ou s√©lectionnez manuellement
3. T√©l√©chargez et installez **Adrenalin Software**
4. Red√©marrez votre ordinateur

**Support OpenGL** : Jusqu'√† OpenGL 4.6

#### Intel HD Graphics

1. Visitez : https://www.intel.com/content/www/us/en/download-center/home.html
2. S√©lectionnez **Graphics**
3. T√©l√©chargez les pilotes pour votre processeur
4. Installez et red√©marrez

**Support OpenGL** : Variable selon le mod√®le (g√©n√©ralement 4.0 √† 4.6)

---

## Configuration de Lazarus pour OpenGL

### √âtape 1 : Installer le package OpenGLContext

Le package **lazopenglcontext** est inclus avec Lazarus mais doit √™tre ajout√© √† votre IDE.

#### Installation via l'IDE

1. Lancez **Lazarus**
2. Menu **Paquet** ‚Üí **Ouvrir un fichier paquet (.lpk)**
3. Naviguez vers : `C:\lazarus\components\opengl\lazopenglcontext.lpk`
4. Dans la fen√™tre du package, cliquez sur **Compiler**
5. Cliquez sur **Utiliser** ‚Üí **Ajouter au projet**

#### V√©rification

Apr√®s installation, le composant **TOpenGLControl** doit appara√Ætre dans la palette **System** de l'IDE.

![Palette System avec TOpenGLControl]

### √âtape 2 : Cr√©er un projet OpenGL

#### Cr√©ation du projet

1. Menu **Projet** ‚Üí **Nouveau projet**
2. S√©lectionnez **Application**
3. Cliquez sur **OK**
4. Sauvegardez le projet dans un nouveau dossier

#### Ajouter le composant OpenGL

1. Dans le formulaire principal, s√©lectionnez l'onglet **System** de la palette
2. Cliquez sur **TOpenGLControl**
3. Cliquez sur le formulaire pour placer le composant
4. Dans l'**Inspecteur d'objets**, d√©finissez :
   - `Align` ‚Üí `alClient` (pour remplir tout le formulaire)
   - `Name` ‚Üí `OpenGLControl1`

### √âtape 3 : Configurer les unit√©s n√©cessaires

Ajoutez les unit√©s OpenGL dans la clause `uses` :

```pascal
unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs,
  OpenGLContext,  // Pour TOpenGLControl
  GL,             // Fonctions OpenGL de base
  GLU,            // Utilitaires OpenGL (gluPerspective, etc.)
  GLext;          // Extensions OpenGL (optionnel)

type
  TForm1 = class(TForm)
    OpenGLControl1: TOpenGLControl;
    procedure FormCreate(Sender: TObject);
    procedure OpenGLControl1Paint(Sender: TObject);
  private
    procedure InitializeOpenGL;
  end;

var
  Form1: TForm1;

implementation

{$R *.lfm}

// √Ä impl√©menter...

end.
```

---

## Initialisation d'OpenGL

### Structure d'initialisation recommand√©e

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
begin
  // S'assurer que le contexte OpenGL est cr√©√©
  OpenGLControl1.MakeCurrent;

  // Initialiser OpenGL
  InitializeOpenGL;
end;

procedure TForm1.InitializeOpenGL;  
begin
  // V√©rifier la version OpenGL
  WriteLn('Version OpenGL: ', glGetString(GL_VERSION));
  WriteLn('Vendor: ', glGetString(GL_VENDOR));
  WriteLn('Renderer: ', glGetString(GL_RENDERER));

  // Configuration de base
  glClearColor(0.1, 0.1, 0.2, 1.0);  // Couleur de fond (bleu fonc√©)

  // Activer le test de profondeur (Z-buffer)
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LESS);

  // Activer le culling des faces arri√®re (optimisation)
  glEnable(GL_CULL_FACE);
  glCullFace(GL_BACK);

  // D√©finir le sens des faces (sens antihoraire = face avant)
  glFrontFace(GL_CCW);

  // Configuration du viewport initial
  glViewport(0, 0, OpenGLControl1.Width, OpenGLControl1.Height);

  // Configuration de la matrice de projection
  ConfigureProjection;
end;
```

### Configuration de la projection

```pascal
procedure TForm1.ConfigureProjection;  
var
  W, H: Integer;
  AspectRatio: Double;
begin
  W := OpenGLControl1.Width;
  H := OpenGLControl1.Height;

  if H = 0 then
    H := 1;  // √âviter division par z√©ro

  AspectRatio := W / H;

  // Configurer la matrice de projection
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;

  // Projection en perspective (pour 3D)
  gluPerspective(
    45.0,           // Angle de vue (FOV) en degr√©s
    AspectRatio,    // Ratio largeur/hauteur
    0.1,            // Plan proche (near)
    100.0           // Plan loin (far)
  );

  // Revenir √† la matrice modelview
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity;
end;
```

---

## Premier rendu : Triangle color√©

### Code complet du rendu

```pascal
procedure TForm1.OpenGLControl1Paint(Sender: TObject);  
begin
  // Effacer les buffers (couleur et profondeur)
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

  // R√©initialiser la matrice modelview
  glLoadIdentity;

  // Positionner la cam√©ra (reculer de 5 unit√©s)
  glTranslatef(0.0, 0.0, -5.0);

  // Dessiner un triangle avec couleurs par sommet
  glBegin(GL_TRIANGLES);
    // Sommet 1 (haut, rouge)
    glColor3f(1.0, 0.0, 0.0);
    glVertex3f(0.0, 1.0, 0.0);

    // Sommet 2 (bas gauche, vert)
    glColor3f(0.0, 1.0, 0.0);
    glVertex3f(-1.0, -1.0, 0.0);

    // Sommet 3 (bas droit, bleu)
    glColor3f(0.0, 0.0, 1.0);
    glVertex3f(1.0, -1.0, 0.0);
  glEnd;

  // √âchanger les buffers (afficher le r√©sultat)
  OpenGLControl1.SwapBuffers;
end;
```

### Gestion du redimensionnement

```pascal
procedure TForm1.OpenGLControl1Resize(Sender: TObject);  
begin
  // Mettre √† jour le viewport
  glViewport(0, 0, OpenGLControl1.Width, OpenGLControl1.Height);

  // Reconfigurer la projection
  ConfigureProjection;

  // Redessiner
  OpenGLControl1.Invalidate;
end;
```

---

## Gestion des erreurs OpenGL

### V√©rifier les erreurs

OpenGL ne g√©n√®re pas d'exceptions. Les erreurs sont silencieuses et doivent √™tre v√©rifi√©es manuellement :

```pascal
procedure CheckOpenGLError(const AContext: string);  
var
  Error: GLenum;
  ErrorStr: string;
begin
  Error := glGetError;

  if Error <> GL_NO_ERROR then
  begin
    case Error of
      GL_INVALID_ENUM:      ErrorStr := 'GL_INVALID_ENUM';
      GL_INVALID_VALUE:     ErrorStr := 'GL_INVALID_VALUE';
      GL_INVALID_OPERATION: ErrorStr := 'GL_INVALID_OPERATION';
      GL_STACK_OVERFLOW:    ErrorStr := 'GL_STACK_OVERFLOW';
      GL_STACK_UNDERFLOW:   ErrorStr := 'GL_STACK_UNDERFLOW';
      GL_OUT_OF_MEMORY:     ErrorStr := 'GL_OUT_OF_MEMORY';
    else
      ErrorStr := Format('Unknown error: %d', [Error]);
    end;

    raise Exception.CreateFmt('Erreur OpenGL dans %s: %s', [AContext, ErrorStr]);
  end;
end;

// Utilisation
procedure TForm1.InitializeOpenGL;  
begin
  glClearColor(0.1, 0.1, 0.2, 1.0);
  CheckOpenGLError('glClearColor');

  glEnable(GL_DEPTH_TEST);
  CheckOpenGLError('glEnable(GL_DEPTH_TEST)');
end;
```

### Wrapper de v√©rification automatique

```pascal
{$IFDEF DEBUG}
procedure GLCheck(const AFunction: string);  
begin
  CheckOpenGLError(AFunction);
end;
{$ELSE}
procedure GLCheck(const AFunction: string);  
begin
  // Ne rien faire en mode Release pour la performance
end;
{$ENDIF}

// Utilisation
glEnable(GL_DEPTH_TEST);  
GLCheck('glEnable');
```

---

## Configuration avanc√©e sous Windows

### Contexte OpenGL √©tendu (WGL)

Pour acc√©der √† des fonctionnalit√©s avanc√©es sous Windows, vous pouvez utiliser les extensions **WGL** (Windows GL).

#### Obtenir les extensions disponibles

```pascal
uses
  GLext;

procedure ListWGLExtensions;  
var
  Extensions: PChar;
begin
  // Obtenir la liste des extensions WGL
  if Assigned(wglGetExtensionsStringARB) then
  begin
    Extensions := wglGetExtensionsStringARB(wglGetCurrentDC);
    WriteLn('Extensions WGL disponibles:');
    WriteLn(Extensions);
  end;
end;
```

#### Activer VSync (synchronisation verticale)

```pascal
procedure SetVSync(AEnabled: Boolean);  
begin
  if Load_WGL_EXT_swap_control then
  begin
    if AEnabled then
      wglSwapIntervalEXT(1)   // Activer VSync
    else
      wglSwapIntervalEXT(0);  // D√©sactiver VSync
  end
  else
    WriteLn('Extension WGL_EXT_swap_control non disponible');
end;

// Utilisation
procedure TForm1.FormCreate(Sender: TObject);  
begin
  OpenGLControl1.MakeCurrent;
  InitializeOpenGL;

  // Activer VSync pour √©viter le d√©chirement (tearing)
  SetVSync(True);
end;
```

### Multi-√©chantillonnage (MSAA - Anti-aliasing)

Pour activer l'anti-aliasing mat√©riel :

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
begin
  OpenGLControl1.MakeCurrent;
  InitializeOpenGL;

  // Activer le multi-√©chantillonnage si disponible
  glEnable(GL_MULTISAMPLE);
  CheckOpenGLError('glEnable(GL_MULTISAMPLE)');
end;
```

**Note** : Le niveau de MSAA (2x, 4x, 8x) doit √™tre configur√© au moment de la cr√©ation du contexte OpenGL, ce qui n√©cessite une configuration plus avanc√©e du TOpenGLControl.

### S√©lectionner la carte graphique (syst√®mes multi-GPU)

Sur les ordinateurs portables avec GPU int√©gr√© et d√©di√© :

```pascal
// Forcer l'utilisation du GPU NVIDIA (d√©di√©)
{$IFDEF WINDOWS}
exports
  NvOptimusEnablement: DWORD = 1;
{$ENDIF}

// Forcer l'utilisation du GPU AMD (d√©di√©)
{$IFDEF WINDOWS}
exports
  AmdPowerXpressRequestHighPerformance: Integer = 1;
{$ENDIF}
```

Ajoutez ces d√©clarations dans votre unit√© principale (en dehors de toute proc√©dure).

---

## Optimisations sp√©cifiques Windows

### Utiliser des extensions WGL

Windows propose des extensions sp√©cifiques pour am√©liorer les performances :

#### Extension WGL_ARB_pixel_format

Permet de cr√©er des contextes OpenGL avec des configurations personnalis√©es :

```pascal
uses
  GLext;

procedure CreateAdvancedContext;  
var
  PixelFormatAttribs: array[0..18] of Integer;
  PixelFormat: Integer;
  NumFormats: GLuint;
begin
  // Charger l'extension
  if not Load_WGL_ARB_pixel_format then
  begin
    WriteLn('Extension WGL_ARB_pixel_format non disponible');
    Exit;
  end;

  // Configuration du pixel format
  PixelFormatAttribs[0] := WGL_DRAW_TO_WINDOW_ARB; PixelFormatAttribs[1] := GL_TRUE;
  PixelFormatAttribs[2] := WGL_SUPPORT_OPENGL_ARB; PixelFormatAttribs[3] := GL_TRUE;
  PixelFormatAttribs[4] := WGL_DOUBLE_BUFFER_ARB;  PixelFormatAttribs[5] := GL_TRUE;
  PixelFormatAttribs[6] := WGL_PIXEL_TYPE_ARB;     PixelFormatAttribs[7] := WGL_TYPE_RGBA_ARB;
  PixelFormatAttribs[8] := WGL_COLOR_BITS_ARB;     PixelFormatAttribs[9] := 32;
  PixelFormatAttribs[10] := WGL_DEPTH_BITS_ARB;    PixelFormatAttribs[11] := 24;
  PixelFormatAttribs[12] := WGL_STENCIL_BITS_ARB;  PixelFormatAttribs[13] := 8;
  PixelFormatAttribs[14] := WGL_SAMPLE_BUFFERS_ARB; PixelFormatAttribs[15] := 1;
  PixelFormatAttribs[16] := WGL_SAMPLES_ARB;       PixelFormatAttribs[17] := 4; // MSAA 4x
  PixelFormatAttribs[18] := 0; // Terminateur

  wglChoosePixelFormatARB(
    wglGetCurrentDC,
    @PixelFormatAttribs,
    nil,
    1,
    @PixelFormat,
    @NumFormats
  );
end;
```

### Performance : R√©duire les changements d'√©tat

```pascal
// ‚ùå MAUVAIS : Changements d'√©tat fr√©quents
procedure RenderSlow;  
var
  i: Integer;
begin
  for i := 0 to 1000 do
  begin
    glEnable(GL_TEXTURE_2D);
    // Dessiner quelque chose
    glDisable(GL_TEXTURE_2D);
  end;
end;

// ‚úÖ BON : Regrouper les √©tats similaires
procedure RenderFast;  
var
  i: Integer;
begin
  glEnable(GL_TEXTURE_2D);
  for i := 0 to 1000 do
  begin
    // Dessiner quelque chose
  end;
  glDisable(GL_TEXTURE_2D);
end;
```

---

## Debugging sous Windows

### Activer les messages de debug OpenGL

Avec OpenGL 4.3+, vous pouvez activer les messages de debug :

```pascal
procedure EnableDebugOutput;  
begin
  if Load_GL_version_4_3 then
  begin
    glEnable(GL_DEBUG_OUTPUT);
    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);

    // Callback pour les messages (n√©cessite une fonction de callback)
    WriteLn('Debug output activ√©');
  end
  else
    WriteLn('Debug output non disponible (OpenGL < 4.3)');
end;
```

### Outils externes

#### RenderDoc

Un outil gratuit et open-source pour capturer et analyser des frames OpenGL :

1. T√©l√©chargez : https://renderdoc.org/
2. Installez RenderDoc
3. Lancez votre application depuis RenderDoc
4. Capturez une frame avec **F12**
5. Analysez les appels OpenGL, textures, shaders, etc.

#### gDEBugger

Un autre outil de debugging OpenGL :
- Trace tous les appels OpenGL
- Affiche l'√©tat complet d'OpenGL
- D√©tecte les fuites de ressources

---

## Exemple complet : Application OpenGL Windows

Voici un exemple complet d'application OpenGL pour Windows :

```pascal
unit MainUnit;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, ExtCtrls,
  OpenGLContext, GL, GLU;

type
  TMainForm = class(TForm)
    OpenGLControl1: TOpenGLControl;
    Timer1: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure OpenGLControl1Paint(Sender: TObject);
    procedure OpenGLControl1Resize(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
  private
    FAngle: Single;
    FLastTime: TDateTime;
    FFPS: Integer;
    FFrameCount: Integer;
    procedure InitializeOpenGL;
    procedure ConfigureProjection;
    procedure RenderScene;
    procedure UpdateFPS;
  end;

var
  MainForm: TMainForm;

implementation

uses
  DateUtils;

{$R *.lfm}

procedure TMainForm.FormCreate(Sender: TObject);  
begin
  FAngle := 0;
  FFrameCount := 0;
  FFPS := 0;
  FLastTime := Now;

  // Initialiser OpenGL
  OpenGLControl1.MakeCurrent;
  InitializeOpenGL;

  // D√©marrer le timer pour l'animation
  Timer1.Interval := 16; // ~60 FPS
  Timer1.Enabled := True;
end;

procedure TMainForm.FormDestroy(Sender: TObject);  
begin
  Timer1.Enabled := False;
end;

procedure TMainForm.InitializeOpenGL;  
begin
  // Afficher les informations OpenGL
  WriteLn('Version OpenGL: ', glGetString(GL_VERSION));
  WriteLn('Vendor: ', glGetString(GL_VENDOR));
  WriteLn('Renderer: ', glGetString(GL_RENDERER));

  // Configuration de base
  glClearColor(0.1, 0.1, 0.2, 1.0);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);

  // √âclairage simple
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_COLOR_MATERIAL);

  // Configuration de la projection
  ConfigureProjection;
end;

procedure TMainForm.ConfigureProjection;  
var
  W, H: Integer;
  AspectRatio: Double;
begin
  W := OpenGLControl1.Width;
  H := OpenGLControl1.Height;
  if H = 0 then H := 1;

  AspectRatio := W / H;

  glViewport(0, 0, W, H);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;
  gluPerspective(45.0, AspectRatio, 0.1, 100.0);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity;
end;

procedure TMainForm.RenderScene;  
begin
  // Effacer
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);
  glLoadIdentity;

  // Position de la cam√©ra
  glTranslatef(0.0, 0.0, -6.0);

  // Rotation anim√©e
  glRotatef(FAngle, 0.0, 1.0, 0.0);
  glRotatef(FAngle * 0.5, 1.0, 0.0, 0.0);

  // Dessiner un cube color√©
  glBegin(GL_QUADS);
    // Face avant (rouge)
    glColor3f(1.0, 0.0, 0.0);
    glVertex3f(-1.0, -1.0, 1.0);
    glVertex3f(1.0, -1.0, 1.0);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(-1.0, 1.0, 1.0);

    // Face arri√®re (vert)
    glColor3f(0.0, 1.0, 0.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(-1.0, 1.0, -1.0);
    glVertex3f(1.0, 1.0, -1.0);
    glVertex3f(1.0, -1.0, -1.0);

    // Face haut (bleu)
    glColor3f(0.0, 0.0, 1.0);
    glVertex3f(-1.0, 1.0, -1.0);
    glVertex3f(-1.0, 1.0, 1.0);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(1.0, 1.0, -1.0);

    // Face bas (jaune)
    glColor3f(1.0, 1.0, 0.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(1.0, -1.0, -1.0);
    glVertex3f(1.0, -1.0, 1.0);
    glVertex3f(-1.0, -1.0, 1.0);

    // Face droite (magenta)
    glColor3f(1.0, 0.0, 1.0);
    glVertex3f(1.0, -1.0, -1.0);
    glVertex3f(1.0, 1.0, -1.0);
    glVertex3f(1.0, 1.0, 1.0);
    glVertex3f(1.0, -1.0, 1.0);

    // Face gauche (cyan)
    glColor3f(0.0, 1.0, 1.0);
    glVertex3f(-1.0, -1.0, -1.0);
    glVertex3f(-1.0, -1.0, 1.0);
    glVertex3f(-1.0, 1.0, 1.0);
    glVertex3f(-1.0, 1.0, -1.0);
  glEnd;
end;

procedure TMainForm.OpenGLControl1Paint(Sender: TObject);  
begin
  RenderScene;
  OpenGLControl1.SwapBuffers;
  UpdateFPS;
end;

procedure TMainForm.OpenGLControl1Resize(Sender: TObject);  
begin
  ConfigureProjection;
end;

procedure TMainForm.Timer1Timer(Sender: TObject);  
begin
  // Incr√©menter l'angle de rotation
  FAngle := FAngle + 1.0;
  if FAngle >= 360.0 then
    FAngle := FAngle - 360.0;

  // Redessiner
  OpenGLControl1.Invalidate;
end;

procedure TMainForm.UpdateFPS;  
var
  CurrentTime: TDateTime;
  ElapsedMS: Int64;
begin
  Inc(FFrameCount);
  CurrentTime := Now;
  ElapsedMS := MilliSecondsBetween(CurrentTime, FLastTime);

  if ElapsedMS >= 1000 then
  begin
    FFPS := FFrameCount;
    FFrameCount := 0;
    FLastTime := CurrentTime;

    Caption := Format('OpenGL Windows - FPS: %d', [FFPS]);
  end;
end;

end.
```

---

## Probl√®mes courants et solutions

### Probl√®me 1 : √âcran noir

**Causes possibles** :
- Contexte OpenGL non cr√©√©
- Projection mal configur√©e
- Objets dessin√©s hors de vue

**Solutions** :
```pascal
// V√©rifier que le contexte est cr√©√©
OpenGLControl1.MakeCurrent;

// V√©rifier la projection
glMatrixMode(GL_PROJECTION);  
glLoadIdentity;  
gluPerspective(45.0, Width/Height, 0.1, 100.0);

// V√©rifier que les objets sont dans le champ de vision
glTranslatef(0.0, 0.0, -5.0);  // Reculer la cam√©ra
```

### Probl√®me 2 : Performance faible

**Causes possibles** :
- Pilotes non √† jour
- Rendu logiciel (pas d'acc√©l√©ration GPU)
- Trop d'appels de dessin

**Solutions** :
```pascal
// V√©rifier le renderer
WriteLn('Renderer: ', glGetString(GL_RENDERER));
// Si vous voyez "GDI Generic", les pilotes ne sont pas bons

// R√©duire les appels glBegin/glEnd
// Utiliser des VBO (Vertex Buffer Objects)
```

### Probl√®me 3 : Scintillement

**Causes possibles** :
- Double buffering d√©sactiv√©
- Pas d'appel √† SwapBuffers

**Solutions** :
```pascal
// S'assurer que DoubleBuffered est activ√©
OpenGLControl1.DoubleBuffered := True;

// Toujours appeler SwapBuffers
OpenGLControl1.SwapBuffers;
```

### Probl√®me 4 : Erreur "Context not created"

**Solution** :
```pascal
// Toujours cr√©er le contexte avant d'utiliser OpenGL
procedure TForm1.FormCreate(Sender: TObject);  
begin
  OpenGLControl1.MakeCurrent;  // IMPORTANT
  InitializeOpenGL;
end;
```

---

## Bonnes pratiques Windows

### 1. Gestion du contexte

```pascal
// Toujours activer le contexte avant les appels OpenGL
procedure TForm1.SomeMethod;  
begin
  OpenGLControl1.MakeCurrent;

  // Appels OpenGL ici
  glClear(GL_COLOR_BUFFER_BIT);
end;
```

### 2. Lib√©ration des ressources

```pascal
procedure TForm1.FormDestroy(Sender: TObject);  
begin
  // Activer le contexte avant de lib√©rer
  if Assigned(OpenGLControl1) then
  begin
    OpenGLControl1.MakeCurrent;

    // Lib√©rer les textures
    if FTextureID <> 0 then
    begin
      glDeleteTextures(1, @FTextureID);
      FTextureID := 0;
    end;

    // Lib√©rer les buffers
    if FVBO <> 0 then
    begin
      glDeleteBuffers(1, @FVBO);
      FVBO := 0;
    end;

    // Lib√©rer les display lists
    if FDisplayList <> 0 then
    begin
      glDeleteLists(FDisplayList, 1);
      FDisplayList := 0;
    end;
  end;
end;
```

### 3. Gestion du redimensionnement

```pascal
procedure TForm1.OpenGLControl1Resize(Sender: TObject);  
begin
  if not OpenGLControl1.MakeCurrent then
    Exit;

  // Mise √† jour du viewport
  glViewport(0, 0, OpenGLControl1.Width, OpenGLControl1.Height);

  // Recalculer la projection
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;

  if OpenGLControl1.Height > 0 then
    gluPerspective(45.0, OpenGLControl1.Width / OpenGLControl1.Height, 0.1, 100.0);

  glMatrixMode(GL_MODELVIEW);

  // Redessiner
  OpenGLControl1.Invalidate;
end;
```

### 4. Gestion de la boucle de rendu

```pascal
type
  TMainForm = class(TForm)
  private
    FLastFrameTime: TDateTime;
    FDeltaTime: Double;
    procedure UpdateDeltaTime;
  end;

procedure TMainForm.UpdateDeltaTime;  
var
  CurrentTime: TDateTime;
begin
  CurrentTime := Now;
  FDeltaTime := MilliSecondsBetween(CurrentTime, FLastFrameTime) / 1000.0;
  FLastFrameTime := CurrentTime;
end;

procedure TMainForm.Timer1Timer(Sender: TObject);  
begin
  UpdateDeltaTime;

  // Mettre √† jour la logique avec deltaTime
  UpdateScene(FDeltaTime);

  // Redessiner
  OpenGLControl1.Invalidate;
end;
```

### 5. Utilisation efficace des √©tats OpenGL

```pascal
type
  TOpenGLStateManager = class
  private
    FCurrentTexture: GLuint;
    FDepthTestEnabled: Boolean;
    FBlendEnabled: Boolean;
  public
    procedure BindTexture(ATexture: GLuint);
    procedure EnableDepthTest(AEnable: Boolean);
    procedure EnableBlend(AEnable: Boolean);
    procedure Reset;
  end;

procedure TOpenGLStateManager.BindTexture(ATexture: GLuint);  
begin
  if FCurrentTexture <> ATexture then
  begin
    glBindTexture(GL_TEXTURE_2D, ATexture);
    FCurrentTexture := ATexture;
  end;
end;

procedure TOpenGLStateManager.EnableDepthTest(AEnable: Boolean);  
begin
  if FDepthTestEnabled <> AEnable then
  begin
    if AEnable then
      glEnable(GL_DEPTH_TEST)
    else
      glDisable(GL_DEPTH_TEST);
    FDepthTestEnabled := AEnable;
  end;
end;

procedure TOpenGLStateManager.EnableBlend(AEnable: Boolean);  
begin
  if FBlendEnabled <> AEnable then
  begin
    if AEnable then
      glEnable(GL_BLEND)
    else
      glDisable(GL_BLEND);
    FBlendEnabled := AEnable;
  end;
end;

procedure TOpenGLStateManager.Reset;  
begin
  FCurrentTexture := 0;
  FDepthTestEnabled := False;
  FBlendEnabled := False;
end;
```

---

## Gestion des textures sous Windows

### Chargement d'images

```pascal
uses
  Graphics, FPImage, IntfGraphics;

function LoadTexture(const AFileName: string): GLuint;  
var
  Picture: TPicture;
  Bitmap: TBitmap;
  IntfImg: TLazIntfImage;
  RawImage: TRawImage;
  TextureID: GLuint;
  Width, Height: Integer;
begin
  Result := 0;

  Picture := TPicture.Create;
  try
    Picture.LoadFromFile(AFileName);

    // Convertir en bitmap 32 bits
    Bitmap := TBitmap.Create;
    try
      Bitmap.PixelFormat := pf32bit;
      Bitmap.Width := Picture.Width;
      Bitmap.Height := Picture.Height;
      Bitmap.Canvas.Draw(0, 0, Picture.Graphic);

      // Cr√©er une interface image
      IntfImg := TLazIntfImage.Create(0, 0);
      try
        IntfImg.LoadFromBitmap(Bitmap.Handle, Bitmap.MaskHandle);

        Width := IntfImg.Width;
        Height := IntfImg.Height;

        // Cr√©er la texture OpenGL
        glGenTextures(1, @TextureID);
        glBindTexture(GL_TEXTURE_2D, TextureID);

        // Param√®tres de la texture
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        // Charger les donn√©es
        RawImage := IntfImg.GetRawImage;
        glTexImage2D(
          GL_TEXTURE_2D,
          0,
          GL_RGBA,
          Width,
          Height,
          0,
          GL_BGRA,
          GL_UNSIGNED_BYTE,
          RawImage.Data
        );

        Result := TextureID;
      finally
        IntfImg.Free;
      end;
    finally
      Bitmap.Free;
    end;
  finally
    Picture.Free;
  end;
end;

// Utilisation
var
  MyTexture: GLuint;
begin
  MyTexture := LoadTexture('texture.png');

  // Dessiner avec la texture
  glEnable(GL_TEXTURE_2D);
  glBindTexture(GL_TEXTURE_2D, MyTexture);

  glBegin(GL_QUADS);
    glTexCoord2f(0.0, 0.0); glVertex3f(-1.0, -1.0, 0.0);
    glTexCoord2f(1.0, 0.0); glVertex3f(1.0, -1.0, 0.0);
    glTexCoord2f(1.0, 1.0); glVertex3f(1.0, 1.0, 0.0);
    glTexCoord2f(0.0, 1.0); glVertex3f(-1.0, 1.0, 0.0);
  glEnd;

  glDisable(GL_TEXTURE_2D);
end;
```

### Mipmapping pour am√©liorer la qualit√©

```pascal
procedure LoadTextureWithMipmaps(const AFileName: string; out ATextureID: GLuint);  
var
  // ... (m√™me code de chargement)
begin
  // Cr√©er la texture avec mipmaps
  glGenTextures(1, @ATextureID);
  glBindTexture(GL_TEXTURE_2D, ATextureID);

  // Param√®tres
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

  // Charger avec g√©n√©ration automatique de mipmaps
  glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, Width, Height, 0,
               GL_BGRA, GL_UNSIGNED_BYTE, RawImage.Data);

  // G√©n√©rer les mipmaps
  glGenerateMipmap(GL_TEXTURE_2D);
end;
```

---

## Optimisations sp√©cifiques Windows

### Display Lists (pour g√©om√©trie statique)

Les Display Lists permettent de pr√©-compiler de la g√©om√©trie :

```pascal
type
  TMyScene = class
  private
    FDisplayList: GLuint;
  public
    constructor Create;
    destructor Destroy; override;
    procedure BuildDisplayList;
    procedure Render;
  end;

constructor TMyScene.Create;  
begin
  FDisplayList := 0;
end;

destructor TMyScene.Destroy;  
begin
  if FDisplayList <> 0 then
  begin
    glDeleteLists(FDisplayList, 1);
    FDisplayList := 0;
  end;
  inherited;
end;

procedure TMyScene.BuildDisplayList;  
begin
  // Cr√©er une display list
  FDisplayList := glGenLists(1);

  glNewList(FDisplayList, GL_COMPILE);
    // Dessiner la g√©om√©trie complexe une seule fois
    glBegin(GL_TRIANGLES);
      // Des milliers de triangles...
      // ... code de dessin ...
    glEnd;
  glEndList;
end;

procedure TMyScene.Render;  
begin
  if FDisplayList <> 0 then
    glCallList(FDisplayList)  // Tr√®s rapide !
  else
    BuildDisplayList;
end;
```

### Vertex Buffer Objects (VBO)

Pour des performances maximales avec de grands ensembles de vertices :

```pascal
type
  TVertex = packed record
    Position: array[0..2] of GLfloat;
    Color: array[0..2] of GLfloat;
  end;

var
  VBO: GLuint;
  Vertices: array of TVertex;

procedure CreateVBO;  
begin
  // Remplir le tableau de vertices
  SetLength(Vertices, 3);

  Vertices[0].Position[0] := 0.0;  Vertices[0].Position[1] := 1.0;  Vertices[0].Position[2] := 0.0;
  Vertices[0].Color[0] := 1.0;     Vertices[0].Color[1] := 0.0;     Vertices[0].Color[2] := 0.0;

  Vertices[1].Position[0] := -1.0; Vertices[1].Position[1] := -1.0; Vertices[1].Position[2] := 0.0;
  Vertices[1].Color[0] := 0.0;     Vertices[1].Color[1] := 1.0;     Vertices[1].Color[2] := 0.0;

  Vertices[2].Position[0] := 1.0;  Vertices[2].Position[1] := -1.0; Vertices[2].Position[2] := 0.0;
  Vertices[2].Color[0] := 0.0;     Vertices[2].Color[1] := 0.0;     Vertices[2].Color[2] := 1.0;

  // Cr√©er le VBO
  glGenBuffers(1, @VBO);
  glBindBuffer(GL_ARRAY_BUFFER, VBO);
  glBufferData(GL_ARRAY_BUFFER, Length(Vertices) * SizeOf(TVertex),
               @Vertices[0], GL_STATIC_DRAW);
end;

procedure RenderVBO;  
begin
  glBindBuffer(GL_ARRAY_BUFFER, VBO);

  // Configurer les pointeurs
  glEnableClientState(GL_VERTEX_ARRAY);
  glEnableClientState(GL_COLOR_ARRAY);

  glVertexPointer(3, GL_FLOAT, SizeOf(TVertex), Pointer(0));
  glColorPointer(3, GL_FLOAT, SizeOf(TVertex), Pointer(12));

  // Dessiner
  glDrawArrays(GL_TRIANGLES, 0, Length(Vertices));

  glDisableClientState(GL_COLOR_ARRAY);
  glDisableClientState(GL_VERTEX_ARRAY);
end;
```

### Frustum Culling

√âliminer les objets hors du champ de vision :

```pascal
type
  TFrustum = record
    Planes: array[0..5] of record
      A, B, C, D: GLfloat;
    end;
  end;

procedure ExtractFrustum(out AFrustum: TFrustum);  
var
  Proj, Model, Clip: array[0..15] of GLfloat;
  i: Integer;
begin
  // Obtenir les matrices
  glGetFloatv(GL_PROJECTION_MATRIX, @Proj);
  glGetFloatv(GL_MODELVIEW_MATRIX, @Model);

  // Multiplier les matrices
  // ... (calculs matriciels) ...

  // Extraire les plans du frustum
  // ... (code d'extraction) ...
end;

function PointInFrustum(const AFrustum: TFrustum; X, Y, Z: GLfloat): Boolean;  
var
  i: Integer;
begin
  Result := True;

  for i := 0 to 5 do
  begin
    with AFrustum.Planes[i] do
    begin
      if (A * X + B * Y + C * Z + D) <= 0 then
      begin
        Result := False;
        Exit;
      end;
    end;
  end;
end;

function SphereInFrustum(const AFrustum: TFrustum; X, Y, Z, Radius: GLfloat): Boolean;  
var
  i: Integer;
  Distance: GLfloat;
begin
  Result := True;

  for i := 0 to 5 do
  begin
    with AFrustum.Planes[i] do
    begin
      Distance := A * X + B * Y + C * Z + D;
      if Distance <= -Radius then
      begin
        Result := False;
        Exit;
      end;
    end;
  end;
end;
```

---

## Gestion avanc√©e de la cam√©ra

### Classe Camera compl√®te

```pascal
type
  TCamera = class
  private
    FPosition: record X, Y, Z: GLfloat; end;
    FRotation: record Pitch, Yaw, Roll: GLfloat; end;
    FSpeed: GLfloat;
  public
    constructor Create;
    procedure MoveForward(ADelta: GLfloat);
    procedure MoveRight(ADelta: GLfloat);
    procedure MoveUp(ADelta: GLfloat);
    procedure RotatePitch(ADelta: GLfloat);
    procedure RotateYaw(ADelta: GLfloat);
    procedure Apply;
  end;

constructor TCamera.Create;  
begin
  FPosition.X := 0;
  FPosition.Y := 0;
  FPosition.Z := 5;
  FRotation.Pitch := 0;
  FRotation.Yaw := 0;
  FRotation.Roll := 0;
  FSpeed := 5.0;
end;

procedure TCamera.MoveForward(ADelta: GLfloat);  
var
  YawRad: GLfloat;
begin
  YawRad := FRotation.Yaw * Pi / 180.0;
  FPosition.X := FPosition.X + Sin(YawRad) * ADelta * FSpeed;
  FPosition.Z := FPosition.Z - Cos(YawRad) * ADelta * FSpeed;
end;

procedure TCamera.MoveRight(ADelta: GLfloat);  
var
  YawRad: GLfloat;
begin
  YawRad := FRotation.Yaw * Pi / 180.0;
  FPosition.X := FPosition.X + Cos(YawRad) * ADelta * FSpeed;
  FPosition.Z := FPosition.Z + Sin(YawRad) * ADelta * FSpeed;
end;

procedure TCamera.MoveUp(ADelta: GLfloat);  
begin
  FPosition.Y := FPosition.Y + ADelta * FSpeed;
end;

procedure TCamera.RotatePitch(ADelta: GLfloat);  
begin
  FRotation.Pitch := FRotation.Pitch + ADelta;

  // Limiter le pitch
  if FRotation.Pitch > 89.0 then
    FRotation.Pitch := 89.0;
  if FRotation.Pitch < -89.0 then
    FRotation.Pitch := -89.0;
end;

procedure TCamera.RotateYaw(ADelta: GLfloat);  
begin
  FRotation.Yaw := FRotation.Yaw + ADelta;

  // Normaliser le yaw (0-360)
  while FRotation.Yaw >= 360.0 do
    FRotation.Yaw := FRotation.Yaw - 360.0;
  while FRotation.Yaw < 0.0 do
    FRotation.Yaw := FRotation.Yaw + 360.0;
end;

procedure TCamera.Apply;  
begin
  glLoadIdentity;

  // Appliquer les rotations
  glRotatef(FRotation.Pitch, 1.0, 0.0, 0.0);
  glRotatef(FRotation.Yaw, 0.0, 1.0, 0.0);
  glRotatef(FRotation.Roll, 0.0, 0.0, 1.0);

  // Appliquer la translation
  glTranslatef(-FPosition.X, -FPosition.Y, -FPosition.Z);
end;

// Utilisation
var
  Camera: TCamera;

procedure TForm1.FormCreate(Sender: TObject);  
begin
  Camera := TCamera.Create;
end;

procedure TForm1.FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);  
begin
  case Key of
    VK_W: Camera.MoveForward(0.1);
    VK_S: Camera.MoveForward(-0.1);
    VK_A: Camera.MoveRight(-0.1);
    VK_D: Camera.MoveRight(0.1);
    VK_SPACE: Camera.MoveUp(0.1);
    VK_LSHIFT: Camera.MoveUp(-0.1);
  end;
  OpenGLControl1.Invalidate;
end;

procedure TForm1.OpenGLControl1Paint(Sender: TObject);  
begin
  glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);

  // Appliquer la cam√©ra
  Camera.Apply;

  // Dessiner la sc√®ne
  RenderScene;

  OpenGLControl1.SwapBuffers;
end;
```

---

## Gestion de la souris pour la rotation

### Capture de la souris

```pascal
type
  TMainForm = class(TForm)
  private
    FMouseCaptured: Boolean;
    FLastMouseX, FLastMouseY: Integer;
    FCamera: TCamera;
    procedure CaptureMouseCursor;
    procedure ReleaseMouseCursor;
  end;

procedure TMainForm.OpenGLControl1MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if Button = mbLeft then
  begin
    FLastMouseX := X;
    FLastMouseY := Y;
    CaptureMouseCursor;
  end;
end;

procedure TMainForm.OpenGLControl1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if Button = mbLeft then
    ReleaseMouseCursor;
end;

procedure TMainForm.OpenGLControl1MouseMove(Sender: TObject; Shift: TShiftState;
  X, Y: Integer);
var
  DX, DY: Integer;
begin
  if FMouseCaptured then
  begin
    DX := X - FLastMouseX;
    DY := Y - FLastMouseY;

    FCamera.RotateYaw(DX * 0.2);
    FCamera.RotatePitch(-DY * 0.2);

    FLastMouseX := X;
    FLastMouseY := Y;

    OpenGLControl1.Invalidate;
  end;
end;

procedure TMainForm.CaptureMouseCursor;  
begin
  FMouseCaptured := True;
  OpenGLControl1.Cursor := crNone;
  OpenGLControl1.SetFocus;
end;

procedure TMainForm.ReleaseMouseCursor;  
begin
  FMouseCaptured := False;
  OpenGLControl1.Cursor := crDefault;
end;
```

---

## Int√©gration avec l'interface Windows

### Menu contextuel OpenGL

```pascal
procedure TForm1.FormCreate(Sender: TObject);  
var
  PopupMenu: TPopupMenu;
  MenuItem: TMenuItem;
begin
  // Cr√©er un menu contextuel
  PopupMenu := TPopupMenu.Create(Self);

  MenuItem := TMenuItem.Create(PopupMenu);
  MenuItem.Caption := 'Wireframe';
  MenuItem.OnClick := @MenuWireframeClick;
  PopupMenu.Items.Add(MenuItem);

  MenuItem := TMenuItem.Create(PopupMenu);
  MenuItem.Caption := 'Solid';
  MenuItem.OnClick := @MenuSolidClick;
  PopupMenu.Items.Add(MenuItem);

  MenuItem := TMenuItem.Create(PopupMenu);
  MenuItem.Caption := '-';  // S√©parateur
  PopupMenu.Items.Add(MenuItem);

  MenuItem := TMenuItem.Create(PopupMenu);
  MenuItem.Caption := 'Reset Camera';
  MenuItem.OnClick := @MenuResetCameraClick;
  PopupMenu.Items.Add(MenuItem);

  OpenGLControl1.PopupMenu := PopupMenu;
end;

procedure TForm1.MenuWireframeClick(Sender: TObject);  
begin
  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  OpenGLControl1.Invalidate;
end;

procedure TForm1.MenuSolidClick(Sender: TObject);  
begin
  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
  OpenGLControl1.Invalidate;
end;

procedure TForm1.MenuResetCameraClick(Sender: TObject);  
begin
  FCamera.Free;
  FCamera := TCamera.Create;
  OpenGLControl1.Invalidate;
end;
```

### Panneau de contr√¥le

```pascal
type
  TMainForm = class(TForm)
    Panel1: TPanel;
    CheckBoxWireframe: TCheckBox;
    CheckBoxLighting: TCheckBox;
    TrackBarRotationSpeed: TTrackBar;
    LabelFPS: TLabel;
    procedure CheckBoxWireframeChange(Sender: TObject);
    procedure CheckBoxLightingChange(Sender: TObject);
    procedure TrackBarRotationSpeedChange(Sender: TObject);
  end;

procedure TMainForm.CheckBoxWireframeChange(Sender: TObject);  
begin
  if CheckBoxWireframe.Checked then
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)
  else
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

  OpenGLControl1.Invalidate;
end;

procedure TMainForm.CheckBoxLightingChange(Sender: TObject);  
begin
  if CheckBoxLighting.Checked then
    glEnable(GL_LIGHTING)
  else
    glDisable(GL_LIGHTING);

  OpenGLControl1.Invalidate;
end;

procedure TMainForm.TrackBarRotationSpeedChange(Sender: TObject);  
begin
  FRotationSpeed := TrackBarRotationSpeed.Position / 10.0;
end;
```

---

## Sauvegarde de screenshot

### Capturer le framebuffer

```pascal
procedure SaveScreenshot(const AFileName: string; AWidth, AHeight: Integer);  
var
  Bitmap: TBitmap;
  y: Integer;
  RowSize: Integer;
  Pixels: PByte;
begin
  Bitmap := TBitmap.Create;
  try
    Bitmap.PixelFormat := pf24bit;
    Bitmap.Width := AWidth;
    Bitmap.Height := AHeight;

    RowSize := AWidth * 3;
    GetMem(Pixels, RowSize * AHeight);
    try
      // Lire les pixels depuis OpenGL
      glReadPixels(0, 0, AWidth, AHeight, GL_BGR, GL_UNSIGNED_BYTE, Pixels);

      // Copier ligne par ligne (inverser Y)
      for y := 0 to AHeight - 1 do
      begin
        Move(Pixels[y * RowSize],
             Bitmap.ScanLine[AHeight - 1 - y]^,
             RowSize);
      end;

      Bitmap.SaveToFile(AFileName);
    finally
      FreeMem(Pixels);
    end;
  finally
    Bitmap.Free;
  end;
end;

// Utilisation
procedure TForm1.ButtonScreenshotClick(Sender: TObject);  
begin
  SaveScreenshot('screenshot.bmp', OpenGLControl1.Width, OpenGLControl1.Height);
  ShowMessage('Screenshot sauvegard√© !');
end;
```

---

## Ressources et documentation Windows

### Documentation Microsoft

- **OpenGL sur Windows** : https://docs.microsoft.com/en-us/windows/win32/opengl/opengl
- **WGL (Windows GL)** : https://www.khronos.org/opengl/wiki/Platform_specifics:_Windows

### Outils de d√©veloppement

#### Visual Studio Code avec extensions
- **Extension Pascal** : Support FreePascal
- **Extension Shader** : Coloration syntaxique GLSL
- **Extension OpenGL** : Documentation int√©gr√©e

#### Debugging tools
- **RenderDoc** : Capture et analyse de frames
- **Intel GPA** : Intel Graphics Performance Analyzers
- **NVIDIA Nsight** : Pour cartes NVIDIA

### Biblioth√®ques compl√©mentaires

- **dglOpenGL** : Wrapper OpenGL alternatif pour Delphi/FreePascal
- **JEDI-SDL** : Simple DirectMedia Layer pour Delphi/FreePascal
- **Castle Game Engine** : Moteur de jeu complet pour FreePascal

---

## Conclusion

Vous disposez maintenant de tous les outils et connaissances n√©cessaires pour configurer et utiliser OpenGL efficacement sous Windows avec FreePascal et Lazarus. Les points cl√©s √† retenir :

‚úÖ **Installation simple** : OpenGL est inclus dans Windows  
‚úÖ **Pilotes importants** : Installez les pilotes GPU officiels  
‚úÖ **Package lazopenglcontext** : Fourni avec Lazarus  
‚úÖ **Gestion du contexte** : Toujours appeler `MakeCurrent`  
‚úÖ **Lib√©ration des ressources** : Important pour √©viter les fuites  
‚úÖ **Optimisations** : VBO, Display Lists, State Management  
‚úÖ **Debugging** : V√©rifier les erreurs avec `glGetError`

### Prochaines √©tapes

- **12.3.2 Configuration OpenGL Linux/Mesa** : Configuration sur Ubuntu/Linux
- **Rendu 3D avanc√©** : Mod√®les complexes, √©clairage
- **Shaders GLSL** : Programmation du pipeline graphique
- **Projets pratiques** : Applications OpenGL compl√®tes

Vous √™tes maintenant pr√™t √† cr√©er des applications graphiques 3D performantes sous Windows ! üöÄ

‚è≠Ô∏è [Configuration OpenGL Linux/Mesa](/12-interfaces-graphiques-avancees/03.2-configuration-opengl-linux-mesa.md)
